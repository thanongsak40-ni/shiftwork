((typeof globalThis !== 'undefined' ? globalThis : self)["makoChunk_@rc-component/dialog"] = (typeof globalThis !== 'undefined' ? globalThis : self)["makoChunk_@rc-component/dialog"] || []).push([
        ['vendors'],
{ "node_modules/@ant-design/icons-svg/inline-svg/outlined/align-left.svg": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    ReactComponent: function() {
        return SvgComponent;
    },
    default: function() {
        return _default;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _jsxdevruntime = __mako_require__("node_modules/react/jsx-dev-runtime.js");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
const SvgComponent = (props)=>/*#__PURE__*/ (0, _jsxdevruntime.jsxDEV)("svg", {
        viewBox: "64 64 896 896",
        focusable: "false",
        ...props,
        children: /*#__PURE__*/ (0, _jsxdevruntime.jsxDEV)("path", {
            d: "M120 230h496c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm0 424h496c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm784 140H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0-424H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8z"
        }, void 0, false, {
            fileName: "node_modules/@ant-design/icons-svg/inline-svg/outlined/align-left.svg",
            lineNumber: 2,
            columnNumber: 89
        }, this)
    }, void 0, false, {
        fileName: "node_modules/@ant-design/icons-svg/inline-svg/outlined/align-left.svg",
        lineNumber: 2,
        columnNumber: 31
    }, this);
var _default = "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSI2NCA2NCA4OTYgODk2IiBmb2N1c2FibGU9ImZhbHNlIj48cGF0aCBkPSJNMTIwIDIzMGg0OTZjNC40IDAgOC0zLjYgOC04di01NmMwLTQuNC0zLjYtOC04LThIMTIwYy00LjQgMC04IDMuNi04IDh2NTZjMCA0LjQgMy42IDggOCA4em0wIDQyNGg0OTZjNC40IDAgOC0zLjYgOC04di01NmMwLTQuNC0zLjYtOC04LThIMTIwYy00LjQgMC04IDMuNi04IDh2NTZjMCA0LjQgMy42IDggOCA4em03ODQgMTQwSDEyMGMtNC40IDAtOCAzLjYtOCA4djU2YzAgNC40IDMuNiA4IDggOGg3ODRjNC40IDAgOC0zLjYgOC04di01NmMwLTQuNC0zLjYtOC04LTh6bTAtNDI0SDEyMGMtNC40IDAtOCAzLjYtOCA4djU2YzAgNC40IDMuNiA4IDggOGg3ODRjNC40IDAgOC0zLjYgOC04di01NmMwLTQuNC0zLjYtOC04LTh6IiAvPjwvc3ZnPg==";

},
"node_modules/@ant-design/icons-svg/inline-svg/outlined/arrow-down.svg": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    ReactComponent: function() {
        return SvgComponent;
    },
    default: function() {
        return _default;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _jsxdevruntime = __mako_require__("node_modules/react/jsx-dev-runtime.js");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
const SvgComponent = (props)=>/*#__PURE__*/ (0, _jsxdevruntime.jsxDEV)("svg", {
        viewBox: "64 64 896 896",
        focusable: "false",
        ...props,
        children: /*#__PURE__*/ (0, _jsxdevruntime.jsxDEV)("path", {
            d: "M862 465.3h-81c-4.6 0-9 2-12.1 5.5L550 723.1V160c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v563.1L255.1 470.8c-3-3.5-7.4-5.5-12.1-5.5h-81c-6.8 0-10.5 8.1-6 13.2L487.9 861a31.96 31.96 0 0048.3 0L868 478.5c4.5-5.2.8-13.2-6-13.2z"
        }, void 0, false, {
            fileName: "node_modules/@ant-design/icons-svg/inline-svg/outlined/arrow-down.svg",
            lineNumber: 2,
            columnNumber: 89
        }, this)
    }, void 0, false, {
        fileName: "node_modules/@ant-design/icons-svg/inline-svg/outlined/arrow-down.svg",
        lineNumber: 2,
        columnNumber: 31
    }, this);
var _default = "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSI2NCA2NCA4OTYgODk2IiBmb2N1c2FibGU9ImZhbHNlIj48cGF0aCBkPSJNODYyIDQ2NS4zaC04MWMtNC42IDAtOSAyLTEyLjEgNS41TDU1MCA3MjMuMVYxNjBjMC00LjQtMy42LTgtOC04aC02MGMtNC40IDAtOCAzLjYtOCA4djU2My4xTDI1NS4xIDQ3MC44Yy0zLTMuNS03LjQtNS41LTEyLjEtNS41aC04MWMtNi44IDAtMTAuNSA4LjEtNiAxMy4yTDQ4Ny45IDg2MWEzMS45NiAzMS45NiAwIDAwNDguMyAwTDg2OCA0NzguNWM0LjUtNS4yLjgtMTMuMi02LTEzLjJ6IiAvPjwvc3ZnPg==";

},
"node_modules/@ant-design/icons-svg/inline-svg/outlined/arrow-left.svg": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    ReactComponent: function() {
        return SvgComponent;
    },
    default: function() {
        return _default;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _jsxdevruntime = __mako_require__("node_modules/react/jsx-dev-runtime.js");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
const SvgComponent = (props)=>/*#__PURE__*/ (0, _jsxdevruntime.jsxDEV)("svg", {
        viewBox: "64 64 896 896",
        focusable: "false",
        ...props,
        children: /*#__PURE__*/ (0, _jsxdevruntime.jsxDEV)("path", {
            d: "M872 474H286.9l350.2-304c5.6-4.9 2.2-14-5.2-14h-88.5c-3.9 0-7.6 1.4-10.5 3.9L155 487.8a31.96 31.96 0 000 48.3L535.1 866c1.5 1.3 3.3 2 5.2 2h91.5c7.4 0 10.8-9.2 5.2-14L286.9 550H872c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8z"
        }, void 0, false, {
            fileName: "node_modules/@ant-design/icons-svg/inline-svg/outlined/arrow-left.svg",
            lineNumber: 2,
            columnNumber: 89
        }, this)
    }, void 0, false, {
        fileName: "node_modules/@ant-design/icons-svg/inline-svg/outlined/arrow-left.svg",
        lineNumber: 2,
        columnNumber: 31
    }, this);
var _default = "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSI2NCA2NCA4OTYgODk2IiBmb2N1c2FibGU9ImZhbHNlIj48cGF0aCBkPSJNODcyIDQ3NEgyODYuOWwzNTAuMi0zMDRjNS42LTQuOSAyLjItMTQtNS4yLTE0aC04OC41Yy0zLjkgMC03LjYgMS40LTEwLjUgMy45TDE1NSA0ODcuOGEzMS45NiAzMS45NiAwIDAwMCA0OC4zTDUzNS4xIDg2NmMxLjUgMS4zIDMuMyAyIDUuMiAyaDkxLjVjNy40IDAgMTAuOC05LjIgNS4yLTE0TDI4Ni45IDU1MEg4NzJjNC40IDAgOC0zLjYgOC04di02MGMwLTQuNC0zLjYtOC04LTh6IiAvPjwvc3ZnPg==";

},
"node_modules/@ant-design/icons-svg/inline-svg/outlined/arrow-up.svg": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    ReactComponent: function() {
        return SvgComponent;
    },
    default: function() {
        return _default;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _jsxdevruntime = __mako_require__("node_modules/react/jsx-dev-runtime.js");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
const SvgComponent = (props)=>/*#__PURE__*/ (0, _jsxdevruntime.jsxDEV)("svg", {
        viewBox: "64 64 896 896",
        focusable: "false",
        ...props,
        children: /*#__PURE__*/ (0, _jsxdevruntime.jsxDEV)("path", {
            d: "M868 545.5L536.1 163a31.96 31.96 0 00-48.3 0L156 545.5a7.97 7.97 0 006 13.2h81c4.6 0 9-2 12.1-5.5L474 300.9V864c0 4.4 3.6 8 8 8h60c4.4 0 8-3.6 8-8V300.9l218.9 252.3c3 3.5 7.4 5.5 12.1 5.5h81c6.8 0 10.5-8 6-13.2z"
        }, void 0, false, {
            fileName: "node_modules/@ant-design/icons-svg/inline-svg/outlined/arrow-up.svg",
            lineNumber: 2,
            columnNumber: 89
        }, this)
    }, void 0, false, {
        fileName: "node_modules/@ant-design/icons-svg/inline-svg/outlined/arrow-up.svg",
        lineNumber: 2,
        columnNumber: 31
    }, this);
var _default = "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSI2NCA2NCA4OTYgODk2IiBmb2N1c2FibGU9ImZhbHNlIj48cGF0aCBkPSJNODY4IDU0NS41TDUzNi4xIDE2M2EzMS45NiAzMS45NiAwIDAwLTQ4LjMgMEwxNTYgNTQ1LjVhNy45NyA3Ljk3IDAgMDA2IDEzLjJoODFjNC42IDAgOS0yIDEyLjEtNS41TDQ3NCAzMDAuOVY4NjRjMCA0LjQgMy42IDggOCA4aDYwYzQuNCAwIDgtMy42IDgtOFYzMDAuOWwyMTguOSAyNTIuM2MzIDMuNSA3LjQgNS41IDEyLjEgNS41aDgxYzYuOCAwIDEwLjUtOCA2LTEzLjJ6IiAvPjwvc3ZnPg==";

},
"node_modules/@ant-design/icons-svg/inline-svg/outlined/clock-circle.svg": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    ReactComponent: function() {
        return SvgComponent;
    },
    default: function() {
        return _default;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _jsxdevruntime = __mako_require__("node_modules/react/jsx-dev-runtime.js");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
const SvgComponent = (props)=>/*#__PURE__*/ (0, _jsxdevruntime.jsxDEV)("svg", {
        viewBox: "64 64 896 896",
        focusable: "false",
        ...props,
        children: [
            /*#__PURE__*/ (0, _jsxdevruntime.jsxDEV)("path", {
                d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z"
            }, void 0, false, {
                fileName: "node_modules/@ant-design/icons-svg/inline-svg/outlined/clock-circle.svg",
                lineNumber: 2,
                columnNumber: 89
            }, this),
            /*#__PURE__*/ (0, _jsxdevruntime.jsxDEV)("path", {
                d: "M686.7 638.6L544.1 535.5V288c0-4.4-3.6-8-8-8H488c-4.4 0-8 3.6-8 8v275.4c0 2.6 1.2 5 3.3 6.5l165.4 120.6c3.6 2.6 8.6 1.8 11.2-1.7l28.6-39c2.6-3.7 1.8-8.7-1.8-11.2z"
            }, void 0, false, {
                fileName: "node_modules/@ant-design/icons-svg/inline-svg/outlined/clock-circle.svg",
                lineNumber: 2,
                columnNumber: 274
            }, this)
        ]
    }, void 0, true, {
        fileName: "node_modules/@ant-design/icons-svg/inline-svg/outlined/clock-circle.svg",
        lineNumber: 2,
        columnNumber: 31
    }, this);
var _default = "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSI2NCA2NCA4OTYgODk2IiBmb2N1c2FibGU9ImZhbHNlIj48cGF0aCBkPSJNNTEyIDY0QzI2NC42IDY0IDY0IDI2NC42IDY0IDUxMnMyMDAuNiA0NDggNDQ4IDQ0OCA0NDgtMjAwLjYgNDQ4LTQ0OFM3NTkuNCA2NCA1MTIgNjR6bTAgODIwYy0yMDUuNCAwLTM3Mi0xNjYuNi0zNzItMzcyczE2Ni42LTM3MiAzNzItMzcyIDM3MiAxNjYuNiAzNzIgMzcyLTE2Ni42IDM3Mi0zNzIgMzcyeiIgLz48cGF0aCBkPSJNNjg2LjcgNjM4LjZMNTQ0LjEgNTM1LjVWMjg4YzAtNC40LTMuNi04LTgtOEg0ODhjLTQuNCAwLTggMy42LTggOHYyNzUuNGMwIDIuNiAxLjIgNSAzLjMgNi41bDE2NS40IDEyMC42YzMuNiAyLjYgOC42IDEuOCAxMS4yLTEuN2wyOC42LTM5YzIuNi0zLjcgMS44LTguNy0xLjgtMTEuMnoiIC8+PC9zdmc+";

},
"node_modules/@ant-design/icons-svg/inline-svg/outlined/close.svg": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    ReactComponent: function() {
        return SvgComponent;
    },
    default: function() {
        return _default;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _jsxdevruntime = __mako_require__("node_modules/react/jsx-dev-runtime.js");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
const SvgComponent = (props)=>/*#__PURE__*/ (0, _jsxdevruntime.jsxDEV)("svg", {
        fillRule: "evenodd",
        viewBox: "64 64 896 896",
        focusable: "false",
        ...props,
        children: /*#__PURE__*/ (0, _jsxdevruntime.jsxDEV)("path", {
            d: "M799.86 166.31c.02 0 .04.02.08.06l57.69 57.7c.04.03.05.05.06.08a.12.12 0 010 .06c0 .03-.02.05-.06.09L569.93 512l287.7 287.7c.04.04.05.06.06.09a.12.12 0 010 .07c0 .02-.02.04-.06.08l-57.7 57.69c-.03.04-.05.05-.07.06a.12.12 0 01-.07 0c-.03 0-.05-.02-.09-.06L512 569.93l-287.7 287.7c-.04.04-.06.05-.09.06a.12.12 0 01-.07 0c-.02 0-.04-.02-.08-.06l-57.69-57.7c-.04-.03-.05-.05-.06-.07a.12.12 0 010-.07c0-.03.02-.05.06-.09L454.07 512l-287.7-287.7c-.04-.04-.05-.06-.06-.09a.12.12 0 010-.07c0-.02.02-.04.06-.08l57.7-57.69c.03-.04.05-.05.07-.06a.12.12 0 01.07 0c.03 0 .05.02.09.06L512 454.07l287.7-287.7c.04-.04.06-.05.09-.06a.12.12 0 01.07 0z"
        }, void 0, false, {
            fileName: "node_modules/@ant-design/icons-svg/inline-svg/outlined/close.svg",
            lineNumber: 2,
            columnNumber: 108
        }, this)
    }, void 0, false, {
        fileName: "node_modules/@ant-design/icons-svg/inline-svg/outlined/close.svg",
        lineNumber: 2,
        columnNumber: 31
    }, this);
var _default = "data:image/svg+xml;base64,PHN2ZyBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiPjxwYXRoIGQ9Ik03OTkuODYgMTY2LjMxYy4wMiAwIC4wNC4wMi4wOC4wNmw1Ny42OSA1Ny43Yy4wNC4wMy4wNS4wNS4wNi4wOGEuMTIuMTIgMCAwMTAgLjA2YzAgLjAzLS4wMi4wNS0uMDYuMDlMNTY5LjkzIDUxMmwyODcuNyAyODcuN2MuMDQuMDQuMDUuMDYuMDYuMDlhLjEyLjEyIDAgMDEwIC4wN2MwIC4wMi0uMDIuMDQtLjA2LjA4bC01Ny43IDU3LjY5Yy0uMDMuMDQtLjA1LjA1LS4wNy4wNmEuMTIuMTIgMCAwMS0uMDcgMGMtLjAzIDAtLjA1LS4wMi0uMDktLjA2TDUxMiA1NjkuOTNsLTI4Ny43IDI4Ny43Yy0uMDQuMDQtLjA2LjA1LS4wOS4wNmEuMTIuMTIgMCAwMS0uMDcgMGMtLjAyIDAtLjA0LS4wMi0uMDgtLjA2bC01Ny42OS01Ny43Yy0uMDQtLjAzLS4wNS0uMDUtLjA2LS4wN2EuMTIuMTIgMCAwMTAtLjA3YzAtLjAzLjAyLS4wNS4wNi0uMDlMNDU0LjA3IDUxMmwtMjg3LjctMjg3LjdjLS4wNC0uMDQtLjA1LS4wNi0uMDYtLjA5YS4xMi4xMiAwIDAxMC0uMDdjMC0uMDIuMDItLjA0LjA2LS4wOGw1Ny43LTU3LjY5Yy4wMy0uMDQuMDUtLjA1LjA3LS4wNmEuMTIuMTIgMCAwMS4wNyAwYy4wMyAwIC4wNS4wMi4wOS4wNkw1MTIgNDU0LjA3bDI4Ny43LTI4Ny43Yy4wNC0uMDQuMDYtLjA1LjA5LS4wNmEuMTIuMTIgMCAwMS4wNyAweiIgLz48L3N2Zz4=";

},
"node_modules/@ant-design/icons-svg/inline-svg/outlined/down.svg": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    ReactComponent: function() {
        return SvgComponent;
    },
    default: function() {
        return _default;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _jsxdevruntime = __mako_require__("node_modules/react/jsx-dev-runtime.js");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
const SvgComponent = (props)=>/*#__PURE__*/ (0, _jsxdevruntime.jsxDEV)("svg", {
        viewBox: "64 64 896 896",
        focusable: "false",
        ...props,
        children: /*#__PURE__*/ (0, _jsxdevruntime.jsxDEV)("path", {
            d: "M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z"
        }, void 0, false, {
            fileName: "node_modules/@ant-design/icons-svg/inline-svg/outlined/down.svg",
            lineNumber: 2,
            columnNumber: 89
        }, this)
    }, void 0, false, {
        fileName: "node_modules/@ant-design/icons-svg/inline-svg/outlined/down.svg",
        lineNumber: 2,
        columnNumber: 31
    }, this);
var _default = "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSI2NCA2NCA4OTYgODk2IiBmb2N1c2FibGU9ImZhbHNlIj48cGF0aCBkPSJNODg0IDI1NmgtNzVjLTUuMSAwLTkuOSAyLjUtMTIuOSA2LjZMNTEyIDY1NC4yIDIyNy45IDI2Mi42Yy0zLTQuMS03LjgtNi42LTEyLjktNi42aC03NWMtNi41IDAtMTAuMyA3LjQtNi41IDEyLjdsMzUyLjYgNDg2LjFjMTIuOCAxNy42IDM5IDE3LjYgNTEuNyAwbDM1Mi42LTQ4Ni4xYzMuOS01LjMuMS0xMi43LTYuNC0xMi43eiIgLz48L3N2Zz4=";

},
"node_modules/@ant-design/icons-svg/inline-svg/outlined/facebook.svg": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    ReactComponent: function() {
        return SvgComponent;
    },
    default: function() {
        return _default;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _jsxdevruntime = __mako_require__("node_modules/react/jsx-dev-runtime.js");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
const SvgComponent = (props)=>/*#__PURE__*/ (0, _jsxdevruntime.jsxDEV)("svg", {
        viewBox: "64 64 896 896",
        focusable: "false",
        ...props,
        children: /*#__PURE__*/ (0, _jsxdevruntime.jsxDEV)("path", {
            d: "M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zm-32 736H663.9V602.2h104l15.6-120.7H663.9v-77.1c0-35 9.7-58.8 59.8-58.8h63.9v-108c-11.1-1.5-49-4.8-93.2-4.8-92.2 0-155.3 56.3-155.3 159.6v89H434.9v120.7h104.3V848H176V176h672v672z"
        }, void 0, false, {
            fileName: "node_modules/@ant-design/icons-svg/inline-svg/outlined/facebook.svg",
            lineNumber: 2,
            columnNumber: 89
        }, this)
    }, void 0, false, {
        fileName: "node_modules/@ant-design/icons-svg/inline-svg/outlined/facebook.svg",
        lineNumber: 2,
        columnNumber: 31
    }, this);
var _default = "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSI2NCA2NCA4OTYgODk2IiBmb2N1c2FibGU9ImZhbHNlIj48cGF0aCBkPSJNODgwIDExMkgxNDRjLTE3LjcgMC0zMiAxNC4zLTMyIDMydjczNmMwIDE3LjcgMTQuMyAzMiAzMiAzMmg3MzZjMTcuNyAwIDMyLTE0LjMgMzItMzJWMTQ0YzAtMTcuNy0xNC4zLTMyLTMyLTMyem0tMzIgNzM2SDY2My45VjYwMi4yaDEwNGwxNS42LTEyMC43SDY2My45di03Ny4xYzAtMzUgOS43LTU4LjggNTkuOC01OC44aDYzLjl2LTEwOGMtMTEuMS0xLjUtNDktNC44LTkzLjItNC44LTkyLjIgMC0xNTUuMyA1Ni4zLTE1NS4zIDE1OS42djg5SDQzNC45djEyMC43aDEwNC4zVjg0OEgxNzZWMTc2aDY3MnY2NzJ6IiAvPjwvc3ZnPg==";

},
"node_modules/@ant-design/icons-svg/inline-svg/outlined/file.svg": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    ReactComponent: function() {
        return SvgComponent;
    },
    default: function() {
        return _default;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _jsxdevruntime = __mako_require__("node_modules/react/jsx-dev-runtime.js");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
const SvgComponent = (props)=>/*#__PURE__*/ (0, _jsxdevruntime.jsxDEV)("svg", {
        viewBox: "64 64 896 896",
        focusable: "false",
        ...props,
        children: /*#__PURE__*/ (0, _jsxdevruntime.jsxDEV)("path", {
            d: "M854.6 288.6L639.4 73.4c-6-6-14.1-9.4-22.6-9.4H192c-17.7 0-32 14.3-32 32v832c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V311.3c0-8.5-3.4-16.7-9.4-22.7zM790.2 326H602V137.8L790.2 326zm1.8 562H232V136h302v216a42 42 0 0042 42h216v494z"
        }, void 0, false, {
            fileName: "node_modules/@ant-design/icons-svg/inline-svg/outlined/file.svg",
            lineNumber: 2,
            columnNumber: 89
        }, this)
    }, void 0, false, {
        fileName: "node_modules/@ant-design/icons-svg/inline-svg/outlined/file.svg",
        lineNumber: 2,
        columnNumber: 31
    }, this);
var _default = "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSI2NCA2NCA4OTYgODk2IiBmb2N1c2FibGU9ImZhbHNlIj48cGF0aCBkPSJNODU0LjYgMjg4LjZMNjM5LjQgNzMuNGMtNi02LTE0LjEtOS40LTIyLjYtOS40SDE5MmMtMTcuNyAwLTMyIDE0LjMtMzIgMzJ2ODMyYzAgMTcuNyAxNC4zIDMyIDMyIDMyaDY0MGMxNy43IDAgMzItMTQuMyAzMi0zMlYzMTEuM2MwLTguNS0zLjQtMTYuNy05LjQtMjIuN3pNNzkwLjIgMzI2SDYwMlYxMzcuOEw3OTAuMiAzMjZ6bTEuOCA1NjJIMjMyVjEzNmgzMDJ2MjE2YTQyIDQyIDAgMDA0MiA0MmgyMTZ2NDk0eiIgLz48L3N2Zz4=";

},
"node_modules/@ant-design/icons-svg/inline-svg/outlined/folder-open.svg": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    ReactComponent: function() {
        return SvgComponent;
    },
    default: function() {
        return _default;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _jsxdevruntime = __mako_require__("node_modules/react/jsx-dev-runtime.js");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
const SvgComponent = (props)=>/*#__PURE__*/ (0, _jsxdevruntime.jsxDEV)("svg", {
        viewBox: "64 64 896 896",
        focusable: "false",
        ...props,
        children: /*#__PURE__*/ (0, _jsxdevruntime.jsxDEV)("path", {
            d: "M928 444H820V330.4c0-17.7-14.3-32-32-32H473L355.7 186.2a8.15 8.15 0 00-5.5-2.2H96c-17.7 0-32 14.3-32 32v592c0 17.7 14.3 32 32 32h698c13 0 24.8-7.9 29.7-20l134-332c1.5-3.8 2.3-7.9 2.3-12 0-17.7-14.3-32-32-32zM136 256h188.5l119.6 114.4H748V444H238c-13 0-24.8 7.9-29.7 20L136 643.2V256zm635.3 512H159l103.3-256h612.4L771.3 768z"
        }, void 0, false, {
            fileName: "node_modules/@ant-design/icons-svg/inline-svg/outlined/folder-open.svg",
            lineNumber: 2,
            columnNumber: 89
        }, this)
    }, void 0, false, {
        fileName: "node_modules/@ant-design/icons-svg/inline-svg/outlined/folder-open.svg",
        lineNumber: 2,
        columnNumber: 31
    }, this);
var _default = "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSI2NCA2NCA4OTYgODk2IiBmb2N1c2FibGU9ImZhbHNlIj48cGF0aCBkPSJNOTI4IDQ0NEg4MjBWMzMwLjRjMC0xNy43LTE0LjMtMzItMzItMzJINDczTDM1NS43IDE4Ni4yYTguMTUgOC4xNSAwIDAwLTUuNS0yLjJIOTZjLTE3LjcgMC0zMiAxNC4zLTMyIDMydjU5MmMwIDE3LjcgMTQuMyAzMiAzMiAzMmg2OThjMTMgMCAyNC44LTcuOSAyOS43LTIwbDEzNC0zMzJjMS41LTMuOCAyLjMtNy45IDIuMy0xMiAwLTE3LjctMTQuMy0zMi0zMi0zMnpNMTM2IDI1NmgxODguNWwxMTkuNiAxMTQuNEg3NDhWNDQ0SDIzOGMtMTMgMC0yNC44IDcuOS0yOS43IDIwTDEzNiA2NDMuMlYyNTZ6bTYzNS4zIDUxMkgxNTlsMTAzLjMtMjU2aDYxMi40TDc3MS4zIDc2OHoiIC8+PC9zdmc+";

},
"node_modules/@ant-design/icons-svg/inline-svg/outlined/folder.svg": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    ReactComponent: function() {
        return SvgComponent;
    },
    default: function() {
        return _default;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _jsxdevruntime = __mako_require__("node_modules/react/jsx-dev-runtime.js");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
const SvgComponent = (props)=>/*#__PURE__*/ (0, _jsxdevruntime.jsxDEV)("svg", {
        viewBox: "64 64 896 896",
        focusable: "false",
        ...props,
        children: /*#__PURE__*/ (0, _jsxdevruntime.jsxDEV)("path", {
            d: "M880 298.4H521L403.7 186.2a8.15 8.15 0 00-5.5-2.2H144c-17.7 0-32 14.3-32 32v592c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V330.4c0-17.7-14.3-32-32-32zM840 768H184V256h188.5l119.6 114.4H840V768z"
        }, void 0, false, {
            fileName: "node_modules/@ant-design/icons-svg/inline-svg/outlined/folder.svg",
            lineNumber: 2,
            columnNumber: 89
        }, this)
    }, void 0, false, {
        fileName: "node_modules/@ant-design/icons-svg/inline-svg/outlined/folder.svg",
        lineNumber: 2,
        columnNumber: 31
    }, this);
var _default = "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSI2NCA2NCA4OTYgODk2IiBmb2N1c2FibGU9ImZhbHNlIj48cGF0aCBkPSJNODgwIDI5OC40SDUyMUw0MDMuNyAxODYuMmE4LjE1IDguMTUgMCAwMC01LjUtMi4ySDE0NGMtMTcuNyAwLTMyIDE0LjMtMzIgMzJ2NTkyYzAgMTcuNyAxNC4zIDMyIDMyIDMyaDczNmMxNy43IDAgMzItMTQuMyAzMi0zMlYzMzAuNGMwLTE3LjctMTQuMy0zMi0zMi0zMnpNODQwIDc2OEgxODRWMjU2aDE4OC41bDExOS42IDExNC40SDg0MFY3Njh6IiAvPjwvc3ZnPg==";

},
"node_modules/@ant-design/icons-svg/inline-svg/outlined/github.svg": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    ReactComponent: function() {
        return SvgComponent;
    },
    default: function() {
        return _default;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _jsxdevruntime = __mako_require__("node_modules/react/jsx-dev-runtime.js");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
const SvgComponent = (props)=>/*#__PURE__*/ (0, _jsxdevruntime.jsxDEV)("svg", {
        viewBox: "64 64 896 896",
        focusable: "false",
        ...props,
        children: /*#__PURE__*/ (0, _jsxdevruntime.jsxDEV)("path", {
            d: "M511.6 76.3C264.3 76.2 64 276.4 64 523.5 64 718.9 189.3 885 363.8 946c23.5 5.9 19.9-10.8 19.9-22.2v-77.5c-135.7 15.9-141.2-73.9-150.3-88.9C215 726 171.5 718 184.5 703c30.9-15.9 62.4 4 98.9 57.9 26.4 39.1 77.9 32.5 104 26 5.7-23.5 17.9-44.5 34.7-60.8-140.6-25.2-199.2-111-199.2-213 0-49.5 16.3-95 48.3-131.7-20.4-60.5 1.9-112.3 4.9-120 58.1-5.2 118.5 41.6 123.2 45.3 33-8.9 70.7-13.6 112.9-13.6 42.4 0 80.2 4.9 113.5 13.9 11.3-8.6 67.3-48.8 121.3-43.9 2.9 7.7 24.7 58.3 5.5 118 32.4 36.8 48.9 82.7 48.9 132.3 0 102.2-59 188.1-200 212.9a127.5 127.5 0 0138.1 91v112.5c.8 9 0 17.9 15 17.9 177.1-59.7 304.6-227 304.6-424.1 0-247.2-200.4-447.3-447.5-447.3z"
        }, void 0, false, {
            fileName: "node_modules/@ant-design/icons-svg/inline-svg/outlined/github.svg",
            lineNumber: 2,
            columnNumber: 89
        }, this)
    }, void 0, false, {
        fileName: "node_modules/@ant-design/icons-svg/inline-svg/outlined/github.svg",
        lineNumber: 2,
        columnNumber: 31
    }, this);
var _default = "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSI2NCA2NCA4OTYgODk2IiBmb2N1c2FibGU9ImZhbHNlIj48cGF0aCBkPSJNNTExLjYgNzYuM0MyNjQuMyA3Ni4yIDY0IDI3Ni40IDY0IDUyMy41IDY0IDcxOC45IDE4OS4zIDg4NSAzNjMuOCA5NDZjMjMuNSA1LjkgMTkuOS0xMC44IDE5LjktMjIuMnYtNzcuNWMtMTM1LjcgMTUuOS0xNDEuMi03My45LTE1MC4zLTg4LjlDMjE1IDcyNiAxNzEuNSA3MTggMTg0LjUgNzAzYzMwLjktMTUuOSA2Mi40IDQgOTguOSA1Ny45IDI2LjQgMzkuMSA3Ny45IDMyLjUgMTA0IDI2IDUuNy0yMy41IDE3LjktNDQuNSAzNC43LTYwLjgtMTQwLjYtMjUuMi0xOTkuMi0xMTEtMTk5LjItMjEzIDAtNDkuNSAxNi4zLTk1IDQ4LjMtMTMxLjctMjAuNC02MC41IDEuOS0xMTIuMyA0LjktMTIwIDU4LjEtNS4yIDExOC41IDQxLjYgMTIzLjIgNDUuMyAzMy04LjkgNzAuNy0xMy42IDExMi45LTEzLjYgNDIuNCAwIDgwLjIgNC45IDExMy41IDEzLjkgMTEuMy04LjYgNjcuMy00OC44IDEyMS4zLTQzLjkgMi45IDcuNyAyNC43IDU4LjMgNS41IDExOCAzMi40IDM2LjggNDguOSA4Mi43IDQ4LjkgMTMyLjMgMCAxMDIuMi01OSAxODguMS0yMDAgMjEyLjlhMTI3LjUgMTI3LjUgMCAwMTM4LjEgOTF2MTEyLjVjLjggOSAwIDE3LjkgMTUgMTcuOSAxNzcuMS01OS43IDMwNC42LTIyNyAzMDQuNi00MjQuMSAwLTI0Ny4yLTIwMC40LTQ0Ny4zLTQ0Ny41LTQ0Ny4zeiIgLz48L3N2Zz4=";

},
"node_modules/@ant-design/icons-svg/inline-svg/outlined/gitlab.svg": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    ReactComponent: function() {
        return SvgComponent;
    },
    default: function() {
        return _default;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _jsxdevruntime = __mako_require__("node_modules/react/jsx-dev-runtime.js");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
const SvgComponent = (props)=>/*#__PURE__*/ (0, _jsxdevruntime.jsxDEV)("svg", {
        viewBox: "64 64 896 896",
        focusable: "false",
        ...props,
        children: /*#__PURE__*/ (0, _jsxdevruntime.jsxDEV)("path", {
            d: "M913.9 552.2L805 181.4v-.1c-7.6-22.9-25.7-36.5-48.3-36.5-23.4 0-42.5 13.5-49.7 35.2l-71.4 213H388.8l-71.4-213c-7.2-21.7-26.3-35.2-49.7-35.2-23.1 0-42.5 14.8-48.4 36.6L110.5 552.2c-4.4 14.7 1.2 31.4 13.5 40.7l368.5 276.4c2.6 3.6 6.2 6.3 10.4 7.8l8.6 6.4 8.5-6.4c4.9-1.7 9-4.7 11.9-8.9l368.4-275.4c12.4-9.2 18-25.9 13.6-40.6zM751.7 193.4c1-1.8 2.9-1.9 3.5-1.9 1.1 0 2.5.3 3.4 3L818 394.3H684.5l67.2-200.9zm-487.4 1c.9-2.6 2.3-2.9 3.4-2.9 2.7 0 2.9.1 3.4 1.7l67.3 201.2H206.5l57.8-200zM158.8 558.7l28.2-97.3 202.4 270.2-230.6-172.9zm73.9-116.4h122.1l90.8 284.3-212.9-284.3zM512.9 776L405.7 442.3H620L512.9 776zm157.9-333.7h119.5L580 723.1l90.8-280.8zm-40.7 293.9l207.3-276.7 29.5 99.2-236.8 177.5z"
        }, void 0, false, {
            fileName: "node_modules/@ant-design/icons-svg/inline-svg/outlined/gitlab.svg",
            lineNumber: 2,
            columnNumber: 89
        }, this)
    }, void 0, false, {
        fileName: "node_modules/@ant-design/icons-svg/inline-svg/outlined/gitlab.svg",
        lineNumber: 2,
        columnNumber: 31
    }, this);
var _default = "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSI2NCA2NCA4OTYgODk2IiBmb2N1c2FibGU9ImZhbHNlIj48cGF0aCBkPSJNOTEzLjkgNTUyLjJMODA1IDE4MS40di0uMWMtNy42LTIyLjktMjUuNy0zNi41LTQ4LjMtMzYuNS0yMy40IDAtNDIuNSAxMy41LTQ5LjcgMzUuMmwtNzEuNCAyMTNIMzg4LjhsLTcxLjQtMjEzYy03LjItMjEuNy0yNi4zLTM1LjItNDkuNy0zNS4yLTIzLjEgMC00Mi41IDE0LjgtNDguNCAzNi42TDExMC41IDU1Mi4yYy00LjQgMTQuNyAxLjIgMzEuNCAxMy41IDQwLjdsMzY4LjUgMjc2LjRjMi42IDMuNiA2LjIgNi4zIDEwLjQgNy44bDguNiA2LjQgOC41LTYuNGM0LjktMS43IDktNC43IDExLjktOC45bDM2OC40LTI3NS40YzEyLjQtOS4yIDE4LTI1LjkgMTMuNi00MC42ek03NTEuNyAxOTMuNGMxLTEuOCAyLjktMS45IDMuNS0xLjkgMS4xIDAgMi41LjMgMy40IDNMODE4IDM5NC4zSDY4NC41bDY3LjItMjAwLjl6bS00ODcuNCAxYy45LTIuNiAyLjMtMi45IDMuNC0yLjkgMi43IDAgMi45LjEgMy40IDEuN2w2Ny4zIDIwMS4ySDIwNi41bDU3LjgtMjAwek0xNTguOCA1NTguN2wyOC4yLTk3LjMgMjAyLjQgMjcwLjItMjMwLjYtMTcyLjl6bTczLjktMTE2LjRoMTIyLjFsOTAuOCAyODQuMy0yMTIuOS0yODQuM3pNNTEyLjkgNzc2TDQwNS43IDQ0Mi4zSDYyMEw1MTIuOSA3NzZ6bTE1Ny45LTMzMy43aDExOS41TDU4MCA3MjMuMWw5MC44LTI4MC44em0tNDAuNyAyOTMuOWwyMDcuMy0yNzYuNyAyOS41IDk5LjItMjM2LjggMTc3LjV6IiAvPjwvc3ZnPg==";

},
"node_modules/@ant-design/icons-svg/inline-svg/outlined/inbox.svg": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    ReactComponent: function() {
        return SvgComponent;
    },
    default: function() {
        return _default;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _jsxdevruntime = __mako_require__("node_modules/react/jsx-dev-runtime.js");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
const SvgComponent = (props)=>/*#__PURE__*/ (0, _jsxdevruntime.jsxDEV)("svg", {
        viewBox: "0 0 1024 1024",
        focusable: "false",
        ...props,
        children: /*#__PURE__*/ (0, _jsxdevruntime.jsxDEV)("path", {
            d: "M885.2 446.3l-.2-.8-112.2-285.1c-5-16.1-19.9-27.2-36.8-27.2H281.2c-17 0-32.1 11.3-36.9 27.6L139.4 443l-.3.7-.2.8c-1.3 4.9-1.7 9.9-1 14.8-.1 1.6-.2 3.2-.2 4.8V830a60.9 60.9 0 0060.8 60.8h627.2c33.5 0 60.8-27.3 60.9-60.8V464.1c0-1.3 0-2.6-.1-3.7.4-4.9 0-9.6-1.3-14.1zm-295.8-43l-.3 15.7c-.8 44.9-31.8 75.1-77.1 75.1-22.1 0-41.1-7.1-54.8-20.6S436 441.2 435.6 419l-.3-15.7H229.5L309 210h399.2l81.7 193.3H589.4zm-375 76.8h157.3c24.3 57.1 76 90.8 140.4 90.8 33.7 0 65-9.4 90.3-27.2 22.2-15.6 39.5-37.4 50.7-63.6h156.5V814H214.4V480.1z"
        }, void 0, false, {
            fileName: "node_modules/@ant-design/icons-svg/inline-svg/outlined/inbox.svg",
            lineNumber: 2,
            columnNumber: 89
        }, this)
    }, void 0, false, {
        fileName: "node_modules/@ant-design/icons-svg/inline-svg/outlined/inbox.svg",
        lineNumber: 2,
        columnNumber: 31
    }, this);
var _default = "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMTAyNCAxMDI0IiBmb2N1c2FibGU9ImZhbHNlIj48cGF0aCBkPSJNODg1LjIgNDQ2LjNsLS4yLS44LTExMi4yLTI4NS4xYy01LTE2LjEtMTkuOS0yNy4yLTM2LjgtMjcuMkgyODEuMmMtMTcgMC0zMi4xIDExLjMtMzYuOSAyNy42TDEzOS40IDQ0M2wtLjMuNy0uMi44Yy0xLjMgNC45LTEuNyA5LjktMSAxNC44LS4xIDEuNi0uMiAzLjItLjIgNC44VjgzMGE2MC45IDYwLjkgMCAwMDYwLjggNjAuOGg2MjcuMmMzMy41IDAgNjAuOC0yNy4zIDYwLjktNjAuOFY0NjQuMWMwLTEuMyAwLTIuNi0uMS0zLjcuNC00LjkgMC05LjYtMS4zLTE0LjF6bS0yOTUuOC00M2wtLjMgMTUuN2MtLjggNDQuOS0zMS44IDc1LjEtNzcuMSA3NS4xLTIyLjEgMC00MS4xLTcuMS01NC44LTIwLjZTNDM2IDQ0MS4yIDQzNS42IDQxOWwtLjMtMTUuN0gyMjkuNUwzMDkgMjEwaDM5OS4ybDgxLjcgMTkzLjNINTg5LjR6bS0zNzUgNzYuOGgxNTcuM2MyNC4zIDU3LjEgNzYgOTAuOCAxNDAuNCA5MC44IDMzLjcgMCA2NS05LjQgOTAuMy0yNy4yIDIyLjItMTUuNiAzOS41LTM3LjQgNTAuNy02My42aDE1Ni41VjgxNEgyMTQuNFY0ODAuMXoiIC8+PC9zdmc+";

},
"node_modules/@ant-design/icons-svg/inline-svg/outlined/linkedin.svg": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    ReactComponent: function() {
        return SvgComponent;
    },
    default: function() {
        return _default;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _jsxdevruntime = __mako_require__("node_modules/react/jsx-dev-runtime.js");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
const SvgComponent = (props)=>/*#__PURE__*/ (0, _jsxdevruntime.jsxDEV)("svg", {
        viewBox: "64 64 896 896",
        focusable: "false",
        ...props,
        children: /*#__PURE__*/ (0, _jsxdevruntime.jsxDEV)("path", {
            d: "M847.7 112H176.3c-35.5 0-64.3 28.8-64.3 64.3v671.4c0 35.5 28.8 64.3 64.3 64.3h671.4c35.5 0 64.3-28.8 64.3-64.3V176.3c0-35.5-28.8-64.3-64.3-64.3zm0 736c-447.8-.1-671.7-.2-671.7-.3.1-447.8.2-671.7.3-671.7 447.8.1 671.7.2 671.7.3-.1 447.8-.2 671.7-.3 671.7zM230.6 411.9h118.7v381.8H230.6zm59.4-52.2c37.9 0 68.8-30.8 68.8-68.8a68.8 68.8 0 10-137.6 0c-.1 38 30.7 68.8 68.8 68.8zm252.3 245.1c0-49.8 9.5-98 71.2-98 60.8 0 61.7 56.9 61.7 101.2v185.7h118.6V584.3c0-102.8-22.2-181.9-142.3-181.9-57.7 0-96.4 31.7-112.3 61.7h-1.6v-52.2H423.7v381.8h118.6V604.8z"
        }, void 0, false, {
            fileName: "node_modules/@ant-design/icons-svg/inline-svg/outlined/linkedin.svg",
            lineNumber: 2,
            columnNumber: 89
        }, this)
    }, void 0, false, {
        fileName: "node_modules/@ant-design/icons-svg/inline-svg/outlined/linkedin.svg",
        lineNumber: 2,
        columnNumber: 31
    }, this);
var _default = "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSI2NCA2NCA4OTYgODk2IiBmb2N1c2FibGU9ImZhbHNlIj48cGF0aCBkPSJNODQ3LjcgMTEySDE3Ni4zYy0zNS41IDAtNjQuMyAyOC44LTY0LjMgNjQuM3Y2NzEuNGMwIDM1LjUgMjguOCA2NC4zIDY0LjMgNjQuM2g2NzEuNGMzNS41IDAgNjQuMy0yOC44IDY0LjMtNjQuM1YxNzYuM2MwLTM1LjUtMjguOC02NC4zLTY0LjMtNjQuM3ptMCA3MzZjLTQ0Ny44LS4xLTY3MS43LS4yLTY3MS43LS4zLjEtNDQ3LjguMi02NzEuNy4zLTY3MS43IDQ0Ny44LjEgNjcxLjcuMiA2NzEuNy4zLS4xIDQ0Ny44LS4yIDY3MS43LS4zIDY3MS43ek0yMzAuNiA0MTEuOWgxMTguN3YzODEuOEgyMzAuNnptNTkuNC01Mi4yYzM3LjkgMCA2OC44LTMwLjggNjguOC02OC44YTY4LjggNjguOCAwIDEwLTEzNy42IDBjLS4xIDM4IDMwLjcgNjguOCA2OC44IDY4Ljh6bTI1Mi4zIDI0NS4xYzAtNDkuOCA5LjUtOTggNzEuMi05OCA2MC44IDAgNjEuNyA1Ni45IDYxLjcgMTAxLjJ2MTg1LjdoMTE4LjZWNTg0LjNjMC0xMDIuOC0yMi4yLTE4MS45LTE0Mi4zLTE4MS45LTU3LjcgMC05Ni40IDMxLjctMTEyLjMgNjEuN2gtMS42di01Mi4ySDQyMy43djM4MS44aDExOC42VjYwNC44eiIgLz48L3N2Zz4=";

},
"node_modules/@ant-design/icons-svg/inline-svg/outlined/menu.svg": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    ReactComponent: function() {
        return SvgComponent;
    },
    default: function() {
        return _default;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _jsxdevruntime = __mako_require__("node_modules/react/jsx-dev-runtime.js");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
const SvgComponent = (props)=>/*#__PURE__*/ (0, _jsxdevruntime.jsxDEV)("svg", {
        viewBox: "64 64 896 896",
        focusable: "false",
        ...props,
        children: /*#__PURE__*/ (0, _jsxdevruntime.jsxDEV)("path", {
            d: "M904 160H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0 624H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0-312H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8z"
        }, void 0, false, {
            fileName: "node_modules/@ant-design/icons-svg/inline-svg/outlined/menu.svg",
            lineNumber: 2,
            columnNumber: 89
        }, this)
    }, void 0, false, {
        fileName: "node_modules/@ant-design/icons-svg/inline-svg/outlined/menu.svg",
        lineNumber: 2,
        columnNumber: 31
    }, this);
var _default = "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSI2NCA2NCA4OTYgODk2IiBmb2N1c2FibGU9ImZhbHNlIj48cGF0aCBkPSJNOTA0IDE2MEgxMjBjLTQuNCAwLTggMy42LTggOHY2NGMwIDQuNCAzLjYgOCA4IDhoNzg0YzQuNCAwIDgtMy42IDgtOHYtNjRjMC00LjQtMy42LTgtOC04em0wIDYyNEgxMjBjLTQuNCAwLTggMy42LTggOHY2NGMwIDQuNCAzLjYgOCA4IDhoNzg0YzQuNCAwIDgtMy42IDgtOHYtNjRjMC00LjQtMy42LTgtOC04em0wLTMxMkgxMjBjLTQuNCAwLTggMy42LTggOHY2NGMwIDQuNCAzLjYgOCA4IDhoNzg0YzQuNCAwIDgtMy42IDgtOHYtNjRjMC00LjQtMy42LTgtOC04eiIgLz48L3N2Zz4=";

},
"node_modules/@ant-design/icons-svg/inline-svg/outlined/minus-square.svg": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    ReactComponent: function() {
        return SvgComponent;
    },
    default: function() {
        return _default;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _jsxdevruntime = __mako_require__("node_modules/react/jsx-dev-runtime.js");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
const SvgComponent = (props)=>/*#__PURE__*/ (0, _jsxdevruntime.jsxDEV)("svg", {
        viewBox: "64 64 896 896",
        focusable: "false",
        ...props,
        children: [
            /*#__PURE__*/ (0, _jsxdevruntime.jsxDEV)("path", {
                d: "M328 544h368c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H328c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8z"
            }, void 0, false, {
                fileName: "node_modules/@ant-design/icons-svg/inline-svg/outlined/minus-square.svg",
                lineNumber: 2,
                columnNumber: 89
            }, this),
            /*#__PURE__*/ (0, _jsxdevruntime.jsxDEV)("path", {
                d: "M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zm-40 728H184V184h656v656z"
            }, void 0, false, {
                fileName: "node_modules/@ant-design/icons-svg/inline-svg/outlined/minus-square.svg",
                lineNumber: 2,
                columnNumber: 190
            }, this)
        ]
    }, void 0, true, {
        fileName: "node_modules/@ant-design/icons-svg/inline-svg/outlined/minus-square.svg",
        lineNumber: 2,
        columnNumber: 31
    }, this);
var _default = "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSI2NCA2NCA4OTYgODk2IiBmb2N1c2FibGU9ImZhbHNlIj48cGF0aCBkPSJNMzI4IDU0NGgzNjhjNC40IDAgOC0zLjYgOC04di00OGMwLTQuNC0zLjYtOC04LThIMzI4Yy00LjQgMC04IDMuNi04IDh2NDhjMCA0LjQgMy42IDggOCA4eiIgLz48cGF0aCBkPSJNODgwIDExMkgxNDRjLTE3LjcgMC0zMiAxNC4zLTMyIDMydjczNmMwIDE3LjcgMTQuMyAzMiAzMiAzMmg3MzZjMTcuNyAwIDMyLTE0LjMgMzItMzJWMTQ0YzAtMTcuNy0xNC4zLTMyLTMyLTMyem0tNDAgNzI4SDE4NFYxODRoNjU2djY1NnoiIC8+PC9zdmc+";

},
"node_modules/@ant-design/icons-svg/inline-svg/outlined/plus-square.svg": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    ReactComponent: function() {
        return SvgComponent;
    },
    default: function() {
        return _default;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _jsxdevruntime = __mako_require__("node_modules/react/jsx-dev-runtime.js");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
const SvgComponent = (props)=>/*#__PURE__*/ (0, _jsxdevruntime.jsxDEV)("svg", {
        viewBox: "64 64 896 896",
        focusable: "false",
        ...props,
        children: [
            /*#__PURE__*/ (0, _jsxdevruntime.jsxDEV)("path", {
                d: "M328 544h152v152c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V544h152c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H544V328c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8v152H328c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8z"
            }, void 0, false, {
                fileName: "node_modules/@ant-design/icons-svg/inline-svg/outlined/plus-square.svg",
                lineNumber: 2,
                columnNumber: 89
            }, this),
            /*#__PURE__*/ (0, _jsxdevruntime.jsxDEV)("path", {
                d: "M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zm-40 728H184V184h656v656z"
            }, void 0, false, {
                fileName: "node_modules/@ant-design/icons-svg/inline-svg/outlined/plus-square.svg",
                lineNumber: 2,
                columnNumber: 286
            }, this)
        ]
    }, void 0, true, {
        fileName: "node_modules/@ant-design/icons-svg/inline-svg/outlined/plus-square.svg",
        lineNumber: 2,
        columnNumber: 31
    }, this);
var _default = "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSI2NCA2NCA4OTYgODk2IiBmb2N1c2FibGU9ImZhbHNlIj48cGF0aCBkPSJNMzI4IDU0NGgxNTJ2MTUyYzAgNC40IDMuNiA4IDggOGg0OGM0LjQgMCA4LTMuNiA4LThWNTQ0aDE1MmM0LjQgMCA4LTMuNiA4LTh2LTQ4YzAtNC40LTMuNi04LTgtOEg1NDRWMzI4YzAtNC40LTMuNi04LTgtOGgtNDhjLTQuNCAwLTggMy42LTggOHYxNTJIMzI4Yy00LjQgMC04IDMuNi04IDh2NDhjMCA0LjQgMy42IDggOCA4eiIgLz48cGF0aCBkPSJNODgwIDExMkgxNDRjLTE3LjcgMC0zMiAxNC4zLTMyIDMydjczNmMwIDE3LjcgMTQuMyAzMiAzMiAzMmg3MzZjMTcuNyAwIDMyLTE0LjMgMzItMzJWMTQ0YzAtMTcuNy0xNC4zLTMyLTMyLTMyem0tNDAgNzI4SDE4NFYxODRoNjU2djY1NnoiIC8+PC9zdmc+";

},
"node_modules/@ant-design/icons-svg/inline-svg/outlined/search.svg": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    ReactComponent: function() {
        return SvgComponent;
    },
    default: function() {
        return _default;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _jsxdevruntime = __mako_require__("node_modules/react/jsx-dev-runtime.js");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
const SvgComponent = (props)=>/*#__PURE__*/ (0, _jsxdevruntime.jsxDEV)("svg", {
        viewBox: "64 64 896 896",
        focusable: "false",
        ...props,
        children: /*#__PURE__*/ (0, _jsxdevruntime.jsxDEV)("path", {
            d: "M909.6 854.5L649.9 594.8C690.2 542.7 712 479 712 412c0-80.2-31.3-155.4-87.9-212.1-56.6-56.7-132-87.9-212.1-87.9s-155.5 31.3-212.1 87.9C143.2 256.5 112 331.8 112 412c0 80.1 31.3 155.5 87.9 212.1C256.5 680.8 331.8 712 412 712c67 0 130.6-21.8 182.7-62l259.7 259.6a8.2 8.2 0 0011.6 0l43.6-43.5a8.2 8.2 0 000-11.6zM570.4 570.4C528 612.7 471.8 636 412 636s-116-23.3-158.4-65.6C211.3 528 188 471.8 188 412s23.3-116.1 65.6-158.4C296 211.3 352.2 188 412 188s116.1 23.2 158.4 65.6S636 352.2 636 412s-23.3 116.1-65.6 158.4z"
        }, void 0, false, {
            fileName: "node_modules/@ant-design/icons-svg/inline-svg/outlined/search.svg",
            lineNumber: 2,
            columnNumber: 89
        }, this)
    }, void 0, false, {
        fileName: "node_modules/@ant-design/icons-svg/inline-svg/outlined/search.svg",
        lineNumber: 2,
        columnNumber: 31
    }, this);
var _default = "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSI2NCA2NCA4OTYgODk2IiBmb2N1c2FibGU9ImZhbHNlIj48cGF0aCBkPSJNOTA5LjYgODU0LjVMNjQ5LjkgNTk0LjhDNjkwLjIgNTQyLjcgNzEyIDQ3OSA3MTIgNDEyYzAtODAuMi0zMS4zLTE1NS40LTg3LjktMjEyLjEtNTYuNi01Ni43LTEzMi04Ny45LTIxMi4xLTg3LjlzLTE1NS41IDMxLjMtMjEyLjEgODcuOUMxNDMuMiAyNTYuNSAxMTIgMzMxLjggMTEyIDQxMmMwIDgwLjEgMzEuMyAxNTUuNSA4Ny45IDIxMi4xQzI1Ni41IDY4MC44IDMzMS44IDcxMiA0MTIgNzEyYzY3IDAgMTMwLjYtMjEuOCAxODIuNy02MmwyNTkuNyAyNTkuNmE4LjIgOC4yIDAgMDAxMS42IDBsNDMuNi00My41YTguMiA4LjIgMCAwMDAtMTEuNnpNNTcwLjQgNTcwLjRDNTI4IDYxMi43IDQ3MS44IDYzNiA0MTIgNjM2cy0xMTYtMjMuMy0xNTguNC02NS42QzIxMS4zIDUyOCAxODggNDcxLjggMTg4IDQxMnMyMy4zLTExNi4xIDY1LjYtMTU4LjRDMjk2IDIxMS4zIDM1Mi4yIDE4OCA0MTIgMTg4czExNi4xIDIzLjIgMTU4LjQgNjUuNlM2MzYgMzUyLjIgNjM2IDQxMnMtMjMuMyAxMTYuMS02NS42IDE1OC40eiIgLz48L3N2Zz4=";

},
"node_modules/@ant-design/icons-svg/inline-svg/outlined/weibo.svg": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    ReactComponent: function() {
        return SvgComponent;
    },
    default: function() {
        return _default;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _jsxdevruntime = __mako_require__("node_modules/react/jsx-dev-runtime.js");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
const SvgComponent = (props)=>/*#__PURE__*/ (0, _jsxdevruntime.jsxDEV)("svg", {
        viewBox: "64 64 896 896",
        focusable: "false",
        ...props,
        children: /*#__PURE__*/ (0, _jsxdevruntime.jsxDEV)("path", {
            d: "M457.3 543c-68.1-17.7-145 16.2-174.6 76.2-30.1 61.2-1 129.1 67.8 151.3 71.2 23 155.2-12.2 184.4-78.3 28.7-64.6-7.2-131-77.6-149.2zm-52 156.2c-13.8 22.1-43.5 31.7-65.8 21.6-22-10-28.5-35.7-14.6-57.2 13.7-21.4 42.3-31 64.4-21.7 22.4 9.5 29.6 35 16 57.3zm45.5-58.5c-5 8.6-16.1 12.7-24.7 9.1-8.5-3.5-11.2-13.1-6.4-21.5 5-8.4 15.6-12.4 24.1-9.1 8.7 3.2 11.8 12.9 7 21.5zm334.5-197.2c15 4.8 31-3.4 35.9-18.3 11.8-36.6 4.4-78.4-23.2-109a111.39 111.39 0 00-106-34.3 28.45 28.45 0 00-21.9 33.8 28.39 28.39 0 0033.8 21.8c18.4-3.9 38.3 1.8 51.9 16.7a54.2 54.2 0 0111.3 53.3 28.45 28.45 0 0018.2 36zm99.8-206c-56.7-62.9-140.4-86.9-217.7-70.5a32.98 32.98 0 00-25.4 39.3 33.12 33.12 0 0039.3 25.5c55-11.7 114.4 5.4 154.8 50.1 40.3 44.7 51.2 105.7 34 159.1-5.6 17.4 3.9 36 21.3 41.7 17.4 5.6 36-3.9 41.6-21.2v-.1c24.1-75.4 8.9-161.1-47.9-223.9zM729 499c-12.2-3.6-20.5-6.1-14.1-22.1 13.8-34.7 15.2-64.7.3-86-28-40.1-104.8-37.9-192.8-1.1 0 0-27.6 12.1-20.6-9.8 13.5-43.5 11.5-79.9-9.6-101-47.7-47.8-174.6 1.8-283.5 110.6C127.3 471.1 80 557.5 80 632.2 80 775.1 263.2 862 442.5 862c235 0 391.3-136.5 391.3-245 0-65.5-55.2-102.6-104.8-118zM443 810.8c-143 14.1-266.5-50.5-275.8-144.5-9.3-93.9 99.2-181.5 242.2-195.6 143-14.2 266.5 50.5 275.8 144.4C694.4 709 586 796.6 443 810.8z"
        }, void 0, false, {
            fileName: "node_modules/@ant-design/icons-svg/inline-svg/outlined/weibo.svg",
            lineNumber: 2,
            columnNumber: 89
        }, this)
    }, void 0, false, {
        fileName: "node_modules/@ant-design/icons-svg/inline-svg/outlined/weibo.svg",
        lineNumber: 2,
        columnNumber: 31
    }, this);
var _default = "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSI2NCA2NCA4OTYgODk2IiBmb2N1c2FibGU9ImZhbHNlIj48cGF0aCBkPSJNNDU3LjMgNTQzYy02OC4xLTE3LjctMTQ1IDE2LjItMTc0LjYgNzYuMi0zMC4xIDYxLjItMSAxMjkuMSA2Ny44IDE1MS4zIDcxLjIgMjMgMTU1LjItMTIuMiAxODQuNC03OC4zIDI4LjctNjQuNi03LjItMTMxLTc3LjYtMTQ5LjJ6bS01MiAxNTYuMmMtMTMuOCAyMi4xLTQzLjUgMzEuNy02NS44IDIxLjYtMjItMTAtMjguNS0zNS43LTE0LjYtNTcuMiAxMy43LTIxLjQgNDIuMy0zMSA2NC40LTIxLjcgMjIuNCA5LjUgMjkuNiAzNSAxNiA1Ny4zem00NS41LTU4LjVjLTUgOC42LTE2LjEgMTIuNy0yNC43IDkuMS04LjUtMy41LTExLjItMTMuMS02LjQtMjEuNSA1LTguNCAxNS42LTEyLjQgMjQuMS05LjEgOC43IDMuMiAxMS44IDEyLjkgNyAyMS41em0zMzQuNS0xOTcuMmMxNSA0LjggMzEtMy40IDM1LjktMTguMyAxMS44LTM2LjYgNC40LTc4LjQtMjMuMi0xMDlhMTExLjM5IDExMS4zOSAwIDAwLTEwNi0zNC4zIDI4LjQ1IDI4LjQ1IDAgMDAtMjEuOSAzMy44IDI4LjM5IDI4LjM5IDAgMDAzMy44IDIxLjhjMTguNC0zLjkgMzguMyAxLjggNTEuOSAxNi43YTU0LjIgNTQuMiAwIDAxMTEuMyA1My4zIDI4LjQ1IDI4LjQ1IDAgMDAxOC4yIDM2em05OS44LTIwNmMtNTYuNy02Mi45LTE0MC40LTg2LjktMjE3LjctNzAuNWEzMi45OCAzMi45OCAwIDAwLTI1LjQgMzkuMyAzMy4xMiAzMy4xMiAwIDAwMzkuMyAyNS41YzU1LTExLjcgMTE0LjQgNS40IDE1NC44IDUwLjEgNDAuMyA0NC43IDUxLjIgMTA1LjcgMzQgMTU5LjEtNS42IDE3LjQgMy45IDM2IDIxLjMgNDEuNyAxNy40IDUuNiAzNi0zLjkgNDEuNi0yMS4ydi0uMWMyNC4xLTc1LjQgOC45LTE2MS4xLTQ3LjktMjIzLjl6TTcyOSA0OTljLTEyLjItMy42LTIwLjUtNi4xLTE0LjEtMjIuMSAxMy44LTM0LjcgMTUuMi02NC43LjMtODYtMjgtNDAuMS0xMDQuOC0zNy45LTE5Mi44LTEuMSAwIDAtMjcuNiAxMi4xLTIwLjYtOS44IDEzLjUtNDMuNSAxMS41LTc5LjktOS42LTEwMS00Ny43LTQ3LjgtMTc0LjYgMS44LTI4My41IDExMC42QzEyNy4zIDQ3MS4xIDgwIDU1Ny41IDgwIDYzMi4yIDgwIDc3NS4xIDI2My4yIDg2MiA0NDIuNSA4NjJjMjM1IDAgMzkxLjMtMTM2LjUgMzkxLjMtMjQ1IDAtNjUuNS01NS4yLTEwMi42LTEwNC44LTExOHpNNDQzIDgxMC44Yy0xNDMgMTQuMS0yNjYuNS01MC41LTI3NS44LTE0NC41LTkuMy05My45IDk5LjItMTgxLjUgMjQyLjItMTk1LjYgMTQzLTE0LjIgMjY2LjUgNTAuNSAyNzUuOCAxNDQuNEM2OTQuNCA3MDkgNTg2IDc5Ni42IDQ0MyA4MTAuOHoiIC8+PC9zdmc+";

},
"node_modules/@ant-design/icons-svg/inline-svg/outlined/x.svg": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    ReactComponent: function() {
        return SvgComponent;
    },
    default: function() {
        return _default;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _jsxdevruntime = __mako_require__("node_modules/react/jsx-dev-runtime.js");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
const SvgComponent = (props)=>/*#__PURE__*/ (0, _jsxdevruntime.jsxDEV)("svg", {
        fillRule: "evenodd",
        viewBox: "64 64 896 896",
        focusable: "false",
        ...props,
        children: /*#__PURE__*/ (0, _jsxdevruntime.jsxDEV)("path", {
            d: "M921 912L601.11 445.75l.55.43L890.08 112H793.7L558.74 384 372.15 112H119.37l298.65 435.31-.04-.04L103 912h96.39L460.6 609.38 668.2 912zM333.96 184.73l448.83 654.54H706.4L257.2 184.73z"
        }, void 0, false, {
            fileName: "node_modules/@ant-design/icons-svg/inline-svg/outlined/x.svg",
            lineNumber: 2,
            columnNumber: 108
        }, this)
    }, void 0, false, {
        fileName: "node_modules/@ant-design/icons-svg/inline-svg/outlined/x.svg",
        lineNumber: 2,
        columnNumber: 31
    }, this);
var _default = "data:image/svg+xml;base64,PHN2ZyBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiPjxwYXRoIGQ9Ik05MjEgOTEyTDYwMS4xMSA0NDUuNzVsLjU1LjQzTDg5MC4wOCAxMTJINzkzLjdMNTU4Ljc0IDM4NCAzNzIuMTUgMTEySDExOS4zN2wyOTguNjUgNDM1LjMxLS4wNC0uMDRMMTAzIDkxMmg5Ni4zOUw0NjAuNiA2MDkuMzggNjY4LjIgOTEyek0zMzMuOTYgMTg0LjczbDQ0OC44MyA2NTQuNTRINzA2LjRMMjU3LjIgMTg0LjczeiIgLz48L3N2Zz4=";

},
"node_modules/@ant-design/icons-svg/inline-svg/outlined/yuque.svg": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    ReactComponent: function() {
        return SvgComponent;
    },
    default: function() {
        return _default;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _jsxdevruntime = __mako_require__("node_modules/react/jsx-dev-runtime.js");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
const SvgComponent = (props)=>/*#__PURE__*/ (0, _jsxdevruntime.jsxDEV)("svg", {
        viewBox: "64 64 896 896",
        focusable: "false",
        ...props,
        children: /*#__PURE__*/ (0, _jsxdevruntime.jsxDEV)("path", {
            d: "M854.6 370.6c-9.9-39.4 9.9-102.2 73.4-124.4l-67.9-3.6s-25.7-90-143.6-98c-117.8-8.1-194.9-3-195-3 .1 0 87.4 55.6 52.4 154.7-25.6 52.5-65.8 95.6-108.8 144.7-1.3 1.3-2.5 2.6-3.5 3.7C319.4 605 96 860 96 860c245.9 64.4 410.7-6.3 508.2-91.1 20.5-.2 35.9-.3 46.3-.3 135.8 0 250.6-117.6 245.9-248.4-3.2-89.9-31.9-110.2-41.8-149.6zm-204.1 334c-10.6 0-26.2.1-46.8.3l-23.6.2-17.8 15.5c-47.1 41-104.4 71.5-171.4 87.6-52.5 12.6-110 16.2-172.7 9.6 18-20.5 36.5-41.6 55.4-63.1 92-104.6 173.8-197.5 236.9-268.5l1.4-1.4 1.3-1.5c4.1-4.6 20.6-23.3 24.7-28.1 9.7-11.1 17.3-19.9 24.5-28.6 30.7-36.7 52.2-67.8 69-102.2l1.6-3.3 1.2-3.4c13.7-38.8 15.4-76.9 6.2-112.8 22.5.7 46.5 1.9 71.7 3.6 33.3 2.3 55.5 12.9 71.1 29.2 5.8 6 10.2 12.5 13.4 18.7 1 2 1.7 3.6 2.3 5l5 17.7c-15.7 34.5-19.9 73.3-11.4 107.2 3 11.8 6.9 22.4 12.3 34.4 2.1 4.7 9.5 20.1 11 23.3 10.3 22.7 15.4 43 16.7 78.7 3.3 94.6-82.7 181.9-182 181.9z"
        }, void 0, false, {
            fileName: "node_modules/@ant-design/icons-svg/inline-svg/outlined/yuque.svg",
            lineNumber: 2,
            columnNumber: 89
        }, this)
    }, void 0, false, {
        fileName: "node_modules/@ant-design/icons-svg/inline-svg/outlined/yuque.svg",
        lineNumber: 2,
        columnNumber: 31
    }, this);
var _default = "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSI2NCA2NCA4OTYgODk2IiBmb2N1c2FibGU9ImZhbHNlIj48cGF0aCBkPSJNODU0LjYgMzcwLjZjLTkuOS0zOS40IDkuOS0xMDIuMiA3My40LTEyNC40bC02Ny45LTMuNnMtMjUuNy05MC0xNDMuNi05OGMtMTE3LjgtOC4xLTE5NC45LTMtMTk1LTMgLjEgMCA4Ny40IDU1LjYgNTIuNCAxNTQuNy0yNS42IDUyLjUtNjUuOCA5NS42LTEwOC44IDE0NC43LTEuMyAxLjMtMi41IDIuNi0zLjUgMy43QzMxOS40IDYwNSA5NiA4NjAgOTYgODYwYzI0NS45IDY0LjQgNDEwLjctNi4zIDUwOC4yLTkxLjEgMjAuNS0uMiAzNS45LS4zIDQ2LjMtLjMgMTM1LjggMCAyNTAuNi0xMTcuNiAyNDUuOS0yNDguNC0zLjItODkuOS0zMS45LTExMC4yLTQxLjgtMTQ5LjZ6bS0yMDQuMSAzMzRjLTEwLjYgMC0yNi4yLjEtNDYuOC4zbC0yMy42LjItMTcuOCAxNS41Yy00Ny4xIDQxLTEwNC40IDcxLjUtMTcxLjQgODcuNi01Mi41IDEyLjYtMTEwIDE2LjItMTcyLjcgOS42IDE4LTIwLjUgMzYuNS00MS42IDU1LjQtNjMuMSA5Mi0xMDQuNiAxNzMuOC0xOTcuNSAyMzYuOS0yNjguNWwxLjQtMS40IDEuMy0xLjVjNC4xLTQuNiAyMC42LTIzLjMgMjQuNy0yOC4xIDkuNy0xMS4xIDE3LjMtMTkuOSAyNC41LTI4LjYgMzAuNy0zNi43IDUyLjItNjcuOCA2OS0xMDIuMmwxLjYtMy4zIDEuMi0zLjRjMTMuNy0zOC44IDE1LjQtNzYuOSA2LjItMTEyLjggMjIuNS43IDQ2LjUgMS45IDcxLjcgMy42IDMzLjMgMi4zIDU1LjUgMTIuOSA3MS4xIDI5LjIgNS44IDYgMTAuMiAxMi41IDEzLjQgMTguNyAxIDIgMS43IDMuNiAyLjMgNWw1IDE3LjdjLTE1LjcgMzQuNS0xOS45IDczLjMtMTEuNCAxMDcuMiAzIDExLjggNi45IDIyLjQgMTIuMyAzNC40IDIuMSA0LjcgOS41IDIwLjEgMTEgMjMuMyAxMC4zIDIyLjcgMTUuNCA0MyAxNi43IDc4LjcgMy4zIDk0LjYtODIuNyAxODEuOS0xODIgMTgxLjl6IiAvPjwvc3ZnPg==";

},
"node_modules/@ant-design/icons-svg/inline-svg/outlined/zhihu.svg": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    ReactComponent: function() {
        return SvgComponent;
    },
    default: function() {
        return _default;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _jsxdevruntime = __mako_require__("node_modules/react/jsx-dev-runtime.js");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
const SvgComponent = (props)=>/*#__PURE__*/ (0, _jsxdevruntime.jsxDEV)("svg", {
        viewBox: "64 64 896 896",
        focusable: "false",
        ...props,
        children: /*#__PURE__*/ (0, _jsxdevruntime.jsxDEV)("path", {
            d: "M564.7 230.1V803h60l25.2 71.4L756.3 803h131.5V230.1H564.7zm247.7 497h-59.9l-75.1 50.4-17.8-50.4h-18V308.3h170.7v418.8zM526.1 486.9H393.3c2.1-44.9 4.3-104.3 6.6-172.9h130.9l-.1-8.1c0-.6-.2-14.7-2.3-29.1-2.1-15-6.6-34.9-21-34.9H287.8c4.4-20.6 15.7-69.7 29.4-93.8l6.4-11.2-12.9-.7c-.8 0-19.6-.9-41.4 10.6-35.7 19-51.7 56.4-58.7 84.4-18.4 73.1-44.6 123.9-55.7 145.6-3.3 6.4-5.3 10.2-6.2 12.8-1.8 4.9-.8 9.8 2.8 13 10.5 9.5 38.2-2.9 38.5-3 .6-.3 1.3-.6 2.2-1 13.9-6.3 55.1-25 69.8-84.5h56.7c.7 32.2 3.1 138.4 2.9 172.9h-141l-2.1 1.5c-23.1 16.9-30.5 63.2-30.8 65.2l-1.4 9.2h167c-12.3 78.3-26.5 113.4-34 127.4-3.7 7-7.3 14-10.7 20.8-21.3 42.2-43.4 85.8-126.3 153.6-3.6 2.8-7 8-4.8 13.7 2.4 6.3 9.3 9.1 24.6 9.1 5.4 0 11.8-.3 19.4-1 49.9-4.4 100.8-18 135.1-87.6 17-35.1 31.7-71.7 43.9-108.9L497 850l5-12c.8-1.9 19-46.3 5.1-95.9l-.5-1.8-108.1-123-22 16.6c6.4-26.1 10.6-49.9 12.5-71.1h158.7v-8c0-40.1-18.5-63.9-19.2-64.9l-2.4-3z"
        }, void 0, false, {
            fileName: "node_modules/@ant-design/icons-svg/inline-svg/outlined/zhihu.svg",
            lineNumber: 2,
            columnNumber: 89
        }, this)
    }, void 0, false, {
        fileName: "node_modules/@ant-design/icons-svg/inline-svg/outlined/zhihu.svg",
        lineNumber: 2,
        columnNumber: 31
    }, this);
var _default = "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSI2NCA2NCA4OTYgODk2IiBmb2N1c2FibGU9ImZhbHNlIj48cGF0aCBkPSJNNTY0LjcgMjMwLjFWODAzaDYwbDI1LjIgNzEuNEw3NTYuMyA4MDNoMTMxLjVWMjMwLjFINTY0Ljd6bTI0Ny43IDQ5N2gtNTkuOWwtNzUuMSA1MC40LTE3LjgtNTAuNGgtMThWMzA4LjNoMTcwLjd2NDE4Ljh6TTUyNi4xIDQ4Ni45SDM5My4zYzIuMS00NC45IDQuMy0xMDQuMyA2LjYtMTcyLjloMTMwLjlsLS4xLTguMWMwLS42LS4yLTE0LjctMi4zLTI5LjEtMi4xLTE1LTYuNi0zNC45LTIxLTM0LjlIMjg3LjhjNC40LTIwLjYgMTUuNy02OS43IDI5LjQtOTMuOGw2LjQtMTEuMi0xMi45LS43Yy0uOCAwLTE5LjYtLjktNDEuNCAxMC42LTM1LjcgMTktNTEuNyA1Ni40LTU4LjcgODQuNC0xOC40IDczLjEtNDQuNiAxMjMuOS01NS43IDE0NS42LTMuMyA2LjQtNS4zIDEwLjItNi4yIDEyLjgtMS44IDQuOS0uOCA5LjggMi44IDEzIDEwLjUgOS41IDM4LjItMi45IDM4LjUtMyAuNi0uMyAxLjMtLjYgMi4yLTEgMTMuOS02LjMgNTUuMS0yNSA2OS44LTg0LjVoNTYuN2MuNyAzMi4yIDMuMSAxMzguNCAyLjkgMTcyLjloLTE0MWwtMi4xIDEuNWMtMjMuMSAxNi45LTMwLjUgNjMuMi0zMC44IDY1LjJsLTEuNCA5LjJoMTY3Yy0xMi4zIDc4LjMtMjYuNSAxMTMuNC0zNCAxMjcuNC0zLjcgNy03LjMgMTQtMTAuNyAyMC44LTIxLjMgNDIuMi00My40IDg1LjgtMTI2LjMgMTUzLjYtMy42IDIuOC03IDgtNC44IDEzLjcgMi40IDYuMyA5LjMgOS4xIDI0LjYgOS4xIDUuNCAwIDExLjgtLjMgMTkuNC0xIDQ5LjktNC40IDEwMC44LTE4IDEzNS4xLTg3LjYgMTctMzUuMSAzMS43LTcxLjcgNDMuOS0xMDguOUw0OTcgODUwbDUtMTJjLjgtMS45IDE5LTQ2LjMgNS4xLTk1LjlsLS41LTEuOC0xMDguMS0xMjMtMjIgMTYuNmM2LjQtMjYuMSAxMC42LTQ5LjkgMTIuNS03MS4xaDE1OC43di04YzAtNDAuMS0xOC41LTYzLjktMTkuMi02NC45bC0yLjQtM3oiIC8+PC9zdmc+";

},
"node_modules/@babel/runtime/helpers/esm/objectDestructuringEmpty.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _objectDestructuringEmpty;
    }
});
function _objectDestructuringEmpty(t) {
    if (null == t) throw new TypeError("Cannot destructure " + t);
}

},
"node_modules/@babel/runtime/helpers/interopRequireDefault.js": function (module, exports, __mako_require__){
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        "default": e
    };
}
module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;

},
"node_modules/@babel/runtime/helpers/typeof.js": function (module, exports, __mako_require__){
function _typeof(o) {
    "@babel/helpers - typeof";
    return module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof(o);
}
module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;

},
"node_modules/@jridgewell/gen-mapping/dist/gen-mapping.mjs": function (module, exports, __mako_require__){
// src/set-array.ts
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    GenMapping: function() {
        return GenMapping;
    },
    addMapping: function() {
        return addMapping;
    },
    addSegment: function() {
        return addSegment;
    },
    allMappings: function() {
        return allMappings;
    },
    fromMap: function() {
        return fromMap;
    },
    maybeAddMapping: function() {
        return maybeAddMapping;
    },
    maybeAddSegment: function() {
        return maybeAddSegment;
    },
    setIgnore: function() {
        return setIgnore;
    },
    setSourceContent: function() {
        return setSourceContent;
    },
    toDecodedMap: function() {
        return toDecodedMap;
    },
    toEncodedMap: function() {
        return toEncodedMap;
    }
});
var _sourcemapcodec = __mako_require__("node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs");
var _tracemapping = __mako_require__("node_modules/@jridgewell/trace-mapping/dist/trace-mapping.mjs");
var SetArray = class {
    constructor(){
        this._indexes = {
            __proto__: null
        };
        this.array = [];
    }
};
function cast(set) {
    return set;
}
function get(setarr, key) {
    return cast(setarr)._indexes[key];
}
function put(setarr, key) {
    const index = get(setarr, key);
    if (index !== void 0) return index;
    const { array, _indexes: indexes } = cast(setarr);
    const length = array.push(key);
    return indexes[key] = length - 1;
}
function remove(setarr, key) {
    const index = get(setarr, key);
    if (index === void 0) return;
    const { array, _indexes: indexes } = cast(setarr);
    for(let i = index + 1; i < array.length; i++){
        const k = array[i];
        array[i - 1] = k;
        indexes[k]--;
    }
    indexes[key] = void 0;
    array.pop();
}
// src/sourcemap-segment.ts
var COLUMN = 0;
var SOURCES_INDEX = 1;
var SOURCE_LINE = 2;
var SOURCE_COLUMN = 3;
var NAMES_INDEX = 4;
// src/gen-mapping.ts
var NO_NAME = -1;
var GenMapping = class {
    constructor({ file, sourceRoot } = {}){
        this._names = new SetArray();
        this._sources = new SetArray();
        this._sourcesContent = [];
        this._mappings = [];
        this.file = file;
        this.sourceRoot = sourceRoot;
        this._ignoreList = new SetArray();
    }
};
function cast2(map) {
    return map;
}
function addSegment(map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {
    return addSegmentInternal(false, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);
}
function addMapping(map, mapping) {
    return addMappingInternal(false, map, mapping);
}
var maybeAddSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name, content)=>{
    return addSegmentInternal(true, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);
};
var maybeAddMapping = (map, mapping)=>{
    return addMappingInternal(true, map, mapping);
};
function setSourceContent(map, source, content) {
    const { _sources: sources, _sourcesContent: sourcesContent } = cast2(map);
    const index = put(sources, source);
    sourcesContent[index] = content;
}
function setIgnore(map, source, ignore = true) {
    const { _sources: sources, _sourcesContent: sourcesContent, _ignoreList: ignoreList } = cast2(map);
    const index = put(sources, source);
    if (index === sourcesContent.length) sourcesContent[index] = null;
    if (ignore) put(ignoreList, index);
    else remove(ignoreList, index);
}
function toDecodedMap(map) {
    const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names, _ignoreList: ignoreList } = cast2(map);
    removeEmptyFinalLines(mappings);
    return {
        version: 3,
        file: map.file || void 0,
        names: names.array,
        sourceRoot: map.sourceRoot || void 0,
        sources: sources.array,
        sourcesContent,
        mappings,
        // originalScopes,
        // generatedRanges,
        ignoreList: ignoreList.array
    };
}
function toEncodedMap(map) {
    const decoded = toDecodedMap(map);
    return Object.assign({}, decoded, {
        // originalScopes: decoded.originalScopes.map((os) => encodeOriginalScopes(os)),
        // generatedRanges: encodeGeneratedRanges(decoded.generatedRanges as GeneratedRange[]),
        mappings: (0, _sourcemapcodec.encode)(decoded.mappings)
    });
}
function fromMap(input) {
    const map = new _tracemapping.TraceMap(input);
    const gen = new GenMapping({
        file: map.file,
        sourceRoot: map.sourceRoot
    });
    putAll(cast2(gen)._names, map.names);
    putAll(cast2(gen)._sources, map.sources);
    cast2(gen)._sourcesContent = map.sourcesContent || map.sources.map(()=>null);
    cast2(gen)._mappings = (0, _tracemapping.decodedMappings)(map);
    if (map.ignoreList) putAll(cast2(gen)._ignoreList, map.ignoreList);
    return gen;
}
function allMappings(map) {
    const out = [];
    const { _mappings: mappings, _sources: sources, _names: names } = cast2(map);
    for(let i = 0; i < mappings.length; i++){
        const line = mappings[i];
        for(let j = 0; j < line.length; j++){
            const seg = line[j];
            const generated = {
                line: i + 1,
                column: seg[COLUMN]
            };
            let source = void 0;
            let original = void 0;
            let name = void 0;
            if (seg.length !== 1) {
                source = sources.array[seg[SOURCES_INDEX]];
                original = {
                    line: seg[SOURCE_LINE] + 1,
                    column: seg[SOURCE_COLUMN]
                };
                if (seg.length === 5) name = names.array[seg[NAMES_INDEX]];
            }
            out.push({
                generated,
                source,
                original,
                name
            });
        }
    }
    return out;
}
function addSegmentInternal(skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {
    const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names } = cast2(map);
    const line = getIndex(mappings, genLine);
    const index = getColumnIndex(line, genColumn);
    if (!source) {
        if (skipable && skipSourceless(line, index)) return;
        return insert(line, index, [
            genColumn
        ]);
    }
    assert(sourceLine);
    assert(sourceColumn);
    const sourcesIndex = put(sources, source);
    const namesIndex = name ? put(names, name) : NO_NAME;
    if (sourcesIndex === sourcesContent.length) sourcesContent[sourcesIndex] = content != null ? content : null;
    if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) return;
    return insert(line, index, name ? [
        genColumn,
        sourcesIndex,
        sourceLine,
        sourceColumn,
        namesIndex
    ] : [
        genColumn,
        sourcesIndex,
        sourceLine,
        sourceColumn
    ]);
}
function assert(_val) {}
function getIndex(arr, index) {
    for(let i = arr.length; i <= index; i++)arr[i] = [];
    return arr[index];
}
function getColumnIndex(line, genColumn) {
    let index = line.length;
    for(let i = index - 1; i >= 0; index = i--){
        const current = line[i];
        if (genColumn >= current[COLUMN]) break;
    }
    return index;
}
function insert(array, index, value) {
    for(let i = array.length; i > index; i--)array[i] = array[i - 1];
    array[index] = value;
}
function removeEmptyFinalLines(mappings) {
    const { length } = mappings;
    let len = length;
    for(let i = len - 1; i >= 0; len = i, i--){
        if (mappings[i].length > 0) break;
    }
    if (len < length) mappings.length = len;
}
function putAll(setarr, array) {
    for(let i = 0; i < array.length; i++)put(setarr, array[i]);
}
function skipSourceless(line, index) {
    if (index === 0) return true;
    const prev = line[index - 1];
    return prev.length === 1;
}
function skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex) {
    if (index === 0) return false;
    const prev = line[index - 1];
    if (prev.length === 1) return false;
    return sourcesIndex === prev[SOURCES_INDEX] && sourceLine === prev[SOURCE_LINE] && sourceColumn === prev[SOURCE_COLUMN] && namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME);
}
function addMappingInternal(skipable, map, mapping) {
    const { generated, source, original, name, content } = mapping;
    if (!source) return addSegmentInternal(skipable, map, generated.line - 1, generated.column, null, null, null, null, null);
    assert(original);
    return addSegmentInternal(skipable, map, generated.line - 1, generated.column, source, original.line - 1, original.column, name, content);
}
 //# sourceMappingURL=gen-mapping.mjs.map

},
"node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js": function (module, exports, __mako_require__){
(function(global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof void 0 === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.resolveURI = factory());
})(this, function() {
    'use strict';
    // Matches the scheme of a URL, eg "http://"
    const schemeRegex = /^[\w+.-]+:\/\//;
    /**
     * Matches the parts of a URL:
     * 1. Scheme, including ":", guaranteed.
     * 2. User/password, including "@", optional.
     * 3. Host, guaranteed.
     * 4. Port, including ":", optional.
     * 5. Path, including "/", optional.
     * 6. Query, including "?", optional.
     * 7. Hash, including "#", optional.
     */ const urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/;
    /**
     * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start
     * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).
     *
     * 1. Host, optional.
     * 2. Path, which may include "/", guaranteed.
     * 3. Query, including "?", optional.
     * 4. Hash, including "#", optional.
     */ const fileRegex = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
    function isAbsoluteUrl(input) {
        return schemeRegex.test(input);
    }
    function isSchemeRelativeUrl(input) {
        return input.startsWith('//');
    }
    function isAbsolutePath(input) {
        return input.startsWith('/');
    }
    function isFileUrl(input) {
        return input.startsWith('file:');
    }
    function isRelative(input) {
        return /^[.?#]/.test(input);
    }
    function parseAbsoluteUrl(input) {
        const match = urlRegex.exec(input);
        return makeUrl(match[1], match[2] || '', match[3], match[4] || '', match[5] || '/', match[6] || '', match[7] || '');
    }
    function parseFileUrl(input) {
        const match = fileRegex.exec(input);
        const path = match[2];
        return makeUrl('file:', '', match[1] || '', '', isAbsolutePath(path) ? path : '/' + path, match[3] || '', match[4] || '');
    }
    function makeUrl(scheme, user, host, port, path, query, hash) {
        return {
            scheme,
            user,
            host,
            port,
            path,
            query,
            hash,
            type: 7 /* Absolute */ 
        };
    }
    function parseUrl(input) {
        if (isSchemeRelativeUrl(input)) {
            const url = parseAbsoluteUrl('http:' + input);
            url.scheme = '';
            url.type = 6 /* SchemeRelative */ ;
            return url;
        }
        if (isAbsolutePath(input)) {
            const url = parseAbsoluteUrl('http://foo.com' + input);
            url.scheme = '';
            url.host = '';
            url.type = 5 /* AbsolutePath */ ;
            return url;
        }
        if (isFileUrl(input)) return parseFileUrl(input);
        if (isAbsoluteUrl(input)) return parseAbsoluteUrl(input);
        const url = parseAbsoluteUrl('http://foo.com/' + input);
        url.scheme = '';
        url.host = '';
        url.type = input ? input.startsWith('?') ? 3 /* Query */  : input.startsWith('#') ? 2 /* Hash */  : 4 /* RelativePath */  : 1 /* Empty */ ;
        return url;
    }
    function stripPathFilename(path) {
        // If a path ends with a parent directory "..", then it's a relative path with excess parent
        // paths. It's not a file, so we can't strip it.
        if (path.endsWith('/..')) return path;
        const index = path.lastIndexOf('/');
        return path.slice(0, index + 1);
    }
    function mergePaths(url, base) {
        normalizePath(base, base.type);
        // If the path is just a "/", then it was an empty path to begin with (remember, we're a relative
        // path).
        if (url.path === '/') url.path = base.path;
        else // Resolution happens relative to the base path's directory, not the file.
        url.path = stripPathFilename(base.path) + url.path;
    }
    /**
     * The path can have empty directories "//", unneeded parents "foo/..", or current directory
     * "foo/.". We need to normalize to a standard representation.
     */ function normalizePath(url, type) {
        const rel = type <= 4 /* RelativePath */ ;
        const pieces = url.path.split('/');
        // We need to preserve the first piece always, so that we output a leading slash. The item at
        // pieces[0] is an empty string.
        let pointer = 1;
        // Positive is the number of real directories we've output, used for popping a parent directory.
        // Eg, "foo/bar/.." will have a positive 2, and we can decrement to be left with just "foo".
        let positive = 0;
        // We need to keep a trailing slash if we encounter an empty directory (eg, splitting "foo/" will
        // generate `["foo", ""]` pieces). And, if we pop a parent directory. But once we encounter a
        // real directory, we won't need to append, unless the other conditions happen again.
        let addTrailingSlash = false;
        for(let i = 1; i < pieces.length; i++){
            const piece = pieces[i];
            // An empty directory, could be a trailing slash, or just a double "//" in the path.
            if (!piece) {
                addTrailingSlash = true;
                continue;
            }
            // If we encounter a real directory, then we don't need to append anymore.
            addTrailingSlash = false;
            // A current directory, which we can always drop.
            if (piece === '.') continue;
            // A parent directory, we need to see if there are any real directories we can pop. Else, we
            // have an excess of parents, and we'll need to keep the "..".
            if (piece === '..') {
                if (positive) {
                    addTrailingSlash = true;
                    positive--;
                    pointer--;
                } else if (rel) // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute
                // URL, protocol relative URL, or an absolute path, we don't need to keep excess.
                pieces[pointer++] = piece;
                continue;
            }
            // We've encountered a real directory. Move it to the next insertion pointer, which accounts for
            // any popped or dropped directories.
            pieces[pointer++] = piece;
            positive++;
        }
        let path = '';
        for(let i = 1; i < pointer; i++)path += '/' + pieces[i];
        if (!path || addTrailingSlash && !path.endsWith('/..')) path += '/';
        url.path = path;
    }
    /**
     * Attempts to resolve `input` URL/path relative to `base`.
     */ function resolve(input, base) {
        if (!input && !base) return '';
        const url = parseUrl(input);
        let inputType = url.type;
        if (base && inputType !== 7 /* Absolute */ ) {
            const baseUrl = parseUrl(base);
            const baseType = baseUrl.type;
            switch(inputType){
                case 1 /* Empty */ :
                    url.hash = baseUrl.hash;
                // fall through
                case 2 /* Hash */ :
                    url.query = baseUrl.query;
                // fall through
                case 3 /* Query */ :
                case 4 /* RelativePath */ :
                    mergePaths(url, baseUrl);
                // fall through
                case 5 /* AbsolutePath */ :
                    // The host, user, and port are joined, you can't copy one without the others.
                    url.user = baseUrl.user;
                    url.host = baseUrl.host;
                    url.port = baseUrl.port;
                // fall through
                case 6 /* SchemeRelative */ :
                    // The input doesn't have a schema at least, so we need to copy at least that over.
                    url.scheme = baseUrl.scheme;
            }
            if (baseType > inputType) inputType = baseType;
        }
        normalizePath(url, inputType);
        const queryHash = url.query + url.hash;
        switch(inputType){
            // This is impossible, because of the empty checks at the start of the function.
            // case UrlType.Empty:
            case 2 /* Hash */ :
            case 3 /* Query */ :
                return queryHash;
            case 4 /* RelativePath */ :
                {
                    // The first char is always a "/", and we need it to be relative.
                    const path = url.path.slice(1);
                    if (!path) return queryHash || '.';
                    if (isRelative(base || input) && !isRelative(path)) // If base started with a leading ".", or there is no base and input started with a ".",
                    // then we need to ensure that the relative path starts with a ".". We don't know if
                    // relative starts with a "..", though, so check before prepending.
                    return './' + path + queryHash;
                    return path + queryHash;
                }
            case 5 /* AbsolutePath */ :
                return url.path + queryHash;
            default:
                return url.scheme + '//' + url.user + url.host + url.port + url.path + queryHash;
        }
    }
    return resolve;
}); //# sourceMappingURL=resolve-uri.umd.js.map

},
"node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs": function (module, exports, __mako_require__){
// src/vlq.ts
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    decode: function() {
        return decode;
    },
    decodeGeneratedRanges: function() {
        return decodeGeneratedRanges;
    },
    decodeOriginalScopes: function() {
        return decodeOriginalScopes;
    },
    encode: function() {
        return encode;
    },
    encodeGeneratedRanges: function() {
        return encodeGeneratedRanges;
    },
    encodeOriginalScopes: function() {
        return encodeOriginalScopes;
    }
});
const Buffer = __mako_require__("node_modules/node-libs-browser-okam/polyfill/buffer.js").Buffer;
var comma = ",".charCodeAt(0);
var semicolon = ";".charCodeAt(0);
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var intToChar = new Uint8Array(64);
var charToInt = new Uint8Array(128);
for(let i = 0; i < chars.length; i++){
    const c = chars.charCodeAt(i);
    intToChar[i] = c;
    charToInt[c] = i;
}
function decodeInteger(reader, relative) {
    let value = 0;
    let shift = 0;
    let integer = 0;
    do {
        const c = reader.next();
        integer = charToInt[c];
        value |= (integer & 31) << shift;
        shift += 5;
    }while (integer & 32)
    const shouldNegate = value & 1;
    value >>>= 1;
    if (shouldNegate) value = -2147483648 | -value;
    return relative + value;
}
function encodeInteger(builder, num, relative) {
    let delta = num - relative;
    delta = delta < 0 ? -delta << 1 | 1 : delta << 1;
    do {
        let clamped = delta & 31;
        delta >>>= 5;
        if (delta > 0) clamped |= 32;
        builder.write(intToChar[clamped]);
    }while (delta > 0)
    return num;
}
function hasMoreVlq(reader, max) {
    if (reader.pos >= max) return false;
    return reader.peek() !== comma;
}
// src/strings.ts
var bufLength = 16384;
var td = typeof TextDecoder !== "undefined" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer !== "undefined" ? {
    decode (buf) {
        const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
        return out.toString();
    }
} : {
    decode (buf) {
        let out = "";
        for(let i = 0; i < buf.length; i++)out += String.fromCharCode(buf[i]);
        return out;
    }
};
var StringWriter = class {
    constructor(){
        this.pos = 0;
        this.out = "";
        this.buffer = new Uint8Array(bufLength);
    }
    write(v) {
        const { buffer } = this;
        buffer[this.pos++] = v;
        if (this.pos === bufLength) {
            this.out += td.decode(buffer);
            this.pos = 0;
        }
    }
    flush() {
        const { buffer, out, pos } = this;
        return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;
    }
};
var StringReader = class {
    constructor(buffer){
        this.pos = 0;
        this.buffer = buffer;
    }
    next() {
        return this.buffer.charCodeAt(this.pos++);
    }
    peek() {
        return this.buffer.charCodeAt(this.pos);
    }
    indexOf(char) {
        const { buffer, pos } = this;
        const idx = buffer.indexOf(char, pos);
        return idx === -1 ? buffer.length : idx;
    }
};
// src/scopes.ts
var EMPTY = [];
function decodeOriginalScopes(input) {
    const { length } = input;
    const reader = new StringReader(input);
    const scopes = [];
    const stack = [];
    let line = 0;
    for(; reader.pos < length; reader.pos++){
        line = decodeInteger(reader, line);
        const column = decodeInteger(reader, 0);
        if (!hasMoreVlq(reader, length)) {
            const last = stack.pop();
            last[2] = line;
            last[3] = column;
            continue;
        }
        const kind = decodeInteger(reader, 0);
        const fields = decodeInteger(reader, 0);
        const hasName = fields & 1;
        const scope = hasName ? [
            line,
            column,
            0,
            0,
            kind,
            decodeInteger(reader, 0)
        ] : [
            line,
            column,
            0,
            0,
            kind
        ];
        let vars = EMPTY;
        if (hasMoreVlq(reader, length)) {
            vars = [];
            do {
                const varsIndex = decodeInteger(reader, 0);
                vars.push(varsIndex);
            }while (hasMoreVlq(reader, length))
        }
        scope.vars = vars;
        scopes.push(scope);
        stack.push(scope);
    }
    return scopes;
}
function encodeOriginalScopes(scopes) {
    const writer = new StringWriter();
    for(let i = 0; i < scopes.length;)i = _encodeOriginalScopes(scopes, i, writer, [
        0
    ]);
    return writer.flush();
}
function _encodeOriginalScopes(scopes, index, writer, state) {
    const scope = scopes[index];
    const { 0: startLine, 1: startColumn, 2: endLine, 3: endColumn, 4: kind, vars } = scope;
    if (index > 0) writer.write(comma);
    state[0] = encodeInteger(writer, startLine, state[0]);
    encodeInteger(writer, startColumn, 0);
    encodeInteger(writer, kind, 0);
    const fields = scope.length === 6 ? 1 : 0;
    encodeInteger(writer, fields, 0);
    if (scope.length === 6) encodeInteger(writer, scope[5], 0);
    for (const v of vars)encodeInteger(writer, v, 0);
    for(index++; index < scopes.length;){
        const next = scopes[index];
        const { 0: l, 1: c } = next;
        if (l > endLine || l === endLine && c >= endColumn) break;
        index = _encodeOriginalScopes(scopes, index, writer, state);
    }
    writer.write(comma);
    state[0] = encodeInteger(writer, endLine, state[0]);
    encodeInteger(writer, endColumn, 0);
    return index;
}
function decodeGeneratedRanges(input) {
    const { length } = input;
    const reader = new StringReader(input);
    const ranges = [];
    const stack = [];
    let genLine = 0;
    let definitionSourcesIndex = 0;
    let definitionScopeIndex = 0;
    let callsiteSourcesIndex = 0;
    let callsiteLine = 0;
    let callsiteColumn = 0;
    let bindingLine = 0;
    let bindingColumn = 0;
    do {
        const semi = reader.indexOf(";");
        let genColumn = 0;
        for(; reader.pos < semi; reader.pos++){
            genColumn = decodeInteger(reader, genColumn);
            if (!hasMoreVlq(reader, semi)) {
                const last = stack.pop();
                last[2] = genLine;
                last[3] = genColumn;
                continue;
            }
            const fields = decodeInteger(reader, 0);
            const hasDefinition = fields & 1;
            const hasCallsite = fields & 2;
            const hasScope = fields & 4;
            let callsite = null;
            let bindings = EMPTY;
            let range;
            if (hasDefinition) {
                const defSourcesIndex = decodeInteger(reader, definitionSourcesIndex);
                definitionScopeIndex = decodeInteger(reader, definitionSourcesIndex === defSourcesIndex ? definitionScopeIndex : 0);
                definitionSourcesIndex = defSourcesIndex;
                range = [
                    genLine,
                    genColumn,
                    0,
                    0,
                    defSourcesIndex,
                    definitionScopeIndex
                ];
            } else range = [
                genLine,
                genColumn,
                0,
                0
            ];
            range.isScope = !!hasScope;
            if (hasCallsite) {
                const prevCsi = callsiteSourcesIndex;
                const prevLine = callsiteLine;
                callsiteSourcesIndex = decodeInteger(reader, callsiteSourcesIndex);
                const sameSource = prevCsi === callsiteSourcesIndex;
                callsiteLine = decodeInteger(reader, sameSource ? callsiteLine : 0);
                callsiteColumn = decodeInteger(reader, sameSource && prevLine === callsiteLine ? callsiteColumn : 0);
                callsite = [
                    callsiteSourcesIndex,
                    callsiteLine,
                    callsiteColumn
                ];
            }
            range.callsite = callsite;
            if (hasMoreVlq(reader, semi)) {
                bindings = [];
                do {
                    bindingLine = genLine;
                    bindingColumn = genColumn;
                    const expressionsCount = decodeInteger(reader, 0);
                    let expressionRanges;
                    if (expressionsCount < -1) {
                        expressionRanges = [
                            [
                                decodeInteger(reader, 0)
                            ]
                        ];
                        for(let i = -1; i > expressionsCount; i--){
                            const prevBl = bindingLine;
                            bindingLine = decodeInteger(reader, bindingLine);
                            bindingColumn = decodeInteger(reader, bindingLine === prevBl ? bindingColumn : 0);
                            const expression = decodeInteger(reader, 0);
                            expressionRanges.push([
                                expression,
                                bindingLine,
                                bindingColumn
                            ]);
                        }
                    } else expressionRanges = [
                        [
                            expressionsCount
                        ]
                    ];
                    bindings.push(expressionRanges);
                }while (hasMoreVlq(reader, semi))
            }
            range.bindings = bindings;
            ranges.push(range);
            stack.push(range);
        }
        genLine++;
        reader.pos = semi + 1;
    }while (reader.pos < length)
    return ranges;
}
function encodeGeneratedRanges(ranges) {
    if (ranges.length === 0) return "";
    const writer = new StringWriter();
    for(let i = 0; i < ranges.length;)i = _encodeGeneratedRanges(ranges, i, writer, [
        0,
        0,
        0,
        0,
        0,
        0,
        0
    ]);
    return writer.flush();
}
function _encodeGeneratedRanges(ranges, index, writer, state) {
    const range = ranges[index];
    const { 0: startLine, 1: startColumn, 2: endLine, 3: endColumn, isScope, callsite, bindings } = range;
    if (state[0] < startLine) {
        catchupLine(writer, state[0], startLine);
        state[0] = startLine;
        state[1] = 0;
    } else if (index > 0) writer.write(comma);
    state[1] = encodeInteger(writer, range[1], state[1]);
    const fields = (range.length === 6 ? 1 : 0) | (callsite ? 2 : 0) | (isScope ? 4 : 0);
    encodeInteger(writer, fields, 0);
    if (range.length === 6) {
        const { 4: sourcesIndex, 5: scopesIndex } = range;
        if (sourcesIndex !== state[2]) state[3] = 0;
        state[2] = encodeInteger(writer, sourcesIndex, state[2]);
        state[3] = encodeInteger(writer, scopesIndex, state[3]);
    }
    if (callsite) {
        const { 0: sourcesIndex, 1: callLine, 2: callColumn } = range.callsite;
        if (sourcesIndex !== state[4]) {
            state[5] = 0;
            state[6] = 0;
        } else if (callLine !== state[5]) state[6] = 0;
        state[4] = encodeInteger(writer, sourcesIndex, state[4]);
        state[5] = encodeInteger(writer, callLine, state[5]);
        state[6] = encodeInteger(writer, callColumn, state[6]);
    }
    if (bindings) for (const binding of bindings){
        if (binding.length > 1) encodeInteger(writer, -binding.length, 0);
        const expression = binding[0][0];
        encodeInteger(writer, expression, 0);
        let bindingStartLine = startLine;
        let bindingStartColumn = startColumn;
        for(let i = 1; i < binding.length; i++){
            const expRange = binding[i];
            bindingStartLine = encodeInteger(writer, expRange[1], bindingStartLine);
            bindingStartColumn = encodeInteger(writer, expRange[2], bindingStartColumn);
            encodeInteger(writer, expRange[0], 0);
        }
    }
    for(index++; index < ranges.length;){
        const next = ranges[index];
        const { 0: l, 1: c } = next;
        if (l > endLine || l === endLine && c >= endColumn) break;
        index = _encodeGeneratedRanges(ranges, index, writer, state);
    }
    if (state[0] < endLine) {
        catchupLine(writer, state[0], endLine);
        state[0] = endLine;
        state[1] = 0;
    } else writer.write(comma);
    state[1] = encodeInteger(writer, endColumn, state[1]);
    return index;
}
function catchupLine(writer, lastLine, line) {
    do writer.write(semicolon);
    while (++lastLine < line)
}
// src/sourcemap-codec.ts
function decode(mappings) {
    const { length } = mappings;
    const reader = new StringReader(mappings);
    const decoded = [];
    let genColumn = 0;
    let sourcesIndex = 0;
    let sourceLine = 0;
    let sourceColumn = 0;
    let namesIndex = 0;
    do {
        const semi = reader.indexOf(";");
        const line = [];
        let sorted = true;
        let lastCol = 0;
        genColumn = 0;
        while(reader.pos < semi){
            let seg;
            genColumn = decodeInteger(reader, genColumn);
            if (genColumn < lastCol) sorted = false;
            lastCol = genColumn;
            if (hasMoreVlq(reader, semi)) {
                sourcesIndex = decodeInteger(reader, sourcesIndex);
                sourceLine = decodeInteger(reader, sourceLine);
                sourceColumn = decodeInteger(reader, sourceColumn);
                if (hasMoreVlq(reader, semi)) {
                    namesIndex = decodeInteger(reader, namesIndex);
                    seg = [
                        genColumn,
                        sourcesIndex,
                        sourceLine,
                        sourceColumn,
                        namesIndex
                    ];
                } else seg = [
                    genColumn,
                    sourcesIndex,
                    sourceLine,
                    sourceColumn
                ];
            } else seg = [
                genColumn
            ];
            line.push(seg);
            reader.pos++;
        }
        if (!sorted) sort(line);
        decoded.push(line);
        reader.pos = semi + 1;
    }while (reader.pos <= length)
    return decoded;
}
function sort(line) {
    line.sort(sortComparator);
}
function sortComparator(a, b) {
    return a[0] - b[0];
}
function encode(decoded) {
    const writer = new StringWriter();
    let sourcesIndex = 0;
    let sourceLine = 0;
    let sourceColumn = 0;
    let namesIndex = 0;
    for(let i = 0; i < decoded.length; i++){
        const line = decoded[i];
        if (i > 0) writer.write(semicolon);
        if (line.length === 0) continue;
        let genColumn = 0;
        for(let j = 0; j < line.length; j++){
            const segment = line[j];
            if (j > 0) writer.write(comma);
            genColumn = encodeInteger(writer, segment[0], genColumn);
            if (segment.length === 1) continue;
            sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);
            sourceLine = encodeInteger(writer, segment[2], sourceLine);
            sourceColumn = encodeInteger(writer, segment[3], sourceColumn);
            if (segment.length === 4) continue;
            namesIndex = encodeInteger(writer, segment[4], namesIndex);
        }
    }
    return writer.flush();
}
 //# sourceMappingURL=sourcemap-codec.mjs.map

},
"node_modules/@jridgewell/trace-mapping/dist/trace-mapping.mjs": function (module, exports, __mako_require__){
// src/trace-mapping.ts
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    AnyMap: function() {
        return FlattenMap;
    },
    FlattenMap: function() {
        return FlattenMap;
    },
    GREATEST_LOWER_BOUND: function() {
        return GREATEST_LOWER_BOUND;
    },
    LEAST_UPPER_BOUND: function() {
        return LEAST_UPPER_BOUND;
    },
    TraceMap: function() {
        return TraceMap;
    },
    allGeneratedPositionsFor: function() {
        return allGeneratedPositionsFor;
    },
    decodedMap: function() {
        return decodedMap;
    },
    decodedMappings: function() {
        return decodedMappings;
    },
    eachMapping: function() {
        return eachMapping;
    },
    encodedMap: function() {
        return encodedMap;
    },
    encodedMappings: function() {
        return encodedMappings;
    },
    generatedPositionFor: function() {
        return generatedPositionFor;
    },
    isIgnored: function() {
        return isIgnored;
    },
    originalPositionFor: function() {
        return originalPositionFor;
    },
    presortedDecodedMap: function() {
        return presortedDecodedMap;
    },
    sourceContentFor: function() {
        return sourceContentFor;
    },
    traceSegment: function() {
        return traceSegment;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _sourcemapcodec = __mako_require__("node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs");
var _resolveuri = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js"));
// src/strip-filename.ts
function stripFilename(path) {
    if (!path) return "";
    const index = path.lastIndexOf("/");
    return path.slice(0, index + 1);
}
// src/resolve.ts
function resolver(mapUrl, sourceRoot) {
    const from = stripFilename(mapUrl);
    const prefix = sourceRoot ? sourceRoot + "/" : "";
    return (source)=>(0, _resolveuri.default)(prefix + (source || ""), from);
}
// src/sourcemap-segment.ts
var COLUMN = 0;
var SOURCES_INDEX = 1;
var SOURCE_LINE = 2;
var SOURCE_COLUMN = 3;
var NAMES_INDEX = 4;
var REV_GENERATED_LINE = 1;
var REV_GENERATED_COLUMN = 2;
// src/sort.ts
function maybeSort(mappings, owned) {
    const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);
    if (unsortedIndex === mappings.length) return mappings;
    if (!owned) mappings = mappings.slice();
    for(let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1))mappings[i] = sortSegments(mappings[i], owned);
    return mappings;
}
function nextUnsortedSegmentLine(mappings, start) {
    for(let i = start; i < mappings.length; i++){
        if (!isSorted(mappings[i])) return i;
    }
    return mappings.length;
}
function isSorted(line) {
    for(let j = 1; j < line.length; j++){
        if (line[j][COLUMN] < line[j - 1][COLUMN]) return false;
    }
    return true;
}
function sortSegments(line, owned) {
    if (!owned) line = line.slice();
    return line.sort(sortComparator);
}
function sortComparator(a, b) {
    return a[COLUMN] - b[COLUMN];
}
// src/binary-search.ts
var found = false;
function binarySearch(haystack, needle, low, high) {
    while(low <= high){
        const mid = low + (high - low >> 1);
        const cmp = haystack[mid][COLUMN] - needle;
        if (cmp === 0) {
            found = true;
            return mid;
        }
        if (cmp < 0) low = mid + 1;
        else high = mid - 1;
    }
    found = false;
    return low - 1;
}
function upperBound(haystack, needle, index) {
    for(let i = index + 1; i < haystack.length; index = i++){
        if (haystack[i][COLUMN] !== needle) break;
    }
    return index;
}
function lowerBound(haystack, needle, index) {
    for(let i = index - 1; i >= 0; index = i--){
        if (haystack[i][COLUMN] !== needle) break;
    }
    return index;
}
function memoizedState() {
    return {
        lastKey: -1,
        lastNeedle: -1,
        lastIndex: -1
    };
}
function memoizedBinarySearch(haystack, needle, state, key) {
    const { lastKey, lastNeedle, lastIndex } = state;
    let low = 0;
    let high = haystack.length - 1;
    if (key === lastKey) {
        if (needle === lastNeedle) {
            found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;
            return lastIndex;
        }
        if (needle >= lastNeedle) low = lastIndex === -1 ? 0 : lastIndex;
        else high = lastIndex;
    }
    state.lastKey = key;
    state.lastNeedle = needle;
    return state.lastIndex = binarySearch(haystack, needle, low, high);
}
// src/by-source.ts
function buildBySources(decoded, memos) {
    const sources = memos.map(buildNullArray);
    for(let i = 0; i < decoded.length; i++){
        const line = decoded[i];
        for(let j = 0; j < line.length; j++){
            const seg = line[j];
            if (seg.length === 1) continue;
            const sourceIndex2 = seg[SOURCES_INDEX];
            const sourceLine = seg[SOURCE_LINE];
            const sourceColumn = seg[SOURCE_COLUMN];
            const originalSource = sources[sourceIndex2];
            const originalLine = originalSource[sourceLine] || (originalSource[sourceLine] = []);
            const memo = memos[sourceIndex2];
            let index = upperBound(originalLine, sourceColumn, memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine));
            memo.lastIndex = ++index;
            insert(originalLine, index, [
                sourceColumn,
                i,
                seg[COLUMN]
            ]);
        }
    }
    return sources;
}
function insert(array, index, value) {
    for(let i = array.length; i > index; i--)array[i] = array[i - 1];
    array[index] = value;
}
function buildNullArray() {
    return {
        __proto__: null
    };
}
// src/types.ts
function parse(map) {
    return typeof map === "string" ? JSON.parse(map) : map;
}
// src/flatten-map.ts
var FlattenMap = function(map, mapUrl) {
    const parsed = parse(map);
    if (!("sections" in parsed)) return new TraceMap(parsed, mapUrl);
    const mappings = [];
    const sources = [];
    const sourcesContent = [];
    const names = [];
    const ignoreList = [];
    recurse(parsed, mapUrl, mappings, sources, sourcesContent, names, ignoreList, 0, 0, Infinity, Infinity);
    const joined = {
        version: 3,
        file: parsed.file,
        names,
        sources,
        sourcesContent,
        mappings,
        ignoreList
    };
    return presortedDecodedMap(joined);
};
function recurse(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {
    const { sections } = input;
    for(let i = 0; i < sections.length; i++){
        const { map, offset } = sections[i];
        let sl = stopLine;
        let sc = stopColumn;
        if (i + 1 < sections.length) {
            const nextOffset = sections[i + 1].offset;
            sl = Math.min(stopLine, lineOffset + nextOffset.line);
            if (sl === stopLine) sc = Math.min(stopColumn, columnOffset + nextOffset.column);
            else if (sl < stopLine) sc = columnOffset + nextOffset.column;
        }
        addSection(map, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset + offset.line, columnOffset + offset.column, sl, sc);
    }
}
function addSection(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {
    const parsed = parse(input);
    if ("sections" in parsed) return recurse(...arguments);
    const map = new TraceMap(parsed, mapUrl);
    const sourcesOffset = sources.length;
    const namesOffset = names.length;
    const decoded = decodedMappings(map);
    const { resolvedSources, sourcesContent: contents, ignoreList: ignores } = map;
    append(sources, resolvedSources);
    append(names, map.names);
    if (contents) append(sourcesContent, contents);
    else for(let i = 0; i < resolvedSources.length; i++)sourcesContent.push(null);
    if (ignores) for(let i = 0; i < ignores.length; i++)ignoreList.push(ignores[i] + sourcesOffset);
    for(let i = 0; i < decoded.length; i++){
        const lineI = lineOffset + i;
        if (lineI > stopLine) return;
        const out = getLine(mappings, lineI);
        const cOffset = i === 0 ? columnOffset : 0;
        const line = decoded[i];
        for(let j = 0; j < line.length; j++){
            const seg = line[j];
            const column = cOffset + seg[COLUMN];
            if (lineI === stopLine && column >= stopColumn) return;
            if (seg.length === 1) {
                out.push([
                    column
                ]);
                continue;
            }
            const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];
            const sourceLine = seg[SOURCE_LINE];
            const sourceColumn = seg[SOURCE_COLUMN];
            out.push(seg.length === 4 ? [
                column,
                sourcesIndex,
                sourceLine,
                sourceColumn
            ] : [
                column,
                sourcesIndex,
                sourceLine,
                sourceColumn,
                namesOffset + seg[NAMES_INDEX]
            ]);
        }
    }
}
function append(arr, other) {
    for(let i = 0; i < other.length; i++)arr.push(other[i]);
}
function getLine(arr, index) {
    for(let i = arr.length; i <= index; i++)arr[i] = [];
    return arr[index];
}
// src/trace-mapping.ts
var LINE_GTR_ZERO = "`line` must be greater than 0 (lines start at line 1)";
var COL_GTR_EQ_ZERO = "`column` must be greater than or equal to 0 (columns start at column 0)";
var LEAST_UPPER_BOUND = -1;
var GREATEST_LOWER_BOUND = 1;
var TraceMap = class {
    constructor(map, mapUrl){
        const isString = typeof map === "string";
        if (!isString && map._decodedMemo) return map;
        const parsed = parse(map);
        const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;
        this.version = version;
        this.file = file;
        this.names = names || [];
        this.sourceRoot = sourceRoot;
        this.sources = sources;
        this.sourcesContent = sourcesContent;
        this.ignoreList = parsed.ignoreList || parsed.x_google_ignoreList || void 0;
        const resolve = resolver(mapUrl, sourceRoot);
        this.resolvedSources = sources.map(resolve);
        const { mappings } = parsed;
        if (typeof mappings === "string") {
            this._encoded = mappings;
            this._decoded = void 0;
        } else if (Array.isArray(mappings)) {
            this._encoded = void 0;
            this._decoded = maybeSort(mappings, isString);
        } else if (parsed.sections) throw new Error(`TraceMap passed sectioned source map, please use FlattenMap export instead`);
        else throw new Error(`invalid source map: ${JSON.stringify(parsed)}`);
        this._decodedMemo = memoizedState();
        this._bySources = void 0;
        this._bySourceMemos = void 0;
    }
};
function cast(map) {
    return map;
}
function encodedMappings(map) {
    var _a, _b;
    return (_b = (_a = cast(map))._encoded) != null ? _b : _a._encoded = (0, _sourcemapcodec.encode)(cast(map)._decoded);
}
function decodedMappings(map) {
    var _a;
    return (_a = cast(map))._decoded || (_a._decoded = (0, _sourcemapcodec.decode)(cast(map)._encoded));
}
function traceSegment(map, line, column) {
    const decoded = decodedMappings(map);
    if (line >= decoded.length) return null;
    const segments = decoded[line];
    const index = traceSegmentInternal(segments, cast(map)._decodedMemo, line, column, GREATEST_LOWER_BOUND);
    return index === -1 ? null : segments[index];
}
function originalPositionFor(map, needle) {
    let { line, column, bias } = needle;
    line--;
    if (line < 0) throw new Error(LINE_GTR_ZERO);
    if (column < 0) throw new Error(COL_GTR_EQ_ZERO);
    const decoded = decodedMappings(map);
    if (line >= decoded.length) return OMapping(null, null, null, null);
    const segments = decoded[line];
    const index = traceSegmentInternal(segments, cast(map)._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);
    if (index === -1) return OMapping(null, null, null, null);
    const segment = segments[index];
    if (segment.length === 1) return OMapping(null, null, null, null);
    const { names, resolvedSources } = map;
    return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], segment.length === 5 ? names[segment[NAMES_INDEX]] : null);
}
function generatedPositionFor(map, needle) {
    const { source, line, column, bias } = needle;
    return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false);
}
function allGeneratedPositionsFor(map, needle) {
    const { source, line, column, bias } = needle;
    return generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, true);
}
function eachMapping(map, cb) {
    const decoded = decodedMappings(map);
    const { names, resolvedSources } = map;
    for(let i = 0; i < decoded.length; i++){
        const line = decoded[i];
        for(let j = 0; j < line.length; j++){
            const seg = line[j];
            const generatedLine = i + 1;
            const generatedColumn = seg[0];
            let source = null;
            let originalLine = null;
            let originalColumn = null;
            let name = null;
            if (seg.length !== 1) {
                source = resolvedSources[seg[1]];
                originalLine = seg[2] + 1;
                originalColumn = seg[3];
            }
            if (seg.length === 5) name = names[seg[4]];
            cb({
                generatedLine,
                generatedColumn,
                source,
                originalLine,
                originalColumn,
                name
            });
        }
    }
}
function sourceIndex(map, source) {
    const { sources, resolvedSources } = map;
    let index = sources.indexOf(source);
    if (index === -1) index = resolvedSources.indexOf(source);
    return index;
}
function sourceContentFor(map, source) {
    const { sourcesContent } = map;
    if (sourcesContent == null) return null;
    const index = sourceIndex(map, source);
    return index === -1 ? null : sourcesContent[index];
}
function isIgnored(map, source) {
    const { ignoreList } = map;
    if (ignoreList == null) return false;
    const index = sourceIndex(map, source);
    return index === -1 ? false : ignoreList.includes(index);
}
function presortedDecodedMap(map, mapUrl) {
    const tracer = new TraceMap(clone(map, []), mapUrl);
    cast(tracer)._decoded = map.mappings;
    return tracer;
}
function decodedMap(map) {
    return clone(map, decodedMappings(map));
}
function encodedMap(map) {
    return clone(map, encodedMappings(map));
}
function clone(map, mappings) {
    return {
        version: map.version,
        file: map.file,
        names: map.names,
        sourceRoot: map.sourceRoot,
        sources: map.sources,
        sourcesContent: map.sourcesContent,
        mappings,
        ignoreList: map.ignoreList || map.x_google_ignoreList
    };
}
function OMapping(source, line, column, name) {
    return {
        source,
        line,
        column,
        name
    };
}
function GMapping(line, column) {
    return {
        line,
        column
    };
}
function traceSegmentInternal(segments, memo, line, column, bias) {
    let index = memoizedBinarySearch(segments, column, memo, line);
    if (found) index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);
    else if (bias === LEAST_UPPER_BOUND) index++;
    if (index === -1 || index === segments.length) return -1;
    return index;
}
function sliceGeneratedPositions(segments, memo, line, column, bias) {
    let min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);
    if (!found && bias === LEAST_UPPER_BOUND) min++;
    if (min === -1 || min === segments.length) return [];
    const matchedColumn = found ? column : segments[min][COLUMN];
    if (!found) min = lowerBound(segments, matchedColumn, min);
    const max = upperBound(segments, matchedColumn, min);
    const result = [];
    for(; min <= max; min++){
        const segment = segments[min];
        result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));
    }
    return result;
}
function generatedPosition(map, source, line, column, bias, all) {
    var _a;
    line--;
    if (line < 0) throw new Error(LINE_GTR_ZERO);
    if (column < 0) throw new Error(COL_GTR_EQ_ZERO);
    const { sources, resolvedSources } = map;
    let sourceIndex2 = sources.indexOf(source);
    if (sourceIndex2 === -1) sourceIndex2 = resolvedSources.indexOf(source);
    if (sourceIndex2 === -1) return all ? [] : GMapping(null, null);
    const generated = (_a = cast(map))._bySources || (_a._bySources = buildBySources(decodedMappings(map), cast(map)._bySourceMemos = sources.map(memoizedState)));
    const segments = generated[sourceIndex2][line];
    if (segments == null) return all ? [] : GMapping(null, null);
    const memo = cast(map)._bySourceMemos[sourceIndex2];
    if (all) return sliceGeneratedPositions(segments, memo, line, column, bias);
    const index = traceSegmentInternal(segments, memo, line, column, bias);
    if (index === -1) return GMapping(null, null);
    const segment = segments[index];
    return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);
}
 //# sourceMappingURL=trace-mapping.mjs.map

},
"node_modules/@makotot/ghostui/dist/ghostui.esm.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    Pagination: function() {
        return Pagination$1;
    },
    ReadingProgress: function() {
        return ReadingProgress$1;
    },
    Scrollspy: function() {
        return Scrollspy;
    },
    usePagination: function() {
        return usePagination;
    },
    useReadingProgress: function() {
        return useReadingProgress;
    },
    useScrollspy: function() {
        return useScrollspy;
    }
});
var _react = __mako_require__("node_modules/react/index.js");
var debounce = function debounce(callback) {
    var reqID = null;
    var exec = function exec(args) {
        return function() {
            // @ts-ignore TS2488
            callback.apply(void 0, args);
        };
    };
    return function() {
        if (reqID) cancelAnimationFrame(reqID);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
        reqID = requestAnimationFrame(exec(args));
    };
};
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}
var ReadingProgressCore = function ReadingProgressCore() {};
var ReadingProgressWindow = /*#__PURE__*/ function(_ReadingProgressCore) {
    _inheritsLoose(ReadingProgressWindow, _ReadingProgressCore);
    function ReadingProgressWindow() {
        var _this;
        _this = _ReadingProgressCore.apply(this, arguments) || this;
        _this.measureWrapperHeight = function() {
            var targetElHeihgt = document.body.getBoundingClientRect().height || 0;
            return Math.round(targetElHeihgt - _this.getViewportHeight());
        };
        _this.getViewportHeight = function() {
            return Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
        };
        _this.getProgress = function() {
            var top = window.pageYOffset || document.documentElement.scrollTop;
            return Math.round(top / _this.measureWrapperHeight() * 100);
        };
        return _this;
    }
    _createClass(ReadingProgressWindow, [
        {
            key: "rootSelector",
            get: function get() {
                return window;
            }
        }
    ]);
    return ReadingProgressWindow;
}(ReadingProgressCore);
var ReadingProgressElement = /*#__PURE__*/ function(_ReadingProgressCore2) {
    _inheritsLoose(ReadingProgressElement, _ReadingProgressCore2);
    function ReadingProgressElement(_ref) {
        var _this2;
        var rootEl = _ref.rootEl, targetEl = _ref.targetEl;
        _this2 = _ReadingProgressCore2.call(this) || this;
        _this2.measureWrapperHeight = function() {
            var _this2$targetEl;
            var targetElHeight = ((_this2$targetEl = _this2.targetEl) == null ? void 0 : _this2$targetEl.getBoundingClientRect().height) || 0;
            return Math.round(targetElHeight - _this2.getViewportHeight());
        };
        _this2.getViewportHeight = function() {
            var _this2$rootEl;
            return ((_this2$rootEl = _this2.rootEl) == null ? void 0 : _this2$rootEl.clientHeight) || 0;
        };
        _this2.getProgress = function() {
            var _this2$rootEl2;
            var top = ((_this2$rootEl2 = _this2.rootEl) == null ? void 0 : _this2$rootEl2.scrollTop) || 0;
            return Math.round(top / _this2.measureWrapperHeight() * 100);
        };
        _this2.rootEl = document.querySelector(rootEl);
        _this2.targetEl = document.querySelector(targetEl);
        return _this2;
    }
    _createClass(ReadingProgressElement, [
        {
            key: "rootSelector",
            get: function get() {
                return this.rootEl;
            }
        }
    ]);
    return ReadingProgressElement;
}(ReadingProgressCore);
var ReadingProgress = /*#__PURE__*/ function() {
    function ReadingProgress(_ref2) {
        var _this3 = this;
        var rootEl = _ref2.rootEl, targetEl = _ref2.targetEl;
        this.getViewportHeight = function() {
            return _this3.rp.getViewportHeight();
        };
        this.getProgress = function() {
            return _this3.rp.getProgress();
        };
        this.rp = typeof rootEl === 'string' && typeof targetEl === 'string' ? new ReadingProgressElement({
            rootEl: rootEl,
            targetEl: targetEl
        }) : new ReadingProgressWindow();
    }
    _createClass(ReadingProgress, [
        {
            key: "rootSelector",
            get: function get() {
                return this.rp.rootSelector;
            }
        }
    ]);
    return ReadingProgress;
}();
var useReadingProgress = function useReadingProgress(props) {
    var _rp$current;
    var rp = (0, _react.useRef)();
    (0, _react.useEffect)(function() {
        rp.current = new ReadingProgress({
            rootEl: props == null ? void 0 : props.rootEl,
            targetEl: props == null ? void 0 : props.targetEl
        });
    }, [
        props
    ]);
    var _useState = (0, _react.useState)(((_rp$current = rp.current) == null ? void 0 : _rp$current.getProgress()) || 0), value = _useState[0], updateProgressValue = _useState[1];
    var update = (0, _react.useCallback)(function() {
        var _rp$current2;
        updateProgressValue(((_rp$current2 = rp.current) == null ? void 0 : _rp$current2.getProgress()) || 0);
    }, []);
    var debounceUpdate = (0, _react.useCallback)(debounce(function() {
        update();
    }), []);
    (0, _react.useEffect)(function() {
        var _rp$current3;
        if ((_rp$current3 = rp.current) != null && _rp$current3.rootSelector) rp.current.rootSelector.addEventListener('scroll', debounceUpdate);
        window.addEventListener('resize', debounceUpdate);
        update();
        return function() {
            var _rp$current4;
            if ((_rp$current4 = rp.current) != null && _rp$current4.rootSelector) rp.current.rootSelector.removeEventListener('scroll', debounceUpdate);
            window.removeEventListener('resize', debounceUpdate);
        };
    }, [
        update,
        debounceUpdate
    ]);
    return {
        value: value
    };
};
var ReadingProgress$1 = function ReadingProgress(_ref) {
    var targetEl = _ref.targetEl, rootEl = _ref.rootEl, children = _ref.children;
    var readingProgress = useReadingProgress({
        targetEl: targetEl,
        rootEl: rootEl
    });
    return children(readingProgress);
};
var Root = function Root() {};
var RootEl = /*#__PURE__*/ function(_Root) {
    _inheritsLoose(RootEl, _Root);
    function RootEl(el) {
        var _this;
        _this = _Root.call(this) || this;
        _this.el = el;
        return _this;
    }
    var _proto = RootEl.prototype;
    _proto.isScrolledToBottom = function isScrolledToBottom() {
        return this.scrollTop + this.outerHeight >= this.scrollHeight;
    };
    _proto.registerScrollEvent = function registerScrollEvent(callback) {
        this.el.addEventListener('scroll', callback);
    };
    _proto.unregisterScrollEvent = function unregisterScrollEvent(callback) {
        this.el.removeEventListener('scroll', callback);
    };
    RootEl.create = function create(selector) {
        var el = document.querySelector(selector);
        if (!el) throw new Error('element is not found.');
        return new RootEl(el);
    };
    _createClass(RootEl, [
        {
            key: "top",
            get: function get() {
                return this.el.getBoundingClientRect().top;
            }
        },
        {
            key: "outerHeight",
            get: function get() {
                return this.el.getBoundingClientRect().height;
            }
        },
        {
            key: "scrollTop",
            get: function get() {
                return this.el.scrollTop;
            }
        },
        {
            key: "scrollHeight",
            get: function get() {
                return this.el.scrollHeight;
            }
        }
    ]);
    return RootEl;
}(Root);
var RootWindow = /*#__PURE__*/ function(_Root) {
    _inheritsLoose(RootWindow, _Root);
    function RootWindow() {
        return _Root.apply(this, arguments) || this;
    }
    var _proto = RootWindow.prototype;
    _proto.isScrolledToBottom = function isScrolledToBottom() {
        return this.scrollTop + this.outerHeight >= this.scrollHeight;
    };
    _proto.registerScrollEvent = function registerScrollEvent(callback) {
        document.addEventListener('scroll', callback);
    };
    _proto.unregisterScrollEvent = function unregisterScrollEvent(callback) {
        document.removeEventListener('scroll', callback);
    };
    RootWindow.create = function create() {
        return new RootWindow();
    };
    _createClass(RootWindow, [
        {
            key: "outerHeight",
            get: function get() {
                return window.innerHeight;
            }
        },
        {
            key: "scrollTop",
            get: function get() {
                return document.documentElement.scrollTop;
            }
        },
        {
            key: "scrollHeight",
            get: function get() {
                return document.documentElement.scrollHeight;
            }
        }
    ]);
    return RootWindow;
}(Root);
var RootFactory = /*#__PURE__*/ function() {
    function RootFactory() {}
    RootFactory.create = function create(selector) {
        if (!selector) return RootWindow.create();
        return RootEl.create(selector);
    };
    return RootFactory;
}();
var useScrollspy = function useScrollspy(_ref) {
    var sectionRefs = _ref.sectionRefs, rootSelector = _ref.rootSelector, _ref$offset = _ref.offset, offset = _ref$offset === void 0 ? 0 : _ref$offset;
    var rootEl = (0, _react.useRef)(null);
    (0, _react.useEffect)(function() {
        rootEl.current = RootFactory.create(rootSelector);
    }, [
        rootSelector
    ]);
    var isScrolledToBottom = (0, _react.useCallback)(function() {
        if (!rootEl.current) return false;
        return rootEl.current.isScrolledToBottom();
    }, [
        rootEl
    ]);
    var isElementInViewport = (0, _react.useCallback)(function(element) {
        if (!rootEl.current) return false;
        var innerScrollTop = rootEl.current.scrollTop;
        var innerScrollBottom = innerScrollTop + rootEl.current.outerHeight;
        var elementRect = element.getBoundingClientRect();
        var elementScrollTop = rootEl.current instanceof RootEl ? innerScrollTop + elementRect.top - rootEl.current.top + offset : innerScrollTop + elementRect.top + offset;
        var elementScrollBottom = elementScrollTop + elementRect.height;
        return [
            elementScrollTop < innerScrollBottom,
            elementScrollBottom > innerScrollTop
        ].every(function(v) {
            return v;
        });
    }, [
        rootEl,
        offset
    ]);
    var getElementsStatusInViewport = (0, _react.useCallback)(function() {
        return sectionRefs.map(function(sectionRef) {
            if (sectionRef.current) return isElementInViewport(sectionRef.current);
            return false;
        });
    }, [
        isElementInViewport,
        sectionRefs
    ]);
    var _useState = (0, _react.useState)([]), elementsStatusInViewport = _useState[0], updateElementsStatusInViewport = _useState[1];
    var currentElementIndexInViewport = (0, _react.useMemo)(function() {
        return elementsStatusInViewport.findIndex(function(status) {
            return status;
        });
    }, [
        elementsStatusInViewport
    ]);
    var spy = (0, _react.useCallback)(function() {
        var newElementsStatusInViewport = isScrolledToBottom() ? [].concat(new Array(sectionRefs.length - 1).fill(false).map(function(v) {
            return v;
        }), [
            true
        ]) : getElementsStatusInViewport();
        updateElementsStatusInViewport(newElementsStatusInViewport);
    }, [
        getElementsStatusInViewport,
        isScrolledToBottom,
        sectionRefs
    ]);
    (0, _react.useEffect)(function() {
        spy();
        if (rootEl.current) rootEl.current.registerScrollEvent(spy);
        return function() {
            if (rootEl.current) rootEl.current.unregisterScrollEvent(spy);
        };
    }, [
        spy
    ]);
    return {
        elementsStatusInViewport: elementsStatusInViewport,
        currentElementIndexInViewport: currentElementIndexInViewport
    };
};
var Scrollspy = function Scrollspy(_ref) {
    var children = _ref.children, sectionRefs = _ref.sectionRefs, rootSelector = _ref.rootSelector, offset = _ref.offset;
    var _useScrollspy = useScrollspy({
        sectionRefs: sectionRefs,
        rootSelector: rootSelector,
        offset: offset
    }), elementsStatusInViewport = _useScrollspy.elementsStatusInViewport, currentElementIndexInViewport = _useScrollspy.currentElementIndexInViewport;
    return children({
        elementsStatusInViewport: elementsStatusInViewport,
        currentElementIndexInViewport: currentElementIndexInViewport
    });
};
var Pagination = function Pagination(_ref) {
    var _this = this;
    var currentPage = _ref.currentPage, totalPage = _ref.totalPage, _ref$middlePagesSibli = _ref.middlePagesSiblingCount, middlePagesSiblingCount = _ref$middlePagesSibli === void 0 ? 2 : _ref$middlePagesSibli, _ref$edgePageCount = _ref.edgePageCount, edgePageCount = _ref$edgePageCount === void 0 ? 2 : _ref$edgePageCount;
    this.getAllPages = function() {
        return [].concat(Array(_this.totalPage)).fill(1).map(function(_, i) {
            return i + 1;
        });
    };
    this.getMiddlePageCount = function() {
        return _this.middlePagesSiblingCount * 2 + 1;
    };
    this.isReachedToFirst = function() {
        return _this.currentPage <= _this.middlePagesSiblingCount;
    };
    this.isReachedToLast = function() {
        return _this.currentPage + _this.middlePagesSiblingCount >= _this.totalPage;
    };
    this.getAllPreviousPages = function() {
        return _this.getAllPages().slice(0, _this.getMiddlePages()[0] - 1);
    };
    this.getAllNextPages = function() {
        var totalPageItems = _this.getAllPages();
        var middlePages = _this.getMiddlePages();
        return totalPageItems.slice(middlePages[middlePages.length - 1], totalPageItems[totalPageItems.length]);
    };
    this.hasPreviousPage = function() {
        return _this.currentPage > 1;
    };
    this.hasNextPage = function() {
        return _this.totalPage > _this.currentPage;
    };
    this.getMiddlePages = function() {
        var totalPageItems = _this.getAllPages();
        var middlePageCount = _this.getMiddlePageCount();
        if (_this.isReachedToFirst()) return totalPageItems.slice(0, middlePageCount);
        if (_this.isReachedToLast()) return totalPageItems.slice(-middlePageCount);
        return totalPageItems.slice(_this.currentPage - _this.middlePagesSiblingCount - 1, _this.currentPage + _this.middlePagesSiblingCount);
    };
    this.getPreviousPages = function() {
        if (_this.isReachedToFirst()) return [];
        if (_this.getAllPreviousPages().length < 1) return [];
        return _this.getAllPages().slice(0, _this.edgePageCount).filter(function(p) {
            return !_this.getMiddlePages().includes(p);
        });
    };
    this.getNextPages = function() {
        if (_this.isReachedToLast()) return [];
        if (_this.getAllNextPages().length < 1) return [];
        var totalPages = _this.getAllPages();
        return totalPages.slice(totalPages.length - _this.edgePageCount, totalPages.length).filter(function(p) {
            return !_this.getMiddlePages().includes(p);
        });
    };
    this.isPreviousTruncable = function() {
        return _this.getAllPreviousPages().filter(function(p) {
            return !_this.getPreviousPages().includes(p) && !_this.getMiddlePages().includes(p);
        }).length > 0;
    };
    this.isNextTruncable = function() {
        return _this.getAllNextPages().filter(function(p) {
            return !_this.getNextPages().includes(p) && !_this.getMiddlePages().includes(p);
        }).length > 0;
    };
    this.currentPage = currentPage;
    this.totalPage = totalPage;
    this.middlePagesSiblingCount = middlePagesSiblingCount;
    this.edgePageCount = edgePageCount;
};
var MIDDLE_PAGES_SIBLING_COUNT = 2;
var EDGE_PAGE_COUNT = 2;
var usePagination = function usePagination(_ref) {
    var totalPage = _ref.totalPage, currentPage = _ref.currentPage, _ref$middlePagesSibli = _ref.middlePagesSiblingCount, middlePagesSiblingCount = _ref$middlePagesSibli === void 0 ? MIDDLE_PAGES_SIBLING_COUNT : _ref$middlePagesSibli, _ref$edgePageCount = _ref.edgePageCount, edgePageCount = _ref$edgePageCount === void 0 ? EDGE_PAGE_COUNT : _ref$edgePageCount;
    var pagination = (0, _react.useMemo)(function() {
        return new Pagination({
            totalPage: totalPage,
            currentPage: currentPage,
            middlePagesSiblingCount: middlePagesSiblingCount,
            edgePageCount: edgePageCount
        });
    }, [
        totalPage,
        currentPage,
        middlePagesSiblingCount,
        edgePageCount
    ]);
    return {
        getMiddlePages: pagination.getMiddlePages,
        hasPreviousPage: pagination.hasPreviousPage,
        hasNextPage: pagination.hasNextPage,
        getPreviousPages: pagination.getPreviousPages,
        getNextPages: pagination.getNextPages,
        isPreviousTruncable: pagination.isPreviousTruncable,
        isNextTruncable: pagination.isNextTruncable,
        totalPage: totalPage,
        currentPage: currentPage
    };
};
var Pagination$1 = function Pagination(_ref) {
    var children = _ref.children, totalPage = _ref.totalPage, currentPage = _ref.currentPage, middlePagesSiblingCount = _ref.middlePagesSiblingCount, edgePageCount = _ref.edgePageCount;
    var pagination = usePagination({
        totalPage: totalPage,
        currentPage: currentPage,
        middlePagesSiblingCount: middlePagesSiblingCount,
        edgePageCount: edgePageCount
    });
    return children(pagination);
};
 //# sourceMappingURL=ghostui.esm.js.map

},
"node_modules/@rc-component/drawer/assets/index.css?asmodule": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
"";
var _default = {
    "rc-drawer-left": `rc-drawer-left-LxHjC8U0`,
    "rc-drawer-content": `rc-drawer-content-yQ7AKf__`,
    "rc-drawer-content-wrapper-hidden": `rc-drawer-content-wrapper-hidden-62Foo3qm`,
    "rc-drawer-content-wrapper": `rc-drawer-content-wrapper-_5feUsKS`,
    "rc-drawer-mask": `rc-drawer-mask-Sjaz2EV5`,
    "rc-drawer-inline": `rc-drawer-inline-RmjyXnm9`,
    "rc-drawer": `rc-drawer-lhRGUC1W`,
    "rc-drawer-right": `rc-drawer-right-cgLz3tD6`
};

},
"node_modules/@rc-component/drawer/es/Drawer.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _portal = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/portal/es/index.js"));
var _useLayoutEffect = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/hooks/useLayoutEffect.js"));
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
var _context = __mako_require__("node_modules/@rc-component/drawer/es/context.js");
var _DrawerPopup = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/drawer/es/DrawerPopup.js"));
var _util = __mako_require__("node_modules/@rc-component/drawer/es/util.js");
const Drawer = (props)=>{
    const { open = false, prefixCls = 'rc-drawer', placement = 'right', autoFocus = true, keyboard = true, width = 378, mask = true, maskClosable = true, getContainer, forceRender, afterOpenChange, destroyOnHidden, onMouseEnter, onMouseOver, onMouseLeave, onClick, onKeyDown, onKeyUp, // Refs
    panelRef } = props;
    const [animatedVisible, setAnimatedVisible] = _react.useState(false);
    (0, _util.warnCheck)(props);
    // ============================= Open =============================
    const [mounted, setMounted] = _react.useState(false);
    (0, _useLayoutEffect.default)(()=>{
        setMounted(true);
    }, []);
    const mergedOpen = mounted ? open : false;
    // ============================ Focus =============================
    const popupRef = _react.useRef(null);
    const lastActiveRef = _react.useRef(null);
    (0, _useLayoutEffect.default)(()=>{
        if (mergedOpen) lastActiveRef.current = document.activeElement;
    }, [
        mergedOpen
    ]);
    // ============================= Open =============================
    const internalAfterOpenChange = (nextVisible)=>{
        var _popupRef_current;
        setAnimatedVisible(nextVisible);
        afterOpenChange === null || afterOpenChange === void 0 || afterOpenChange(nextVisible);
        if (!nextVisible && lastActiveRef.current && !((_popupRef_current = popupRef.current) === null || _popupRef_current === void 0 ? void 0 : _popupRef_current.contains(lastActiveRef.current))) {
            var _lastActiveRef_current;
            (_lastActiveRef_current = lastActiveRef.current) === null || _lastActiveRef_current === void 0 || _lastActiveRef_current.focus({
                preventScroll: true
            });
        }
    };
    // =========================== Context ============================
    const refContext = _react.useMemo(()=>({
            panel: panelRef
        }), [
        panelRef
    ]);
    // ============================ Render ============================
    if (!forceRender && !animatedVisible && !mergedOpen && destroyOnHidden) return null;
    const eventHandlers = {
        onMouseEnter,
        onMouseOver,
        onMouseLeave,
        onClick,
        onKeyDown,
        onKeyUp
    };
    const drawerPopupProps = {
        ...props,
        open: mergedOpen,
        prefixCls,
        placement,
        autoFocus,
        keyboard,
        width,
        mask,
        maskClosable,
        inline: getContainer === false,
        afterOpenChange: internalAfterOpenChange,
        ref: popupRef,
        ...eventHandlers
    };
    return /*#__PURE__*/ _react.createElement(_context.RefContext.Provider, {
        value: refContext
    }, /*#__PURE__*/ _react.createElement(_portal.default, {
        open: mergedOpen || forceRender || animatedVisible,
        autoDestroy: false,
        getContainer: getContainer,
        autoLock: mask && (mergedOpen || animatedVisible)
    }, /*#__PURE__*/ _react.createElement(_DrawerPopup.default, drawerPopupProps)));
};
Drawer.displayName = 'Drawer';
var _default = Drawer;

},
"node_modules/@rc-component/drawer/es/DrawerPanel.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _classnames = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/classnames/index.js"));
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
var _context = __mako_require__("node_modules/@rc-component/drawer/es/context.js");
var _pickAttrs = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/pickAttrs.js"));
var _ref = __mako_require__("node_modules/@rc-component/util/es/ref.js");
function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
const DrawerPanel = (props)=>{
    const { prefixCls, className, containerRef, ...restProps } = props;
    const { panel: panelRef } = _react.useContext(_context.RefContext);
    const mergedRef = (0, _ref.useComposeRef)(panelRef, containerRef);
    // =============================== Render ===============================
    return /*#__PURE__*/ _react.createElement("div", _extends({
        className: (0, _classnames.default)(`${prefixCls}-section`, className),
        role: "dialog",
        ref: mergedRef
    }, (0, _pickAttrs.default)(props, {
        aria: true
    }), {
        "aria-modal": "true"
    }, restProps));
};
DrawerPanel.displayName = 'DrawerPanel';
var _default = DrawerPanel;

},
"node_modules/@rc-component/drawer/es/DrawerPopup.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _classnames = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/classnames/index.js"));
var _motion = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/motion/es/index.js"));
var _KeyCode = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/KeyCode.js"));
var _pickAttrs = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/pickAttrs.js"));
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
var _context = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/drawer/es/context.js"));
var _DrawerPanel = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/drawer/es/DrawerPanel.js"));
var _util = __mako_require__("node_modules/@rc-component/drawer/es/util.js");
function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
const sentinelStyle = {
    width: 0,
    height: 0,
    overflow: 'hidden',
    outline: 'none',
    position: 'absolute'
};
const DrawerPopup = (props, ref)=>{
    const { prefixCls, open, placement, inline, push, forceRender, autoFocus, keyboard, // classNames
    classNames: drawerClassNames, // Root
    rootClassName, rootStyle, zIndex, // Drawer
    className, id, style, motion, width, height, children, // Mask
    mask, maskClosable, maskMotion, maskClassName, maskStyle, // Events
    afterOpenChange, onClose, onMouseEnter, onMouseOver, onMouseLeave, onClick, onKeyDown, onKeyUp, styles, drawerRender } = props;
    // ================================ Refs ================================
    const panelRef = _react.useRef(null);
    const sentinelStartRef = _react.useRef(null);
    const sentinelEndRef = _react.useRef(null);
    _react.useImperativeHandle(ref, ()=>panelRef.current);
    const onPanelKeyDown = (event)=>{
        const { keyCode, shiftKey } = event;
        switch(keyCode){
            // Tab active
            case _KeyCode.default.TAB:
                if (keyCode === _KeyCode.default.TAB) {
                    if (!shiftKey && document.activeElement === sentinelEndRef.current) {
                        var _sentinelStartRef_current;
                        (_sentinelStartRef_current = sentinelStartRef.current) === null || _sentinelStartRef_current === void 0 || _sentinelStartRef_current.focus({
                            preventScroll: true
                        });
                    } else if (shiftKey && document.activeElement === sentinelStartRef.current) {
                        var _sentinelEndRef_current;
                        (_sentinelEndRef_current = sentinelEndRef.current) === null || _sentinelEndRef_current === void 0 || _sentinelEndRef_current.focus({
                            preventScroll: true
                        });
                    }
                }
                break;
            // Close
            case _KeyCode.default.ESC:
                if (onClose && keyboard) {
                    event.stopPropagation();
                    onClose(event);
                }
                break;
        }
    };
    // ========================== Control ===========================
    // Auto Focus
    _react.useEffect(()=>{
        if (open && autoFocus) {
            var _panelRef_current;
            (_panelRef_current = panelRef.current) === null || _panelRef_current === void 0 || _panelRef_current.focus({
                preventScroll: true
            });
        }
    }, [
        open
    ]);
    // ============================ Push ============================
    const [pushed, setPushed] = _react.useState(false);
    const parentContext = _react.useContext(_context.default);
    // Merge push distance
    let pushConfig;
    if (typeof push === 'boolean') pushConfig = push ? {} : {
        distance: 0
    };
    else pushConfig = push || {};
    const pushDistance = (pushConfig === null || pushConfig === void 0 ? void 0 : pushConfig.distance) ?? (parentContext === null || parentContext === void 0 ? void 0 : parentContext.pushDistance) ?? 180;
    const mergedContext = _react.useMemo(()=>({
            pushDistance,
            push: ()=>{
                setPushed(true);
            },
            pull: ()=>{
                setPushed(false);
            }
        }), [
        pushDistance
    ]);
    // ========================= ScrollLock =========================
    // Tell parent to push
    _react.useEffect(()=>{
        if (open) {
            var _parentContext_push;
            parentContext === null || parentContext === void 0 || (_parentContext_push = parentContext.push) === null || _parentContext_push === void 0 || _parentContext_push.call(parentContext);
        } else {
            var _parentContext_pull;
            parentContext === null || parentContext === void 0 || (_parentContext_pull = parentContext.pull) === null || _parentContext_pull === void 0 || _parentContext_pull.call(parentContext);
        }
    }, [
        open
    ]);
    // Clean up
    _react.useEffect(()=>()=>{
            var _parentContext_pull;
            parentContext === null || parentContext === void 0 || (_parentContext_pull = parentContext.pull) === null || _parentContext_pull === void 0 || _parentContext_pull.call(parentContext);
        }, []);
    // ============================ Mask ============================
    const maskNode = mask && /*#__PURE__*/ _react.createElement(_motion.default, _extends({
        key: "mask"
    }, maskMotion, {
        visible: open
    }), ({ className: motionMaskClassName, style: motionMaskStyle }, maskRef)=>/*#__PURE__*/ _react.createElement("div", {
            className: (0, _classnames.default)(`${prefixCls}-mask`, motionMaskClassName, drawerClassNames === null || drawerClassNames === void 0 ? void 0 : drawerClassNames.mask, maskClassName),
            style: {
                ...motionMaskStyle,
                ...maskStyle,
                ...styles === null || styles === void 0 ? void 0 : styles.mask
            },
            onClick: maskClosable && open ? onClose : undefined,
            ref: maskRef
        }));
    // =========================== Panel ============================
    const motionProps = typeof motion === 'function' ? motion(placement) : motion;
    const wrapperStyle = {};
    if (pushed && pushDistance) switch(placement){
        case 'top':
            wrapperStyle.transform = `translateY(${pushDistance}px)`;
            break;
        case 'bottom':
            wrapperStyle.transform = `translateY(${-pushDistance}px)`;
            break;
        case 'left':
            wrapperStyle.transform = `translateX(${pushDistance}px)`;
            break;
        default:
            wrapperStyle.transform = `translateX(${-pushDistance}px)`;
            break;
    }
    if (placement === 'left' || placement === 'right') wrapperStyle.width = (0, _util.parseWidthHeight)(width);
    else wrapperStyle.height = (0, _util.parseWidthHeight)(height);
    const eventHandlers = {
        onMouseEnter,
        onMouseOver,
        onMouseLeave,
        onClick,
        onKeyDown,
        onKeyUp
    };
    const panelNode = /*#__PURE__*/ _react.createElement(_motion.default, _extends({
        key: "panel"
    }, motionProps, {
        visible: open,
        forceRender: forceRender,
        onVisibleChanged: (nextVisible)=>{
            afterOpenChange === null || afterOpenChange === void 0 || afterOpenChange(nextVisible);
        },
        removeOnLeave: false,
        leavedClassName: `${prefixCls}-content-wrapper-hidden`
    }), ({ className: motionClassName, style: motionStyle }, motionRef)=>{
        const content = /*#__PURE__*/ _react.createElement(_DrawerPanel.default, _extends({
            id: id,
            containerRef: motionRef,
            prefixCls: prefixCls,
            className: (0, _classnames.default)(className, drawerClassNames === null || drawerClassNames === void 0 ? void 0 : drawerClassNames.section),
            style: {
                ...style,
                ...styles === null || styles === void 0 ? void 0 : styles.section
            }
        }, (0, _pickAttrs.default)(props, {
            aria: true
        }), eventHandlers), children);
        return /*#__PURE__*/ _react.createElement("div", _extends({
            className: (0, _classnames.default)(`${prefixCls}-content-wrapper`, drawerClassNames === null || drawerClassNames === void 0 ? void 0 : drawerClassNames.wrapper, motionClassName),
            style: {
                ...wrapperStyle,
                ...motionStyle,
                ...styles === null || styles === void 0 ? void 0 : styles.wrapper
            }
        }, (0, _pickAttrs.default)(props, {
            data: true
        })), drawerRender ? drawerRender(content) : content);
    });
    // =========================== Render ===========================
    const containerStyle = {
        ...rootStyle
    };
    if (zIndex) containerStyle.zIndex = zIndex;
    return /*#__PURE__*/ _react.createElement(_context.default.Provider, {
        value: mergedContext
    }, /*#__PURE__*/ _react.createElement("div", {
        className: (0, _classnames.default)(prefixCls, `${prefixCls}-${placement}`, rootClassName, {
            [`${prefixCls}-open`]: open,
            [`${prefixCls}-inline`]: inline
        }),
        style: containerStyle,
        tabIndex: -1,
        ref: panelRef,
        onKeyDown: onPanelKeyDown
    }, maskNode, /*#__PURE__*/ _react.createElement("div", {
        tabIndex: 0,
        ref: sentinelStartRef,
        style: sentinelStyle,
        "aria-hidden": "true",
        "data-sentinel": "start"
    }), panelNode, /*#__PURE__*/ _react.createElement("div", {
        tabIndex: 0,
        ref: sentinelEndRef,
        style: sentinelStyle,
        "aria-hidden": "true",
        "data-sentinel": "end"
    })));
};
const RefDrawerPopup = /*#__PURE__*/ _react.forwardRef(DrawerPopup);
RefDrawerPopup.displayName = 'DrawerPopup';
var _default = RefDrawerPopup;

},
"node_modules/@rc-component/drawer/es/context.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    RefContext: function() {
        return RefContext;
    },
    default: function() {
        return _default;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
const DrawerContext = /*#__PURE__*/ _react.createContext(null);
const RefContext = /*#__PURE__*/ _react.createContext({});
var _default = DrawerContext;

},
"node_modules/@rc-component/drawer/es/index.js": function (module, exports, __mako_require__){
// export this package's api
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _Drawer = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/drawer/es/Drawer.js"));
var _default = _Drawer.default;

},
"node_modules/@rc-component/drawer/es/util.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    parseWidthHeight: function() {
        return parseWidthHeight;
    },
    warnCheck: function() {
        return warnCheck;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _warning = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/warning.js"));
var _canUseDom = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/Dom/canUseDom.js"));
function parseWidthHeight(value) {
    if (typeof value === 'string' && String(Number(value)) === value) {
        (0, _warning.default)(false, 'Invalid value type of `width` or `height` which should be number type instead.');
        return Number(value);
    }
    return value;
}
function warnCheck(props) {
    (0, _warning.default)(!('wrapperClassName' in props), `'wrapperClassName' is removed. Please use 'rootClassName' instead.`);
    (0, _warning.default)((0, _canUseDom.default)() || !props.open, `Drawer with 'open' in SSR is not work since no place to createPortal. Please move to 'useEffect' instead.`);
}

},
"node_modules/@rc-component/motion/es/CSSMotion.js": function (module, exports, __mako_require__){
/* eslint-disable react/default-props-match-prop-types, react/no-multi-comp, react/prop-types */ "use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    default: function() {
        return _default;
    },
    genCSSMotion: function() {
        return genCSSMotion;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _findDOMNode = __mako_require__("node_modules/@rc-component/util/es/Dom/findDOMNode.js");
var _ref = __mako_require__("node_modules/@rc-component/util/es/ref.js");
var _classnames = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/classnames/index.js"));
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
var _context = __mako_require__("node_modules/@rc-component/motion/es/context.js");
var _useStatus = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/motion/es/hooks/useStatus.js"));
var _useStepQueue = __mako_require__("node_modules/@rc-component/motion/es/hooks/useStepQueue.js");
var _interface = __mako_require__("node_modules/@rc-component/motion/es/interface.js");
var _motion = __mako_require__("node_modules/@rc-component/motion/es/util/motion.js");
function genCSSMotion(config) {
    let transitionSupport = config;
    if (typeof config === 'object') ({ transitionSupport } = config);
    function isSupportTransition(props, contextMotion) {
        return !!(props.motionName && transitionSupport && contextMotion !== false);
    }
    const CSSMotion = /*#__PURE__*/ _react.forwardRef((props, ref)=>{
        const { // Default config
        visible = true, removeOnLeave = true, forceRender, children, motionName, leavedClassName, eventProps } = props;
        const { motion: contextMotion } = _react.useContext(_context.Context);
        const supportMotion = isSupportTransition(props, contextMotion);
        // Ref to the react node, it may be a HTMLElement
        const nodeRef = (0, _react.useRef)();
        function getDomElement() {
            return (0, _findDOMNode.getDOM)(nodeRef.current);
        }
        const [getStatus, statusStep, statusStyle, mergedVisible] = (0, _useStatus.default)(supportMotion, visible, getDomElement, props);
        const status = getStatus();
        // Record whether content has rendered
        // Will return null for un-rendered even when `removeOnLeave={false}`
        const renderedRef = _react.useRef(mergedVisible);
        if (mergedVisible) renderedRef.current = true;
        // ====================== Refs ======================
        const refObj = _react.useMemo(()=>{
            const obj = {};
            Object.defineProperties(obj, {
                nativeElement: {
                    enumerable: true,
                    get: getDomElement
                },
                inMotion: {
                    enumerable: true,
                    get: ()=>()=>getStatus() !== _interface.STATUS_NONE
                },
                enableMotion: {
                    enumerable: true,
                    get: ()=>()=>supportMotion
                }
            });
            return obj;
        }, []);
        // We lock `deps` here since function return object
        // will repeat trigger ref from `refConfig` -> `null` -> `refConfig`
        _react.useImperativeHandle(ref, ()=>refObj, []);
        // ===================== Render =====================
        let motionChildren;
        const mergedProps = {
            ...eventProps,
            visible
        };
        if (!children) // No children
        motionChildren = null;
        else if (status === _interface.STATUS_NONE) {
            // Stable children
            if (mergedVisible) motionChildren = children({
                ...mergedProps
            }, nodeRef);
            else if (!removeOnLeave && renderedRef.current && leavedClassName) motionChildren = children({
                ...mergedProps,
                className: leavedClassName
            }, nodeRef);
            else if (forceRender || !removeOnLeave && !leavedClassName) motionChildren = children({
                ...mergedProps,
                style: {
                    display: 'none'
                }
            }, nodeRef);
            else motionChildren = null;
        } else {
            // In motion
            let statusSuffix;
            if (statusStep === _interface.STEP_PREPARE) statusSuffix = 'prepare';
            else if ((0, _useStepQueue.isActive)(statusStep)) statusSuffix = 'active';
            else if (statusStep === _interface.STEP_START) statusSuffix = 'start';
            const motionCls = (0, _motion.getTransitionName)(motionName, `${status}-${statusSuffix}`);
            motionChildren = children({
                ...mergedProps,
                className: (0, _classnames.default)((0, _motion.getTransitionName)(motionName, status), {
                    [motionCls]: motionCls && statusSuffix,
                    [motionName]: typeof motionName === 'string'
                }),
                style: statusStyle
            }, nodeRef);
        }
        // Auto inject ref if child node not have `ref` props
        if (/*#__PURE__*/ _react.isValidElement(motionChildren) && (0, _ref.supportRef)(motionChildren)) {
            const originNodeRef = (0, _ref.getNodeRef)(motionChildren);
            if (!originNodeRef) motionChildren = /*#__PURE__*/ _react.cloneElement(motionChildren, {
                ref: nodeRef
            });
        }
        return motionChildren;
    });
    CSSMotion.displayName = 'CSSMotion';
    return CSSMotion;
}
var _default = genCSSMotion(_motion.supportTransition);

},
"node_modules/@rc-component/motion/es/CSSMotionList.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    default: function() {
        return _default;
    },
    genCSSMotionList: function() {
        return genCSSMotionList;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
var _CSSMotion = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/motion/es/CSSMotion.js"));
var _diff = __mako_require__("node_modules/@rc-component/motion/es/util/diff.js");
var _motion = __mako_require__("node_modules/@rc-component/motion/es/util/motion.js");
function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
const MOTION_PROP_NAMES = [
    'eventProps',
    'visible',
    'children',
    'motionName',
    'motionAppear',
    'motionEnter',
    'motionLeave',
    'motionLeaveImmediately',
    'motionDeadline',
    'removeOnLeave',
    'leavedClassName',
    'onAppearPrepare',
    'onAppearStart',
    'onAppearActive',
    'onAppearEnd',
    'onEnterStart',
    'onEnterActive',
    'onEnterEnd',
    'onLeaveStart',
    'onLeaveActive',
    'onLeaveEnd'
];
function genCSSMotionList(transitionSupport, CSSMotion = _CSSMotion.default) {
    class CSSMotionList extends _react.Component {
        static defaultProps = {
            component: 'div'
        };
        state = {
            keyEntities: []
        };
        static getDerivedStateFromProps({ keys }, { keyEntities }) {
            const parsedKeyObjects = (0, _diff.parseKeys)(keys);
            const mixedKeyEntities = (0, _diff.diffKeys)(keyEntities, parsedKeyObjects);
            return {
                keyEntities: mixedKeyEntities.filter((entity)=>{
                    const prevEntity = keyEntities.find(({ key })=>entity.key === key);
                    // Remove if already mark as removed
                    if (prevEntity && prevEntity.status === _diff.STATUS_REMOVED && entity.status === _diff.STATUS_REMOVE) return false;
                    return true;
                })
            };
        }
        // ZombieJ: Return the count of rest keys. It's safe to refactor if need more info.
        removeKey = (removeKey)=>{
            this.setState((prevState)=>{
                const nextKeyEntities = prevState.keyEntities.map((entity)=>{
                    if (entity.key !== removeKey) return entity;
                    return {
                        ...entity,
                        status: _diff.STATUS_REMOVED
                    };
                });
                return {
                    keyEntities: nextKeyEntities
                };
            }, ()=>{
                const { keyEntities } = this.state;
                const restKeysCount = keyEntities.filter(({ status })=>status !== _diff.STATUS_REMOVED).length;
                if (restKeysCount === 0 && this.props.onAllRemoved) this.props.onAllRemoved();
            });
        };
        render() {
            const { keyEntities } = this.state;
            const { component, children, onVisibleChanged, onAllRemoved, ...restProps } = this.props;
            const Component = component || _react.Fragment;
            const motionProps = {};
            MOTION_PROP_NAMES.forEach((prop)=>{
                motionProps[prop] = restProps[prop];
                delete restProps[prop];
            });
            delete restProps.keys;
            return /*#__PURE__*/ _react.createElement(Component, restProps, keyEntities.map(({ status, ...eventProps }, index)=>{
                const visible = status === _diff.STATUS_ADD || status === _diff.STATUS_KEEP;
                return /*#__PURE__*/ _react.createElement(CSSMotion, _extends({}, motionProps, {
                    key: eventProps.key,
                    visible: visible,
                    eventProps: eventProps,
                    onVisibleChanged: (changedVisible)=>{
                        onVisibleChanged === null || onVisibleChanged === void 0 || onVisibleChanged(changedVisible, {
                            key: eventProps.key
                        });
                        if (!changedVisible) this.removeKey(eventProps.key);
                    }
                }), (props, ref)=>children({
                        ...props,
                        index
                    }, ref));
            }));
        }
    }
    return CSSMotionList;
}
var _default = genCSSMotionList(_motion.supportTransition);

},
"node_modules/@rc-component/motion/es/context.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    Context: function() {
        return Context;
    },
    default: function() {
        return MotionProvider;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
const Context = /*#__PURE__*/ _react.createContext({});
function MotionProvider({ children, ...props }) {
    return /*#__PURE__*/ _react.createElement(Context.Provider, {
        value: props
    }, children);
}

},
"node_modules/@rc-component/motion/es/hooks/useDomMotionEvents.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
var _motion = __mako_require__("node_modules/@rc-component/motion/es/util/motion.js");
var _default = (onInternalMotionEnd)=>{
    const cacheElementRef = (0, _react.useRef)();
    // Remove events
    function removeMotionEvents(element) {
        if (element) {
            element.removeEventListener(_motion.transitionEndName, onInternalMotionEnd);
            element.removeEventListener(_motion.animationEndName, onInternalMotionEnd);
        }
    }
    // Patch events
    function patchMotionEvents(element) {
        if (cacheElementRef.current && cacheElementRef.current !== element) removeMotionEvents(cacheElementRef.current);
        if (element && element !== cacheElementRef.current) {
            element.addEventListener(_motion.transitionEndName, onInternalMotionEnd);
            element.addEventListener(_motion.animationEndName, onInternalMotionEnd);
            // Save as cache in case dom removed trigger by `motionDeadline`
            cacheElementRef.current = element;
        }
    }
    // Clean up when removed
    _react.useEffect(()=>()=>{
            removeMotionEvents(cacheElementRef.current);
        }, []);
    return [
        patchMotionEvents,
        removeMotionEvents
    ];
};

},
"node_modules/@rc-component/motion/es/hooks/useIsomorphicLayoutEffect.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _canUseDom = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/Dom/canUseDom.js"));
var _react = __mako_require__("node_modules/react/index.js");
// It's safe to use `useLayoutEffect` but the warning is annoying
const useIsomorphicLayoutEffect = (0, _canUseDom.default)() ? _react.useLayoutEffect : _react.useEffect;
var _default = useIsomorphicLayoutEffect;

},
"node_modules/@rc-component/motion/es/hooks/useNextFrame.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _raf = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/raf.js"));
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
var _default = ()=>{
    const nextFrameRef = _react.useRef(null);
    function cancelNextFrame() {
        _raf.default.cancel(nextFrameRef.current);
    }
    function nextFrame(callback, delay = 2) {
        cancelNextFrame();
        const nextFrameId = (0, _raf.default)(()=>{
            if (delay <= 1) callback({
                isCanceled: ()=>nextFrameId !== nextFrameRef.current
            });
            else nextFrame(callback, delay - 1);
        });
        nextFrameRef.current = nextFrameId;
    }
    _react.useEffect(()=>()=>{
            cancelNextFrame();
        }, []);
    return [
        nextFrame,
        cancelNextFrame
    ];
};

},
"node_modules/@rc-component/motion/es/hooks/useStatus.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return useStatus;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _util = __mako_require__("node_modules/@rc-component/util/es/index.js");
var _useState = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/hooks/useState.js"));
var _useSyncState = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/hooks/useSyncState.js"));
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
var _interface = __mako_require__("node_modules/@rc-component/motion/es/interface.js");
var _useDomMotionEvents = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/motion/es/hooks/useDomMotionEvents.js"));
var _useIsomorphicLayoutEffect = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/motion/es/hooks/useIsomorphicLayoutEffect.js"));
var _useStepQueue = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/@rc-component/motion/es/hooks/useStepQueue.js"));
function useStatus(supportMotion, visible, getElement, { motionEnter = true, motionAppear = true, motionLeave = true, motionDeadline, motionLeaveImmediately, onAppearPrepare, onEnterPrepare, onLeavePrepare, onAppearStart, onEnterStart, onLeaveStart, onAppearActive, onEnterActive, onLeaveActive, onAppearEnd, onEnterEnd, onLeaveEnd, onVisibleChanged }) {
    // Used for outer render usage to avoid `visible: false & status: none` to render nothing
    const [asyncVisible, setAsyncVisible] = (0, _useState.default)();
    const [getStatus, setStatus] = (0, _useSyncState.default)(_interface.STATUS_NONE);
    const [style, setStyle] = (0, _useState.default)(null);
    const currentStatus = getStatus();
    const mountedRef = (0, _react.useRef)(false);
    const deadlineRef = (0, _react.useRef)(null);
    // =========================== Dom Node ===========================
    function getDomElement() {
        return getElement();
    }
    // ========================== Motion End ==========================
    const activeRef = (0, _react.useRef)(false);
    /**
   * Clean up status & style
   */ function updateMotionEndStatus() {
        setStatus(_interface.STATUS_NONE);
        setStyle(null, true);
    }
    const onInternalMotionEnd = (0, _util.useEvent)((event)=>{
        const status = getStatus();
        // Do nothing since not in any transition status.
        // This may happen when `motionDeadline` trigger.
        if (status === _interface.STATUS_NONE) return;
        const element = getDomElement();
        if (event && !event.deadline && event.target !== element) // event exists
        // not initiated by deadline
        // transitionEnd not fired by inner elements
        return;
        const currentActive = activeRef.current;
        let canEnd;
        if (status === _interface.STATUS_APPEAR && currentActive) canEnd = onAppearEnd === null || onAppearEnd === void 0 ? void 0 : onAppearEnd(element, event);
        else if (status === _interface.STATUS_ENTER && currentActive) canEnd = onEnterEnd === null || onEnterEnd === void 0 ? void 0 : onEnterEnd(element, event);
        else if (status === _interface.STATUS_LEAVE && currentActive) canEnd = onLeaveEnd === null || onLeaveEnd === void 0 ? void 0 : onLeaveEnd(element, event);
        // Only update status when `canEnd` and not destroyed
        if (currentActive && canEnd !== false) updateMotionEndStatus();
    });
    const [patchMotionEvents] = (0, _useDomMotionEvents.default)(onInternalMotionEnd);
    // ============================= Step =============================
    const getEventHandlers = (targetStatus)=>{
        switch(targetStatus){
            case _interface.STATUS_APPEAR:
                return {
                    [_interface.STEP_PREPARE]: onAppearPrepare,
                    [_interface.STEP_START]: onAppearStart,
                    [_interface.STEP_ACTIVE]: onAppearActive
                };
            case _interface.STATUS_ENTER:
                return {
                    [_interface.STEP_PREPARE]: onEnterPrepare,
                    [_interface.STEP_START]: onEnterStart,
                    [_interface.STEP_ACTIVE]: onEnterActive
                };
            case _interface.STATUS_LEAVE:
                return {
                    [_interface.STEP_PREPARE]: onLeavePrepare,
                    [_interface.STEP_START]: onLeaveStart,
                    [_interface.STEP_ACTIVE]: onLeaveActive
                };
            default:
                return {};
        }
    };
    const eventHandlers = _react.useMemo(()=>getEventHandlers(currentStatus), [
        currentStatus
    ]);
    const [startStep, step] = (0, _useStepQueue.default)(currentStatus, !supportMotion, (newStep)=>{
        // Only prepare step can be skip
        if (newStep === _interface.STEP_PREPARE) {
            const onPrepare = eventHandlers[_interface.STEP_PREPARE];
            if (!onPrepare) return _useStepQueue.SkipStep;
            return onPrepare(getDomElement());
        }
        // Rest step is sync update
        if (step in eventHandlers) {
            var _eventHandlers_step;
            setStyle(((_eventHandlers_step = eventHandlers[step]) === null || _eventHandlers_step === void 0 ? void 0 : _eventHandlers_step.call(eventHandlers, getDomElement(), null)) || null);
        }
        if (step === _interface.STEP_ACTIVE && currentStatus !== _interface.STATUS_NONE) {
            // Patch events when motion needed
            patchMotionEvents(getDomElement());
            if (motionDeadline > 0) {
                clearTimeout(deadlineRef.current);
                deadlineRef.current = setTimeout(()=>{
                    onInternalMotionEnd({
                        deadline: true
                    });
                }, motionDeadline);
            }
        }
        if (step === _interface.STEP_PREPARED) updateMotionEndStatus();
        return _useStepQueue.DoStep;
    });
    const active = (0, _useStepQueue.isActive)(step);
    activeRef.current = active;
    // ============================ Status ============================
    const visibleRef = (0, _react.useRef)(null);
    // Update with new status
    (0, _useIsomorphicLayoutEffect.default)(()=>{
        // When use Suspense, the `visible` will repeat trigger,
        // But not real change of the `visible`, we need to skip it.
        // https://github.com/ant-design/ant-design/issues/44379
        if (mountedRef.current && visibleRef.current === visible) return;
        setAsyncVisible(visible);
        const isMounted = mountedRef.current;
        mountedRef.current = true;
        // if (!supportMotion) {
        //   return;
        // }
        let nextStatus;
        // Appear
        if (!isMounted && visible && motionAppear) nextStatus = _interface.STATUS_APPEAR;
        // Enter
        if (isMounted && visible && motionEnter) nextStatus = _interface.STATUS_ENTER;
        // Leave
        if (isMounted && !visible && motionLeave || !isMounted && motionLeaveImmediately && !visible && motionLeave) nextStatus = _interface.STATUS_LEAVE;
        const nextEventHandlers = getEventHandlers(nextStatus);
        // Update to next status
        if (nextStatus && (supportMotion || nextEventHandlers[_interface.STEP_PREPARE])) {
            setStatus(nextStatus);
            startStep();
        } else // Set back in case no motion but prev status has prepare step
        setStatus(_interface.STATUS_NONE);
        visibleRef.current = visible;
    }, [
        visible
    ]);
    // ============================ Effect ============================
    // Reset when motion changed
    (0, _react.useEffect)(()=>{
        if (// Cancel appear
        currentStatus === _interface.STATUS_APPEAR && !motionAppear || // Cancel enter
        currentStatus === _interface.STATUS_ENTER && !motionEnter || // Cancel leave
        currentStatus === _interface.STATUS_LEAVE && !motionLeave) setStatus(_interface.STATUS_NONE);
    }, [
        motionAppear,
        motionEnter,
        motionLeave
    ]);
    (0, _react.useEffect)(()=>()=>{
            mountedRef.current = false;
            clearTimeout(deadlineRef.current);
        }, []);
    // Trigger `onVisibleChanged`
    const firstMountChangeRef = _react.useRef(false);
    (0, _react.useEffect)(()=>{
        // [visible & motion not end] => [!visible & motion end] still need trigger onVisibleChanged
        if (asyncVisible) firstMountChangeRef.current = true;
        if (asyncVisible !== undefined && currentStatus === _interface.STATUS_NONE) {
            // Skip first render is invisible since it's nothing changed
            if (firstMountChangeRef.current || asyncVisible) onVisibleChanged === null || onVisibleChanged === void 0 || onVisibleChanged(asyncVisible);
            firstMountChangeRef.current = true;
        }
    }, [
        asyncVisible,
        currentStatus
    ]);
    // ============================ Styles ============================
    let mergedStyle = style;
    if (eventHandlers[_interface.STEP_PREPARE] && step === _interface.STEP_START) mergedStyle = {
        transition: 'none',
        ...mergedStyle
    };
    return [
        getStatus,
        step,
        mergedStyle,
        asyncVisible ?? visible
    ];
}

},
"node_modules/@rc-component/motion/es/hooks/useStepQueue.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    DoStep: function() {
        return DoStep;
    },
    SkipStep: function() {
        return SkipStep;
    },
    default: function() {
        return _default;
    },
    isActive: function() {
        return isActive;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _useState = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/hooks/useState.js"));
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
var _interface = __mako_require__("node_modules/@rc-component/motion/es/interface.js");
var _useIsomorphicLayoutEffect = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/motion/es/hooks/useIsomorphicLayoutEffect.js"));
var _useNextFrame = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/motion/es/hooks/useNextFrame.js"));
const FULL_STEP_QUEUE = [
    _interface.STEP_PREPARE,
    _interface.STEP_START,
    _interface.STEP_ACTIVE,
    _interface.STEP_ACTIVATED
];
const SIMPLE_STEP_QUEUE = [
    _interface.STEP_PREPARE,
    _interface.STEP_PREPARED
];
const SkipStep = false;
const DoStep = true;
function isActive(step) {
    return step === _interface.STEP_ACTIVE || step === _interface.STEP_ACTIVATED;
}
var _default = (status, prepareOnly, callback)=>{
    const [step, setStep] = (0, _useState.default)(_interface.STEP_NONE);
    const [nextFrame, cancelNextFrame] = (0, _useNextFrame.default)();
    function startQueue() {
        setStep(_interface.STEP_PREPARE, true);
    }
    const STEP_QUEUE = prepareOnly ? SIMPLE_STEP_QUEUE : FULL_STEP_QUEUE;
    (0, _useIsomorphicLayoutEffect.default)(()=>{
        if (step !== _interface.STEP_NONE && step !== _interface.STEP_ACTIVATED) {
            const index = STEP_QUEUE.indexOf(step);
            const nextStep = STEP_QUEUE[index + 1];
            const result = callback(step);
            if (result === SkipStep) // Skip when no needed
            setStep(nextStep, true);
            else if (nextStep) // Do as frame for step update
            nextFrame((info)=>{
                function doNext() {
                    // Skip since current queue is ood
                    if (info.isCanceled()) return;
                    setStep(nextStep, true);
                }
                if (result === true) doNext();
                else // Only promise should be async
                Promise.resolve(result).then(doNext);
            });
        }
    }, [
        status,
        step
    ]);
    _react.useEffect(()=>()=>{
            cancelNextFrame();
        }, []);
    return [
        startQueue,
        step
    ];
};

},
"node_modules/@rc-component/motion/es/index.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    CSSMotionList: function() {
        return _CSSMotionList.default;
    },
    Provider: function() {
        return _context.default;
    },
    default: function() {
        return _default;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _CSSMotion = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/motion/es/CSSMotion.js"));
var _CSSMotionList = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/motion/es/CSSMotionList.js"));
var _context = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/motion/es/context.js"));
var _default = _CSSMotion.default;

},
"node_modules/@rc-component/motion/es/interface.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    STATUS_APPEAR: function() {
        return STATUS_APPEAR;
    },
    STATUS_ENTER: function() {
        return STATUS_ENTER;
    },
    STATUS_LEAVE: function() {
        return STATUS_LEAVE;
    },
    STATUS_NONE: function() {
        return STATUS_NONE;
    },
    STEP_ACTIVATED: function() {
        return STEP_ACTIVATED;
    },
    STEP_ACTIVE: function() {
        return STEP_ACTIVE;
    },
    STEP_NONE: function() {
        return STEP_NONE;
    },
    STEP_PREPARE: function() {
        return STEP_PREPARE;
    },
    STEP_PREPARED: function() {
        return STEP_PREPARED;
    },
    STEP_START: function() {
        return STEP_START;
    }
});
const STATUS_NONE = 'none';
const STATUS_APPEAR = 'appear';
const STATUS_ENTER = 'enter';
const STATUS_LEAVE = 'leave';
const STEP_NONE = 'none';
const STEP_PREPARE = 'prepare';
const STEP_START = 'start';
const STEP_ACTIVE = 'active';
const STEP_ACTIVATED = 'end';
const STEP_PREPARED = 'prepared';

},
"node_modules/@rc-component/motion/es/util/diff.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    STATUS_ADD: function() {
        return STATUS_ADD;
    },
    STATUS_KEEP: function() {
        return STATUS_KEEP;
    },
    STATUS_REMOVE: function() {
        return STATUS_REMOVE;
    },
    STATUS_REMOVED: function() {
        return STATUS_REMOVED;
    },
    diffKeys: function() {
        return diffKeys;
    },
    parseKeys: function() {
        return parseKeys;
    },
    wrapKeyToObject: function() {
        return wrapKeyToObject;
    }
});
const STATUS_ADD = 'add';
const STATUS_KEEP = 'keep';
const STATUS_REMOVE = 'remove';
const STATUS_REMOVED = 'removed';
function wrapKeyToObject(key) {
    let keyObj;
    if (key && typeof key === 'object' && 'key' in key) keyObj = key;
    else keyObj = {
        key: key
    };
    return {
        ...keyObj,
        key: String(keyObj.key)
    };
}
function parseKeys(keys = []) {
    return keys.map(wrapKeyToObject);
}
function diffKeys(prevKeys = [], currentKeys = []) {
    let list = [];
    let currentIndex = 0;
    const currentLen = currentKeys.length;
    const prevKeyObjects = parseKeys(prevKeys);
    const currentKeyObjects = parseKeys(currentKeys);
    // Check prev keys to insert or keep
    prevKeyObjects.forEach((keyObj)=>{
        let hit = false;
        for(let i = currentIndex; i < currentLen; i += 1){
            const currentKeyObj = currentKeyObjects[i];
            if (currentKeyObj.key === keyObj.key) {
                // New added keys should add before current key
                if (currentIndex < i) {
                    list = list.concat(currentKeyObjects.slice(currentIndex, i).map((obj)=>({
                            ...obj,
                            status: STATUS_ADD
                        })));
                    currentIndex = i;
                }
                list.push({
                    ...currentKeyObj,
                    status: STATUS_KEEP
                });
                currentIndex += 1;
                hit = true;
                break;
            }
        }
        // If not hit, it means key is removed
        if (!hit) list.push({
            ...keyObj,
            status: STATUS_REMOVE
        });
    });
    // Add rest to the list
    if (currentIndex < currentLen) list = list.concat(currentKeyObjects.slice(currentIndex).map((obj)=>({
            ...obj,
            status: STATUS_ADD
        })));
    /**
   * Merge same key when it remove and add again:
   *    [1 - add, 2 - keep, 1 - remove] -> [1 - keep, 2 - keep]
   */ const keys = {};
    list.forEach(({ key })=>{
        keys[key] = (keys[key] || 0) + 1;
    });
    const duplicatedKeys = Object.keys(keys).filter((key)=>keys[key] > 1);
    duplicatedKeys.forEach((matchKey)=>{
        // Remove `STATUS_REMOVE` node.
        list = list.filter(({ key, status })=>key !== matchKey || status !== STATUS_REMOVE);
        // Update `STATUS_ADD` to `STATUS_KEEP`
        list.forEach((node)=>{
            if (node.key === matchKey) // eslint-disable-next-line no-param-reassign
            node.status = STATUS_KEEP;
        });
    });
    return list;
}

},
"node_modules/@rc-component/motion/es/util/motion.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    animationEndName: function() {
        return animationEndName;
    },
    getTransitionName: function() {
        return getTransitionName;
    },
    getVendorPrefixedEventName: function() {
        return getVendorPrefixedEventName;
    },
    getVendorPrefixes: function() {
        return getVendorPrefixes;
    },
    supportTransition: function() {
        return supportTransition;
    },
    transitionEndName: function() {
        return transitionEndName;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _canUseDom = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/Dom/canUseDom.js"));
// ================= Transition =================
// Event wrapper. Copy from react source code
function makePrefixMap(styleProp, eventName) {
    const prefixes = {};
    prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
    prefixes[`Webkit${styleProp}`] = `webkit${eventName}`;
    prefixes[`Moz${styleProp}`] = `moz${eventName}`;
    prefixes[`ms${styleProp}`] = `MS${eventName}`;
    prefixes[`O${styleProp}`] = `o${eventName.toLowerCase()}`;
    return prefixes;
}
function getVendorPrefixes(domSupport, win) {
    const prefixes = {
        animationend: makePrefixMap('Animation', 'AnimationEnd'),
        transitionend: makePrefixMap('Transition', 'TransitionEnd')
    };
    if (domSupport) {
        if (!('AnimationEvent' in win)) delete prefixes.animationend.animation;
        if (!('TransitionEvent' in win)) delete prefixes.transitionend.transition;
    }
    return prefixes;
}
const vendorPrefixes = getVendorPrefixes((0, _canUseDom.default)(), typeof window !== 'undefined' ? window : {});
let style = {};
if ((0, _canUseDom.default)()) ({ style } = document.createElement('div'));
const prefixedEventNames = {};
function getVendorPrefixedEventName(eventName) {
    if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
    const prefixMap = vendorPrefixes[eventName];
    if (prefixMap) {
        const stylePropList = Object.keys(prefixMap);
        const len = stylePropList.length;
        for(let i = 0; i < len; i += 1){
            const styleProp = stylePropList[i];
            if (Object.prototype.hasOwnProperty.call(prefixMap, styleProp) && styleProp in style) {
                prefixedEventNames[eventName] = prefixMap[styleProp];
                return prefixedEventNames[eventName];
            }
        }
    }
    return '';
}
const internalAnimationEndName = getVendorPrefixedEventName('animationend');
const internalTransitionEndName = getVendorPrefixedEventName('transitionend');
const supportTransition = !!(internalAnimationEndName && internalTransitionEndName);
const animationEndName = internalAnimationEndName || 'animationend';
const transitionEndName = internalTransitionEndName || 'transitionend';
function getTransitionName(transitionName, transitionType) {
    if (!transitionName) return null;
    if (typeof transitionName === 'object') {
        const type = transitionType.replace(/-\w/g, (match)=>match[1].toUpperCase());
        return transitionName[type];
    }
    return `${transitionName}-${transitionType}`;
}

},
"node_modules/@rc-component/portal/es/Context.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
const OrderContext = /*#__PURE__*/ _react.createContext(null);
var _default = OrderContext;

},
"node_modules/@rc-component/portal/es/Portal.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _canUseDom = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/Dom/canUseDom.js"));
var _ref = __mako_require__("node_modules/@rc-component/util/es/ref.js");
var _warning = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/warning.js"));
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
var _reactdom = __mako_require__("node_modules/react-dom/index.js");
var _Context = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/portal/es/Context.js"));
var _mock = __mako_require__("node_modules/@rc-component/portal/es/mock.js");
var _useDom = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/portal/es/useDom.js"));
var _useScrollLocker = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/portal/es/useScrollLocker.js"));
const getPortalContainer = (getContainer)=>{
    if (getContainer === false) return false;
    if (!(0, _canUseDom.default)() || !getContainer) return null;
    if (typeof getContainer === 'string') return document.querySelector(getContainer);
    if (typeof getContainer === 'function') return getContainer();
    return getContainer;
};
const Portal = /*#__PURE__*/ _react.forwardRef((props, ref)=>{
    const { open, autoLock, getContainer, debug, autoDestroy = true, children } = props;
    const [shouldRender, setShouldRender] = _react.useState(open);
    const mergedRender = shouldRender || open;
    (0, _warning.default)((0, _canUseDom.default)() || !open, `Portal only work in client side. Please call 'useEffect' to show Portal instead default render in SSR.`);
    // ====================== Should Render ======================
    _react.useEffect(()=>{
        if (autoDestroy || open) setShouldRender(open);
    }, [
        open,
        autoDestroy
    ]);
    // ======================== Container ========================
    const [innerContainer, setInnerContainer] = _react.useState(()=>getPortalContainer(getContainer));
    _react.useEffect(()=>{
        const customizeContainer = getPortalContainer(getContainer);
        // Tell component that we check this in effect which is safe to be `null`
        setInnerContainer(customizeContainer ?? null);
    });
    const [defaultContainer, queueCreate] = (0, _useDom.default)(mergedRender && !innerContainer, debug);
    const mergedContainer = innerContainer ?? defaultContainer;
    // ========================= Locker ==========================
    (0, _useScrollLocker.default)(autoLock && open && (0, _canUseDom.default)() && (mergedContainer === defaultContainer || mergedContainer === document.body));
    // =========================== Ref ===========================
    let childRef = null;
    if (children && (0, _ref.supportRef)(children) && ref) childRef = (0, _ref.getNodeRef)(children);
    const mergedRef = (0, _ref.useComposeRef)(childRef, ref);
    // ========================= Render ==========================
    // Do not render when nothing need render
    // When innerContainer is `undefined`, it may not ready since user use ref in the same render
    if (!mergedRender || !(0, _canUseDom.default)() || innerContainer === undefined) return null;
    // Render inline
    const renderInline = mergedContainer === false || (0, _mock.inlineMock)();
    let reffedChildren = children;
    if (ref) reffedChildren = /*#__PURE__*/ _react.cloneElement(children, {
        ref: mergedRef
    });
    return /*#__PURE__*/ _react.createElement(_Context.default.Provider, {
        value: queueCreate
    }, renderInline ? reffedChildren : /*#__PURE__*/ (0, _reactdom.createPortal)(reffedChildren, mergedContainer));
});
Portal.displayName = 'Portal';
var _default = Portal;

},
"node_modules/@rc-component/portal/es/index.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    default: function() {
        return _default;
    },
    inlineMock: function() {
        return _mock.inlineMock;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _Portal = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/portal/es/Portal.js"));
var _mock = __mako_require__("node_modules/@rc-component/portal/es/mock.js");
var _default = _Portal.default;

},
"node_modules/@rc-component/portal/es/mock.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    inline: function() {
        return inline;
    },
    inlineMock: function() {
        return inlineMock;
    }
});
let inline = false;
function inlineMock(nextInline) {
    if (typeof nextInline === 'boolean') inline = nextInline;
    return inline;
}

},
"node_modules/@rc-component/portal/es/useDom.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, /**
 * Will add `div` to document. Nest call will keep order
 * @param render Render DOM in document
 */ "default", {
    enumerable: true,
    get: function() {
        return useDom;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
var _useLayoutEffect = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/hooks/useLayoutEffect.js"));
var _canUseDom = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/Dom/canUseDom.js"));
var _Context = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/portal/es/Context.js"));
const EMPTY_LIST = [];
function useDom(render, debug) {
    const [ele] = _react.useState(()=>{
        if (!(0, _canUseDom.default)()) return null;
        const defaultEle = document.createElement('div');
        if (debug) defaultEle.setAttribute('data-debug', debug);
        return defaultEle;
    });
    // ========================== Order ==========================
    const appendedRef = _react.useRef(false);
    const queueCreate = _react.useContext(_Context.default);
    const [queue, setQueue] = _react.useState(EMPTY_LIST);
    const mergedQueueCreate = queueCreate || (appendedRef.current ? undefined : (appendFn)=>{
        setQueue((origin)=>{
            const newQueue = [
                appendFn,
                ...origin
            ];
            return newQueue;
        });
    });
    // =========================== DOM ===========================
    function append() {
        if (!ele.parentElement) document.body.appendChild(ele);
        appendedRef.current = true;
    }
    function cleanup() {
        var _ele_parentElement;
        (_ele_parentElement = ele.parentElement) === null || _ele_parentElement === void 0 || _ele_parentElement.removeChild(ele);
        appendedRef.current = false;
    }
    (0, _useLayoutEffect.default)(()=>{
        if (render) {
            if (queueCreate) queueCreate(append);
            else append();
        } else cleanup();
        return cleanup;
    }, [
        render
    ]);
    (0, _useLayoutEffect.default)(()=>{
        if (queue.length) {
            queue.forEach((appendFn)=>appendFn());
            setQueue(EMPTY_LIST);
        }
    }, [
        queue
    ]);
    return [
        ele,
        mergedQueueCreate
    ];
}

},
"node_modules/@rc-component/portal/es/useScrollLocker.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return useScrollLocker;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
var _dynamicCSS = __mako_require__("node_modules/@rc-component/util/es/Dom/dynamicCSS.js");
var _useLayoutEffect = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/hooks/useLayoutEffect.js"));
var _getScrollBarSize = __mako_require__("node_modules/@rc-component/util/es/getScrollBarSize.js");
var _util = __mako_require__("node_modules/@rc-component/portal/es/util.js");
const UNIQUE_ID = `rc-util-locker-${Date.now()}`;
let uuid = 0;
function useScrollLocker(lock) {
    const mergedLock = !!lock;
    const [id] = _react.useState(()=>{
        uuid += 1;
        return `${UNIQUE_ID}_${uuid}`;
    });
    (0, _useLayoutEffect.default)(()=>{
        if (mergedLock) {
            const scrollbarSize = (0, _getScrollBarSize.getTargetScrollBarSize)(document.body).width;
            const isOverflow = (0, _util.isBodyOverflowing)();
            (0, _dynamicCSS.updateCSS)(`
html body {
  overflow-y: hidden;
  ${isOverflow ? `width: calc(100% - ${scrollbarSize}px);` : ''}
}`, id);
        } else (0, _dynamicCSS.removeCSS)(id);
        return ()=>{
            (0, _dynamicCSS.removeCSS)(id);
        };
    }, [
        mergedLock,
        id
    ]);
}

},
"node_modules/@rc-component/portal/es/util.js": function (module, exports, __mako_require__){
/**
 * Test usage export. Do not use in your production
 */ "use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "isBodyOverflowing", {
    enumerable: true,
    get: function() {
        return isBodyOverflowing;
    }
});
function isBodyOverflowing() {
    return document.body.scrollHeight > (window.innerHeight || document.documentElement.clientHeight) && window.innerWidth > document.body.offsetWidth;
}

},
"node_modules/@rc-component/resize-observer/es/Collection.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    Collection: function() {
        return Collection;
    },
    CollectionContext: function() {
        return CollectionContext;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
const CollectionContext = /*#__PURE__*/ _react.createContext(null);
function Collection({ children, onBatchResize }) {
    const resizeIdRef = _react.useRef(0);
    const resizeInfosRef = _react.useRef([]);
    const onCollectionResize = _react.useContext(CollectionContext);
    const onResize = _react.useCallback((size, element, data)=>{
        resizeIdRef.current += 1;
        const currentId = resizeIdRef.current;
        resizeInfosRef.current.push({
            size,
            element,
            data
        });
        Promise.resolve().then(()=>{
            if (currentId === resizeIdRef.current) {
                onBatchResize === null || onBatchResize === void 0 || onBatchResize(resizeInfosRef.current);
                resizeInfosRef.current = [];
            }
        });
        // Continue bubbling if parent exist
        onCollectionResize === null || onCollectionResize === void 0 || onCollectionResize(size, element, data);
    }, [
        onBatchResize,
        onCollectionResize
    ]);
    return /*#__PURE__*/ _react.createElement(CollectionContext.Provider, {
        value: onResize
    }, children);
}

},
"node_modules/@rc-component/resize-observer/es/SingleObserver/index.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _findDOMNode = __mako_require__("node_modules/@rc-component/util/es/Dom/findDOMNode.js");
var _ref = __mako_require__("node_modules/@rc-component/util/es/ref.js");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
var _Collection = __mako_require__("node_modules/@rc-component/resize-observer/es/Collection.js");
var _observerUtil = __mako_require__("node_modules/@rc-component/resize-observer/es/utils/observerUtil.js");
function SingleObserver(props, ref) {
    const { children, disabled } = props;
    const elementRef = _react.useRef(null);
    const onCollectionResize = _react.useContext(_Collection.CollectionContext);
    // =========================== Children ===========================
    const isRenderProps = typeof children === 'function';
    const mergedChildren = isRenderProps ? children(elementRef) : children;
    // ============================= Size =============================
    const sizeRef = _react.useRef({
        width: -1,
        height: -1,
        offsetWidth: -1,
        offsetHeight: -1
    });
    // ============================= Ref ==============================
    const canRef = !isRenderProps && /*#__PURE__*/ _react.isValidElement(mergedChildren) && (0, _ref.supportRef)(mergedChildren);
    const originRef = canRef ? (0, _ref.getNodeRef)(mergedChildren) : null;
    const mergedRef = (0, _ref.useComposeRef)(originRef, elementRef);
    const getDomElement = ()=>{
        return (0, _findDOMNode.getDOM)(elementRef.current);
    };
    _react.useImperativeHandle(ref, ()=>getDomElement());
    // =========================== Observe ============================
    const propsRef = _react.useRef(props);
    propsRef.current = props;
    // Handler
    const onInternalResize = _react.useCallback((target)=>{
        const { onResize, data } = propsRef.current;
        const { width, height } = target.getBoundingClientRect();
        const { offsetWidth, offsetHeight } = target;
        /**
     * Resize observer trigger when content size changed.
     * In most case we just care about element size,
     * let's use `boundary` instead of `contentRect` here to avoid shaking.
     */ const fixedWidth = Math.floor(width);
        const fixedHeight = Math.floor(height);
        if (sizeRef.current.width !== fixedWidth || sizeRef.current.height !== fixedHeight || sizeRef.current.offsetWidth !== offsetWidth || sizeRef.current.offsetHeight !== offsetHeight) {
            const size = {
                width: fixedWidth,
                height: fixedHeight,
                offsetWidth,
                offsetHeight
            };
            sizeRef.current = size;
            // IE is strange, right?
            const mergedOffsetWidth = offsetWidth === Math.round(width) ? width : offsetWidth;
            const mergedOffsetHeight = offsetHeight === Math.round(height) ? height : offsetHeight;
            const sizeInfo = {
                ...size,
                offsetWidth: mergedOffsetWidth,
                offsetHeight: mergedOffsetHeight
            };
            // Let collection know what happened
            onCollectionResize === null || onCollectionResize === void 0 || onCollectionResize(sizeInfo, target, data);
            if (onResize) // defer the callback but not defer to next frame
            Promise.resolve().then(()=>{
                onResize(sizeInfo, target);
            });
        }
    }, []);
    // Dynamic observe
    _react.useEffect(()=>{
        const currentElement = getDomElement();
        if (currentElement && !disabled) (0, _observerUtil.observe)(currentElement, onInternalResize);
        return ()=>(0, _observerUtil.unobserve)(currentElement, onInternalResize);
    }, [
        elementRef.current,
        disabled
    ]);
    // ============================ Render ============================
    return canRef ? /*#__PURE__*/ _react.cloneElement(mergedChildren, {
        ref: mergedRef
    }) : mergedChildren;
}
const RefSingleObserver = /*#__PURE__*/ _react.forwardRef(SingleObserver);
RefSingleObserver.displayName = 'SingleObserver';
var _default = RefSingleObserver;

},
"node_modules/@rc-component/resize-observer/es/index.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    _rs: function() {
        return _observerUtil._rs;
    },
    default: function() {
        return _default;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
var _toArray = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/Children/toArray.js"));
var _warning = __mako_require__("node_modules/@rc-component/util/es/warning.js");
var _SingleObserver = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/resize-observer/es/SingleObserver/index.js"));
var _Collection = __mako_require__("node_modules/@rc-component/resize-observer/es/Collection.js");
var _observerUtil = __mako_require__("node_modules/@rc-component/resize-observer/es/utils/observerUtil.js");
function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
const INTERNAL_PREFIX_KEY = 'rc-observer-key';
function ResizeObserver(props, ref) {
    const { children } = props;
    const childNodes = typeof children === 'function' ? [
        children
    ] : (0, _toArray.default)(children);
    if (childNodes.length > 1) (0, _warning.warning)(false, 'Find more than one child node with `children` in ResizeObserver. Please use ResizeObserver.Collection instead.');
    else if (childNodes.length === 0) (0, _warning.warning)(false, '`children` of ResizeObserver is empty. Nothing is in observe.');
    return childNodes.map((child, index)=>{
        const key = (child === null || child === void 0 ? void 0 : child.key) || `${INTERNAL_PREFIX_KEY}-${index}`;
        return /*#__PURE__*/ _react.createElement(_SingleObserver.default, _extends({}, props, {
            key: key,
            ref: index === 0 ? ref : undefined
        }), child);
    });
}
const RefResizeObserver = /*#__PURE__*/ _react.forwardRef(ResizeObserver);
RefResizeObserver.displayName = 'ResizeObserver';
RefResizeObserver.Collection = _Collection.Collection;
var _default = RefResizeObserver;

},
"node_modules/@rc-component/resize-observer/es/utils/observerUtil.js": function (module, exports, __mako_require__){
// =============================== Const ===============================
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    _el: function() {
        return _el;
    },
    _rs: function() {
        return _rs;
    },
    observe: function() {
        return observe;
    },
    unobserve: function() {
        return unobserve;
    }
});
const elementListeners = new Map();
function onResize(entities) {
    entities.forEach((entity)=>{
        var _elementListeners_get;
        const { target } = entity;
        (_elementListeners_get = elementListeners.get(target)) === null || _elementListeners_get === void 0 || _elementListeners_get.forEach((listener)=>listener(target));
    });
}
// Delay create ResizeObserver since it's not supported in server side
let observer;
function ensureResizeObserver() {
    if (!observer) observer = new ResizeObserver(onResize);
    return observer;
}
const _el = elementListeners; // eslint-disable-line
const _rs = onResize; // eslint-disable-line
function observe(element, callback) {
    if (!elementListeners.has(element)) {
        elementListeners.set(element, new Set());
        ensureResizeObserver().observe(element);
    }
    elementListeners.get(element).add(callback);
}
function unobserve(element, callback) {
    if (elementListeners.has(element)) {
        elementListeners.get(element).delete(callback);
        if (!elementListeners.get(element).size) {
            ensureResizeObserver().unobserve(element);
            elementListeners.delete(element);
        }
    }
}

},
"node_modules/@rc-component/select/assets/index.less?asmodule": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
"";
var _default = {
    "rc-select-selection-item-disabled": `rc-select-selection-item-disabled-R8h6p4S0`,
    "rc-select-item-option-active": `rc-select-item-option-active-CzQHMpfB`,
    "rc-select-selection__choice-zoom-leave-active": `rc-select-selection__choice-zoom-leave-active-uJKNloJb`,
    "rc-select-dropdown-placement-bottomLeft": `rc-select-dropdown-placement-bottomLeft-jvTLU_Vo`,
    "rc-select-selection-wrap": `rc-select-selection-wrap-p2adktxQ`,
    "rc-select-arrow": `rc-select-arrow-OOaZmUjg`,
    "rc-select-selector": `rc-select-selector-t32QpsUx`,
    "rc-select-selection-item": `rc-select-selection-item-4JtkmtDi`,
    "rc-select-dropdown-hidden": `rc-select-dropdown-hidden-l1bx2zcw`,
    "rc-select-arrow-icon": `rc-select-arrow-icon-DeDG-xpA`,
    "rc-select-selection-search-input": `rc-select-selection-search-input-DNjeyBW2`,
    "rc-select-item-option-disabled": `rc-select-item-option-disabled-1FRNvQBP`,
    "rc-select-single": `rc-select-single-ErC18FLa`,
    "rc-select": `rc-select-wgW9WeTe`,
    "rc-select-dropdown-placement-topLeft": `rc-select-dropdown-placement-topLeft-6Dowpe0T`,
    "rcSelectDropdownSlideDownIn": `rcSelectDropdownSlideDownIn-3Tw-4Tnw`,
    "rc-select-selection-overflow": `rc-select-selection-overflow-uGG9MFj3`,
    "rc-select-loading": `rc-select-loading-E-Fr4YSm`,
    "rc-select-item-option-state": `rc-select-item-option-state-mEhNyTqj`,
    "rc-select-dropdown-slide-up-appear": `rc-select-dropdown-slide-up-appear-ha-sopWn`,
    "rc-select-selection-search-mirror": `rc-select-selection-search-mirror-D7kzMgWh`,
    "rc-select-item-option": `rc-select-item-option-apuUEu8S`,
    "rc-select-dropdown-placement-topRight": `rc-select-dropdown-placement-topRight--wHhBhcf`,
    "rcSelectDropdownSlideUpOut": `rcSelectDropdownSlideUpOut-BUykZvgK`,
    "rc-select-dropdown-slide-up-leave": `rc-select-dropdown-slide-up-leave-WKq8eBVY`,
    "rc-select-dropdown-slide-up-leave-active": `rc-select-dropdown-slide-up-leave-active-RjgVudoK`,
    "rcSelectLoadingIcon": `rcSelectLoadingIcon-A_SHsB-o`,
    "rc-select-selection__choice-zoom-leave": `rc-select-selection__choice-zoom-leave-9XpZNZOT`,
    "rcSelectDropdownSlideDownOut": `rcSelectDropdownSlideDownOut-dbFUjupI`,
    "rc-select-selection__choice-zoom": `rc-select-selection__choice-zoom-uxAxYqp_`,
    "rc-select-focused": `rc-select-focused-RCC3Y9Y2`,
    "rc-select-item-empty": `rc-select-item-empty-xT5Dmv9P`,
    "rc-select-dropdown-slide-up-enter-active": `rc-select-dropdown-slide-up-enter-active-qKmfiPDx`,
    "rc-select-customize-input": `rc-select-customize-input-rtd4d3dF`,
    "rc-select-dropdown-placement-bottomRight": `rc-select-dropdown-placement-bottomRight-U2sgYtP2`,
    "rc-select-disabled": `rc-select-disabled-nJp3BQmC`,
    "rc-select-selection-placeholder": `rc-select-selection-placeholder-ZW1GZtpS`,
    "rc-select-allow-clear": `rc-select-allow-clear-FxQny2qf`,
    "rc-select-show-arrow": `rc-select-show-arrow-zCXetSzs`,
    "rc-select-selection-overflow-item": `rc-select-selection-overflow-item-yI0jyzQ5`,
    "rc-select-multiple": `rc-select-multiple-Jedg2SPH`,
    "rc-select-item-group": `rc-select-item-group-Srjr_Ygc`,
    "rc-select-selection__choice-zoom-appear": `rc-select-selection__choice-zoom-appear-lD370LGJ`,
    "rc-select-item": `rc-select-item-wI--Cb1-`,
    "rc-select-selection-search": `rc-select-selection-search-b3zLzpC_`,
    "rc-select-selection__choice-zoom-appear-active": `rc-select-selection__choice-zoom-appear-active-uP057SJH`,
    "rc-select-dropdown": `rc-select-dropdown-hOIFtSRb`,
    "rc-select-item-option-grouped": `rc-select-item-option-grouped-tIAPe6I8`,
    "rc-select-dropdown-slide-up-enter": `rc-select-dropdown-slide-up-enter-rOvQk9rx`,
    "rc-select-dropdown-slide-up-appear-active": `rc-select-dropdown-slide-up-appear-active-0-_mJ8E6`,
    "rc-select-clear": `rc-select-clear-ki_sdEVh`,
    "rcSelectDropdownSlideUpIn": `rcSelectDropdownSlideUpIn-Q92iW4Qv`
};

},
"node_modules/@rc-component/select/es/BaseSelect/Polite.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return Polite;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
function Polite(props) {
    const { visible, values } = props;
    if (!visible) return null;
    // Only cut part of values since it's a screen reader
    const MAX_COUNT = 50;
    return /*#__PURE__*/ _react.createElement("span", {
        "aria-live": "polite",
        style: {
            width: 0,
            height: 0,
            position: 'absolute',
            overflow: 'hidden',
            opacity: 0
        }
    }, `${values.slice(0, MAX_COUNT).map(({ label, value })=>[
            'number',
            'string'
        ].includes(typeof label) ? label : value).join(', ')}`, values.length > MAX_COUNT ? ', ...' : null);
}

},
"node_modules/@rc-component/select/es/BaseSelect/index.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    default: function() {
        return _default;
    },
    isMultiple: function() {
        return isMultiple;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _classnames = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/classnames/index.js"));
var _useLayoutEffect = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/hooks/useLayoutEffect.js"));
var _useMergedState = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/hooks/useMergedState.js"));
var _isMobile = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/isMobile.js"));
var _ref = __mako_require__("node_modules/@rc-component/util/es/ref.js");
var _findDOMNode = __mako_require__("node_modules/@rc-component/util/es/Dom/findDOMNode.js");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
var _useAllowClear = __mako_require__("node_modules/@rc-component/select/es/hooks/useAllowClear.js");
var _useBaseProps = __mako_require__("node_modules/@rc-component/select/es/hooks/useBaseProps.js");
var _useDelayReset = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/select/es/hooks/useDelayReset.js"));
var _useLock = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/select/es/hooks/useLock.js"));
var _useSelectTriggerControl = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/select/es/hooks/useSelectTriggerControl.js"));
var _Selector = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/select/es/Selector/index.js"));
var _SelectTrigger = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/select/es/SelectTrigger.js"));
var _TransBtn = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/select/es/TransBtn.js"));
var _valueUtil = __mako_require__("node_modules/@rc-component/select/es/utils/valueUtil.js");
var _Polite = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/select/es/BaseSelect/Polite.js"));
function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
const DEFAULT_OMIT_PROPS = [
    'value',
    'onChange',
    'removeIcon',
    'placeholder',
    'autoFocus',
    'maxTagCount',
    'maxTagTextLength',
    'maxTagPlaceholder',
    'choiceTransitionName',
    'onInputKeyDown',
    'onPopupScroll',
    'tabIndex'
];
const isMultiple = (mode)=>mode === 'tags' || mode === 'multiple';
const BaseSelect = /*#__PURE__*/ _react.forwardRef((props, ref)=>{
    var _customizeRawInputElement_props;
    const { id, prefixCls, className, styles, classNames, showSearch, tagRender, showScrollBar = 'optional', direction, omitDomProps, // Value
    displayValues, onDisplayValuesChange, emptyOptions, notFoundContent = 'Not Found', onClear, maxCount, // Mode
    mode, // Status
    disabled, loading, // Customize Input
    getInputElement, getRawInputElement, // Open
    open, defaultOpen, onPopupVisibleChange, // Active
    activeValue, onActiveValueChange, activeDescendantId, // Search
    searchValue, autoClearSearchValue, onSearch, onSearchSplit, tokenSeparators, // Icons
    allowClear, prefix, suffixIcon, clearIcon, // Dropdown
    OptionList, animation, transitionName, popupStyle, popupClassName, popupMatchSelectWidth, popupRender, popupAlign, placement, builtinPlacements, getPopupContainer, // Focus
    showAction = [], onFocus, onBlur, // Rest Events
    onKeyUp, onKeyDown, onMouseDown, // Rest Props
    ...restProps } = props;
    // ============================== MISC ==============================
    const multiple = isMultiple(mode);
    const mergedShowSearch = (showSearch !== undefined ? showSearch : multiple) || mode === 'combobox';
    const domProps = {
        ...restProps
    };
    DEFAULT_OMIT_PROPS.forEach((propName)=>{
        delete domProps[propName];
    });
    omitDomProps === null || omitDomProps === void 0 || omitDomProps.forEach((propName)=>{
        delete domProps[propName];
    });
    // ============================= Mobile =============================
    const [mobile, setMobile] = _react.useState(false);
    _react.useEffect(()=>{
        // Only update on the client side
        setMobile((0, _isMobile.default)());
    }, []);
    // ============================== Refs ==============================
    const containerRef = _react.useRef(null);
    const triggerRef = _react.useRef(null);
    const selectorRef = _react.useRef(null);
    const listRef = _react.useRef(null);
    const blurRef = _react.useRef(false);
    const customDomRef = _react.useRef(null);
    /** Used for component focused management */ const [mockFocused, setMockFocused, cancelSetMockFocused] = (0, _useDelayReset.default)();
    // =========================== Imperative ===========================
    _react.useImperativeHandle(ref, ()=>{
        var _selectorRef_current, _selectorRef_current1, _selectorRef_current2;
        return {
            focus: (_selectorRef_current = selectorRef.current) === null || _selectorRef_current === void 0 ? void 0 : _selectorRef_current.focus,
            blur: (_selectorRef_current1 = selectorRef.current) === null || _selectorRef_current1 === void 0 ? void 0 : _selectorRef_current1.blur,
            scrollTo: (arg)=>{
                var _listRef_current;
                return (_listRef_current = listRef.current) === null || _listRef_current === void 0 ? void 0 : _listRef_current.scrollTo(arg);
            },
            nativeElement: containerRef.current || ((_selectorRef_current2 = selectorRef.current) === null || _selectorRef_current2 === void 0 ? void 0 : _selectorRef_current2.nativeElement) || (0, _findDOMNode.getDOM)(customDomRef.current)
        };
    });
    // ========================== Search Value ==========================
    const mergedSearchValue = _react.useMemo(()=>{
        var _displayValues_;
        if (mode !== 'combobox') return searchValue;
        const val = (_displayValues_ = displayValues[0]) === null || _displayValues_ === void 0 ? void 0 : _displayValues_.value;
        return typeof val === 'string' || typeof val === 'number' ? String(val) : '';
    }, [
        searchValue,
        mode,
        displayValues
    ]);
    // ========================== Custom Input ==========================
    // Only works in `combobox`
    const customizeInputElement = mode === 'combobox' && typeof getInputElement === 'function' && getInputElement() || null;
    // Used for customize replacement for `rc-cascader`
    const customizeRawInputElement = typeof getRawInputElement === 'function' && getRawInputElement();
    const customizeRawInputRef = (0, _ref.useComposeRef)(customDomRef, customizeRawInputElement === null || customizeRawInputElement === void 0 ? void 0 : (_customizeRawInputElement_props = customizeRawInputElement.props) === null || _customizeRawInputElement_props === void 0 ? void 0 : _customizeRawInputElement_props.ref);
    // ============================== Open ==============================
    // SSR not support Portal which means we need delay `open` for the first time render
    const [rendered, setRendered] = _react.useState(false);
    (0, _useLayoutEffect.default)(()=>{
        setRendered(true);
    }, []);
    const [innerOpen, setInnerOpen] = (0, _useMergedState.default)(false, {
        defaultValue: defaultOpen,
        value: open
    });
    let mergedOpen = rendered ? innerOpen : false;
    // Not trigger `open` in `combobox` when `notFoundContent` is empty
    const emptyListContent = !notFoundContent && emptyOptions;
    if (disabled || emptyListContent && mergedOpen && mode === 'combobox') mergedOpen = false;
    const triggerOpen = emptyListContent ? false : mergedOpen;
    const onToggleOpen = _react.useCallback((newOpen)=>{
        const nextOpen = newOpen !== undefined ? newOpen : !mergedOpen;
        if (!disabled) {
            setInnerOpen(nextOpen);
            if (mergedOpen !== nextOpen) onPopupVisibleChange === null || onPopupVisibleChange === void 0 || onPopupVisibleChange(nextOpen);
        }
    }, [
        disabled,
        mergedOpen,
        setInnerOpen,
        onPopupVisibleChange
    ]);
    // ============================= Search =============================
    const tokenWithEnter = _react.useMemo(()=>(tokenSeparators || []).some((tokenSeparator)=>[
                '\n',
                '\r\n'
            ].includes(tokenSeparator)), [
        tokenSeparators
    ]);
    const onInternalSearch = (searchText, fromTyping, isCompositing)=>{
        if (multiple && (0, _valueUtil.isValidCount)(maxCount) && displayValues.length >= maxCount) return;
        let ret = true;
        let newSearchText = searchText;
        onActiveValueChange === null || onActiveValueChange === void 0 || onActiveValueChange(null);
        const separatedList = (0, _valueUtil.getSeparatedContent)(searchText, tokenSeparators, (0, _valueUtil.isValidCount)(maxCount) ? maxCount - displayValues.length : undefined);
        // Check if match the `tokenSeparators`
        const patchLabels = isCompositing ? null : separatedList;
        // Ignore combobox since it's not split-able
        if (mode !== 'combobox' && patchLabels) {
            newSearchText = '';
            onSearchSplit === null || onSearchSplit === void 0 || onSearchSplit(patchLabels);
            // Should close when paste finish
            onToggleOpen(false);
            // Tell Selector that break next actions
            ret = false;
        }
        if (onSearch && mergedSearchValue !== newSearchText) onSearch(newSearchText, {
            source: fromTyping ? 'typing' : 'effect'
        });
        return ret;
    };
    // Only triggered when menu is closed & mode is tags
    // If menu is open, OptionList will take charge
    // If mode isn't tags, press enter is not meaningful when you can't see any option
    const onInternalSearchSubmit = (searchText)=>{
        // prevent empty tags from appearing when you click the Enter button
        if (!searchText || !searchText.trim()) return;
        onSearch(searchText, {
            source: 'submit'
        });
    };
    // Close will clean up single mode search text
    _react.useEffect(()=>{
        if (!mergedOpen && !multiple && mode !== 'combobox') onInternalSearch('', false, false);
    }, [
        mergedOpen
    ]);
    // ============================ Disabled ============================
    // Close dropdown & remove focus state when disabled change
    _react.useEffect(()=>{
        if (innerOpen && disabled) setInnerOpen(false);
        // After onBlur is triggered, the focused does not need to be reset
        if (disabled && !blurRef.current) setMockFocused(false);
    }, [
        disabled
    ]);
    // ============================ Keyboard ============================
    /**
   * We record input value here to check if can press to clean up by backspace
   * - null: Key is not down, this is reset by key up
   * - true: Search text is empty when first time backspace down
   * - false: Search text is not empty when first time backspace down
   */ const [getClearLock, setClearLock] = (0, _useLock.default)();
    const keyLockRef = _react.useRef(false);
    // KeyDown
    const onInternalKeyDown = (event, ...rest)=>{
        const clearLock = getClearLock();
        const { key } = event;
        const isEnterKey = key === 'Enter';
        if (isEnterKey) {
            // Do not submit form when type in the input
            if (mode !== 'combobox') event.preventDefault();
            // We only manage open state here, close logic should handle by list component
            if (!mergedOpen) onToggleOpen(true);
        }
        setClearLock(!!mergedSearchValue);
        // Remove value by `backspace`
        if (key === 'Backspace' && !clearLock && multiple && !mergedSearchValue && displayValues.length) {
            const cloneDisplayValues = [
                ...displayValues
            ];
            let removedDisplayValue = null;
            for(let i = cloneDisplayValues.length - 1; i >= 0; i -= 1){
                const current = cloneDisplayValues[i];
                if (!current.disabled) {
                    cloneDisplayValues.splice(i, 1);
                    removedDisplayValue = current;
                    break;
                }
            }
            if (removedDisplayValue) onDisplayValuesChange(cloneDisplayValues, {
                type: 'remove',
                values: [
                    removedDisplayValue
                ]
            });
        }
        if (mergedOpen && (!isEnterKey || !keyLockRef.current)) {
            var _listRef_current;
            // Lock the Enter key after it is pressed to avoid repeated triggering of the onChange event.
            if (isEnterKey) keyLockRef.current = true;
            (_listRef_current = listRef.current) === null || _listRef_current === void 0 || _listRef_current.onKeyDown(event, ...rest);
        }
        onKeyDown === null || onKeyDown === void 0 || onKeyDown(event, ...rest);
    };
    // KeyUp
    const onInternalKeyUp = (event, ...rest)=>{
        if (mergedOpen) {
            var _listRef_current;
            (_listRef_current = listRef.current) === null || _listRef_current === void 0 || _listRef_current.onKeyUp(event, ...rest);
        }
        if (event.key === 'Enter') keyLockRef.current = false;
        onKeyUp === null || onKeyUp === void 0 || onKeyUp(event, ...rest);
    };
    // ============================ Selector ============================
    const onSelectorRemove = (val)=>{
        const newValues = displayValues.filter((i)=>i !== val);
        onDisplayValuesChange(newValues, {
            type: 'remove',
            values: [
                val
            ]
        });
    };
    const onInputBlur = ()=>{
        // Unlock the Enter key after the input blur; otherwise, the Enter key needs to be pressed twice to trigger the correct effect.
        keyLockRef.current = false;
    };
    // ========================== Focus / Blur ==========================
    /** Record real focus status */ const focusRef = _react.useRef(false);
    const onContainerFocus = (...args)=>{
        setMockFocused(true);
        if (!disabled) {
            if (onFocus && !focusRef.current) onFocus(...args);
            // `showAction` should handle `focus` if set
            if (showAction.includes('focus')) onToggleOpen(true);
        }
        focusRef.current = true;
    };
    const onContainerBlur = (...args)=>{
        blurRef.current = true;
        setMockFocused(false, ()=>{
            focusRef.current = false;
            blurRef.current = false;
            onToggleOpen(false);
        });
        if (disabled) return;
        if (mergedSearchValue) {
            // `tags` mode should move `searchValue` into values
            if (mode === 'tags') onSearch(mergedSearchValue, {
                source: 'submit'
            });
            else if (mode === 'multiple') // `multiple` mode only clean the search value but not trigger event
            onSearch('', {
                source: 'blur'
            });
        }
        if (onBlur) onBlur(...args);
    };
    // Give focus back of Select
    const activeTimeoutIds = [];
    _react.useEffect(()=>()=>{
            activeTimeoutIds.forEach((timeoutId)=>clearTimeout(timeoutId));
            activeTimeoutIds.splice(0, activeTimeoutIds.length);
        }, []);
    const onInternalMouseDown = (event, ...restArgs)=>{
        var _triggerRef_current;
        const { target } = event;
        const popupElement = (_triggerRef_current = triggerRef.current) === null || _triggerRef_current === void 0 ? void 0 : _triggerRef_current.getPopupElement();
        // We should give focus back to selector if clicked item is not focusable
        if (popupElement && popupElement.contains(target)) {
            const timeoutId = setTimeout(()=>{
                const index = activeTimeoutIds.indexOf(timeoutId);
                if (index !== -1) activeTimeoutIds.splice(index, 1);
                cancelSetMockFocused();
                if (!mobile && !popupElement.contains(document.activeElement)) {
                    var _selectorRef_current;
                    (_selectorRef_current = selectorRef.current) === null || _selectorRef_current === void 0 || _selectorRef_current.focus();
                }
            });
            activeTimeoutIds.push(timeoutId);
        }
        onMouseDown === null || onMouseDown === void 0 || onMouseDown(event, ...restArgs);
    };
    // ============================ Dropdown ============================
    const [, forceUpdate] = _react.useState({});
    // We need force update here since popup dom is render async
    function onPopupMouseEnter() {
        forceUpdate({});
    }
    // Used for raw custom input trigger
    let onTriggerVisibleChange;
    if (customizeRawInputElement) onTriggerVisibleChange = (newOpen)=>{
        onToggleOpen(newOpen);
    };
    // Close when click on non-select element
    (0, _useSelectTriggerControl.default)(()=>{
        var _triggerRef_current;
        return [
            containerRef.current,
            (_triggerRef_current = triggerRef.current) === null || _triggerRef_current === void 0 ? void 0 : _triggerRef_current.getPopupElement()
        ];
    }, triggerOpen, onToggleOpen, !!customizeRawInputElement);
    // ============================ Context =============================
    const baseSelectContext = _react.useMemo(()=>({
            ...props,
            notFoundContent,
            open: mergedOpen,
            triggerOpen,
            id,
            showSearch: mergedShowSearch,
            multiple,
            toggleOpen: onToggleOpen,
            showScrollBar,
            styles,
            classNames
        }), [
        props,
        notFoundContent,
        triggerOpen,
        mergedOpen,
        id,
        mergedShowSearch,
        multiple,
        onToggleOpen,
        showScrollBar,
        styles,
        classNames
    ]);
    // ==================================================================
    // ==                            Render                            ==
    // ==================================================================
    // ============================= Arrow ==============================
    const showSuffixIcon = !!suffixIcon || loading;
    let arrowNode;
    if (showSuffixIcon) arrowNode = /*#__PURE__*/ _react.createElement(_TransBtn.default, {
        className: (0, _classnames.default)(`${prefixCls}-arrow`, classNames === null || classNames === void 0 ? void 0 : classNames.suffix, {
            [`${prefixCls}-arrow-loading`]: loading
        }),
        style: styles === null || styles === void 0 ? void 0 : styles.suffix,
        customizeIcon: suffixIcon,
        customizeIconProps: {
            loading,
            searchValue: mergedSearchValue,
            open: mergedOpen,
            focused: mockFocused,
            showSearch: mergedShowSearch
        }
    });
    // ============================= Clear ==============================
    const onClearMouseDown = ()=>{
        var _selectorRef_current;
        onClear === null || onClear === void 0 || onClear();
        (_selectorRef_current = selectorRef.current) === null || _selectorRef_current === void 0 || _selectorRef_current.focus();
        onDisplayValuesChange([], {
            type: 'clear',
            values: displayValues
        });
        onInternalSearch('', false, false);
    };
    const { allowClear: mergedAllowClear, clearIcon: clearNode } = (0, _useAllowClear.useAllowClear)(prefixCls, onClearMouseDown, displayValues, allowClear, clearIcon, disabled, mergedSearchValue, mode);
    // =========================== OptionList ===========================
    const optionList = /*#__PURE__*/ _react.createElement(OptionList, {
        ref: listRef
    });
    // ============================= Select =============================
    const mergedClassName = (0, _classnames.default)(prefixCls, className, {
        [`${prefixCls}-focused`]: mockFocused,
        [`${prefixCls}-multiple`]: multiple,
        [`${prefixCls}-single`]: !multiple,
        [`${prefixCls}-allow-clear`]: allowClear,
        [`${prefixCls}-show-arrow`]: showSuffixIcon,
        [`${prefixCls}-disabled`]: disabled,
        [`${prefixCls}-loading`]: loading,
        [`${prefixCls}-open`]: mergedOpen,
        [`${prefixCls}-customize-input`]: customizeInputElement,
        [`${prefixCls}-show-search`]: mergedShowSearch
    });
    // >>> Selector
    const selectorNode = /*#__PURE__*/ _react.createElement(_SelectTrigger.default, {
        ref: triggerRef,
        disabled: disabled,
        prefixCls: prefixCls,
        visible: triggerOpen,
        popupElement: optionList,
        animation: animation,
        transitionName: transitionName,
        popupStyle: popupStyle,
        popupClassName: popupClassName,
        direction: direction,
        popupMatchSelectWidth: popupMatchSelectWidth,
        popupRender: popupRender,
        popupAlign: popupAlign,
        placement: placement,
        builtinPlacements: builtinPlacements,
        getPopupContainer: getPopupContainer,
        empty: emptyOptions,
        onPopupVisibleChange: onTriggerVisibleChange,
        onPopupMouseEnter: onPopupMouseEnter
    }, customizeRawInputElement ? /*#__PURE__*/ _react.cloneElement(customizeRawInputElement, {
        ref: customizeRawInputRef
    }) : /*#__PURE__*/ _react.createElement(_Selector.default, _extends({}, props, {
        prefixClassName: classNames === null || classNames === void 0 ? void 0 : classNames.prefix,
        prefixStyle: styles === null || styles === void 0 ? void 0 : styles.prefix,
        prefixCls: prefixCls,
        inputElement: customizeInputElement,
        ref: selectorRef,
        id: id,
        prefix: prefix,
        showSearch: mergedShowSearch,
        autoClearSearchValue: autoClearSearchValue,
        mode: mode,
        activeDescendantId: activeDescendantId,
        tagRender: tagRender,
        values: displayValues,
        open: mergedOpen,
        onToggleOpen: onToggleOpen,
        activeValue: activeValue,
        searchValue: mergedSearchValue,
        onSearch: onInternalSearch,
        onSearchSubmit: onInternalSearchSubmit,
        onRemove: onSelectorRemove,
        tokenWithEnter: tokenWithEnter,
        onInputBlur: onInputBlur
    })));
    // >>> Render
    let renderNode;
    // Render raw
    if (customizeRawInputElement) renderNode = selectorNode;
    else renderNode = /*#__PURE__*/ _react.createElement("div", _extends({
        className: mergedClassName
    }, domProps, {
        ref: containerRef,
        onMouseDown: onInternalMouseDown,
        onKeyDown: onInternalKeyDown,
        onKeyUp: onInternalKeyUp,
        onFocus: onContainerFocus,
        onBlur: onContainerBlur
    }), /*#__PURE__*/ _react.createElement(_Polite.default, {
        visible: mockFocused && !mergedOpen,
        values: displayValues
    }), selectorNode, arrowNode, mergedAllowClear && clearNode);
    return /*#__PURE__*/ _react.createElement(_useBaseProps.BaseSelectContext.Provider, {
        value: baseSelectContext
    }, renderNode);
});
BaseSelect.displayName = 'BaseSelect';
var _default = BaseSelect;

},
"node_modules/@rc-component/select/es/OptGroup.js": function (module, exports, __mako_require__){
/* istanbul ignore file */ /** This is a placeholder, not real render in dom */ "use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
const OptGroup = ()=>null;
OptGroup.isSelectOptGroup = true;
var _default = OptGroup;

},
"node_modules/@rc-component/select/es/Option.js": function (module, exports, __mako_require__){
/* istanbul ignore file */ /** This is a placeholder, not real render in dom */ "use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
const Option = ()=>null;
Option.isSelectOption = true;
var _default = Option;

},
"node_modules/@rc-component/select/es/OptionList.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _classnames = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/classnames/index.js"));
var _KeyCode = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/KeyCode.js"));
var _useMemo = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/hooks/useMemo.js"));
var _omit = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/omit.js"));
var _pickAttrs = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/pickAttrs.js"));
var _rcvirtuallist = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/rc-virtual-list/es/index.js"));
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
var _SelectContext = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/select/es/SelectContext.js"));
var _TransBtn = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/select/es/TransBtn.js"));
var _useBaseProps = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/select/es/hooks/useBaseProps.js"));
var _platformUtil = __mako_require__("node_modules/@rc-component/select/es/utils/platformUtil.js");
var _valueUtil = __mako_require__("node_modules/@rc-component/select/es/utils/valueUtil.js");
function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
// export interface OptionListProps<OptionsType extends object[]> {
function isTitleType(content) {
    return typeof content === 'string' || typeof content === 'number';
}
/**
 * Using virtual list of option display.
 * Will fallback to dom if use customize render.
 */ const OptionList = (_, ref)=>{
    var _contextClassNames_popup, _contextStyles_popup;
    const { prefixCls, id, open, multiple, mode, searchValue, toggleOpen, notFoundContent, onPopupScroll, showScrollBar } = (0, _useBaseProps.default)();
    const { maxCount, flattenOptions, onActiveValue, defaultActiveFirstOption, onSelect, menuItemSelectedIcon, rawValues, fieldNames, virtual, direction, listHeight, listItemHeight, optionRender, classNames: contextClassNames, styles: contextStyles } = _react.useContext(_SelectContext.default);
    const itemPrefixCls = `${prefixCls}-item`;
    const memoFlattenOptions = (0, _useMemo.default)(()=>flattenOptions, [
        open,
        flattenOptions
    ], (prev, next)=>next[0] && prev[1] !== next[1]);
    // =========================== List ===========================
    const listRef = _react.useRef(null);
    const overMaxCount = _react.useMemo(()=>multiple && (0, _valueUtil.isValidCount)(maxCount) && (rawValues === null || rawValues === void 0 ? void 0 : rawValues.size) >= maxCount, [
        multiple,
        maxCount,
        rawValues === null || rawValues === void 0 ? void 0 : rawValues.size
    ]);
    const onListMouseDown = (event)=>{
        event.preventDefault();
    };
    const scrollIntoView = (args)=>{
        var _listRef_current;
        (_listRef_current = listRef.current) === null || _listRef_current === void 0 || _listRef_current.scrollTo(typeof args === 'number' ? {
            index: args
        } : args);
    };
    // https://github.com/ant-design/ant-design/issues/34975
    const isSelected = _react.useCallback((value)=>{
        if (mode === 'combobox') return false;
        return rawValues.has(value);
    }, [
        mode,
        [
            ...rawValues
        ].toString(),
        rawValues.size
    ]);
    // ========================== Active ==========================
    const getEnabledActiveIndex = (index, offset = 1)=>{
        const len = memoFlattenOptions.length;
        for(let i = 0; i < len; i += 1){
            const current = (index + i * offset + len) % len;
            const { group, data } = memoFlattenOptions[current] || {};
            if (!group && !(data === null || data === void 0 ? void 0 : data.disabled) && (isSelected(data.value) || !overMaxCount)) return current;
        }
        return -1;
    };
    const [activeIndex, setActiveIndex] = _react.useState(()=>getEnabledActiveIndex(0));
    const setActive = (index, fromKeyboard = false)=>{
        setActiveIndex(index);
        const info = {
            source: fromKeyboard ? 'keyboard' : 'mouse'
        };
        // Trigger active event
        const flattenItem = memoFlattenOptions[index];
        if (!flattenItem) {
            onActiveValue(null, -1, info);
            return;
        }
        onActiveValue(flattenItem.value, index, info);
    };
    // Auto active first item when list length or searchValue changed
    (0, _react.useEffect)(()=>{
        setActive(defaultActiveFirstOption !== false ? getEnabledActiveIndex(0) : -1);
    }, [
        memoFlattenOptions.length,
        searchValue
    ]);
    // https://github.com/ant-design/ant-design/issues/48036
    const isAriaSelected = _react.useCallback((value)=>{
        if (mode === 'combobox') return String(value).toLowerCase() === searchValue.toLowerCase();
        return rawValues.has(value);
    }, [
        mode,
        searchValue,
        [
            ...rawValues
        ].toString(),
        rawValues.size
    ]);
    // Auto scroll to item position in single mode
    (0, _react.useEffect)(()=>{
        /**
     * React will skip `onChange` when component update.
     * `setActive` function will call root accessibility state update which makes re-render.
     * So we need to delay to let Input component trigger onChange first.
     */ let timeoutId;
        if (!multiple && open && rawValues.size === 1) {
            const value = Array.from(rawValues)[0];
            // Scroll to the option closest to the searchValue if searching.
            const index = memoFlattenOptions.findIndex(({ data })=>searchValue ? String(data.value).startsWith(searchValue) : data.value === value);
            if (index !== -1) {
                setActive(index);
                timeoutId = setTimeout(()=>{
                    scrollIntoView(index);
                });
            }
        }
        // Force trigger scrollbar visible when open
        if (open) {
            var _listRef_current;
            (_listRef_current = listRef.current) === null || _listRef_current === void 0 || _listRef_current.scrollTo(undefined);
        }
        return ()=>clearTimeout(timeoutId);
    }, [
        open,
        searchValue
    ]);
    // ========================== Values ==========================
    const onSelectValue = (value)=>{
        if (value !== undefined) onSelect(value, {
            selected: !rawValues.has(value)
        });
        // Single mode should always close by select
        if (!multiple) toggleOpen(false);
    };
    // ========================= Keyboard =========================
    _react.useImperativeHandle(ref, ()=>({
            onKeyDown: (event)=>{
                const { which, ctrlKey } = event;
                switch(which){
                    // >>> Arrow keys & ctrl + n/p on Mac
                    case _KeyCode.default.N:
                    case _KeyCode.default.P:
                    case _KeyCode.default.UP:
                    case _KeyCode.default.DOWN:
                        {
                            let offset = 0;
                            if (which === _KeyCode.default.UP) offset = -1;
                            else if (which === _KeyCode.default.DOWN) offset = 1;
                            else if ((0, _platformUtil.isPlatformMac)() && ctrlKey) {
                                if (which === _KeyCode.default.N) offset = 1;
                                else if (which === _KeyCode.default.P) offset = -1;
                            }
                            if (offset !== 0) {
                                const nextActiveIndex = getEnabledActiveIndex(activeIndex + offset, offset);
                                scrollIntoView(nextActiveIndex);
                                setActive(nextActiveIndex, true);
                            }
                            break;
                        }
                    // >>> Select (Tab / Enter)
                    case _KeyCode.default.TAB:
                    case _KeyCode.default.ENTER:
                        {
                            // value
                            const item = memoFlattenOptions[activeIndex];
                            if (!item || item.data.disabled) return onSelectValue(undefined);
                            if (!overMaxCount || rawValues.has(item.value)) onSelectValue(item.value);
                            else onSelectValue(undefined);
                            if (open) event.preventDefault();
                            break;
                        }
                    // >>> Close
                    case _KeyCode.default.ESC:
                        toggleOpen(false);
                        if (open) event.stopPropagation();
                }
            },
            onKeyUp: ()=>{},
            scrollTo: (index)=>{
                scrollIntoView(index);
            }
        }));
    // ========================== Render ==========================
    if (memoFlattenOptions.length === 0) return /*#__PURE__*/ _react.createElement("div", {
        role: "listbox",
        id: `${id}_list`,
        className: `${itemPrefixCls}-empty`,
        onMouseDown: onListMouseDown
    }, notFoundContent);
    const omitFieldNameList = Object.keys(fieldNames).map((key)=>fieldNames[key]);
    const getLabel = (item)=>item.label;
    function getItemAriaProps(item, index) {
        const { group } = item;
        return {
            role: group ? 'presentation' : 'option',
            id: `${id}_list_${index}`
        };
    }
    const renderItem = (index)=>{
        const item = memoFlattenOptions[index];
        if (!item) return null;
        const itemData = item.data || {};
        const { value } = itemData;
        const { group } = item;
        const attrs = (0, _pickAttrs.default)(itemData, true);
        const mergedLabel = getLabel(item);
        return item ? /*#__PURE__*/ _react.createElement("div", _extends({
            "aria-label": typeof mergedLabel === 'string' && !group ? mergedLabel : null
        }, attrs, {
            key: index
        }, getItemAriaProps(item, index), {
            "aria-selected": isAriaSelected(value)
        }), value) : null;
    };
    const a11yProps = {
        role: 'listbox',
        id: `${id}_list`
    };
    return /*#__PURE__*/ _react.createElement(_react.Fragment, null, virtual && /*#__PURE__*/ _react.createElement("div", _extends({}, a11yProps, {
        style: {
            height: 0,
            width: 0,
            overflow: 'hidden'
        }
    }), renderItem(activeIndex - 1), renderItem(activeIndex), renderItem(activeIndex + 1)), /*#__PURE__*/ _react.createElement(_rcvirtuallist.default, {
        itemKey: "key",
        ref: listRef,
        data: memoFlattenOptions,
        height: listHeight,
        itemHeight: listItemHeight,
        fullHeight: false,
        onMouseDown: onListMouseDown,
        onScroll: onPopupScroll,
        virtual: virtual,
        direction: direction,
        innerProps: virtual ? null : a11yProps,
        showScrollBar: showScrollBar,
        className: contextClassNames === null || contextClassNames === void 0 ? void 0 : (_contextClassNames_popup = contextClassNames.popup) === null || _contextClassNames_popup === void 0 ? void 0 : _contextClassNames_popup.list,
        style: contextStyles === null || contextStyles === void 0 ? void 0 : (_contextStyles_popup = contextStyles.popup) === null || _contextStyles_popup === void 0 ? void 0 : _contextStyles_popup.list
    }, (item, itemIndex)=>{
        var _contextClassNames_popup, _contextStyles_popup;
        const { group, groupOption, data, label, value } = item;
        const { key } = data;
        // Group
        if (group) {
            const groupTitle = data.title ?? (isTitleType(label) ? label.toString() : undefined);
            return /*#__PURE__*/ _react.createElement("div", {
                className: (0, _classnames.default)(itemPrefixCls, `${itemPrefixCls}-group`, data.className),
                title: groupTitle
            }, label !== undefined ? label : key);
        }
        const { disabled, title, children, style, className, ...otherProps } = data;
        const passedProps = (0, _omit.default)(otherProps, omitFieldNameList);
        // Option
        const selected = isSelected(value);
        const mergedDisabled = disabled || !selected && overMaxCount;
        const optionPrefixCls = `${itemPrefixCls}-option`;
        const optionClassName = (0, _classnames.default)(itemPrefixCls, optionPrefixCls, className, contextClassNames === null || contextClassNames === void 0 ? void 0 : (_contextClassNames_popup = contextClassNames.popup) === null || _contextClassNames_popup === void 0 ? void 0 : _contextClassNames_popup.listItem, {
            [`${optionPrefixCls}-grouped`]: groupOption,
            [`${optionPrefixCls}-active`]: activeIndex === itemIndex && !mergedDisabled,
            [`${optionPrefixCls}-disabled`]: mergedDisabled,
            [`${optionPrefixCls}-selected`]: selected
        });
        const mergedLabel = getLabel(item);
        const iconVisible = !menuItemSelectedIcon || typeof menuItemSelectedIcon === 'function' || selected;
        // https://github.com/ant-design/ant-design/issues/34145
        const content = typeof mergedLabel === 'number' ? mergedLabel : mergedLabel || value;
        // https://github.com/ant-design/ant-design/issues/26717
        let optionTitle = isTitleType(content) ? content.toString() : undefined;
        if (title !== undefined) optionTitle = title;
        return /*#__PURE__*/ _react.createElement("div", _extends({}, (0, _pickAttrs.default)(passedProps), !virtual ? getItemAriaProps(item, itemIndex) : {}, {
            "aria-selected": virtual ? undefined : isAriaSelected(value),
            className: optionClassName,
            title: optionTitle,
            onMouseMove: ()=>{
                if (activeIndex === itemIndex || mergedDisabled) return;
                setActive(itemIndex);
            },
            onClick: ()=>{
                if (!mergedDisabled) onSelectValue(value);
            },
            style: {
                ...contextStyles === null || contextStyles === void 0 ? void 0 : (_contextStyles_popup = contextStyles.popup) === null || _contextStyles_popup === void 0 ? void 0 : _contextStyles_popup.listItem,
                ...style
            }
        }), /*#__PURE__*/ _react.createElement("div", {
            className: `${optionPrefixCls}-content`
        }, typeof optionRender === 'function' ? optionRender(item, {
            index: itemIndex
        }) : content), /*#__PURE__*/ _react.isValidElement(menuItemSelectedIcon) || selected, iconVisible && /*#__PURE__*/ _react.createElement(_TransBtn.default, {
            className: `${itemPrefixCls}-option-state`,
            customizeIcon: menuItemSelectedIcon,
            customizeIconProps: {
                value,
                disabled: mergedDisabled,
                isSelected: selected
            }
        }, selected ? '' : null));
    }));
};
const RefOptionList = /*#__PURE__*/ _react.forwardRef(OptionList);
RefOptionList.displayName = 'OptionList';
var _default = RefOptionList;

},
"node_modules/@rc-component/select/es/Select.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _useMergedState = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/hooks/useMergedState.js"));
var _warning = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/warning.js"));
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
var _BaseSelect = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/@rc-component/select/es/BaseSelect/index.js"));
var _OptGroup = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/select/es/OptGroup.js"));
var _Option = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/select/es/Option.js"));
var _OptionList = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/select/es/OptionList.js"));
var _SelectContext = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/select/es/SelectContext.js"));
var _useCache = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/select/es/hooks/useCache.js"));
var _useFilterOptions = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/select/es/hooks/useFilterOptions.js"));
var _useId = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/hooks/useId.js"));
var _useOptions = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/select/es/hooks/useOptions.js"));
var _useRefFunc = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/select/es/hooks/useRefFunc.js"));
var _commonUtil = __mako_require__("node_modules/@rc-component/select/es/utils/commonUtil.js");
var _valueUtil = __mako_require__("node_modules/@rc-component/select/es/utils/valueUtil.js");
var _warningPropsUtil = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/@rc-component/select/es/utils/warningPropsUtil.js"));
var _useSearchConfig = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/select/es/hooks/useSearchConfig.js"));
function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
const OMIT_DOM_PROPS = [
    'inputValue'
];
function isRawValue(value) {
    return !value || typeof value !== 'object';
}
const Select = /*#__PURE__*/ _react.forwardRef((props, ref)=>{
    const { id, mode, prefixCls = 'rc-select', backfill, fieldNames, // Search
    showSearch, searchValue: legacySearchValue, onSearch: legacyOnSearch, autoClearSearchValue: legacyAutoClearSearchValue, filterOption: legacyFilterOption, optionFilterProp: legacyOptionFilterProp, filterSort: legacyFilterSort, // Select
    onSelect, onDeselect, onActive, popupMatchSelectWidth = true, optionLabelProp, options, optionRender, children, defaultActiveFirstOption, menuItemSelectedIcon, virtual, direction, listHeight = 200, listItemHeight = 20, labelRender, // Value
    value, defaultValue, labelInValue, onChange, maxCount, classNames, styles, ...restProps } = props;
    const searchProps = {
        searchValue: legacySearchValue,
        onSearch: legacyOnSearch,
        autoClearSearchValue: legacyAutoClearSearchValue,
        filterOption: legacyFilterOption,
        optionFilterProp: legacyOptionFilterProp,
        filterSort: legacyFilterSort
    };
    const [mergedShowSearch, searchConfig] = (0, _useSearchConfig.default)(showSearch, searchProps);
    const { filterOption, searchValue, optionFilterProp, filterSort, onSearch, autoClearSearchValue = true } = searchConfig;
    const mergedId = (0, _useId.default)(id);
    const multiple = (0, _BaseSelect.isMultiple)(mode);
    const childrenAsData = !!(!options && children);
    const mergedFilterOption = _react.useMemo(()=>{
        if (filterOption === undefined && mode === 'combobox') return false;
        return filterOption;
    }, [
        filterOption,
        mode
    ]);
    // ========================= FieldNames =========================
    const mergedFieldNames = _react.useMemo(()=>(0, _valueUtil.fillFieldNames)(fieldNames, childrenAsData), /* eslint-disable react-hooks/exhaustive-deps */ [
        // We stringify fieldNames to avoid unnecessary re-renders.
        JSON.stringify(fieldNames),
        childrenAsData
    ]);
    // =========================== Search ===========================
    const [mergedSearchValue, setSearchValue] = (0, _useMergedState.default)('', {
        value: searchValue,
        postState: (search)=>search || ''
    });
    // =========================== Option ===========================
    const parsedOptions = (0, _useOptions.default)(options, children, mergedFieldNames, optionFilterProp, optionLabelProp);
    const { valueOptions, labelOptions, options: mergedOptions } = parsedOptions;
    // ========================= Wrap Value =========================
    const convert2LabelValues = _react.useCallback((draftValues)=>{
        // Convert to array
        const valueList = (0, _commonUtil.toArray)(draftValues);
        // Convert to labelInValue type
        return valueList.map((val)=>{
            let rawValue;
            let rawLabel;
            let rawDisabled;
            let rawTitle;
            // Fill label & value
            if (isRawValue(val)) rawValue = val;
            else {
                rawLabel = val.label;
                rawValue = val.value;
            }
            const option = valueOptions.get(rawValue);
            if (option) {
                // Fill missing props
                if (rawLabel === undefined) rawLabel = option === null || option === void 0 ? void 0 : option[optionLabelProp || mergedFieldNames.label];
                rawDisabled = option === null || option === void 0 ? void 0 : option.disabled;
                rawTitle = option === null || option === void 0 ? void 0 : option.title;
                // Warning if label not same as provided
                if (!optionLabelProp) {
                    const optionLabel = option === null || option === void 0 ? void 0 : option[mergedFieldNames.label];
                    if (optionLabel !== undefined && !/*#__PURE__*/ _react.isValidElement(optionLabel) && !/*#__PURE__*/ _react.isValidElement(rawLabel) && optionLabel !== rawLabel) (0, _warning.default)(false, '`label` of `value` is not same as `label` in Select options.');
                }
            }
            return {
                label: rawLabel,
                value: rawValue,
                key: rawValue,
                disabled: rawDisabled,
                title: rawTitle
            };
        });
    }, [
        mergedFieldNames,
        optionLabelProp,
        valueOptions
    ]);
    // =========================== Values ===========================
    const [internalValue, setInternalValue] = (0, _useMergedState.default)(defaultValue, {
        value
    });
    // Merged value with LabelValueType
    const rawLabeledValues = _react.useMemo(()=>{
        var _values_;
        const newInternalValue = multiple && internalValue === null ? [] : internalValue;
        const values = convert2LabelValues(newInternalValue);
        // combobox no need save value when it's no value (exclude value equal 0)
        if (mode === 'combobox' && (0, _commonUtil.isComboNoValue)((_values_ = values[0]) === null || _values_ === void 0 ? void 0 : _values_.value)) return [];
        return values;
    }, [
        internalValue,
        convert2LabelValues,
        mode,
        multiple
    ]);
    // Fill label with cache to avoid option remove
    const [mergedValues, getMixedOption] = (0, _useCache.default)(rawLabeledValues, valueOptions);
    const displayValues = _react.useMemo(()=>{
        // `null` need show as placeholder instead
        // https://github.com/ant-design/ant-design/issues/25057
        if (!mode && mergedValues.length === 1) {
            const firstValue = mergedValues[0];
            if (firstValue.value === null && (firstValue.label === null || firstValue.label === undefined)) return [];
        }
        return mergedValues.map((item)=>({
                ...item,
                label: (typeof labelRender === 'function' ? labelRender(item) : item.label) ?? item.value
            }));
    }, [
        mode,
        mergedValues,
        labelRender
    ]);
    /** Convert `displayValues` to raw value type set */ const rawValues = _react.useMemo(()=>new Set(mergedValues.map((val)=>val.value)), [
        mergedValues
    ]);
    _react.useEffect(()=>{
        if (mode === 'combobox') {
            var _mergedValues_;
            const strValue = (_mergedValues_ = mergedValues[0]) === null || _mergedValues_ === void 0 ? void 0 : _mergedValues_.value;
            setSearchValue((0, _commonUtil.hasValue)(strValue) ? String(strValue) : '');
        }
    }, [
        mergedValues
    ]);
    // ======================= Display Option =======================
    // Create a placeholder item if not exist in `options`
    const createTagOption = (0, _useRefFunc.default)((val, label)=>{
        const mergedLabel = label ?? val;
        return {
            [mergedFieldNames.value]: val,
            [mergedFieldNames.label]: mergedLabel
        };
    });
    // Fill tag as option if mode is `tags`
    const filledTagOptions = _react.useMemo(()=>{
        if (mode !== 'tags') return mergedOptions;
        // >>> Tag mode
        const cloneOptions = [
            ...mergedOptions
        ];
        // Check if value exist in options (include new patch item)
        const existOptions = (val)=>valueOptions.has(val);
        // Fill current value as option
        [
            ...mergedValues
        ].sort((a, b)=>a.value < b.value ? -1 : 1).forEach((item)=>{
            const val = item.value;
            if (!existOptions(val)) cloneOptions.push(createTagOption(val, item.label));
        });
        return cloneOptions;
    }, [
        createTagOption,
        mergedOptions,
        valueOptions,
        mergedValues,
        mode
    ]);
    const filteredOptions = (0, _useFilterOptions.default)(filledTagOptions, mergedFieldNames, mergedSearchValue, mergedFilterOption, optionFilterProp);
    // Fill options with search value if needed
    const filledSearchOptions = _react.useMemo(()=>{
        if (mode !== 'tags' || !mergedSearchValue || filteredOptions.some((item)=>item[optionFilterProp || 'value'] === mergedSearchValue)) return filteredOptions;
        // ignore when search value equal select input value
        if (filteredOptions.some((item)=>item[mergedFieldNames.value] === mergedSearchValue)) return filteredOptions;
        // Fill search value as option
        return [
            createTagOption(mergedSearchValue),
            ...filteredOptions
        ];
    }, [
        createTagOption,
        optionFilterProp,
        mode,
        filteredOptions,
        mergedSearchValue,
        mergedFieldNames
    ]);
    const sorter = (inputOptions)=>{
        const sortedOptions = [
            ...inputOptions
        ].sort((a, b)=>filterSort(a, b, {
                searchValue: mergedSearchValue
            }));
        return sortedOptions.map((item)=>{
            if (Array.isArray(item.options)) return {
                ...item,
                options: item.options.length > 0 ? sorter(item.options) : item.options
            };
            return item;
        });
    };
    const orderedFilteredOptions = _react.useMemo(()=>{
        if (!filterSort) return filledSearchOptions;
        return sorter(filledSearchOptions);
    }, [
        filledSearchOptions,
        filterSort,
        mergedSearchValue
    ]);
    const displayOptions = _react.useMemo(()=>(0, _valueUtil.flattenOptions)(orderedFilteredOptions, {
            fieldNames: mergedFieldNames,
            childrenAsData
        }), [
        orderedFilteredOptions,
        mergedFieldNames,
        childrenAsData
    ]);
    // =========================== Change ===========================
    const triggerChange = (values)=>{
        const labeledValues = convert2LabelValues(values);
        setInternalValue(labeledValues);
        if (onChange && // Trigger event only when value changed
        (labeledValues.length !== mergedValues.length || labeledValues.some((newVal, index)=>{
            var _mergedValues_index;
            return ((_mergedValues_index = mergedValues[index]) === null || _mergedValues_index === void 0 ? void 0 : _mergedValues_index.value) !== (newVal === null || newVal === void 0 ? void 0 : newVal.value);
        }))) {
            const returnValues = labelInValue ? labeledValues.map(({ label: l, value: v })=>({
                    label: l,
                    value: v
                })) : labeledValues.map((v)=>v.value);
            const returnOptions = labeledValues.map((v)=>(0, _valueUtil.injectPropsWithOption)(getMixedOption(v.value)));
            onChange(// Value
            multiple ? returnValues : returnValues[0], // Option
            multiple ? returnOptions : returnOptions[0]);
        }
    };
    // ======================= Accessibility ========================
    const [activeValue, setActiveValue] = _react.useState(null);
    const [accessibilityIndex, setAccessibilityIndex] = _react.useState(0);
    const mergedDefaultActiveFirstOption = defaultActiveFirstOption !== undefined ? defaultActiveFirstOption : mode !== 'combobox';
    const activeEventRef = _react.useRef();
    const onActiveValue = _react.useCallback((active, index, { source = 'keyboard' } = {})=>{
        setAccessibilityIndex(index);
        if (backfill && mode === 'combobox' && active !== null && source === 'keyboard') setActiveValue(String(active));
        // Active will call multiple times.
        // We only need trigger the last one.
        const promise = Promise.resolve().then(()=>{
            if (activeEventRef.current === promise) onActive === null || onActive === void 0 || onActive(active);
        });
        activeEventRef.current = promise;
    }, [
        backfill,
        mode,
        onActive
    ]);
    // ========================= OptionList =========================
    const triggerSelect = (val, selected, type)=>{
        const getSelectEnt = ()=>{
            const option = getMixedOption(val);
            return [
                labelInValue ? {
                    label: option === null || option === void 0 ? void 0 : option[mergedFieldNames.label],
                    value: val
                } : val,
                (0, _valueUtil.injectPropsWithOption)(option)
            ];
        };
        if (selected && onSelect) {
            const [wrappedValue, option] = getSelectEnt();
            onSelect(wrappedValue, option);
        } else if (!selected && onDeselect && type !== 'clear') {
            const [wrappedValue, option] = getSelectEnt();
            onDeselect(wrappedValue, option);
        }
    };
    // Used for OptionList selection
    const onInternalSelect = (0, _useRefFunc.default)((val, info)=>{
        let cloneValues;
        // Single mode always trigger select only with option list
        const mergedSelect = multiple ? info.selected : true;
        if (mergedSelect) cloneValues = multiple ? [
            ...mergedValues,
            val
        ] : [
            val
        ];
        else cloneValues = mergedValues.filter((v)=>v.value !== val);
        triggerChange(cloneValues);
        triggerSelect(val, mergedSelect);
        // Clean search value if single or configured
        if (mode === 'combobox') setActiveValue('');
        else if (!_BaseSelect.isMultiple || autoClearSearchValue) {
            setSearchValue('');
            setActiveValue('');
        }
    });
    // ======================= Display Change =======================
    // BaseSelect display values change
    const onDisplayValuesChange = (nextValues, info)=>{
        triggerChange(nextValues);
        const { type, values } = info;
        if (type === 'remove' || type === 'clear') values.forEach((item)=>{
            triggerSelect(item.value, false, type);
        });
    };
    // =========================== Search ===========================
    const onInternalSearch = (searchText, info)=>{
        setSearchValue(searchText);
        setActiveValue(null);
        // [Submit] Tag mode should flush input
        if (info.source === 'submit') {
            const formatted = (searchText || '').trim();
            // prevent empty tags from appearing when you click the Enter button
            if (formatted) {
                const newRawValues = Array.from(new Set([
                    ...rawValues,
                    formatted
                ]));
                triggerChange(newRawValues);
                triggerSelect(formatted, true);
                setSearchValue('');
            }
            return;
        }
        if (info.source !== 'blur') {
            if (mode === 'combobox') triggerChange(searchText);
            onSearch === null || onSearch === void 0 || onSearch(searchText);
        }
    };
    const onInternalSearchSplit = (words)=>{
        let patchValues = words;
        if (mode !== 'tags') patchValues = words.map((word)=>{
            const opt = labelOptions.get(word);
            return opt === null || opt === void 0 ? void 0 : opt.value;
        }).filter((val)=>val !== undefined);
        const newRawValues = Array.from(new Set([
            ...rawValues,
            ...patchValues
        ]));
        triggerChange(newRawValues);
        newRawValues.forEach((newRawValue)=>{
            triggerSelect(newRawValue, true);
        });
    };
    // ========================== Context ===========================
    const selectContext = _react.useMemo(()=>{
        const realVirtual = virtual !== false && popupMatchSelectWidth !== false;
        return {
            ...parsedOptions,
            flattenOptions: displayOptions,
            onActiveValue,
            defaultActiveFirstOption: mergedDefaultActiveFirstOption,
            onSelect: onInternalSelect,
            menuItemSelectedIcon,
            rawValues,
            fieldNames: mergedFieldNames,
            virtual: realVirtual,
            direction,
            listHeight,
            listItemHeight,
            childrenAsData,
            maxCount,
            optionRender,
            classNames,
            styles
        };
    }, [
        maxCount,
        parsedOptions,
        displayOptions,
        onActiveValue,
        mergedDefaultActiveFirstOption,
        onInternalSelect,
        menuItemSelectedIcon,
        rawValues,
        mergedFieldNames,
        virtual,
        popupMatchSelectWidth,
        direction,
        listHeight,
        listItemHeight,
        childrenAsData,
        optionRender,
        classNames,
        styles
    ]);
    (0, _warningPropsUtil.default)(props);
    (0, _warningPropsUtil.warningNullOptions)(mergedOptions, mergedFieldNames);
    // ==============================================================
    // ==                          Render                          ==
    // ==============================================================
    return /*#__PURE__*/ _react.createElement(_SelectContext.default.Provider, {
        value: selectContext
    }, /*#__PURE__*/ _react.createElement(_BaseSelect.default, _extends({}, restProps, {
        // >>> MISC
        id: mergedId,
        prefixCls: prefixCls,
        ref: ref,
        omitDomProps: OMIT_DOM_PROPS,
        mode: mode,
        classNames: classNames,
        styles: styles,
        displayValues: displayValues,
        onDisplayValuesChange: onDisplayValuesChange,
        maxCount: maxCount,
        direction: direction,
        showSearch: mergedShowSearch,
        searchValue: mergedSearchValue,
        onSearch: onInternalSearch,
        autoClearSearchValue: autoClearSearchValue,
        onSearchSplit: onInternalSearchSplit,
        popupMatchSelectWidth: popupMatchSelectWidth,
        OptionList: _OptionList.default,
        emptyOptions: !displayOptions.length,
        activeValue: activeValue,
        activeDescendantId: `${mergedId}_list_${accessibilityIndex}`
    })));
});
Select.displayName = 'Select';
const TypedSelect = Select;
TypedSelect.Option = _Option.default;
TypedSelect.OptGroup = _OptGroup.default;
var _default = TypedSelect;

},
"node_modules/@rc-component/select/es/SelectContext.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
// Use any here since we do not get the type during compilation
/**
 * SelectContext is only used for Select. BaseSelect should not consume this context.
 */ const SelectContext = /*#__PURE__*/ _react.createContext(null);
var _default = SelectContext;

},
"node_modules/@rc-component/select/es/SelectTrigger.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _trigger = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/trigger/es/index.js"));
var _classnames = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/classnames/index.js"));
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
const getBuiltInPlacements = (popupMatchSelectWidth)=>{
    // Enable horizontal overflow auto-adjustment when a custom dropdown width is provided
    const adjustX = popupMatchSelectWidth === true ? 0 : 1;
    return {
        bottomLeft: {
            points: [
                'tl',
                'bl'
            ],
            offset: [
                0,
                4
            ],
            overflow: {
                adjustX,
                adjustY: 1
            },
            htmlRegion: 'scroll'
        },
        bottomRight: {
            points: [
                'tr',
                'br'
            ],
            offset: [
                0,
                4
            ],
            overflow: {
                adjustX,
                adjustY: 1
            },
            htmlRegion: 'scroll'
        },
        topLeft: {
            points: [
                'bl',
                'tl'
            ],
            offset: [
                0,
                -4
            ],
            overflow: {
                adjustX,
                adjustY: 1
            },
            htmlRegion: 'scroll'
        },
        topRight: {
            points: [
                'br',
                'tr'
            ],
            offset: [
                0,
                -4
            ],
            overflow: {
                adjustX,
                adjustY: 1
            },
            htmlRegion: 'scroll'
        }
    };
};
const SelectTrigger = (props, ref)=>{
    const { prefixCls, disabled, visible, children, popupElement, animation, transitionName, popupStyle, popupClassName, direction = 'ltr', placement, builtinPlacements, popupMatchSelectWidth, popupRender, popupAlign, getPopupContainer, empty, onPopupVisibleChange, onPopupMouseEnter, ...restProps } = props;
    // We still use `dropdown` className to keep compatibility
    // This is used for:
    // 1. Styles
    // 2. Animation
    // 3. Theme customization
    // Please do not modify this since it's a breaking change
    const popupPrefixCls = `${prefixCls}-dropdown`;
    let popupNode = popupElement;
    if (popupRender) popupNode = popupRender(popupElement);
    const mergedBuiltinPlacements = _react.useMemo(()=>builtinPlacements || getBuiltInPlacements(popupMatchSelectWidth), [
        builtinPlacements,
        popupMatchSelectWidth
    ]);
    // ===================== Motion ======================
    const mergedTransitionName = animation ? `${popupPrefixCls}-${animation}` : transitionName;
    // =================== Popup Width ===================
    const isNumberPopupWidth = typeof popupMatchSelectWidth === 'number';
    const stretch = _react.useMemo(()=>{
        if (isNumberPopupWidth) return null;
        return popupMatchSelectWidth === false ? 'minWidth' : 'width';
    }, [
        popupMatchSelectWidth,
        isNumberPopupWidth
    ]);
    let mergedPopupStyle = popupStyle;
    if (isNumberPopupWidth) mergedPopupStyle = {
        ...popupStyle,
        width: popupMatchSelectWidth
    };
    // ======================= Ref =======================
    const triggerPopupRef = _react.useRef(null);
    _react.useImperativeHandle(ref, ()=>({
            getPopupElement: ()=>{
                var _triggerPopupRef_current;
                return (_triggerPopupRef_current = triggerPopupRef.current) === null || _triggerPopupRef_current === void 0 ? void 0 : _triggerPopupRef_current.popupElement;
            }
        }));
    return /*#__PURE__*/ _react.createElement(_trigger.default, _extends({}, restProps, {
        showAction: onPopupVisibleChange ? [
            'click'
        ] : [],
        hideAction: onPopupVisibleChange ? [
            'click'
        ] : [],
        popupPlacement: placement || (direction === 'rtl' ? 'bottomRight' : 'bottomLeft'),
        builtinPlacements: mergedBuiltinPlacements,
        prefixCls: popupPrefixCls,
        popupMotion: {
            motionName: mergedTransitionName
        },
        popup: /*#__PURE__*/ _react.createElement("div", {
            onMouseEnter: onPopupMouseEnter
        }, popupNode),
        ref: triggerPopupRef,
        stretch: stretch,
        popupAlign: popupAlign,
        popupVisible: visible,
        getPopupContainer: getPopupContainer,
        popupClassName: (0, _classnames.default)(popupClassName, {
            [`${popupPrefixCls}-empty`]: empty
        }),
        popupStyle: mergedPopupStyle,
        onPopupVisibleChange: onPopupVisibleChange
    }), children);
};
const RefSelectTrigger = /*#__PURE__*/ _react.forwardRef(SelectTrigger);
RefSelectTrigger.displayName = 'SelectTrigger';
var _default = RefSelectTrigger;

},
"node_modules/@rc-component/select/es/Selector/Input.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
var _classnames = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/classnames/index.js"));
var _ref = __mako_require__("node_modules/@rc-component/util/es/ref.js");
var _warning = __mako_require__("node_modules/@rc-component/util/es/warning.js");
var _composeProps = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/composeProps.js"));
var _useBaseProps = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/select/es/hooks/useBaseProps.js"));
const Input = (props, ref)=>{
    const { prefixCls, id, inputElement, autoComplete, editable, activeDescendantId, value, open, attrs, ...restProps } = props;
    const { classNames: contextClassNames, styles: contextStyles } = (0, _useBaseProps.default)() || {};
    let inputNode = inputElement || /*#__PURE__*/ _react.createElement("input", null);
    const { ref: originRef, props: originProps } = inputNode;
    (0, _warning.warning)(!('maxLength' in inputNode.props), `Passing 'maxLength' to input element directly may not work because input in BaseSelect is controlled.`);
    inputNode = /*#__PURE__*/ _react.cloneElement(inputNode, {
        type: 'search',
        ...(0, _composeProps.default)(restProps, originProps, true),
        // Override over origin props
        id,
        ref: (0, _ref.composeRef)(ref, originRef),
        autoComplete: autoComplete || 'off',
        className: (0, _classnames.default)(`${prefixCls}-selection-search-input`, originProps.className, contextClassNames === null || contextClassNames === void 0 ? void 0 : contextClassNames.input),
        role: 'combobox',
        'aria-expanded': open || false,
        'aria-haspopup': 'listbox',
        'aria-owns': `${id}_list`,
        'aria-autocomplete': 'list',
        'aria-controls': `${id}_list`,
        'aria-activedescendant': open ? activeDescendantId : undefined,
        ...attrs,
        value: editable ? value : '',
        readOnly: !editable,
        unselectable: !editable ? 'on' : null,
        style: {
            ...originProps.style,
            opacity: editable ? null : 0,
            ...contextStyles === null || contextStyles === void 0 ? void 0 : contextStyles.input
        }
    });
    return inputNode;
};
const RefInput = /*#__PURE__*/ _react.forwardRef(Input);
RefInput.displayName = 'Input';
var _default = RefInput;

},
"node_modules/@rc-component/select/es/Selector/MultipleSelector.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
var _classnames = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/classnames/index.js"));
var _pickAttrs = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/pickAttrs.js"));
var _rcoverflow = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/rc-overflow/es/index.js"));
var _TransBtn = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/select/es/TransBtn.js"));
var _Input = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/select/es/Selector/Input.js"));
var _useLayoutEffect = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/select/es/hooks/useLayoutEffect.js"));
var _commonUtil = __mako_require__("node_modules/@rc-component/select/es/utils/commonUtil.js");
function itemKey(value) {
    return value.key ?? value.value;
}
const onPreventMouseDown = (event)=>{
    event.preventDefault();
    event.stopPropagation();
};
const SelectSelector = (props)=>{
    const { id, prefixCls, values, open, searchValue, autoClearSearchValue, inputRef, placeholder, disabled, mode, showSearch, autoFocus, autoComplete, activeDescendantId, tabIndex, removeIcon, maxTagCount, maxTagTextLength, maxTagPlaceholder = (omittedValues)=>`+ ${omittedValues.length} ...`, tagRender, onToggleOpen, onRemove, onInputChange, onInputPaste, onInputKeyDown, onInputMouseDown, onInputCompositionStart, onInputCompositionEnd, onInputBlur } = props;
    const measureRef = _react.useRef(null);
    const [inputWidth, setInputWidth] = (0, _react.useState)(0);
    const [focused, setFocused] = (0, _react.useState)(false);
    const selectionPrefixCls = `${prefixCls}-selection`;
    // ===================== Search ======================
    const inputValue = open || mode === 'multiple' && autoClearSearchValue === false || mode === 'tags' ? searchValue : '';
    const inputEditable = mode === 'tags' || mode === 'multiple' && autoClearSearchValue === false || showSearch && (open || focused);
    // We measure width and set to the input immediately
    (0, _useLayoutEffect.default)(()=>{
        setInputWidth(measureRef.current.scrollWidth);
    }, [
        inputValue
    ]);
    // ===================== Render ======================
    // >>> Render Selector Node. Includes Item & Rest
    const defaultRenderSelector = (item, content, itemDisabled, closable, onClose)=>/*#__PURE__*/ _react.createElement("span", {
            title: (0, _commonUtil.getTitle)(item),
            className: (0, _classnames.default)(`${selectionPrefixCls}-item`, {
                [`${selectionPrefixCls}-item-disabled`]: itemDisabled
            })
        }, /*#__PURE__*/ _react.createElement("span", {
            className: `${selectionPrefixCls}-item-content`
        }, content), closable && /*#__PURE__*/ _react.createElement(_TransBtn.default, {
            className: `${selectionPrefixCls}-item-remove`,
            onMouseDown: onPreventMouseDown,
            onClick: onClose,
            customizeIcon: removeIcon
        }, "\xD7"));
    const customizeRenderSelector = (value, content, itemDisabled, closable, onClose, isMaxTag, info)=>{
        const onMouseDown = (e)=>{
            onPreventMouseDown(e);
            onToggleOpen(!open);
        };
        return /*#__PURE__*/ _react.createElement("span", {
            onMouseDown: onMouseDown
        }, tagRender({
            label: content,
            value,
            index: info === null || info === void 0 ? void 0 : info.index,
            disabled: itemDisabled,
            closable,
            onClose,
            isMaxTag: !!isMaxTag
        }));
    };
    const renderItem = (valueItem, info)=>{
        const { disabled: itemDisabled, label, value } = valueItem;
        const closable = !disabled && !itemDisabled;
        let displayLabel = label;
        if (typeof maxTagTextLength === 'number') {
            if (typeof label === 'string' || typeof label === 'number') {
                const strLabel = String(displayLabel);
                if (strLabel.length > maxTagTextLength) displayLabel = `${strLabel.slice(0, maxTagTextLength)}...`;
            }
        }
        const onClose = (event)=>{
            if (event) event.stopPropagation();
            onRemove(valueItem);
        };
        return typeof tagRender === 'function' ? customizeRenderSelector(value, displayLabel, itemDisabled, closable, onClose, undefined, info) : defaultRenderSelector(valueItem, displayLabel, itemDisabled, closable, onClose);
    };
    const renderRest = (omittedValues)=>{
        // https://github.com/ant-design/ant-design/issues/48930
        if (!values.length) return null;
        const content = typeof maxTagPlaceholder === 'function' ? maxTagPlaceholder(omittedValues) : maxTagPlaceholder;
        return typeof tagRender === 'function' ? customizeRenderSelector(undefined, content, false, false, undefined, true) : defaultRenderSelector({
            title: content
        }, content, false);
    };
    // >>> Input Node
    const inputNode = /*#__PURE__*/ _react.createElement("div", {
        className: `${selectionPrefixCls}-search`,
        style: {
            width: inputWidth
        },
        onFocus: ()=>{
            setFocused(true);
        },
        onBlur: ()=>{
            setFocused(false);
        }
    }, /*#__PURE__*/ _react.createElement(_Input.default, {
        ref: inputRef,
        open: open,
        prefixCls: prefixCls,
        id: id,
        inputElement: null,
        disabled: disabled,
        autoFocus: autoFocus,
        autoComplete: autoComplete,
        editable: inputEditable,
        activeDescendantId: activeDescendantId,
        value: inputValue,
        onKeyDown: onInputKeyDown,
        onMouseDown: onInputMouseDown,
        onChange: onInputChange,
        onPaste: onInputPaste,
        onCompositionStart: onInputCompositionStart,
        onCompositionEnd: onInputCompositionEnd,
        onBlur: onInputBlur,
        tabIndex: tabIndex,
        attrs: (0, _pickAttrs.default)(props, true)
    }), /*#__PURE__*/ _react.createElement("span", {
        ref: measureRef,
        className: `${selectionPrefixCls}-search-mirror`,
        "aria-hidden": true
    }, inputValue, "\xA0"));
    // >>> Selections
    const selectionNode = /*#__PURE__*/ _react.createElement(_rcoverflow.default, {
        prefixCls: `${selectionPrefixCls}-overflow`,
        data: values,
        renderItem: renderItem,
        renderRest: renderRest,
        suffix: inputNode,
        itemKey: itemKey,
        maxCount: maxTagCount
    });
    return /*#__PURE__*/ _react.createElement("span", {
        className: `${selectionPrefixCls}-wrap`
    }, selectionNode, !values.length && !inputValue && /*#__PURE__*/ _react.createElement("span", {
        className: `${selectionPrefixCls}-placeholder`
    }, placeholder));
};
var _default = SelectSelector;

},
"node_modules/@rc-component/select/es/Selector/SingleSelector.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
var _pickAttrs = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/pickAttrs.js"));
var _Input = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/select/es/Selector/Input.js"));
var _commonUtil = __mako_require__("node_modules/@rc-component/select/es/utils/commonUtil.js");
const SingleSelector = (props)=>{
    const { inputElement, prefixCls, id, inputRef, disabled, autoFocus, autoComplete, activeDescendantId, mode, open, values, placeholder, tabIndex, showSearch, searchValue, activeValue, maxLength, onInputKeyDown, onInputMouseDown, onInputChange, onInputPaste, onInputCompositionStart, onInputCompositionEnd, onInputBlur, title } = props;
    const [inputChanged, setInputChanged] = _react.useState(false);
    const combobox = mode === 'combobox';
    const inputEditable = combobox || showSearch;
    const item = values[0];
    let inputValue = searchValue || '';
    if (combobox && activeValue && !inputChanged) inputValue = activeValue;
    _react.useEffect(()=>{
        if (combobox) setInputChanged(false);
    }, [
        combobox,
        activeValue
    ]);
    // Not show text when closed expect combobox mode
    const hasTextInput = mode !== 'combobox' && !open && !showSearch ? false : !!inputValue;
    // Get title of selection item
    const selectionTitle = title === undefined ? (0, _commonUtil.getTitle)(item) : title;
    const placeholderNode = _react.useMemo(()=>{
        if (item) return null;
        return /*#__PURE__*/ _react.createElement("span", {
            className: `${prefixCls}-selection-placeholder`,
            style: hasTextInput ? {
                visibility: 'hidden'
            } : undefined
        }, placeholder);
    }, [
        item,
        hasTextInput,
        placeholder,
        prefixCls
    ]);
    return /*#__PURE__*/ _react.createElement("span", {
        className: `${prefixCls}-selection-wrap`
    }, /*#__PURE__*/ _react.createElement("span", {
        className: `${prefixCls}-selection-search`
    }, /*#__PURE__*/ _react.createElement(_Input.default, {
        ref: inputRef,
        prefixCls: prefixCls,
        id: id,
        open: open,
        inputElement: inputElement,
        disabled: disabled,
        autoFocus: autoFocus,
        autoComplete: autoComplete,
        editable: inputEditable,
        activeDescendantId: activeDescendantId,
        value: inputValue,
        onKeyDown: onInputKeyDown,
        onMouseDown: onInputMouseDown,
        onChange: (e)=>{
            setInputChanged(true);
            onInputChange(e);
        },
        onPaste: onInputPaste,
        onCompositionStart: onInputCompositionStart,
        onCompositionEnd: onInputCompositionEnd,
        onBlur: onInputBlur,
        tabIndex: tabIndex,
        attrs: (0, _pickAttrs.default)(props, true),
        maxLength: combobox ? maxLength : undefined
    })), !combobox && item ? /*#__PURE__*/ _react.createElement("span", {
        className: `${prefixCls}-selection-item`,
        title: selectionTitle,
        style: hasTextInput ? {
            visibility: 'hidden'
        } : undefined
    }, item.label) : null, placeholderNode);
};
var _default = SingleSelector;

},
"node_modules/@rc-component/select/es/Selector/index.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _KeyCode = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/KeyCode.js"));
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
var _useLock = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/select/es/hooks/useLock.js"));
var _keyUtil = __mako_require__("node_modules/@rc-component/select/es/utils/keyUtil.js");
var _MultipleSelector = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/select/es/Selector/MultipleSelector.js"));
var _SingleSelector = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/select/es/Selector/SingleSelector.js"));
var _classnames = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/classnames/index.js"));
function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
const Selector = (props, ref)=>{
    const inputRef = (0, _react.useRef)(null);
    const compositionStatusRef = (0, _react.useRef)(false);
    const { prefixClassName, prefixStyle, prefixCls, open, mode, showSearch, tokenWithEnter, disabled, prefix, autoClearSearchValue, onSearch, onSearchSubmit, onToggleOpen, onInputKeyDown, onInputBlur } = props;
    // ======================= Ref =======================
    const containerRef = _react.useRef(null);
    _react.useImperativeHandle(ref, ()=>({
            focus: (options)=>{
                inputRef.current.focus(options);
            },
            blur: ()=>{
                inputRef.current.blur();
            },
            nativeElement: containerRef.current
        }));
    // ====================== Input ======================
    const [getInputMouseDown, setInputMouseDown] = (0, _useLock.default)(0);
    const onInternalInputKeyDown = (event)=>{
        const { which } = event;
        // Compatible with multiple lines in TextArea
        const isTextAreaElement = inputRef.current instanceof HTMLTextAreaElement;
        if (!isTextAreaElement && open && (which === _KeyCode.default.UP || which === _KeyCode.default.DOWN)) event.preventDefault();
        if (onInputKeyDown) onInputKeyDown(event);
        if (which === _KeyCode.default.ENTER && mode === 'tags' && !compositionStatusRef.current && !open) // When menu isn't open, OptionList won't trigger a value change
        // So when enter is pressed, the tag's input value should be emitted here to let selector know
        onSearchSubmit === null || onSearchSubmit === void 0 || onSearchSubmit(event.target.value);
        // Move within the text box
        if (isTextAreaElement && !open && ~[
            _KeyCode.default.UP,
            _KeyCode.default.DOWN,
            _KeyCode.default.LEFT,
            _KeyCode.default.RIGHT
        ].indexOf(which)) return;
        if ((0, _keyUtil.isValidateOpenKey)(which)) onToggleOpen(true);
    };
    /**
   * We can not use `findDOMNode` sine it will get warning,
   * have to use timer to check if is input element.
   */ const onInternalInputMouseDown = ()=>{
        setInputMouseDown(true);
    };
    // When paste come, ignore next onChange
    const pastedTextRef = (0, _react.useRef)(null);
    const triggerOnSearch = (value)=>{
        if (onSearch(value, true, compositionStatusRef.current) !== false) onToggleOpen(true);
    };
    const onInputCompositionStart = ()=>{
        compositionStatusRef.current = true;
    };
    const onInputCompositionEnd = (e)=>{
        compositionStatusRef.current = false;
        // Trigger search again to support `tokenSeparators` with typewriting
        if (mode !== 'combobox') triggerOnSearch(e.target.value);
    };
    const onInputChange = (event)=>{
        let { target: { value } } = event;
        // Pasted text should replace back to origin content
        if (tokenWithEnter && pastedTextRef.current && /[\r\n]/.test(pastedTextRef.current)) {
            // CRLF will be treated as a single space for input element
            const replacedText = pastedTextRef.current.replace(/[\r\n]+$/, '').replace(/\r\n/g, ' ').replace(/[\r\n]/g, ' ');
            value = value.replace(replacedText, pastedTextRef.current);
        }
        pastedTextRef.current = null;
        triggerOnSearch(value);
    };
    const onInputPaste = (e)=>{
        const { clipboardData } = e;
        const value = clipboardData === null || clipboardData === void 0 ? void 0 : clipboardData.getData('text');
        pastedTextRef.current = value || '';
    };
    const onClick = ({ target })=>{
        if (target !== inputRef.current) {
            // Should focus input if click the selector
            const isIE = document.body.style.msTouchAction !== undefined;
            if (isIE) setTimeout(()=>{
                inputRef.current.focus();
            });
            else inputRef.current.focus();
        }
    };
    const onMouseDown = (event)=>{
        const inputMouseDown = getInputMouseDown();
        // when mode is combobox and it is disabled, don't prevent default behavior
        // https://github.com/ant-design/ant-design/issues/37320
        // https://github.com/ant-design/ant-design/issues/48281
        if (event.target !== inputRef.current && !inputMouseDown && !(mode === 'combobox' && disabled)) event.preventDefault();
        if (mode !== 'combobox' && (!showSearch || !inputMouseDown) || !open) {
            if (open && autoClearSearchValue !== false) onSearch('', true, false);
            onToggleOpen();
        }
    };
    // ================= Inner Selector ==================
    const sharedProps = {
        inputRef,
        onInputKeyDown: onInternalInputKeyDown,
        onInputMouseDown: onInternalInputMouseDown,
        onInputChange,
        onInputPaste,
        onInputCompositionStart,
        onInputCompositionEnd,
        onInputBlur
    };
    const selectNode = mode === 'multiple' || mode === 'tags' ? /*#__PURE__*/ _react.createElement(_MultipleSelector.default, _extends({}, props, sharedProps)) : /*#__PURE__*/ _react.createElement(_SingleSelector.default, _extends({}, props, sharedProps));
    return /*#__PURE__*/ _react.createElement("div", {
        ref: containerRef,
        className: `${prefixCls}-selector`,
        onClick: onClick,
        onMouseDown: onMouseDown
    }, prefix && /*#__PURE__*/ _react.createElement("div", {
        className: (0, _classnames.default)(`${prefixCls}-prefix`, prefixClassName),
        style: prefixStyle
    }, prefix), selectNode);
};
const ForwardSelector = /*#__PURE__*/ _react.forwardRef(Selector);
ForwardSelector.displayName = 'Selector';
var _default = ForwardSelector;

},
"node_modules/@rc-component/select/es/TransBtn.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
var _classnames = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/classnames/index.js"));
const TransBtn = (props)=>{
    const { className, style, customizeIcon, customizeIconProps, children, onMouseDown, onClick } = props;
    const icon = typeof customizeIcon === 'function' ? customizeIcon(customizeIconProps) : customizeIcon;
    return /*#__PURE__*/ _react.createElement("span", {
        className: className,
        onMouseDown: (event)=>{
            event.preventDefault();
            onMouseDown === null || onMouseDown === void 0 || onMouseDown(event);
        },
        style: {
            userSelect: 'none',
            WebkitUserSelect: 'none',
            ...style
        },
        unselectable: "on",
        onClick: onClick,
        "aria-hidden": true
    }, icon !== undefined ? icon : /*#__PURE__*/ _react.createElement("span", {
        className: (0, _classnames.default)(className.split(/\s+/).map((cls)=>`${cls}-icon`))
    }, children));
};
var _default = TransBtn;

},
"node_modules/@rc-component/select/es/hooks/useAllowClear.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "useAllowClear", {
    enumerable: true,
    get: function() {
        return useAllowClear;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _TransBtn = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/select/es/TransBtn.js"));
var _react = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/react/index.js"));
const useAllowClear = (prefixCls, onClearMouseDown, displayValues, allowClear, clearIcon, disabled = false, mergedSearchValue, mode)=>{
    const mergedClearIcon = _react.default.useMemo(()=>{
        if (typeof allowClear === 'object') return allowClear.clearIcon;
        if (clearIcon) return clearIcon;
    }, [
        allowClear,
        clearIcon
    ]);
    const mergedAllowClear = _react.default.useMemo(()=>{
        if (!disabled && !!allowClear && (displayValues.length || mergedSearchValue) && !(mode === 'combobox' && mergedSearchValue === '')) return true;
        return false;
    }, [
        allowClear,
        disabled,
        displayValues.length,
        mergedSearchValue,
        mode
    ]);
    return {
        allowClear: mergedAllowClear,
        clearIcon: /*#__PURE__*/ _react.default.createElement(_TransBtn.default, {
            className: `${prefixCls}-clear`,
            onMouseDown: onClearMouseDown,
            customizeIcon: mergedClearIcon
        }, "\xD7")
    };
};

},
"node_modules/@rc-component/select/es/hooks/useBaseProps.js": function (module, exports, __mako_require__){
/**
 * BaseSelect provide some parsed data into context.
 * You can use this hooks to get them.
 */ "use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    BaseSelectContext: function() {
        return BaseSelectContext;
    },
    default: function() {
        return useBaseProps;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
const BaseSelectContext = /*#__PURE__*/ _react.createContext(null);
function useBaseProps() {
    return _react.useContext(BaseSelectContext);
}

},
"node_modules/@rc-component/select/es/hooks/useCache.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, /**
 * Cache `value` related LabeledValue & options.
 */ "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
var _default = (labeledValues, valueOptions)=>{
    const cacheRef = _react.useRef({
        values: new Map(),
        options: new Map()
    });
    const filledLabeledValues = _react.useMemo(()=>{
        const { values: prevValueCache, options: prevOptionCache } = cacheRef.current;
        // Fill label by cache
        const patchedValues = labeledValues.map((item)=>{
            if (item.label === undefined) {
                var _prevValueCache_get;
                return {
                    ...item,
                    label: (_prevValueCache_get = prevValueCache.get(item.value)) === null || _prevValueCache_get === void 0 ? void 0 : _prevValueCache_get.label
                };
            }
            return item;
        });
        // Refresh cache
        const valueCache = new Map();
        const optionCache = new Map();
        patchedValues.forEach((item)=>{
            valueCache.set(item.value, item);
            optionCache.set(item.value, valueOptions.get(item.value) || prevOptionCache.get(item.value));
        });
        cacheRef.current.values = valueCache;
        cacheRef.current.options = optionCache;
        return patchedValues;
    }, [
        labeledValues,
        valueOptions
    ]);
    const getOption = _react.useCallback((val)=>valueOptions.get(val) || cacheRef.current.options.get(val), [
        valueOptions
    ]);
    return [
        filledLabeledValues,
        getOption
    ];
};

},
"node_modules/@rc-component/select/es/hooks/useDelayReset.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, /**
 * Similar with `useLock`, but this hook will always execute last value.
 * When set to `true`, it will keep `true` for a short time even if `false` is set.
 */ "default", {
    enumerable: true,
    get: function() {
        return useDelayReset;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
function useDelayReset(timeout = 10) {
    const [bool, setBool] = _react.useState(false);
    const delayRef = _react.useRef(null);
    const cancelLatest = ()=>{
        window.clearTimeout(delayRef.current);
    };
    _react.useEffect(()=>cancelLatest, []);
    const delaySetBool = (value, callback)=>{
        cancelLatest();
        delayRef.current = window.setTimeout(()=>{
            setBool(value);
            if (callback) callback();
        }, timeout);
    };
    return [
        bool,
        delaySetBool,
        cancelLatest
    ];
}

},
"node_modules/@rc-component/select/es/hooks/useFilterOptions.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
var _commonUtil = __mako_require__("node_modules/@rc-component/select/es/utils/commonUtil.js");
var _valueUtil = __mako_require__("node_modules/@rc-component/select/es/utils/valueUtil.js");
function includes(test, search) {
    return (0, _commonUtil.toArray)(test).join('').toUpperCase().includes(search);
}
var _default = (options, fieldNames, searchValue, filterOption, optionFilterProp)=>_react.useMemo(()=>{
        if (!searchValue || filterOption === false) return options;
        const { options: fieldOptions, label: fieldLabel, value: fieldValue } = fieldNames;
        const filteredOptions = [];
        const customizeFilter = typeof filterOption === 'function';
        const upperSearch = searchValue.toUpperCase();
        const filterFunc = customizeFilter ? filterOption : (_, option)=>{
            // Use provided `optionFilterProp`
            if (optionFilterProp) return includes(option[optionFilterProp], upperSearch);
            // Auto select `label` or `value` by option type
            if (option[fieldOptions]) // hack `fieldLabel` since `OptionGroup` children is not `label`
            return includes(option[fieldLabel !== 'children' ? fieldLabel : 'label'], upperSearch);
            return includes(option[fieldValue], upperSearch);
        };
        const wrapOption = customizeFilter ? (opt)=>(0, _valueUtil.injectPropsWithOption)(opt) : (opt)=>opt;
        options.forEach((item)=>{
            // Group should check child options
            if (item[fieldOptions]) {
                // Check group first
                const matchGroup = filterFunc(searchValue, wrapOption(item));
                if (matchGroup) filteredOptions.push(item);
                else {
                    // Check option
                    const subOptions = item[fieldOptions].filter((subItem)=>filterFunc(searchValue, wrapOption(subItem)));
                    if (subOptions.length) filteredOptions.push({
                        ...item,
                        [fieldOptions]: subOptions
                    });
                }
                return;
            }
            if (filterFunc(searchValue, wrapOption(item))) filteredOptions.push(item);
        });
        return filteredOptions;
    }, [
        options,
        filterOption,
        optionFilterProp,
        searchValue,
        fieldNames
    ]);

},
"node_modules/@rc-component/select/es/hooks/useLayoutEffect.js": function (module, exports, __mako_require__){
/* eslint-disable react-hooks/rules-of-hooks */ "use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, /**
 * Wrap `React.useLayoutEffect` which will not throw warning message in test env
 */ "default" /* eslint-enable */ , {
    enumerable: true,
    get: function() {
        return useLayoutEffect;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
var _commonUtil = __mako_require__("node_modules/@rc-component/select/es/utils/commonUtil.js");
function useLayoutEffect(effect, deps) {
    // Never happen in test env
    if (_commonUtil.isBrowserClient) /* istanbul ignore next */ _react.useLayoutEffect(effect, deps);
    else _react.useEffect(effect, deps);
}

},
"node_modules/@rc-component/select/es/hooks/useLock.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, /**
 * Locker return cached mark.
 * If set to `true`, will return `true` in a short time even if set `false`.
 * If set to `false` and then set to `true`, will change to `true`.
 * And after time duration, it will back to `null` automatically.
 */ "default", {
    enumerable: true,
    get: function() {
        return useLock;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
function useLock(duration = 250) {
    const lockRef = _react.useRef(null);
    const timeoutRef = _react.useRef(null);
    // Clean up
    _react.useEffect(()=>()=>{
            window.clearTimeout(timeoutRef.current);
        }, []);
    function doLock(locked) {
        if (locked || lockRef.current === null) lockRef.current = locked;
        window.clearTimeout(timeoutRef.current);
        timeoutRef.current = window.setTimeout(()=>{
            lockRef.current = null;
        }, duration);
    }
    return [
        ()=>lockRef.current,
        doLock
    ];
}

},
"node_modules/@rc-component/select/es/hooks/useOptions.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
var _legacyUtil = __mako_require__("node_modules/@rc-component/select/es/utils/legacyUtil.js");
/**
 * Parse `children` to `options` if `options` is not provided.
 * Then flatten the `options`.
 */ const useOptions = (options, children, fieldNames, optionFilterProp, optionLabelProp)=>{
    return _react.useMemo(()=>{
        let mergedOptions = options;
        const childrenAsData = !options;
        if (childrenAsData) mergedOptions = (0, _legacyUtil.convertChildrenToData)(children);
        const valueOptions = new Map();
        const labelOptions = new Map();
        const setLabelOptions = (labelOptionsMap, option, key)=>{
            if (key && typeof key === 'string') labelOptionsMap.set(option[key], option);
        };
        const dig = (optionList, isChildren = false)=>{
            // for loop to speed up collection speed
            for(let i = 0; i < optionList.length; i += 1){
                const option = optionList[i];
                if (!option[fieldNames.options] || isChildren) {
                    valueOptions.set(option[fieldNames.value], option);
                    setLabelOptions(labelOptions, option, fieldNames.label);
                    // https://github.com/ant-design/ant-design/issues/35304
                    setLabelOptions(labelOptions, option, optionFilterProp);
                    setLabelOptions(labelOptions, option, optionLabelProp);
                } else dig(option[fieldNames.options], true);
            }
        };
        dig(mergedOptions);
        return {
            options: mergedOptions,
            valueOptions,
            labelOptions
        };
    }, [
        options,
        children,
        fieldNames,
        optionFilterProp,
        optionLabelProp
    ]);
};
var _default = useOptions;

},
"node_modules/@rc-component/select/es/hooks/useRefFunc.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, /**
 * Same as `React.useCallback` but always return a memoized function
 * but redirect to real function.
 */ "default", {
    enumerable: true,
    get: function() {
        return useRefFunc;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
function useRefFunc(callback) {
    const funcRef = _react.useRef();
    funcRef.current = callback;
    const cacheFn = _react.useCallback((...args)=>{
        return funcRef.current(...args);
    }, []);
    return cacheFn;
}

},
"node_modules/@rc-component/select/es/hooks/useSearchConfig.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, // Convert `showSearch` to unique config
"default", {
    enumerable: true,
    get: function() {
        return useSearchConfig;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
function useSearchConfig(showSearch, props) {
    const { filterOption, searchValue, optionFilterProp, filterSort, onSearch, autoClearSearchValue } = props;
    return _react.useMemo(()=>{
        const isObject = typeof showSearch === 'object';
        const searchConfig = {
            filterOption,
            searchValue,
            optionFilterProp,
            filterSort,
            onSearch,
            autoClearSearchValue,
            ...isObject ? showSearch : {}
        };
        return [
            isObject ? true : showSearch,
            searchConfig
        ];
    }, [
        showSearch,
        filterOption,
        searchValue,
        optionFilterProp,
        filterSort,
        onSearch,
        autoClearSearchValue
    ]);
}

},
"node_modules/@rc-component/select/es/hooks/useSelectTriggerControl.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return useSelectTriggerControl;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
function useSelectTriggerControl(elements, open, triggerOpen, customizedTrigger) {
    const propsRef = _react.useRef(null);
    propsRef.current = {
        open,
        triggerOpen,
        customizedTrigger
    };
    _react.useEffect(()=>{
        function onGlobalMouseDown(event) {
            var _propsRef_current;
            // If trigger is customized, Trigger will take control of popupVisible
            if ((_propsRef_current = propsRef.current) === null || _propsRef_current === void 0 ? void 0 : _propsRef_current.customizedTrigger) return;
            let target = event.target;
            if (target.shadowRoot && event.composed) target = event.composedPath()[0] || target;
            if (propsRef.current.open && elements().filter((element)=>element).every((element)=>!element.contains(target) && element !== target)) // Should trigger close
            propsRef.current.triggerOpen(false);
        }
        window.addEventListener('mousedown', onGlobalMouseDown);
        return ()=>window.removeEventListener('mousedown', onGlobalMouseDown);
    }, []);
}

},
"node_modules/@rc-component/select/es/index.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    BaseSelect: function() {
        return _BaseSelect.default;
    },
    OptGroup: function() {
        return _OptGroup.default;
    },
    Option: function() {
        return _Option.default;
    },
    default: function() {
        return _default;
    },
    useBaseProps: function() {
        return _useBaseProps.default;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _Select = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/select/es/Select.js"));
var _Option = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/select/es/Option.js"));
var _OptGroup = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/select/es/OptGroup.js"));
var _BaseSelect = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/select/es/BaseSelect/index.js"));
var _useBaseProps = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/select/es/hooks/useBaseProps.js"));
var _default = _Select.default;

},
"node_modules/@rc-component/select/es/utils/commonUtil.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    getTitle: function() {
        return getTitle;
    },
    hasValue: function() {
        return hasValue;
    },
    isBrowserClient: function() {
        return isBrowserClient;
    },
    isClient: function() {
        return isClient;
    },
    isComboNoValue: function() {
        return isComboNoValue;
    },
    toArray: function() {
        return toArray;
    }
});
function toArray(value) {
    if (Array.isArray(value)) return value;
    return value !== undefined ? [
        value
    ] : [];
}
const isClient = typeof window !== 'undefined' && window.document && window.document.documentElement;
const isBrowserClient = isClient;
function hasValue(value) {
    return value !== undefined && value !== null;
}
function isComboNoValue(value) {
    return !value && value !== 0;
}
function isTitleType(title) {
    return [
        'string',
        'number'
    ].includes(typeof title);
}
function getTitle(item) {
    let title = undefined;
    if (item) {
        if (isTitleType(item.title)) title = item.title.toString();
        else if (isTitleType(item.label)) title = item.label.toString();
    }
    return title;
}

},
"node_modules/@rc-component/select/es/utils/keyUtil.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "isValidateOpenKey", {
    enumerable: true,
    get: function() {
        return isValidateOpenKey;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _KeyCode = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/KeyCode.js"));
function isValidateOpenKey(currentKeyCode) {
    return(// Undefined for Edge bug:
    // https://github.com/ant-design/ant-design/issues/51292
    currentKeyCode && // Other keys
    ![
        // System function button
        _KeyCode.default.ESC,
        _KeyCode.default.SHIFT,
        _KeyCode.default.BACKSPACE,
        _KeyCode.default.TAB,
        _KeyCode.default.WIN_KEY,
        _KeyCode.default.ALT,
        _KeyCode.default.META,
        _KeyCode.default.WIN_KEY_RIGHT,
        _KeyCode.default.CTRL,
        _KeyCode.default.SEMICOLON,
        _KeyCode.default.EQUALS,
        _KeyCode.default.CAPS_LOCK,
        _KeyCode.default.CONTEXT_MENU,
        // F1-F12
        _KeyCode.default.F1,
        _KeyCode.default.F2,
        _KeyCode.default.F3,
        _KeyCode.default.F4,
        _KeyCode.default.F5,
        _KeyCode.default.F6,
        _KeyCode.default.F7,
        _KeyCode.default.F8,
        _KeyCode.default.F9,
        _KeyCode.default.F10,
        _KeyCode.default.F11,
        _KeyCode.default.F12
    ].includes(currentKeyCode));
}

},
"node_modules/@rc-component/select/es/utils/legacyUtil.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "convertChildrenToData", {
    enumerable: true,
    get: function() {
        return convertChildrenToData;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
var _toArray = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/Children/toArray.js"));
function convertNodeToOption(node) {
    const { key, props: { children, value, ...restProps } } = node;
    return {
        key,
        value: value !== undefined ? value : key,
        children,
        ...restProps
    };
}
function convertChildrenToData(nodes, optionOnly = false) {
    return (0, _toArray.default)(nodes).map((node, index)=>{
        if (!/*#__PURE__*/ _react.isValidElement(node) || !node.type) return null;
        const { type: { isSelectOptGroup }, key, props: { children, ...restProps } } = node;
        if (optionOnly || !isSelectOptGroup) return convertNodeToOption(node);
        return {
            key: `__RC_SELECT_GRP__${key === null ? index : key}__`,
            label: key,
            ...restProps,
            options: convertChildrenToData(children)
        };
    }).filter((data)=>data);
}

},
"node_modules/@rc-component/select/es/utils/platformUtil.js": function (module, exports, __mako_require__){
/* istanbul ignore file */ "use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "isPlatformMac", {
    enumerable: true,
    get: function() {
        return isPlatformMac;
    }
});
function isPlatformMac() {
    return /(mac\sos|macintosh)/i.test(navigator.appVersion);
}

},
"node_modules/@rc-component/select/es/utils/valueUtil.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    fillFieldNames: function() {
        return fillFieldNames;
    },
    flattenOptions: function() {
        return flattenOptions;
    },
    getSeparatedContent: function() {
        return getSeparatedContent;
    },
    injectPropsWithOption: function() {
        return injectPropsWithOption;
    },
    isValidCount: function() {
        return isValidCount;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _warning = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/warning.js"));
function getKey(data, index) {
    const { key } = data;
    let value;
    if ('value' in data) ({ value } = data);
    if (key !== null && key !== undefined) return key;
    if (value !== undefined) return value;
    return `rc-index-key-${index}`;
}
function isValidCount(value) {
    return typeof value !== 'undefined' && !Number.isNaN(value);
}
function fillFieldNames(fieldNames, childrenAsData) {
    const { label, value, options, groupLabel } = fieldNames || {};
    const mergedLabel = label || (childrenAsData ? 'children' : 'label');
    return {
        label: mergedLabel,
        value: value || 'value',
        options: options || 'options',
        groupLabel: groupLabel || mergedLabel
    };
}
function flattenOptions(options, { fieldNames, childrenAsData } = {}) {
    const flattenList = [];
    const { label: fieldLabel, value: fieldValue, options: fieldOptions, groupLabel } = fillFieldNames(fieldNames, false);
    function dig(list, isGroupOption) {
        if (!Array.isArray(list)) return;
        list.forEach((data)=>{
            if (isGroupOption || !(fieldOptions in data)) {
                const value = data[fieldValue];
                // Option
                flattenList.push({
                    key: getKey(data, flattenList.length),
                    groupOption: isGroupOption,
                    data,
                    label: data[fieldLabel],
                    value
                });
            } else {
                let grpLabel = data[groupLabel];
                if (grpLabel === undefined && childrenAsData) grpLabel = data.label;
                // Option Group
                flattenList.push({
                    key: getKey(data, flattenList.length),
                    group: true,
                    data,
                    label: grpLabel
                });
                dig(data[fieldOptions], true);
            }
        });
    }
    dig(options, false);
    return flattenList;
}
function injectPropsWithOption(option) {
    const newOption = {
        ...option
    };
    if (!('props' in newOption)) Object.defineProperty(newOption, 'props', {
        get () {
            (0, _warning.default)(false, 'Return type is option instead of Option instance. Please read value directly instead of reading from `props`.');
            return newOption;
        }
    });
    return newOption;
}
const getSeparatedContent = (text, tokens, end)=>{
    if (!tokens || !tokens.length) return null;
    let match = false;
    const separate = (str, [token, ...restTokens])=>{
        if (!token) return [
            str
        ];
        const list = str.split(token);
        match = match || list.length > 1;
        return list.reduce((prevList, unitStr)=>[
                ...prevList,
                ...separate(unitStr, restTokens)
            ], []).filter(Boolean);
    };
    const list = separate(text, tokens);
    if (match) return typeof end !== 'undefined' ? list.slice(0, end) : list;
    else return null;
};

},
"node_modules/@rc-component/select/es/utils/warningPropsUtil.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    default: function() {
        return _default;
    },
    warningNullOptions: function() {
        return warningNullOptions;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _toArray = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/Children/toArray.js"));
var _warning = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/@rc-component/util/es/warning.js"));
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
var _BaseSelect = __mako_require__("node_modules/@rc-component/select/es/BaseSelect/index.js");
var _commonUtil = __mako_require__("node_modules/@rc-component/select/es/utils/commonUtil.js");
var _legacyUtil = __mako_require__("node_modules/@rc-component/select/es/utils/legacyUtil.js");
function warningProps(props) {
    const { mode, options, children, backfill, allowClear, placeholder, getInputElement, showSearch, onSearch, defaultOpen, autoFocus, labelInValue, value, optionLabelProp } = props;
    const multiple = (0, _BaseSelect.isMultiple)(mode);
    const mergedShowSearch = showSearch !== undefined ? showSearch : multiple || mode === 'combobox';
    const mergedOptions = options || (0, _legacyUtil.convertChildrenToData)(children);
    // `tags` should not set option as disabled
    (0, _warning.default)(mode !== 'tags' || mergedOptions.every((opt)=>!opt.disabled), 'Please avoid setting option to disabled in tags mode since user can always type text as tag.');
    // `combobox` & `tags` should option be `string` type
    if (mode === 'tags' || mode === 'combobox') {
        const hasNumberValue = mergedOptions.some((item)=>{
            if (item.options) return item.options.some((opt)=>typeof ('value' in opt ? opt.value : opt.key) === 'number');
            return typeof ('value' in item ? item.value : item.key) === 'number';
        });
        (0, _warning.default)(!hasNumberValue, '`value` of Option should not use number type when `mode` is `tags` or `combobox`.');
    }
    // `combobox` should not use `optionLabelProp`
    (0, _warning.default)(mode !== 'combobox' || !optionLabelProp, '`combobox` mode not support `optionLabelProp`. Please set `value` on Option directly.');
    // Only `combobox` support `backfill`
    (0, _warning.default)(mode === 'combobox' || !backfill, '`backfill` only works with `combobox` mode.');
    // Only `combobox` support `getInputElement`
    (0, _warning.default)(mode === 'combobox' || !getInputElement, '`getInputElement` only work with `combobox` mode.');
    // Customize `getInputElement` should not use `allowClear` & `placeholder`
    (0, _warning.noteOnce)(mode !== 'combobox' || !getInputElement || !allowClear || !placeholder, 'Customize `getInputElement` should customize clear and placeholder logic instead of configuring `allowClear` and `placeholder`.');
    // `onSearch` should use in `combobox` or `showSearch`
    if (onSearch && !mergedShowSearch && mode !== 'combobox' && mode !== 'tags') (0, _warning.default)(false, '`onSearch` should work with `showSearch` instead of use alone.');
    (0, _warning.noteOnce)(!defaultOpen || autoFocus, '`defaultOpen` makes Select open without focus which means it will not close by click outside. You can set `autoFocus` if needed.');
    if (value !== undefined && value !== null) {
        const values = (0, _commonUtil.toArray)(value);
        (0, _warning.default)(!labelInValue || values.every((val)=>typeof val === 'object' && ('key' in val || 'value' in val)), '`value` should in shape of `{ value: string | number, label?: ReactNode }` when you set `labelInValue` to `true`');
        (0, _warning.default)(!multiple || Array.isArray(value), '`value` should be array when `mode` is `multiple` or `tags`');
    }
    // Syntactic sugar should use correct children type
    if (children) {
        let invalidateChildType = null;
        (0, _toArray.default)(children).some((node)=>{
            if (!/*#__PURE__*/ _react.isValidElement(node) || !node.type) return false;
            const { type } = node;
            if (type.isSelectOption) return false;
            if (type.isSelectOptGroup) {
                const allChildrenValid = (0, _toArray.default)(node.props.children).every((subNode)=>{
                    if (!/*#__PURE__*/ _react.isValidElement(subNode) || !node.type || subNode.type.isSelectOption) return true;
                    invalidateChildType = subNode.type;
                    return false;
                });
                if (allChildrenValid) return false;
                return true;
            }
            invalidateChildType = type;
            return true;
        });
        if (invalidateChildType) (0, _warning.default)(false, `\`children\` should be \`Select.Option\` or \`Select.OptGroup\` instead of \`${invalidateChildType.displayName || invalidateChildType.name || invalidateChildType}\`.`);
    }
}
function warningNullOptions(options, fieldNames) {
    if (options) {
        const recursiveOptions = (optionsList, inGroup = false)=>{
            for(let i = 0; i < optionsList.length; i++){
                const option = optionsList[i];
                if (option[fieldNames === null || fieldNames === void 0 ? void 0 : fieldNames.value] === null) {
                    (0, _warning.default)(false, '`value` in Select options should not be `null`.');
                    return true;
                }
                if (!inGroup && Array.isArray(option[fieldNames === null || fieldNames === void 0 ? void 0 : fieldNames.options]) && recursiveOptions(option[fieldNames === null || fieldNames === void 0 ? void 0 : fieldNames.options], true)) break;
            }
        };
        recursiveOptions(options);
    }
}
var _default = warningProps;

},
"node_modules/@rc-component/trigger/es/Popup/Arrow.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return Arrow;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _classnames = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/classnames/index.js"));
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
function Arrow(props) {
    const { prefixCls, align, arrow, arrowPos } = props;
    const { className, content } = arrow || {};
    const { x = 0, y = 0 } = arrowPos;
    const arrowRef = _react.useRef(null);
    // Skip if no align
    if (!align || !align.points) return null;
    const alignStyle = {
        position: 'absolute'
    };
    // Skip if no need to align
    if (align.autoArrow !== false) {
        const popupPoints = align.points[0];
        const targetPoints = align.points[1];
        const popupTB = popupPoints[0];
        const popupLR = popupPoints[1];
        const targetTB = targetPoints[0];
        const targetLR = targetPoints[1];
        // Top & Bottom
        if (popupTB === targetTB || ![
            't',
            'b'
        ].includes(popupTB)) alignStyle.top = y;
        else if (popupTB === 't') alignStyle.top = 0;
        else alignStyle.bottom = 0;
        // Left & Right
        if (popupLR === targetLR || ![
            'l',
            'r'
        ].includes(popupLR)) alignStyle.left = x;
        else if (popupLR === 'l') alignStyle.left = 0;
        else alignStyle.right = 0;
    }
    return /*#__PURE__*/ _react.createElement("div", {
        ref: arrowRef,
        className: (0, _classnames.default)(`${prefixCls}-arrow`, className),
        style: alignStyle
    }, content);
}

},
"node_modules/@rc-component/trigger/es/Popup/Mask.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return Mask;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _classnames = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/classnames/index.js"));
var _motion = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/motion/es/index.js"));
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
function Mask(props) {
    const { prefixCls, open, zIndex, mask, motion, mobile } = props;
    if (!mask) return null;
    return /*#__PURE__*/ _react.createElement(_motion.default, _extends({}, motion, {
        motionAppear: true,
        visible: open,
        removeOnLeave: true
    }), ({ className })=>/*#__PURE__*/ _react.createElement("div", {
            style: {
                zIndex
            },
            className: (0, _classnames.default)(`${prefixCls}-mask`, mobile && `${prefixCls}-mobile-mask`, className)
        }));
}

},
"node_modules/@rc-component/trigger/es/Popup/PopupContent.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
const PopupContent = /*#__PURE__*/ _react.memo(({ children })=>children, (_, next)=>next.cache);
PopupContent.displayName = 'PopupContent';
var _default = PopupContent;

},
"node_modules/@rc-component/trigger/es/Popup/index.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _classnames = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/classnames/index.js"));
var _motion = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/motion/es/index.js"));
var _resizeobserver = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/resize-observer/es/index.js"));
var _useLayoutEffect = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/hooks/useLayoutEffect.js"));
var _ref = __mako_require__("node_modules/@rc-component/util/es/ref.js");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
var _Arrow = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/trigger/es/Popup/Arrow.js"));
var _Mask = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/trigger/es/Popup/Mask.js"));
var _PopupContent = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/trigger/es/Popup/PopupContent.js"));
function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
const Popup = /*#__PURE__*/ _react.forwardRef((props, ref)=>{
    const { popup, className, prefixCls, style, target, onVisibleChanged, // Open
    open, keepDom, fresh, // Click
    onClick, // Mask
    mask, // Arrow
    arrow, arrowPos, align, // Motion
    motion, maskMotion, // Mobile
    mobile, // Portal
    forceRender, getPopupContainer, autoDestroy, portal: Portal, zIndex, onMouseEnter, onMouseLeave, onPointerEnter, onPointerDownCapture, ready, offsetX, offsetY, offsetR, offsetB, onAlign, onPrepare, stretch, targetWidth, targetHeight } = props;
    const childNode = typeof popup === 'function' ? popup() : popup;
    // We can not remove holder only when motion finished.
    const isNodeVisible = open || keepDom;
    // ========================= Mobile =========================
    const isMobile = !!mobile;
    // ========================== Mask ==========================
    const [mergedMask, mergedMaskMotion, mergedPopupMotion] = _react.useMemo(()=>{
        if (mobile) return [
            mobile.mask,
            mobile.maskMotion,
            mobile.motion
        ];
        return [
            mask,
            maskMotion,
            motion
        ];
    }, [
        mobile
    ]);
    // ======================= Container ========================
    const getPopupContainerNeedParams = (getPopupContainer === null || getPopupContainer === void 0 ? void 0 : getPopupContainer.length) > 0;
    const [show, setShow] = _react.useState(!getPopupContainer || !getPopupContainerNeedParams);
    // Delay to show since `getPopupContainer` need target element
    (0, _useLayoutEffect.default)(()=>{
        if (!show && getPopupContainerNeedParams && target) setShow(true);
    }, [
        show,
        getPopupContainerNeedParams,
        target
    ]);
    // ========================= Render =========================
    if (!show) return null;
    // >>>>> Offset
    const AUTO = 'auto';
    const offsetStyle = isMobile ? {} : {
        left: '-1000vw',
        top: '-1000vh',
        right: AUTO,
        bottom: AUTO
    };
    // Set align style
    if (!isMobile && (ready || !open)) {
        var _align__experimental;
        const { points } = align;
        const dynamicInset = align.dynamicInset || ((_align__experimental = align._experimental) === null || _align__experimental === void 0 ? void 0 : _align__experimental.dynamicInset);
        const alignRight = dynamicInset && points[0][1] === 'r';
        const alignBottom = dynamicInset && points[0][0] === 'b';
        if (alignRight) {
            offsetStyle.right = offsetR;
            offsetStyle.left = AUTO;
        } else {
            offsetStyle.left = offsetX;
            offsetStyle.right = AUTO;
        }
        if (alignBottom) {
            offsetStyle.bottom = offsetB;
            offsetStyle.top = AUTO;
        } else {
            offsetStyle.top = offsetY;
            offsetStyle.bottom = AUTO;
        }
    }
    // >>>>> Misc
    const miscStyle = {};
    if (stretch) {
        if (stretch.includes('height') && targetHeight) miscStyle.height = targetHeight;
        else if (stretch.includes('minHeight') && targetHeight) miscStyle.minHeight = targetHeight;
        if (stretch.includes('width') && targetWidth) miscStyle.width = targetWidth;
        else if (stretch.includes('minWidth') && targetWidth) miscStyle.minWidth = targetWidth;
    }
    if (!open) miscStyle.pointerEvents = 'none';
    return /*#__PURE__*/ _react.createElement(Portal, {
        open: forceRender || isNodeVisible,
        getContainer: getPopupContainer && (()=>getPopupContainer(target)),
        autoDestroy: autoDestroy
    }, /*#__PURE__*/ _react.createElement(_Mask.default, {
        prefixCls: prefixCls,
        open: open,
        zIndex: zIndex,
        mask: mergedMask,
        motion: mergedMaskMotion,
        mobile: isMobile
    }), /*#__PURE__*/ _react.createElement(_resizeobserver.default, {
        onResize: onAlign,
        disabled: !open
    }, (resizeObserverRef)=>{
        return /*#__PURE__*/ _react.createElement(_motion.default, _extends({
            motionAppear: true,
            motionEnter: true,
            motionLeave: true,
            removeOnLeave: false,
            forceRender: forceRender,
            leavedClassName: `${prefixCls}-hidden`
        }, mergedPopupMotion, {
            onAppearPrepare: onPrepare,
            onEnterPrepare: onPrepare,
            visible: open,
            onVisibleChanged: (nextVisible)=>{
                var _motion_onVisibleChanged;
                motion === null || motion === void 0 || (_motion_onVisibleChanged = motion.onVisibleChanged) === null || _motion_onVisibleChanged === void 0 || _motion_onVisibleChanged.call(motion, nextVisible);
                onVisibleChanged(nextVisible);
            }
        }), ({ className: motionClassName, style: motionStyle }, motionRef)=>{
            const cls = (0, _classnames.default)(prefixCls, motionClassName, className, {
                [`${prefixCls}-mobile`]: isMobile
            });
            return /*#__PURE__*/ _react.createElement("div", {
                ref: (0, _ref.composeRef)(resizeObserverRef, ref, motionRef),
                className: cls,
                style: {
                    '--arrow-x': `${arrowPos.x || 0}px`,
                    '--arrow-y': `${arrowPos.y || 0}px`,
                    ...offsetStyle,
                    ...miscStyle,
                    ...motionStyle,
                    boxSizing: 'border-box',
                    zIndex,
                    ...style
                },
                onMouseEnter: onMouseEnter,
                onMouseLeave: onMouseLeave,
                onPointerEnter: onPointerEnter,
                onClick: onClick,
                onPointerDownCapture: onPointerDownCapture
            }, arrow && /*#__PURE__*/ _react.createElement(_Arrow.default, {
                prefixCls: prefixCls,
                arrow: arrow,
                arrowPos: arrowPos,
                align: align
            }), /*#__PURE__*/ _react.createElement(_PopupContent.default, {
                cache: !open && !fresh
            }, childNode));
        });
    }));
});
Popup.displayName = 'Popup';
var _default = Popup;

},
"node_modules/@rc-component/trigger/es/context.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
const TriggerContext = /*#__PURE__*/ _react.createContext(null);
var _default = TriggerContext;

},
"node_modules/@rc-component/trigger/es/hooks/useAction.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return useAction;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
function toArray(val) {
    return val ? Array.isArray(val) ? val : [
        val
    ] : [];
}
function useAction(action, showAction, hideAction) {
    return _react.useMemo(()=>{
        const mergedShowAction = toArray(showAction ?? action);
        const mergedHideAction = toArray(hideAction ?? action);
        const showActionSet = new Set(mergedShowAction);
        const hideActionSet = new Set(mergedHideAction);
        if (showActionSet.has('hover') && !showActionSet.has('click')) showActionSet.add('touch');
        if (hideActionSet.has('hover') && !hideActionSet.has('click')) hideActionSet.add('touch');
        return [
            showActionSet,
            hideActionSet
        ];
    }, [
        action,
        showAction,
        hideAction
    ]);
}

},
"node_modules/@rc-component/trigger/es/hooks/useAlign.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return useAlign;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _findDOMNode = __mako_require__("node_modules/@rc-component/util/es/Dom/findDOMNode.js");
var _isVisible = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/Dom/isVisible.js"));
var _useEvent = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/hooks/useEvent.js"));
var _useLayoutEffect = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/hooks/useLayoutEffect.js"));
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
var _util = __mako_require__("node_modules/@rc-component/trigger/es/util.js");
function getUnitOffset(size, offset = 0) {
    const offsetStr = `${offset}`;
    const cells = offsetStr.match(/^(.*)\%$/);
    if (cells) return size * (parseFloat(cells[1]) / 100);
    return parseFloat(offsetStr);
}
function getNumberOffset(rect, offset) {
    const [offsetX, offsetY] = offset || [];
    return [
        getUnitOffset(rect.width, offsetX),
        getUnitOffset(rect.height, offsetY)
    ];
}
function splitPoints(points = '') {
    return [
        points[0],
        points[1]
    ];
}
function getAlignPoint(rect, points) {
    const topBottom = points[0];
    const leftRight = points[1];
    let x;
    let y;
    // Top & Bottom
    if (topBottom === 't') y = rect.y;
    else if (topBottom === 'b') y = rect.y + rect.height;
    else y = rect.y + rect.height / 2;
    // Left & Right
    if (leftRight === 'l') x = rect.x;
    else if (leftRight === 'r') x = rect.x + rect.width;
    else x = rect.x + rect.width / 2;
    return {
        x,
        y
    };
}
function reversePoints(points, index) {
    const reverseMap = {
        t: 'b',
        b: 't',
        l: 'r',
        r: 'l'
    };
    return points.map((point, i)=>{
        if (i === index) return reverseMap[point] || 'c';
        return point;
    }).join('');
}
function useAlign(open, popupEle, target, placement, builtinPlacements, popupAlign, onPopupAlign, mobile) {
    const [offsetInfo, setOffsetInfo] = _react.useState({
        ready: false,
        offsetX: 0,
        offsetY: 0,
        offsetR: 0,
        offsetB: 0,
        arrowX: 0,
        arrowY: 0,
        scaleX: 1,
        scaleY: 1,
        align: builtinPlacements[placement] || {}
    });
    const alignCountRef = _react.useRef(0);
    const scrollerList = _react.useMemo(()=>{
        if (!popupEle || mobile) return [];
        return (0, _util.collectScroller)(popupEle);
    }, [
        popupEle
    ]);
    // ========================= Flip ==========================
    // We will memo flip info.
    // If size change to make flip, it will memo the flip info and use it in next align.
    const prevFlipRef = _react.useRef({});
    const resetFlipCache = ()=>{
        prevFlipRef.current = {};
    };
    if (!open) resetFlipCache();
    // ========================= Align =========================
    const onAlign = (0, _useEvent.default)(()=>{
        if (popupEle && target && open && !mobile) {
            var _popupElement_parentElement, _popupElement_parentElement1;
            const popupElement = popupEle;
            const doc = popupElement.ownerDocument;
            const win = (0, _util.getWin)(popupElement);
            const { position: popupPosition } = win.getComputedStyle(popupElement);
            const originLeft = popupElement.style.left;
            const originTop = popupElement.style.top;
            const originRight = popupElement.style.right;
            const originBottom = popupElement.style.bottom;
            const originOverflow = popupElement.style.overflow;
            // Placement
            const placementInfo = {
                ...builtinPlacements[placement],
                ...popupAlign
            };
            // placeholder element
            const placeholderElement = doc.createElement('div');
            (_popupElement_parentElement = popupElement.parentElement) === null || _popupElement_parentElement === void 0 || _popupElement_parentElement.appendChild(placeholderElement);
            placeholderElement.style.left = `${popupElement.offsetLeft}px`;
            placeholderElement.style.top = `${popupElement.offsetTop}px`;
            placeholderElement.style.position = popupPosition;
            placeholderElement.style.height = `${popupElement.offsetHeight}px`;
            placeholderElement.style.width = `${popupElement.offsetWidth}px`;
            // Reset first
            popupElement.style.left = '0';
            popupElement.style.top = '0';
            popupElement.style.right = 'auto';
            popupElement.style.bottom = 'auto';
            popupElement.style.overflow = 'hidden';
            // Calculate align style, we should consider `transform` case
            let targetRect;
            if (Array.isArray(target)) targetRect = {
                x: target[0],
                y: target[1],
                width: 0,
                height: 0
            };
            else {
                const rect = target.getBoundingClientRect();
                rect.x = rect.x ?? rect.left;
                rect.y = rect.y ?? rect.top;
                targetRect = {
                    x: rect.x,
                    y: rect.y,
                    width: rect.width,
                    height: rect.height
                };
            }
            const popupRect = popupElement.getBoundingClientRect();
            const { height, width } = win.getComputedStyle(popupElement);
            popupRect.x = popupRect.x ?? popupRect.left;
            popupRect.y = popupRect.y ?? popupRect.top;
            const { clientWidth, clientHeight, scrollWidth, scrollHeight, scrollTop, scrollLeft } = doc.documentElement;
            const popupHeight = popupRect.height;
            const popupWidth = popupRect.width;
            const targetHeight = targetRect.height;
            const targetWidth = targetRect.width;
            // Get bounding of visible area
            const visibleRegion = {
                left: 0,
                top: 0,
                right: clientWidth,
                bottom: clientHeight
            };
            const scrollRegion = {
                left: -scrollLeft,
                top: -scrollTop,
                right: scrollWidth - scrollLeft,
                bottom: scrollHeight - scrollTop
            };
            let { htmlRegion } = placementInfo;
            const VISIBLE = 'visible';
            const VISIBLE_FIRST = 'visibleFirst';
            if (htmlRegion !== 'scroll' && htmlRegion !== VISIBLE_FIRST) htmlRegion = VISIBLE;
            const isVisibleFirst = htmlRegion === VISIBLE_FIRST;
            const scrollRegionArea = (0, _util.getVisibleArea)(scrollRegion, scrollerList);
            const visibleRegionArea = (0, _util.getVisibleArea)(visibleRegion, scrollerList);
            const visibleArea = htmlRegion === VISIBLE ? visibleRegionArea : scrollRegionArea;
            // When set to `visibleFirst`,
            // the check `adjust` logic will use `visibleRegion` for check first.
            const adjustCheckVisibleArea = isVisibleFirst ? visibleRegionArea : visibleArea;
            // Record right & bottom align data
            popupElement.style.left = 'auto';
            popupElement.style.top = 'auto';
            popupElement.style.right = '0';
            popupElement.style.bottom = '0';
            const popupMirrorRect = popupElement.getBoundingClientRect();
            // Reset back
            popupElement.style.left = originLeft;
            popupElement.style.top = originTop;
            popupElement.style.right = originRight;
            popupElement.style.bottom = originBottom;
            popupElement.style.overflow = originOverflow;
            (_popupElement_parentElement1 = popupElement.parentElement) === null || _popupElement_parentElement1 === void 0 || _popupElement_parentElement1.removeChild(placeholderElement);
            // Calculate scale
            const scaleX = (0, _util.toNum)(Math.round(popupWidth / parseFloat(width) * 1000) / 1000);
            const scaleY = (0, _util.toNum)(Math.round(popupHeight / parseFloat(height) * 1000) / 1000);
            // No need to align since it's not visible in view
            if (scaleX === 0 || scaleY === 0 || (0, _findDOMNode.isDOM)(target) && !(0, _isVisible.default)(target)) return;
            // Offset
            const { offset, targetOffset } = placementInfo;
            let [popupOffsetX, popupOffsetY] = getNumberOffset(popupRect, offset);
            const [targetOffsetX, targetOffsetY] = getNumberOffset(targetRect, targetOffset);
            targetRect.x -= targetOffsetX;
            targetRect.y -= targetOffsetY;
            // Points
            const [popupPoint, targetPoint] = placementInfo.points || [];
            const targetPoints = splitPoints(targetPoint);
            const popupPoints = splitPoints(popupPoint);
            const targetAlignPoint = getAlignPoint(targetRect, targetPoints);
            const popupAlignPoint = getAlignPoint(popupRect, popupPoints);
            // Real align info may not same as origin one
            const nextAlignInfo = {
                ...placementInfo
            };
            // Next Offset
            let nextOffsetX = targetAlignPoint.x - popupAlignPoint.x + popupOffsetX;
            let nextOffsetY = targetAlignPoint.y - popupAlignPoint.y + popupOffsetY;
            // ============== Intersection ===============
            // Get area by position. Used for check if flip area is better
            function getIntersectionVisibleArea(offsetX, offsetY, area = visibleArea) {
                const l = popupRect.x + offsetX;
                const t = popupRect.y + offsetY;
                const r = l + popupWidth;
                const b = t + popupHeight;
                const visibleL = Math.max(l, area.left);
                const visibleT = Math.max(t, area.top);
                const visibleR = Math.min(r, area.right);
                const visibleB = Math.min(b, area.bottom);
                return Math.max(0, (visibleR - visibleL) * (visibleB - visibleT));
            }
            const originIntersectionVisibleArea = getIntersectionVisibleArea(nextOffsetX, nextOffsetY);
            // As `visibleFirst`, we prepare this for check
            const originIntersectionRecommendArea = getIntersectionVisibleArea(nextOffsetX, nextOffsetY, visibleRegionArea);
            // ========================== Overflow ===========================
            const targetAlignPointTL = getAlignPoint(targetRect, [
                't',
                'l'
            ]);
            const popupAlignPointTL = getAlignPoint(popupRect, [
                't',
                'l'
            ]);
            const targetAlignPointBR = getAlignPoint(targetRect, [
                'b',
                'r'
            ]);
            const popupAlignPointBR = getAlignPoint(popupRect, [
                'b',
                'r'
            ]);
            const overflow = placementInfo.overflow || {};
            const { adjustX, adjustY, shiftX, shiftY } = overflow;
            const supportAdjust = (val)=>{
                if (typeof val === 'boolean') return val;
                return val >= 0;
            };
            // Prepare position
            let nextPopupY;
            let nextPopupBottom;
            let nextPopupX;
            let nextPopupRight;
            function syncNextPopupPosition() {
                nextPopupY = popupRect.y + nextOffsetY;
                nextPopupBottom = nextPopupY + popupHeight;
                nextPopupX = popupRect.x + nextOffsetX;
                nextPopupRight = nextPopupX + popupWidth;
            }
            syncNextPopupPosition();
            // >>>>>>>>>> Top & Bottom
            const needAdjustY = supportAdjust(adjustY);
            const sameTB = popupPoints[0] === targetPoints[0];
            // Bottom to Top
            if (needAdjustY && popupPoints[0] === 't' && (nextPopupBottom > adjustCheckVisibleArea.bottom || prevFlipRef.current.bt)) {
                let tmpNextOffsetY = nextOffsetY;
                if (sameTB) tmpNextOffsetY -= popupHeight - targetHeight;
                else tmpNextOffsetY = targetAlignPointTL.y - popupAlignPointBR.y - popupOffsetY;
                const newVisibleArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY);
                const newVisibleRecommendArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY, visibleRegionArea);
                if (// Of course use larger one
                newVisibleArea > originIntersectionVisibleArea || newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst || // Choose recommend one
                newVisibleRecommendArea >= originIntersectionRecommendArea)) {
                    prevFlipRef.current.bt = true;
                    nextOffsetY = tmpNextOffsetY;
                    popupOffsetY = -popupOffsetY;
                    nextAlignInfo.points = [
                        reversePoints(popupPoints, 0),
                        reversePoints(targetPoints, 0)
                    ];
                } else prevFlipRef.current.bt = false;
            }
            // Top to Bottom
            if (needAdjustY && popupPoints[0] === 'b' && (nextPopupY < adjustCheckVisibleArea.top || prevFlipRef.current.tb)) {
                let tmpNextOffsetY = nextOffsetY;
                if (sameTB) tmpNextOffsetY += popupHeight - targetHeight;
                else tmpNextOffsetY = targetAlignPointBR.y - popupAlignPointTL.y - popupOffsetY;
                const newVisibleArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY);
                const newVisibleRecommendArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY, visibleRegionArea);
                if (// Of course use larger one
                newVisibleArea > originIntersectionVisibleArea || newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst || // Choose recommend one
                newVisibleRecommendArea >= originIntersectionRecommendArea)) {
                    prevFlipRef.current.tb = true;
                    nextOffsetY = tmpNextOffsetY;
                    popupOffsetY = -popupOffsetY;
                    nextAlignInfo.points = [
                        reversePoints(popupPoints, 0),
                        reversePoints(targetPoints, 0)
                    ];
                } else prevFlipRef.current.tb = false;
            }
            // >>>>>>>>>> Left & Right
            const needAdjustX = supportAdjust(adjustX);
            // >>>>> Flip
            const sameLR = popupPoints[1] === targetPoints[1];
            // Right to Left
            if (needAdjustX && popupPoints[1] === 'l' && (nextPopupRight > adjustCheckVisibleArea.right || prevFlipRef.current.rl)) {
                let tmpNextOffsetX = nextOffsetX;
                if (sameLR) tmpNextOffsetX -= popupWidth - targetWidth;
                else tmpNextOffsetX = targetAlignPointTL.x - popupAlignPointBR.x - popupOffsetX;
                const newVisibleArea = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY);
                const newVisibleRecommendArea = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY, visibleRegionArea);
                if (// Of course use larger one
                newVisibleArea > originIntersectionVisibleArea || newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst || // Choose recommend one
                newVisibleRecommendArea >= originIntersectionRecommendArea)) {
                    prevFlipRef.current.rl = true;
                    nextOffsetX = tmpNextOffsetX;
                    popupOffsetX = -popupOffsetX;
                    nextAlignInfo.points = [
                        reversePoints(popupPoints, 1),
                        reversePoints(targetPoints, 1)
                    ];
                } else prevFlipRef.current.rl = false;
            }
            // Left to Right
            if (needAdjustX && popupPoints[1] === 'r' && (nextPopupX < adjustCheckVisibleArea.left || prevFlipRef.current.lr)) {
                let tmpNextOffsetX = nextOffsetX;
                if (sameLR) tmpNextOffsetX += popupWidth - targetWidth;
                else tmpNextOffsetX = targetAlignPointBR.x - popupAlignPointTL.x - popupOffsetX;
                const newVisibleArea = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY);
                const newVisibleRecommendArea = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY, visibleRegionArea);
                if (// Of course use larger one
                newVisibleArea > originIntersectionVisibleArea || newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst || // Choose recommend one
                newVisibleRecommendArea >= originIntersectionRecommendArea)) {
                    prevFlipRef.current.lr = true;
                    nextOffsetX = tmpNextOffsetX;
                    popupOffsetX = -popupOffsetX;
                    nextAlignInfo.points = [
                        reversePoints(popupPoints, 1),
                        reversePoints(targetPoints, 1)
                    ];
                } else prevFlipRef.current.lr = false;
            }
            // ============================ Shift ============================
            syncNextPopupPosition();
            const numShiftX = shiftX === true ? 0 : shiftX;
            if (typeof numShiftX === 'number') {
                // Left
                if (nextPopupX < visibleRegionArea.left) {
                    nextOffsetX -= nextPopupX - visibleRegionArea.left - popupOffsetX;
                    if (targetRect.x + targetWidth < visibleRegionArea.left + numShiftX) nextOffsetX += targetRect.x - visibleRegionArea.left + targetWidth - numShiftX;
                }
                // Right
                if (nextPopupRight > visibleRegionArea.right) {
                    nextOffsetX -= nextPopupRight - visibleRegionArea.right - popupOffsetX;
                    if (targetRect.x > visibleRegionArea.right - numShiftX) nextOffsetX += targetRect.x - visibleRegionArea.right + numShiftX;
                }
            }
            const numShiftY = shiftY === true ? 0 : shiftY;
            if (typeof numShiftY === 'number') {
                // Top
                if (nextPopupY < visibleRegionArea.top) {
                    nextOffsetY -= nextPopupY - visibleRegionArea.top - popupOffsetY;
                    // When target if far away from visible area
                    // Stop shift
                    if (targetRect.y + targetHeight < visibleRegionArea.top + numShiftY) nextOffsetY += targetRect.y - visibleRegionArea.top + targetHeight - numShiftY;
                }
                // Bottom
                if (nextPopupBottom > visibleRegionArea.bottom) {
                    nextOffsetY -= nextPopupBottom - visibleRegionArea.bottom - popupOffsetY;
                    if (targetRect.y > visibleRegionArea.bottom - numShiftY) nextOffsetY += targetRect.y - visibleRegionArea.bottom + numShiftY;
                }
            }
            // ============================ Arrow ============================
            // Arrow center align
            const popupLeft = popupRect.x + nextOffsetX;
            const popupRight = popupLeft + popupWidth;
            const popupTop = popupRect.y + nextOffsetY;
            const popupBottom = popupTop + popupHeight;
            const targetLeft = targetRect.x;
            const targetRight = targetLeft + targetWidth;
            const targetTop = targetRect.y;
            const targetBottom = targetTop + targetHeight;
            /** Max left of the popup and target element */ const maxLeft = Math.max(popupLeft, targetLeft);
            /** Min right of the popup and target element */ const minRight = Math.min(popupRight, targetRight);
            /** The center X of popup & target cross area */ const xCenter = (maxLeft + minRight) / 2;
            /** Arrow X of popup offset */ const nextArrowX = xCenter - popupLeft;
            const maxTop = Math.max(popupTop, targetTop);
            const minBottom = Math.min(popupBottom, targetBottom);
            const yCenter = (maxTop + minBottom) / 2;
            const nextArrowY = yCenter - popupTop;
            onPopupAlign === null || onPopupAlign === void 0 || onPopupAlign(popupEle, nextAlignInfo);
            // Additional calculate right & bottom position
            let offsetX4Right = popupMirrorRect.right - popupRect.x - (nextOffsetX + popupRect.width);
            let offsetY4Bottom = popupMirrorRect.bottom - popupRect.y - (nextOffsetY + popupRect.height);
            if (scaleX === 1) {
                nextOffsetX = Math.round(nextOffsetX);
                offsetX4Right = Math.round(offsetX4Right);
            }
            if (scaleY === 1) {
                nextOffsetY = Math.round(nextOffsetY);
                offsetY4Bottom = Math.round(offsetY4Bottom);
            }
            const nextOffsetInfo = {
                ready: true,
                offsetX: nextOffsetX / scaleX,
                offsetY: nextOffsetY / scaleY,
                offsetR: offsetX4Right / scaleX,
                offsetB: offsetY4Bottom / scaleY,
                arrowX: nextArrowX / scaleX,
                arrowY: nextArrowY / scaleY,
                scaleX,
                scaleY,
                align: nextAlignInfo
            };
            setOffsetInfo(nextOffsetInfo);
        }
    });
    const triggerAlign = ()=>{
        alignCountRef.current += 1;
        const id = alignCountRef.current;
        // Merge all align requirement into one frame
        Promise.resolve().then(()=>{
            if (alignCountRef.current === id) onAlign();
        });
    };
    // Reset ready status when placement & open changed
    const resetReady = ()=>{
        setOffsetInfo((ori)=>({
                ...ori,
                ready: false
            }));
    };
    (0, _useLayoutEffect.default)(resetReady, [
        placement
    ]);
    (0, _useLayoutEffect.default)(()=>{
        if (!open) resetReady();
    }, [
        open
    ]);
    return [
        offsetInfo.ready,
        offsetInfo.offsetX,
        offsetInfo.offsetY,
        offsetInfo.offsetR,
        offsetInfo.offsetB,
        offsetInfo.arrowX,
        offsetInfo.arrowY,
        offsetInfo.scaleX,
        offsetInfo.scaleY,
        offsetInfo.align,
        triggerAlign
    ];
}

},
"node_modules/@rc-component/trigger/es/hooks/useWatch.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return useWatch;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _useLayoutEffect = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/hooks/useLayoutEffect.js"));
var _util = __mako_require__("node_modules/@rc-component/trigger/es/util.js");
function useWatch(open, target, popup, onAlign, onScroll) {
    (0, _useLayoutEffect.default)(()=>{
        if (open && target && popup) {
            const targetElement = target;
            const popupElement = popup;
            const targetScrollList = (0, _util.collectScroller)(targetElement);
            const popupScrollList = (0, _util.collectScroller)(popupElement);
            const win = (0, _util.getWin)(popupElement);
            const mergedList = new Set([
                win,
                ...targetScrollList,
                ...popupScrollList
            ]);
            function notifyScroll() {
                onAlign();
                onScroll();
            }
            mergedList.forEach((scroller)=>{
                scroller.addEventListener('scroll', notifyScroll, {
                    passive: true
                });
            });
            win.addEventListener('resize', notifyScroll, {
                passive: true
            });
            // First time always do align
            onAlign();
            return ()=>{
                mergedList.forEach((scroller)=>{
                    scroller.removeEventListener('scroll', notifyScroll);
                    win.removeEventListener('resize', notifyScroll);
                });
            };
        }
    }, [
        open,
        target,
        popup
    ]);
}

},
"node_modules/@rc-component/trigger/es/hooks/useWinClick.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, /**
 * Close if click on the window.
 * Return the function that click on the Popup element.
 */ "default", {
    enumerable: true,
    get: function() {
        return useWinClick;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _shadow = __mako_require__("node_modules/@rc-component/util/es/Dom/shadow.js");
var _warning = __mako_require__("node_modules/@rc-component/util/es/warning.js");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
var _util = __mako_require__("node_modules/@rc-component/trigger/es/util.js");
function useWinClick(open, clickToHide, targetEle, popupEle, mask, maskClosable, inPopupOrChild, triggerOpen) {
    const openRef = _react.useRef(open);
    openRef.current = open;
    const popupPointerDownRef = _react.useRef(false);
    // Click to hide is special action since click popup element should not hide
    _react.useEffect(()=>{
        if (clickToHide && popupEle && (!mask || maskClosable)) {
            const onPointerDown = ()=>{
                popupPointerDownRef.current = false;
            };
            const onTriggerClose = (e)=>{
                var _e_composedPath, _e_composedPath1;
                if (openRef.current && !inPopupOrChild(((_e_composedPath1 = e.composedPath) === null || _e_composedPath1 === void 0 ? void 0 : (_e_composedPath = _e_composedPath1.call(e)) === null || _e_composedPath === void 0 ? void 0 : _e_composedPath[0]) || e.target) && !popupPointerDownRef.current) triggerOpen(false);
            };
            const win = (0, _util.getWin)(popupEle);
            win.addEventListener('pointerdown', onPointerDown, true);
            win.addEventListener('mousedown', onTriggerClose, true);
            win.addEventListener('contextmenu', onTriggerClose, true);
            // shadow root
            const targetShadowRoot = (0, _shadow.getShadowRoot)(targetEle);
            if (targetShadowRoot) {
                targetShadowRoot.addEventListener('mousedown', onTriggerClose, true);
                targetShadowRoot.addEventListener('contextmenu', onTriggerClose, true);
            }
            {
                var _targetEle_getRootNode, _popupEle_getRootNode;
                const targetRoot = targetEle === null || targetEle === void 0 ? void 0 : (_targetEle_getRootNode = targetEle.getRootNode) === null || _targetEle_getRootNode === void 0 ? void 0 : _targetEle_getRootNode.call(targetEle);
                const popupRoot = (_popupEle_getRootNode = popupEle.getRootNode) === null || _popupEle_getRootNode === void 0 ? void 0 : _popupEle_getRootNode.call(popupEle);
                (0, _warning.warning)(targetRoot === popupRoot, `trigger element and popup element should in same shadow root.`);
            }
            return ()=>{
                win.removeEventListener('pointerdown', onPointerDown, true);
                win.removeEventListener('mousedown', onTriggerClose, true);
                win.removeEventListener('contextmenu', onTriggerClose, true);
                if (targetShadowRoot) {
                    targetShadowRoot.removeEventListener('mousedown', onTriggerClose, true);
                    targetShadowRoot.removeEventListener('contextmenu', onTriggerClose, true);
                }
            };
        }
    }, [
        clickToHide,
        targetEle,
        popupEle,
        mask,
        maskClosable
    ]);
    function onPopupPointerDown() {
        popupPointerDownRef.current = true;
    }
    return onPopupPointerDown;
}

},
"node_modules/@rc-component/trigger/es/index.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    default: function() {
        return _default;
    },
    generateTrigger: function() {
        return generateTrigger;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _portal = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/portal/es/index.js"));
var _classnames = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/classnames/index.js"));
var _resizeobserver = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/resize-observer/es/index.js"));
var _findDOMNode = __mako_require__("node_modules/@rc-component/util/es/Dom/findDOMNode.js");
var _shadow = __mako_require__("node_modules/@rc-component/util/es/Dom/shadow.js");
var _useEvent = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/hooks/useEvent.js"));
var _useId = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/hooks/useId.js"));
var _useLayoutEffect = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/hooks/useLayoutEffect.js"));
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
var _Popup = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/trigger/es/Popup/index.js"));
var _context = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/trigger/es/context.js"));
var _useAction = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/trigger/es/hooks/useAction.js"));
var _useAlign = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/trigger/es/hooks/useAlign.js"));
var _useWatch = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/trigger/es/hooks/useWatch.js"));
var _useWinClick = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/trigger/es/hooks/useWinClick.js"));
var _util = __mako_require__("node_modules/@rc-component/trigger/es/util.js");
function generateTrigger(PortalComponent = _portal.default) {
    const Trigger = /*#__PURE__*/ _react.forwardRef((props, ref)=>{
        var _rendedRef;
        const { prefixCls = 'rc-trigger-popup', children, // Action
        action = 'hover', showAction, hideAction, // Open
        popupVisible, defaultPopupVisible, onOpenChange, afterOpenChange, onPopupVisibleChange, afterPopupVisibleChange, // Delay
        mouseEnterDelay, mouseLeaveDelay = 0.1, focusDelay, blurDelay, // Mask
        mask, maskClosable = true, // Portal
        getPopupContainer, forceRender, autoDestroy, // Popup
        popup, popupClassName, popupStyle, popupPlacement, builtinPlacements = {}, popupAlign, zIndex, stretch, getPopupClassNameFromAlign, fresh, alignPoint, onPopupClick, onPopupAlign, // Arrow
        arrow, // Motion
        popupMotion, maskMotion, // Private
        mobile, ...restProps } = props;
        const mergedAutoDestroy = autoDestroy || false;
        // =========================== Mobile ===========================
        const isMobile = !!mobile;
        // ========================== Context ===========================
        const subPopupElements = _react.useRef({});
        const parentContext = _react.useContext(_context.default);
        const context = _react.useMemo(()=>{
            return {
                registerSubPopup: (id, subPopupEle)=>{
                    subPopupElements.current[id] = subPopupEle;
                    parentContext === null || parentContext === void 0 || parentContext.registerSubPopup(id, subPopupEle);
                }
            };
        }, [
            parentContext
        ]);
        // =========================== Popup ============================
        const id = (0, _useId.default)();
        const [popupEle, setPopupEle] = _react.useState(null);
        // Used for forwardRef popup. Not use internal
        const externalPopupRef = _react.useRef(null);
        const setPopupRef = (0, _useEvent.default)((node)=>{
            externalPopupRef.current = node;
            if ((0, _findDOMNode.isDOM)(node) && popupEle !== node) setPopupEle(node);
            parentContext === null || parentContext === void 0 || parentContext.registerSubPopup(id, node);
        });
        // =========================== Target ===========================
        // Use state to control here since `useRef` update not trigger render
        const [targetEle, setTargetEle] = _react.useState(null);
        // Used for forwardRef target. Not use internal
        const externalForwardRef = _react.useRef(null);
        const setTargetRef = (0, _useEvent.default)((node)=>{
            if ((0, _findDOMNode.isDOM)(node) && targetEle !== node) {
                setTargetEle(node);
                externalForwardRef.current = node;
            }
        });
        // ========================== Children ==========================
        const child = _react.Children.only(children);
        const originChildProps = (child === null || child === void 0 ? void 0 : child.props) || {};
        const cloneProps = {};
        const inPopupOrChild = (0, _useEvent.default)((ele)=>{
            var _getShadowRoot, _getShadowRoot1;
            const childDOM = targetEle;
            return (childDOM === null || childDOM === void 0 ? void 0 : childDOM.contains(ele)) || ((_getShadowRoot = (0, _shadow.getShadowRoot)(childDOM)) === null || _getShadowRoot === void 0 ? void 0 : _getShadowRoot.host) === ele || ele === childDOM || (popupEle === null || popupEle === void 0 ? void 0 : popupEle.contains(ele)) || ((_getShadowRoot1 = (0, _shadow.getShadowRoot)(popupEle)) === null || _getShadowRoot1 === void 0 ? void 0 : _getShadowRoot1.host) === ele || ele === popupEle || Object.values(subPopupElements.current).some((subPopupEle)=>(subPopupEle === null || subPopupEle === void 0 ? void 0 : subPopupEle.contains(ele)) || ele === subPopupEle);
        });
        // ============================ Open ============================
        const [internalOpen, setInternalOpen] = _react.useState(defaultPopupVisible || false);
        // Render still use props as first priority
        const mergedOpen = popupVisible ?? internalOpen;
        // We use effect sync here in case `popupVisible` back to `undefined`
        const setMergedOpen = (0, _useEvent.default)((nextOpen)=>{
            if (popupVisible === undefined) setInternalOpen(nextOpen);
        });
        (0, _useLayoutEffect.default)(()=>{
            setInternalOpen(popupVisible || false);
        }, [
            popupVisible
        ]);
        const openRef = _react.useRef(mergedOpen);
        openRef.current = mergedOpen;
        const lastTriggerRef = _react.useRef([]);
        lastTriggerRef.current = [];
        const internalTriggerOpen = (0, _useEvent.default)((nextOpen)=>{
            setMergedOpen(nextOpen);
            // Enter or Pointer will both trigger open state change
            // We only need take one to avoid duplicated change event trigger
            // Use `lastTriggerRef` to record last open type
            if ((lastTriggerRef.current[lastTriggerRef.current.length - 1] ?? mergedOpen) !== nextOpen) {
                lastTriggerRef.current.push(nextOpen);
                onOpenChange === null || onOpenChange === void 0 || onOpenChange(nextOpen);
                onPopupVisibleChange === null || onPopupVisibleChange === void 0 || onPopupVisibleChange(nextOpen);
            }
        });
        // Trigger for delay
        const delayRef = _react.useRef(null);
        const clearDelay = ()=>{
            clearTimeout(delayRef.current);
        };
        const triggerOpen = (nextOpen, delay = 0)=>{
            clearDelay();
            if (delay === 0) internalTriggerOpen(nextOpen);
            else delayRef.current = setTimeout(()=>{
                internalTriggerOpen(nextOpen);
            }, delay * 1000);
        };
        _react.useEffect(()=>clearDelay, []);
        // ========================== Motion ============================
        const [inMotion, setInMotion] = _react.useState(false);
        (0, _useLayoutEffect.default)((firstMount)=>{
            if (!firstMount || mergedOpen) setInMotion(true);
        }, [
            mergedOpen
        ]);
        const [motionPrepareResolve, setMotionPrepareResolve] = _react.useState(null);
        // =========================== Align ============================
        const [mousePos, setMousePos] = _react.useState(null);
        const setMousePosByEvent = (event)=>{
            setMousePos([
                event.clientX,
                event.clientY
            ]);
        };
        const [ready, offsetX, offsetY, offsetR, offsetB, arrowX, arrowY, scaleX, scaleY, alignInfo, onAlign] = (0, _useAlign.default)(mergedOpen, popupEle, alignPoint && mousePos !== null ? mousePos : targetEle, popupPlacement, builtinPlacements, popupAlign, onPopupAlign, isMobile);
        const [showActions, hideActions] = (0, _useAction.default)(action, showAction, hideAction);
        const clickToShow = showActions.has('click');
        const clickToHide = hideActions.has('click') || hideActions.has('contextMenu');
        const triggerAlign = (0, _useEvent.default)(()=>{
            if (!inMotion) onAlign();
        });
        const onScroll = ()=>{
            if (openRef.current && alignPoint && clickToHide) triggerOpen(false);
        };
        (0, _useWatch.default)(mergedOpen, targetEle, popupEle, triggerAlign, onScroll);
        (0, _useLayoutEffect.default)(()=>{
            triggerAlign();
        }, [
            mousePos,
            popupPlacement
        ]);
        // When no builtinPlacements and popupAlign changed
        (0, _useLayoutEffect.default)(()=>{
            if (mergedOpen && !(builtinPlacements === null || builtinPlacements === void 0 ? void 0 : builtinPlacements[popupPlacement])) triggerAlign();
        }, [
            JSON.stringify(popupAlign)
        ]);
        const alignedClassName = _react.useMemo(()=>{
            const baseClassName = (0, _util.getAlignPopupClassName)(builtinPlacements, prefixCls, alignInfo, alignPoint);
            return (0, _classnames.default)(baseClassName, getPopupClassNameFromAlign === null || getPopupClassNameFromAlign === void 0 ? void 0 : getPopupClassNameFromAlign(alignInfo));
        }, [
            alignInfo,
            getPopupClassNameFromAlign,
            builtinPlacements,
            prefixCls,
            alignPoint
        ]);
        // ============================ Refs ============================
        _react.useImperativeHandle(ref, ()=>({
                nativeElement: externalForwardRef.current,
                popupElement: externalPopupRef.current,
                forceAlign: triggerAlign
            }));
        // ========================== Stretch ===========================
        const [targetWidth, setTargetWidth] = _react.useState(0);
        const [targetHeight, setTargetHeight] = _react.useState(0);
        const syncTargetSize = ()=>{
            if (stretch && targetEle) {
                const rect = targetEle.getBoundingClientRect();
                setTargetWidth(rect.width);
                setTargetHeight(rect.height);
            }
        };
        const onTargetResize = ()=>{
            syncTargetSize();
            triggerAlign();
        };
        // ========================== Motion ============================
        const onVisibleChanged = (visible)=>{
            setInMotion(false);
            onAlign();
            afterOpenChange === null || afterOpenChange === void 0 || afterOpenChange(visible);
            afterPopupVisibleChange === null || afterPopupVisibleChange === void 0 || afterPopupVisibleChange(visible);
        };
        // We will trigger align when motion is in prepare
        const onPrepare = ()=>new Promise((resolve)=>{
                syncTargetSize();
                setMotionPrepareResolve(()=>resolve);
            });
        (0, _useLayoutEffect.default)(()=>{
            if (motionPrepareResolve) {
                onAlign();
                motionPrepareResolve();
                setMotionPrepareResolve(null);
            }
        }, [
            motionPrepareResolve
        ]);
        // =========================== Action ===========================
        /**
     * Util wrapper for trigger action
     * @param eventName  Listen event name
     * @param nextOpen  Next open state after trigger
     * @param delay Delay to trigger open change
     * @param callback Callback if current event need additional action
     * @param ignoreCheck  Ignore current event if check return true
     */ function wrapperAction(eventName, nextOpen, delay, callback, ignoreCheck) {
            cloneProps[eventName] = (event, ...args)=>{
                var // Pass to origin
                _originChildProps_eventName;
                if (!ignoreCheck || !ignoreCheck()) {
                    callback === null || callback === void 0 || callback(event);
                    triggerOpen(nextOpen, delay);
                }
                (_originChildProps_eventName = originChildProps[eventName]) === null || _originChildProps_eventName === void 0 || _originChildProps_eventName.call(originChildProps, event, ...args);
            };
        }
        // ======================= Action: Touch ========================
        const touchToShow = showActions.has('touch');
        const touchToHide = hideActions.has('touch');
        /** Used for prevent `hover` event conflict with mobile env */ const touchedRef = _react.useRef(false);
        if (touchToShow || touchToHide) cloneProps.onTouchStart = (...args)=>{
            var // Pass to origin
            _originChildProps_onTouchStart;
            touchedRef.current = true;
            if (openRef.current && touchToHide) triggerOpen(false);
            else if (!openRef.current && touchToShow) triggerOpen(true);
            (_originChildProps_onTouchStart = originChildProps.onTouchStart) === null || _originChildProps_onTouchStart === void 0 || _originChildProps_onTouchStart.call(originChildProps, ...args);
        };
        // ======================= Action: Click ========================
        if (clickToShow || clickToHide) cloneProps.onClick = (event, ...args)=>{
            var // Pass to origin
            _originChildProps_onClick;
            if (openRef.current && clickToHide) triggerOpen(false);
            else if (!openRef.current && clickToShow) {
                setMousePosByEvent(event);
                triggerOpen(true);
            }
            (_originChildProps_onClick = originChildProps.onClick) === null || _originChildProps_onClick === void 0 || _originChildProps_onClick.call(originChildProps, event, ...args);
            touchedRef.current = false;
        };
        // Click to hide is special action since click popup element should not hide
        const onPopupPointerDown = (0, _useWinClick.default)(mergedOpen, clickToHide || touchToHide, targetEle, popupEle, mask, maskClosable, inPopupOrChild, triggerOpen);
        // ======================= Action: Hover ========================
        const hoverToShow = showActions.has('hover');
        const hoverToHide = hideActions.has('hover');
        let onPopupMouseEnter;
        let onPopupMouseLeave;
        const ignoreMouseTrigger = ()=>{
            return touchedRef.current;
        };
        if (hoverToShow) {
            const onMouseEnterCallback = (event)=>{
                setMousePosByEvent(event);
            };
            // Compatible with old browser which not support pointer event
            wrapperAction('onMouseEnter', true, mouseEnterDelay, onMouseEnterCallback, ignoreMouseTrigger);
            wrapperAction('onPointerEnter', true, mouseEnterDelay, onMouseEnterCallback, ignoreMouseTrigger);
            onPopupMouseEnter = (event)=>{
                // Only trigger re-open when popup is visible
                if ((mergedOpen || inMotion) && (popupEle === null || popupEle === void 0 ? void 0 : popupEle.contains(event.target))) triggerOpen(true, mouseEnterDelay);
            };
            // Align Point
            if (alignPoint) cloneProps.onMouseMove = (event)=>{
                var _originChildProps_onMouseMove;
                (_originChildProps_onMouseMove = originChildProps.onMouseMove) === null || _originChildProps_onMouseMove === void 0 || _originChildProps_onMouseMove.call(originChildProps, event);
            };
        }
        if (hoverToHide) {
            wrapperAction('onMouseLeave', false, mouseLeaveDelay, undefined, ignoreMouseTrigger);
            wrapperAction('onPointerLeave', false, mouseLeaveDelay, undefined, ignoreMouseTrigger);
            onPopupMouseLeave = ()=>{
                triggerOpen(false, mouseLeaveDelay);
            };
        }
        // ======================= Action: Focus ========================
        if (showActions.has('focus')) wrapperAction('onFocus', true, focusDelay);
        if (hideActions.has('focus')) wrapperAction('onBlur', false, blurDelay);
        // ==================== Action: ContextMenu =====================
        if (showActions.has('contextMenu')) cloneProps.onContextMenu = (event, ...args)=>{
            var // Pass to origin
            _originChildProps_onContextMenu;
            if (openRef.current && hideActions.has('contextMenu')) triggerOpen(false);
            else {
                setMousePosByEvent(event);
                triggerOpen(true);
            }
            event.preventDefault();
            (_originChildProps_onContextMenu = originChildProps.onContextMenu) === null || _originChildProps_onContextMenu === void 0 || _originChildProps_onContextMenu.call(originChildProps, event, ...args);
        };
        // ============================ Perf ============================
        const rendedRef = _react.useRef(false);
        (_rendedRef = rendedRef).current || (_rendedRef.current = forceRender || mergedOpen || inMotion);
        // =========================== Render ===========================
        const mergedChildrenProps = {
            ...originChildProps,
            ...cloneProps
        };
        // Pass props into cloneProps for nest usage
        const passedProps = {};
        const passedEventList = [
            'onContextMenu',
            'onClick',
            'onMouseDown',
            'onTouchStart',
            'onMouseEnter',
            'onMouseLeave',
            'onFocus',
            'onBlur'
        ];
        passedEventList.forEach((eventName)=>{
            if (restProps[eventName]) passedProps[eventName] = (...args)=>{
                var _mergedChildrenProps_eventName;
                (_mergedChildrenProps_eventName = mergedChildrenProps[eventName]) === null || _mergedChildrenProps_eventName === void 0 || _mergedChildrenProps_eventName.call(mergedChildrenProps, ...args);
                restProps[eventName](...args);
            };
        });
        const arrowPos = {
            x: arrowX,
            y: arrowY
        };
        const innerArrow = arrow ? {
            // true and Object likely
            ...arrow !== true ? arrow : {}
        } : null;
        // Child Node
        const triggerNode = /*#__PURE__*/ _react.cloneElement(child, {
            ...mergedChildrenProps,
            ...passedProps
        });
        // Render
        return /*#__PURE__*/ _react.createElement(_react.Fragment, null, /*#__PURE__*/ _react.createElement(_resizeobserver.default, {
            disabled: !mergedOpen,
            ref: setTargetRef,
            onResize: onTargetResize
        }, triggerNode), rendedRef.current && /*#__PURE__*/ _react.createElement(_context.default.Provider, {
            value: context
        }, /*#__PURE__*/ _react.createElement(_Popup.default, {
            portal: PortalComponent,
            ref: setPopupRef,
            prefixCls: prefixCls,
            popup: popup,
            className: (0, _classnames.default)(popupClassName, !isMobile && alignedClassName),
            style: popupStyle,
            target: targetEle,
            onMouseEnter: onPopupMouseEnter,
            onMouseLeave: onPopupMouseLeave,
            onPointerEnter: onPopupMouseEnter,
            zIndex: zIndex,
            open: mergedOpen,
            keepDom: inMotion,
            fresh: fresh,
            onClick: onPopupClick,
            onPointerDownCapture: onPopupPointerDown,
            mask: mask,
            motion: popupMotion,
            maskMotion: maskMotion,
            onVisibleChanged: onVisibleChanged,
            onPrepare: onPrepare,
            forceRender: forceRender,
            autoDestroy: mergedAutoDestroy,
            getPopupContainer: getPopupContainer,
            align: alignInfo,
            arrow: innerArrow,
            arrowPos: arrowPos,
            ready: ready,
            offsetX: offsetX,
            offsetY: offsetY,
            offsetR: offsetR,
            offsetB: offsetB,
            onAlign: triggerAlign,
            stretch: stretch,
            targetWidth: targetWidth / scaleX,
            targetHeight: targetHeight / scaleY,
            mobile: mobile
        })));
    });
    Trigger.displayName = 'Trigger';
    return Trigger;
}
var _default = generateTrigger(_portal.default);

},
"node_modules/@rc-component/trigger/es/util.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    collectScroller: function() {
        return collectScroller;
    },
    getAlignPopupClassName: function() {
        return getAlignPopupClassName;
    },
    getVisibleArea: function() {
        return getVisibleArea;
    },
    getWin: function() {
        return getWin;
    },
    toNum: function() {
        return toNum;
    }
});
function isPointsEq(a1 = [], a2 = [], isAlignPoint) {
    if (isAlignPoint) return a1[0] === a2[0];
    return a1[0] === a2[0] && a1[1] === a2[1];
}
function getAlignPopupClassName(builtinPlacements, prefixCls, align, isAlignPoint) {
    const { points } = align;
    const placements = Object.keys(builtinPlacements);
    for(let i = 0; i < placements.length; i += 1){
        var _builtinPlacements_placement;
        const placement = placements[i];
        if (isPointsEq((_builtinPlacements_placement = builtinPlacements[placement]) === null || _builtinPlacements_placement === void 0 ? void 0 : _builtinPlacements_placement.points, points, isAlignPoint)) return `${prefixCls}-placement-${placement}`;
    }
    return '';
}
function getWin(ele) {
    return ele.ownerDocument.defaultView;
}
function collectScroller(ele) {
    const scrollerList = [];
    let current = ele === null || ele === void 0 ? void 0 : ele.parentElement;
    const scrollStyle = [
        'hidden',
        'scroll',
        'clip',
        'auto'
    ];
    while(current){
        const { overflowX, overflowY, overflow } = getWin(current).getComputedStyle(current);
        if ([
            overflowX,
            overflowY,
            overflow
        ].some((o)=>scrollStyle.includes(o))) scrollerList.push(current);
        current = current.parentElement;
    }
    return scrollerList;
}
function toNum(num, defaultValue = 1) {
    return Number.isNaN(num) ? defaultValue : num;
}
function getPxValue(val) {
    return toNum(parseFloat(val), 0);
}
function getVisibleArea(initArea, scrollerList) {
    const visibleArea = {
        ...initArea
    };
    (scrollerList || []).forEach((ele)=>{
        if (ele instanceof HTMLBodyElement || ele instanceof HTMLHtmlElement) return;
        // Skip if static position which will not affect visible area
        const { overflow, overflowClipMargin, borderTopWidth, borderBottomWidth, borderLeftWidth, borderRightWidth } = getWin(ele).getComputedStyle(ele);
        const eleRect = ele.getBoundingClientRect();
        const { offsetHeight: eleOutHeight, clientHeight: eleInnerHeight, offsetWidth: eleOutWidth, clientWidth: eleInnerWidth } = ele;
        const borderTopNum = getPxValue(borderTopWidth);
        const borderBottomNum = getPxValue(borderBottomWidth);
        const borderLeftNum = getPxValue(borderLeftWidth);
        const borderRightNum = getPxValue(borderRightWidth);
        const scaleX = toNum(Math.round(eleRect.width / eleOutWidth * 1000) / 1000);
        const scaleY = toNum(Math.round(eleRect.height / eleOutHeight * 1000) / 1000);
        // Original visible area
        const eleScrollWidth = (eleOutWidth - eleInnerWidth - borderLeftNum - borderRightNum) * scaleX;
        const eleScrollHeight = (eleOutHeight - eleInnerHeight - borderTopNum - borderBottomNum) * scaleY;
        // Cut border size
        const scaledBorderTopWidth = borderTopNum * scaleY;
        const scaledBorderBottomWidth = borderBottomNum * scaleY;
        const scaledBorderLeftWidth = borderLeftNum * scaleX;
        const scaledBorderRightWidth = borderRightNum * scaleX;
        // Clip margin
        let clipMarginWidth = 0;
        let clipMarginHeight = 0;
        if (overflow === 'clip') {
            const clipNum = getPxValue(overflowClipMargin);
            clipMarginWidth = clipNum * scaleX;
            clipMarginHeight = clipNum * scaleY;
        }
        // Region
        const eleLeft = eleRect.x + scaledBorderLeftWidth - clipMarginWidth;
        const eleTop = eleRect.y + scaledBorderTopWidth - clipMarginHeight;
        const eleRight = eleLeft + eleRect.width + 2 * clipMarginWidth - scaledBorderLeftWidth - scaledBorderRightWidth - eleScrollWidth;
        const eleBottom = eleTop + eleRect.height + 2 * clipMarginHeight - scaledBorderTopWidth - scaledBorderBottomWidth - eleScrollHeight;
        visibleArea.left = Math.max(visibleArea.left, eleLeft);
        visibleArea.top = Math.max(visibleArea.top, eleTop);
        visibleArea.right = Math.min(visibleArea.right, eleRight);
        visibleArea.bottom = Math.min(visibleArea.bottom, eleBottom);
    });
    return visibleArea;
}

},
"node_modules/@rc-component/util/es/Children/toArray.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return toArray;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _isFragment = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/React/isFragment.js"));
var _react = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/react/index.js"));
function toArray(children, option = {}) {
    let ret = [];
    _react.default.Children.forEach(children, (child)=>{
        if ((child === undefined || child === null) && !option.keepEmpty) return;
        if (Array.isArray(child)) ret = ret.concat(toArray(child));
        else if ((0, _isFragment.default)(child) && child.props) ret = ret.concat(toArray(child.props.children, option));
        else ret.push(child);
    });
    return ret;
}

},
"node_modules/@rc-component/util/es/Dom/canUseDom.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return canUseDom;
    }
});
function canUseDom() {
    return !!(typeof window !== 'undefined' && window.document && window.document.createElement);
}

},
"node_modules/@rc-component/util/es/Dom/contains.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return contains;
    }
});
function contains(root, n) {
    if (!root) return false;
    // Use native if support
    if (root.contains) return root.contains(n);
    // `document.contains` not support with IE11
    let node = n;
    while(node){
        if (node === root) return true;
        node = node.parentNode;
    }
    return false;
}

},
"node_modules/@rc-component/util/es/Dom/dynamicCSS.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    clearContainerCache: function() {
        return clearContainerCache;
    },
    injectCSS: function() {
        return injectCSS;
    },
    removeCSS: function() {
        return removeCSS;
    },
    updateCSS: function() {
        return updateCSS;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _canUseDom = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/Dom/canUseDom.js"));
var _contains = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/Dom/contains.js"));
const APPEND_ORDER = 'data-rc-order';
const APPEND_PRIORITY = 'data-rc-priority';
const MARK_KEY = `rc-util-key`;
const containerCache = new Map();
function getMark({ mark } = {}) {
    if (mark) return mark.startsWith('data-') ? mark : `data-${mark}`;
    return MARK_KEY;
}
function getContainer(option) {
    if (option.attachTo) return option.attachTo;
    const head = document.querySelector('head');
    return head || document.body;
}
function getOrder(prepend) {
    if (prepend === 'queue') return 'prependQueue';
    return prepend ? 'prepend' : 'append';
}
/**
 * Find style which inject by rc-util
 */ function findStyles(container) {
    return Array.from((containerCache.get(container) || container).children).filter((node)=>node.tagName === 'STYLE');
}
function injectCSS(css, option = {}) {
    if (!(0, _canUseDom.default)()) return null;
    const { csp, prepend, priority = 0 } = option;
    const mergedOrder = getOrder(prepend);
    const isPrependQueue = mergedOrder === 'prependQueue';
    const styleNode = document.createElement('style');
    styleNode.setAttribute(APPEND_ORDER, mergedOrder);
    if (isPrependQueue && priority) styleNode.setAttribute(APPEND_PRIORITY, `${priority}`);
    if (csp === null || csp === void 0 ? void 0 : csp.nonce) styleNode.nonce = csp === null || csp === void 0 ? void 0 : csp.nonce;
    styleNode.innerHTML = css;
    const container = getContainer(option);
    const { firstChild } = container;
    if (prepend) {
        // If is queue `prepend`, it will prepend first style and then append rest style
        if (isPrependQueue) {
            const existStyle = (option.styles || findStyles(container)).filter((node)=>{
                // Ignore style which not injected by rc-util with prepend
                if (![
                    'prepend',
                    'prependQueue'
                ].includes(node.getAttribute(APPEND_ORDER))) return false;
                // Ignore style which priority less then new style
                const nodePriority = Number(node.getAttribute(APPEND_PRIORITY) || 0);
                return priority >= nodePriority;
            });
            if (existStyle.length) {
                container.insertBefore(styleNode, existStyle[existStyle.length - 1].nextSibling);
                return styleNode;
            }
        }
        // Use `insertBefore` as `prepend`
        container.insertBefore(styleNode, firstChild);
    } else container.appendChild(styleNode);
    return styleNode;
}
function findExistNode(key, option = {}) {
    let { styles } = option;
    styles || (styles = findStyles(getContainer(option)));
    return styles.find((node)=>node.getAttribute(getMark(option)) === key);
}
function removeCSS(key, option = {}) {
    const existNode = findExistNode(key, option);
    if (existNode) {
        const container = getContainer(option);
        container.removeChild(existNode);
    }
}
/**
 * qiankun will inject `appendChild` to insert into other
 */ function syncRealContainer(container, option) {
    const cachedRealContainer = containerCache.get(container);
    // Find real container when not cached or cached container removed
    if (!cachedRealContainer || !(0, _contains.default)(document, cachedRealContainer)) {
        const placeholderStyle = injectCSS('', option);
        const { parentNode } = placeholderStyle;
        containerCache.set(container, parentNode);
        container.removeChild(placeholderStyle);
    }
}
function clearContainerCache() {
    containerCache.clear();
}
function updateCSS(css, key, originOption = {}) {
    const container = getContainer(originOption);
    const styles = findStyles(container);
    const option = {
        ...originOption,
        styles
    };
    // Sync real parent
    syncRealContainer(container, option);
    const existNode = findExistNode(key, option);
    if (existNode) {
        var _option_csp, _option_csp1;
        if (((_option_csp = option.csp) === null || _option_csp === void 0 ? void 0 : _option_csp.nonce) && existNode.nonce !== ((_option_csp1 = option.csp) === null || _option_csp1 === void 0 ? void 0 : _option_csp1.nonce)) {
            var _option_csp2;
            existNode.nonce = (_option_csp2 = option.csp) === null || _option_csp2 === void 0 ? void 0 : _option_csp2.nonce;
        }
        if (existNode.innerHTML !== css) existNode.innerHTML = css;
        return existNode;
    }
    const newNode = injectCSS(css, option);
    newNode.setAttribute(getMark(option), key);
    return newNode;
}

},
"node_modules/@rc-component/util/es/Dom/findDOMNode.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    /**
 * Return if a node is a DOM node. Else will return by `findDOMNode`
 */ default: function() {
        return findDOMNode;
    },
    getDOM: function() {
        return getDOM;
    },
    isDOM: function() {
        return isDOM;
    }
});
function isDOM(node) {
    // https://developer.mozilla.org/en-US/docs/Web/API/Element
    // Since XULElement is also subclass of Element, we only need HTMLElement and SVGElement
    return node instanceof HTMLElement || node instanceof SVGElement;
}
function getDOM(node) {
    if (node && typeof node === 'object' && isDOM(node.nativeElement)) return node.nativeElement;
    if (isDOM(node)) return node;
    return null;
}
function findDOMNode(node) {
    const domNode = getDOM(node);
    if (domNode) return domNode;
    if (node && typeof node === 'object' && 'current' in node) {
        const refDomNode = getDOM(node.current);
        if (refDomNode) return refDomNode;
    }
    return null;
}

},
"node_modules/@rc-component/util/es/Dom/isVisible.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _default = (element)=>{
    if (!element) return false;
    if (element instanceof Element) {
        if (element.offsetParent) return true;
        if (element.getBBox) {
            const { width, height } = element.getBBox();
            if (width || height) return true;
        }
        if (element.getBoundingClientRect) {
            const { width, height } = element.getBoundingClientRect();
            if (width || height) return true;
        }
    }
    return false;
};

},
"node_modules/@rc-component/util/es/Dom/shadow.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    getShadowRoot: function() {
        return getShadowRoot;
    },
    inShadow: function() {
        return inShadow;
    }
});
function getRoot(ele) {
    var _ele_getRootNode;
    return ele === null || ele === void 0 ? void 0 : (_ele_getRootNode = ele.getRootNode) === null || _ele_getRootNode === void 0 ? void 0 : _ele_getRootNode.call(ele);
}
function inShadow(ele) {
    return getRoot(ele) instanceof ShadowRoot;
}
function getShadowRoot(ele) {
    return inShadow(ele) ? getRoot(ele) : null;
}

},
"node_modules/@rc-component/util/es/KeyCode.js": function (module, exports, __mako_require__){
/**
 * @ignore
 * some key-codes definition and utils from closure-library
 * @author yiminghe@gmail.com
 */ "use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
const KeyCode = {
    /**
   * MAC_ENTER
   */ MAC_ENTER: 3,
    /**
   * BACKSPACE
   */ BACKSPACE: 8,
    /**
   * TAB
   */ TAB: 9,
    /**
   * NUMLOCK on FF/Safari Mac
   */ NUM_CENTER: 12,
    // NUMLOCK on FF/Safari Mac
    /**
   * ENTER
   */ ENTER: 13,
    /**
   * SHIFT
   */ SHIFT: 16,
    /**
   * CTRL
   */ CTRL: 17,
    /**
   * ALT
   */ ALT: 18,
    /**
   * PAUSE
   */ PAUSE: 19,
    /**
   * CAPS_LOCK
   */ CAPS_LOCK: 20,
    /**
   * ESC
   */ ESC: 27,
    /**
   * SPACE
   */ SPACE: 32,
    /**
   * PAGE_UP
   */ PAGE_UP: 33,
    // also NUM_NORTH_EAST
    /**
   * PAGE_DOWN
   */ PAGE_DOWN: 34,
    // also NUM_SOUTH_EAST
    /**
   * END
   */ END: 35,
    // also NUM_SOUTH_WEST
    /**
   * HOME
   */ HOME: 36,
    // also NUM_NORTH_WEST
    /**
   * LEFT
   */ LEFT: 37,
    // also NUM_WEST
    /**
   * UP
   */ UP: 38,
    // also NUM_NORTH
    /**
   * RIGHT
   */ RIGHT: 39,
    // also NUM_EAST
    /**
   * DOWN
   */ DOWN: 40,
    // also NUM_SOUTH
    /**
   * PRINT_SCREEN
   */ PRINT_SCREEN: 44,
    /**
   * INSERT
   */ INSERT: 45,
    // also NUM_INSERT
    /**
   * DELETE
   */ DELETE: 46,
    // also NUM_DELETE
    /**
   * ZERO
   */ ZERO: 48,
    /**
   * ONE
   */ ONE: 49,
    /**
   * TWO
   */ TWO: 50,
    /**
   * THREE
   */ THREE: 51,
    /**
   * FOUR
   */ FOUR: 52,
    /**
   * FIVE
   */ FIVE: 53,
    /**
   * SIX
   */ SIX: 54,
    /**
   * SEVEN
   */ SEVEN: 55,
    /**
   * EIGHT
   */ EIGHT: 56,
    /**
   * NINE
   */ NINE: 57,
    /**
   * QUESTION_MARK
   */ QUESTION_MARK: 63,
    // needs localization
    /**
   * A
   */ A: 65,
    /**
   * B
   */ B: 66,
    /**
   * C
   */ C: 67,
    /**
   * D
   */ D: 68,
    /**
   * E
   */ E: 69,
    /**
   * F
   */ F: 70,
    /**
   * G
   */ G: 71,
    /**
   * H
   */ H: 72,
    /**
   * I
   */ I: 73,
    /**
   * J
   */ J: 74,
    /**
   * K
   */ K: 75,
    /**
   * L
   */ L: 76,
    /**
   * M
   */ M: 77,
    /**
   * N
   */ N: 78,
    /**
   * O
   */ O: 79,
    /**
   * P
   */ P: 80,
    /**
   * Q
   */ Q: 81,
    /**
   * R
   */ R: 82,
    /**
   * S
   */ S: 83,
    /**
   * T
   */ T: 84,
    /**
   * U
   */ U: 85,
    /**
   * V
   */ V: 86,
    /**
   * W
   */ W: 87,
    /**
   * X
   */ X: 88,
    /**
   * Y
   */ Y: 89,
    /**
   * Z
   */ Z: 90,
    /**
   * META
   */ META: 91,
    // WIN_KEY_LEFT
    /**
   * WIN_KEY_RIGHT
   */ WIN_KEY_RIGHT: 92,
    /**
   * CONTEXT_MENU
   */ CONTEXT_MENU: 93,
    /**
   * NUM_ZERO
   */ NUM_ZERO: 96,
    /**
   * NUM_ONE
   */ NUM_ONE: 97,
    /**
   * NUM_TWO
   */ NUM_TWO: 98,
    /**
   * NUM_THREE
   */ NUM_THREE: 99,
    /**
   * NUM_FOUR
   */ NUM_FOUR: 100,
    /**
   * NUM_FIVE
   */ NUM_FIVE: 101,
    /**
   * NUM_SIX
   */ NUM_SIX: 102,
    /**
   * NUM_SEVEN
   */ NUM_SEVEN: 103,
    /**
   * NUM_EIGHT
   */ NUM_EIGHT: 104,
    /**
   * NUM_NINE
   */ NUM_NINE: 105,
    /**
   * NUM_MULTIPLY
   */ NUM_MULTIPLY: 106,
    /**
   * NUM_PLUS
   */ NUM_PLUS: 107,
    /**
   * NUM_MINUS
   */ NUM_MINUS: 109,
    /**
   * NUM_PERIOD
   */ NUM_PERIOD: 110,
    /**
   * NUM_DIVISION
   */ NUM_DIVISION: 111,
    /**
   * F1
   */ F1: 112,
    /**
   * F2
   */ F2: 113,
    /**
   * F3
   */ F3: 114,
    /**
   * F4
   */ F4: 115,
    /**
   * F5
   */ F5: 116,
    /**
   * F6
   */ F6: 117,
    /**
   * F7
   */ F7: 118,
    /**
   * F8
   */ F8: 119,
    /**
   * F9
   */ F9: 120,
    /**
   * F10
   */ F10: 121,
    /**
   * F11
   */ F11: 122,
    /**
   * F12
   */ F12: 123,
    /**
   * NUMLOCK
   */ NUMLOCK: 144,
    /**
   * SEMICOLON
   */ SEMICOLON: 186,
    // needs localization
    /**
   * DASH
   */ DASH: 189,
    // needs localization
    /**
   * EQUALS
   */ EQUALS: 187,
    // needs localization
    /**
   * COMMA
   */ COMMA: 188,
    // needs localization
    /**
   * PERIOD
   */ PERIOD: 190,
    // needs localization
    /**
   * SLASH
   */ SLASH: 191,
    // needs localization
    /**
   * APOSTROPHE
   */ APOSTROPHE: 192,
    // needs localization
    /**
   * SINGLE_QUOTE
   */ SINGLE_QUOTE: 222,
    // needs localization
    /**
   * OPEN_SQUARE_BRACKET
   */ OPEN_SQUARE_BRACKET: 219,
    // needs localization
    /**
   * BACKSLASH
   */ BACKSLASH: 220,
    // needs localization
    /**
   * CLOSE_SQUARE_BRACKET
   */ CLOSE_SQUARE_BRACKET: 221,
    // needs localization
    /**
   * WIN_KEY
   */ WIN_KEY: 224,
    /**
   * MAC_FF_META
   */ MAC_FF_META: 224,
    // Firefox (Gecko) fires this for the meta key instead of 91
    /**
   * WIN_IME
   */ WIN_IME: 229,
    // ======================== Function ========================
    /**
   * whether text and modified key is entered at the same time.
   */ isTextModifyingKeyEvent: function isTextModifyingKeyEvent(e) {
        const { keyCode } = e;
        if (e.altKey && !e.ctrlKey || e.metaKey || // Function keys don't generate text
        keyCode >= KeyCode.F1 && keyCode <= KeyCode.F12) return false;
        // The following keys are quite harmless, even in combination with
        // CTRL, ALT or SHIFT.
        switch(keyCode){
            case KeyCode.ALT:
            case KeyCode.CAPS_LOCK:
            case KeyCode.CONTEXT_MENU:
            case KeyCode.CTRL:
            case KeyCode.DOWN:
            case KeyCode.END:
            case KeyCode.ESC:
            case KeyCode.HOME:
            case KeyCode.INSERT:
            case KeyCode.LEFT:
            case KeyCode.MAC_FF_META:
            case KeyCode.META:
            case KeyCode.NUMLOCK:
            case KeyCode.NUM_CENTER:
            case KeyCode.PAGE_DOWN:
            case KeyCode.PAGE_UP:
            case KeyCode.PAUSE:
            case KeyCode.PRINT_SCREEN:
            case KeyCode.RIGHT:
            case KeyCode.SHIFT:
            case KeyCode.UP:
            case KeyCode.WIN_KEY:
            case KeyCode.WIN_KEY_RIGHT:
                return false;
            default:
                return true;
        }
    },
    /**
   * whether character is entered.
   */ isCharacterKey: function isCharacterKey(keyCode) {
        if (keyCode >= KeyCode.ZERO && keyCode <= KeyCode.NINE) return true;
        if (keyCode >= KeyCode.NUM_ZERO && keyCode <= KeyCode.NUM_MULTIPLY) return true;
        if (keyCode >= KeyCode.A && keyCode <= KeyCode.Z) return true;
        // Safari sends zero key code for non-latin characters.
        if (window.navigator.userAgent.indexOf('WebKit') !== -1 && keyCode === 0) return true;
        switch(keyCode){
            case KeyCode.SPACE:
            case KeyCode.QUESTION_MARK:
            case KeyCode.NUM_PLUS:
            case KeyCode.NUM_MINUS:
            case KeyCode.NUM_PERIOD:
            case KeyCode.NUM_DIVISION:
            case KeyCode.SEMICOLON:
            case KeyCode.DASH:
            case KeyCode.EQUALS:
            case KeyCode.COMMA:
            case KeyCode.PERIOD:
            case KeyCode.SLASH:
            case KeyCode.APOSTROPHE:
            case KeyCode.SINGLE_QUOTE:
            case KeyCode.OPEN_SQUARE_BRACKET:
            case KeyCode.BACKSLASH:
            case KeyCode.CLOSE_SQUARE_BRACKET:
                return true;
            default:
                return false;
        }
    }
};
var _default = KeyCode;

},
"node_modules/@rc-component/util/es/React/isFragment.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, /**
 * Compatible with React 18 or 19 to check if node is a Fragment.
 */ "default", {
    enumerable: true,
    get: function() {
        return isFragment;
    }
});
const REACT_ELEMENT_TYPE_18 = Symbol.for('react.element');
const REACT_ELEMENT_TYPE_19 = Symbol.for('react.transitional.element');
const REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
function isFragment(object) {
    return(// Base object type
    object && typeof object === 'object' && // React Element type
    (object.$$typeof === REACT_ELEMENT_TYPE_18 || object.$$typeof === REACT_ELEMENT_TYPE_19) && // React Fragment type
    object.type === REACT_FRAGMENT_TYPE);
}

},
"node_modules/@rc-component/util/es/composeProps.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
function composeProps(originProps, patchProps, isAll) {
    const composedProps = {
        ...originProps,
        ...isAll ? patchProps : {}
    };
    Object.keys(patchProps).forEach((key)=>{
        const func = patchProps[key];
        if (typeof func === 'function') composedProps[key] = (...args)=>{
            var _originProps_key;
            func(...args);
            return (_originProps_key = originProps[key]) === null || _originProps_key === void 0 ? void 0 : _originProps_key.call(originProps, ...args);
        };
    });
    return composedProps;
}
var _default = composeProps;

},
"node_modules/@rc-component/util/es/getScrollBarSize.js": function (module, exports, __mako_require__){
/* eslint-disable no-param-reassign */ "use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    default: function() {
        return getScrollBarSize;
    },
    getTargetScrollBarSize: function() {
        return getTargetScrollBarSize;
    }
});
var _dynamicCSS = __mako_require__("node_modules/@rc-component/util/es/Dom/dynamicCSS.js");
let cached;
function measureScrollbarSize(ele) {
    const randomId = `rc-scrollbar-measure-${Math.random().toString(36).substring(7)}`;
    const measureEle = document.createElement('div');
    measureEle.id = randomId;
    // Create Style
    const measureStyle = measureEle.style;
    measureStyle.position = 'absolute';
    measureStyle.left = '0';
    measureStyle.top = '0';
    measureStyle.width = '100px';
    measureStyle.height = '100px';
    measureStyle.overflow = 'scroll';
    // Clone Style if needed
    let fallbackWidth;
    let fallbackHeight;
    if (ele) {
        const targetStyle = getComputedStyle(ele);
        measureStyle.scrollbarColor = targetStyle.scrollbarColor;
        measureStyle.scrollbarWidth = targetStyle.scrollbarWidth;
        // Set Webkit style
        const webkitScrollbarStyle = getComputedStyle(ele, '::-webkit-scrollbar');
        const width = parseInt(webkitScrollbarStyle.width, 10);
        const height = parseInt(webkitScrollbarStyle.height, 10);
        // Try wrap to handle CSP case
        try {
            const widthStyle = width ? `width: ${webkitScrollbarStyle.width};` : '';
            const heightStyle = height ? `height: ${webkitScrollbarStyle.height};` : '';
            (0, _dynamicCSS.updateCSS)(`
#${randomId}::-webkit-scrollbar {
${widthStyle}
${heightStyle}
}`, randomId);
        } catch (e) {
            // Can't wrap, just log error
            console.error(e);
            // Get from style directly
            fallbackWidth = width;
            fallbackHeight = height;
        }
    }
    document.body.appendChild(measureEle);
    // Measure. Get fallback style if provided
    const scrollWidth = ele && fallbackWidth && !isNaN(fallbackWidth) ? fallbackWidth : measureEle.offsetWidth - measureEle.clientWidth;
    const scrollHeight = ele && fallbackHeight && !isNaN(fallbackHeight) ? fallbackHeight : measureEle.offsetHeight - measureEle.clientHeight;
    // Clean up
    document.body.removeChild(measureEle);
    (0, _dynamicCSS.removeCSS)(randomId);
    return {
        width: scrollWidth,
        height: scrollHeight
    };
}
function getScrollBarSize(fresh) {
    if (typeof document === 'undefined') return 0;
    if (fresh || cached === undefined) cached = measureScrollbarSize();
    return cached.width;
}
function getTargetScrollBarSize(target) {
    if (typeof document === 'undefined' || !target || !(target instanceof Element)) return {
        width: 0,
        height: 0
    };
    return measureScrollbarSize(target);
}

},
"node_modules/@rc-component/util/es/hooks/useControlledState.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, /**
 * Similar to `useState` but will use props value if provided.
 * From React 18, we do not need safe `useState` since it will not throw for unmounted update.
 * This hooks remove the `onChange` & `postState` logic since we only need basic merged state logic.
 */ "default", {
    enumerable: true,
    get: function() {
        return useControlledState;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _react = __mako_require__("node_modules/react/index.js");
var _useLayoutEffect = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/hooks/useLayoutEffect.js"));
function useControlledState(defaultStateValue, value) {
    const [innerValue, setInnerValue] = (0, _react.useState)(defaultStateValue);
    const mergedValue = value !== undefined ? value : innerValue;
    (0, _useLayoutEffect.default)((mount)=>{
        if (!mount) setInnerValue(value);
    }, [
        value
    ]);
    return [
        // Value
        mergedValue,
        // Update function
        setInnerValue
    ];
}

},
"node_modules/@rc-component/util/es/hooks/useEvent.js": function (module, exports, __mako_require__){
/* eslint-disable @typescript-eslint/ban-types */ /* eslint-disable react-hooks/exhaustive-deps */ "use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
function useEvent(callback) {
    const fnRef = _react.useRef(callback);
    fnRef.current = callback;
    const memoFn = _react.useCallback((...args)=>{
        var _fnRef_current;
        return (_fnRef_current = fnRef.current) === null || _fnRef_current === void 0 ? void 0 : _fnRef_current.call(fnRef, ...args);
    }, []);
    return memoFn;
}
var _default = useEvent;

},
"node_modules/@rc-component/util/es/hooks/useId.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    default: function() {
        return _default;
    },
    resetUuid: function() {
        return resetUuid;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
function getUseId() {
    // We need fully clone React function here to avoid webpack warning React 17 do not export `useId`
    const fullClone = {
        ..._react
    };
    return fullClone.useId;
}
let uuid = 0;
function resetUuid() {
    uuid = 0;
}
const useOriginId = getUseId();
var _default = useOriginId ? // Use React `useId`
function useId(id) {
    const reactId = useOriginId();
    // Developer passed id is single source of truth
    if (id) return id;
    return reactId;
} : // Use compatible of `useId`
function useCompatId(id) {
    // Inner id for accessibility usage. Only work in client side
    const [innerId, setInnerId] = _react.useState('ssr-id');
    _react.useEffect(()=>{
        const nextId = uuid;
        uuid += 1;
        setInnerId(`rc_unique_${nextId}`);
    }, []);
    // Developer passed id is single source of truth
    if (id) return id;
    // Return react native id or inner id
    return innerId;
};

},
"node_modules/@rc-component/util/es/hooks/useLayoutEffect.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    default: function() {
        return _default;
    },
    useLayoutUpdateEffect: function() {
        return useLayoutUpdateEffect;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
var _canUseDom = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/Dom/canUseDom.js"));
/**
 * Wrap `React.useLayoutEffect` which will not throw warning message in test env
 */ const useInternalLayoutEffect = (0, _canUseDom.default)() ? _react.useLayoutEffect : _react.useEffect;
const useLayoutEffect = (callback, deps)=>{
    const firstMountRef = _react.useRef(true);
    useInternalLayoutEffect(()=>{
        return callback(firstMountRef.current);
    }, deps);
    // We tell react that first mount has passed
    useInternalLayoutEffect(()=>{
        firstMountRef.current = false;
        return ()=>{
            firstMountRef.current = true;
        };
    }, []);
};
const useLayoutUpdateEffect = (callback, deps)=>{
    useLayoutEffect((firstMount)=>{
        if (!firstMount) return callback();
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, deps);
};
var _default = useLayoutEffect;

},
"node_modules/@rc-component/util/es/hooks/useMemo.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return useMemo;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
function useMemo(getValue, condition, shouldUpdate) {
    const cacheRef = _react.useRef({});
    if (!('value' in cacheRef.current) || shouldUpdate(cacheRef.current.condition, condition)) {
        cacheRef.current.value = getValue();
        cacheRef.current.condition = condition;
    }
    return cacheRef.current.value;
}

},
"node_modules/@rc-component/util/es/hooks/useMergedState.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, /**
 * @deprecated Please use `useControlledState` instead if not need support < React 18.
 * Similar to `useState` but will use props value if provided.
 * Note that internal use rc-util `useState` hook.
 */ "default", {
    enumerable: true,
    get: function() {
        return useMergedState;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _useEvent = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/hooks/useEvent.js"));
var _useLayoutEffect = __mako_require__("node_modules/@rc-component/util/es/hooks/useLayoutEffect.js");
var _useState = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/hooks/useState.js"));
/** We only think `undefined` is empty */ function hasValue(value) {
    return value !== undefined;
}
function useMergedState(defaultStateValue, option) {
    const { defaultValue, value, onChange, postState } = option || {};
    // ======================= Init =======================
    const [innerValue, setInnerValue] = (0, _useState.default)(()=>{
        if (hasValue(value)) return value;
        else if (hasValue(defaultValue)) return typeof defaultValue === 'function' ? defaultValue() : defaultValue;
        else return typeof defaultStateValue === 'function' ? defaultStateValue() : defaultStateValue;
    });
    const mergedValue = value !== undefined ? value : innerValue;
    const postMergedValue = postState ? postState(mergedValue) : mergedValue;
    // ====================== Change ======================
    const onChangeFn = (0, _useEvent.default)(onChange);
    const [prevValue, setPrevValue] = (0, _useState.default)([
        mergedValue
    ]);
    (0, _useLayoutEffect.useLayoutUpdateEffect)(()=>{
        const prev = prevValue[0];
        if (innerValue !== prev) onChangeFn(innerValue, prev);
    }, [
        prevValue
    ]);
    // Sync value back to `undefined` when it from control to un-control
    (0, _useLayoutEffect.useLayoutUpdateEffect)(()=>{
        if (!hasValue(value)) setInnerValue(value);
    }, [
        value
    ]);
    // ====================== Update ======================
    const triggerChange = (0, _useEvent.default)((updater, ignoreDestroy)=>{
        setInnerValue(updater, ignoreDestroy);
        setPrevValue([
            mergedValue
        ], ignoreDestroy);
    });
    return [
        postMergedValue,
        triggerChange
    ];
}

},
"node_modules/@rc-component/util/es/hooks/useState.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, /**
 * Same as React.useState but `setState` accept `ignoreDestroy` param to not to setState after destroyed.
 * We do not make this auto is to avoid real memory leak.
 * Developer should confirm it's safe to ignore themselves.
 */ "default", {
    enumerable: true,
    get: function() {
        return useSafeState;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
function useSafeState(defaultValue) {
    const destroyRef = _react.useRef(false);
    const [value, setValue] = _react.useState(defaultValue);
    _react.useEffect(()=>{
        destroyRef.current = false;
        return ()=>{
            destroyRef.current = true;
        };
    }, []);
    function safeSetState(updater, ignoreDestroy) {
        if (ignoreDestroy && destroyRef.current) return;
        setValue(updater);
    }
    return [
        value,
        safeSetState
    ];
}

},
"node_modules/@rc-component/util/es/hooks/useSyncState.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, /**
 * Same as React.useState but will always get latest state.
 * This is useful when React merge multiple state updates into one.
 * e.g. onTransitionEnd trigger multiple event at once will be merged state update in React.
 */ "default", {
    enumerable: true,
    get: function() {
        return useSyncState;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
var _useEvent = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/hooks/useEvent.js"));
function useSyncState(defaultValue) {
    const [, forceUpdate] = _react.useReducer((x)=>x + 1, 0);
    const currentValueRef = _react.useRef(defaultValue);
    const getValue = (0, _useEvent.default)(()=>{
        return currentValueRef.current;
    });
    const setValue = (0, _useEvent.default)((updater)=>{
        currentValueRef.current = typeof updater === 'function' ? updater(currentValueRef.current) : updater;
        forceUpdate();
    });
    return [
        getValue,
        setValue
    ];
}

},
"node_modules/@rc-component/util/es/index.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    get: function() {
        return _get.default;
    },
    merge: function() {
        return _set.merge;
    },
    mergeWith: function() {
        return _set.mergeWith;
    },
    noteOnce: function() {
        return _warning.noteOnce;
    },
    omit: function() {
        return _omit.default;
    },
    set: function() {
        return _set.default;
    },
    supportNodeRef: function() {
        return _ref.supportNodeRef;
    },
    supportRef: function() {
        return _ref.supportRef;
    },
    toArray: function() {
        return _toArray.default;
    },
    useComposeRef: function() {
        return _ref.useComposeRef;
    },
    useControlledState: function() {
        return _useControlledState.default;
    },
    useEvent: function() {
        return _useEvent.default;
    },
    useMergedState: function() {
        return _useMergedState.default;
    },
    warning: function() {
        return _warning.default;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _useEvent = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/hooks/useEvent.js"));
var _useMergedState = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/hooks/useMergedState.js"));
var _useControlledState = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/hooks/useControlledState.js"));
var _ref = __mako_require__("node_modules/@rc-component/util/es/ref.js");
var _get = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/utils/get.js"));
var _set = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/@rc-component/util/es/utils/set.js"));
var _warning = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/@rc-component/util/es/warning.js"));
var _omit = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/omit.js"));
var _toArray = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/Children/toArray.js"));

},
"node_modules/@rc-component/util/es/isMobile.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _ismobile = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/is-mobile/index.js"));
let cached;
var _default = ()=>{
    if (typeof cached === 'undefined') cached = (0, _ismobile.default)();
    return cached;
};

},
"node_modules/@rc-component/util/es/omit.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return omit;
    }
});
function omit(obj, fields) {
    const clone = Object.assign({}, obj);
    if (Array.isArray(fields)) fields.forEach((key)=>{
        delete clone[key];
    });
    return clone;
}

},
"node_modules/@rc-component/util/es/pickAttrs.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, /**
 * Picker props from exist props with filter
 * @param props Passed props
 * @param ariaOnly boolean | { aria?: boolean; data?: boolean; attr?: boolean; } filter config
 */ "default", {
    enumerable: true,
    get: function() {
        return pickAttrs;
    }
});
const attributes = `accept acceptCharset accessKey action allowFullScreen allowTransparency
    alt async autoComplete autoFocus autoPlay capture cellPadding cellSpacing challenge
    charSet checked classID className colSpan cols content contentEditable contextMenu
    controls coords crossOrigin data dateTime default defer dir disabled download draggable
    encType form formAction formEncType formMethod formNoValidate formTarget frameBorder
    headers height hidden high href hrefLang htmlFor httpEquiv icon id inputMode integrity
    is keyParams keyType kind label lang list loop low manifest marginHeight marginWidth max maxLength media
    mediaGroup method min minLength multiple muted name noValidate nonce open
    optimum pattern placeholder poster preload radioGroup readOnly rel required
    reversed role rowSpan rows sandbox scope scoped scrolling seamless selected
    shape size sizes span spellCheck src srcDoc srcLang srcSet start step style
    summary tabIndex target title type useMap value width wmode wrap`;
const eventsName = `onCopy onCut onPaste onCompositionEnd onCompositionStart onCompositionUpdate onKeyDown
    onKeyPress onKeyUp onFocus onBlur onChange onInput onSubmit onClick onContextMenu onDoubleClick
    onDrag onDragEnd onDragEnter onDragExit onDragLeave onDragOver onDragStart onDrop onMouseDown
    onMouseEnter onMouseLeave onMouseMove onMouseOut onMouseOver onMouseUp onSelect onTouchCancel
    onTouchEnd onTouchMove onTouchStart onScroll onWheel onAbort onCanPlay onCanPlayThrough
    onDurationChange onEmptied onEncrypted onEnded onError onLoadedData onLoadedMetadata
    onLoadStart onPause onPlay onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend onTimeUpdate onVolumeChange onWaiting onLoad onError`;
const propList = `${attributes} ${eventsName}`.split(/[\s\n]+/);
/* eslint-enable max-len */ const ariaPrefix = 'aria-';
const dataPrefix = 'data-';
function match(key, prefix) {
    return key.indexOf(prefix) === 0;
}
function pickAttrs(props, ariaOnly = false) {
    let mergedConfig;
    if (ariaOnly === false) mergedConfig = {
        aria: true,
        data: true,
        attr: true
    };
    else if (ariaOnly === true) mergedConfig = {
        aria: true
    };
    else mergedConfig = {
        ...ariaOnly
    };
    const attrs = {};
    Object.keys(props).forEach((key)=>{
        if (// Aria
        mergedConfig.aria && (key === 'role' || match(key, ariaPrefix)) || // Data
        mergedConfig.data && match(key, dataPrefix) || // Attr
        mergedConfig.attr && propList.includes(key)) attrs[key] = props[key];
    });
    return attrs;
}

},
"node_modules/@rc-component/util/es/raf.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
let raf = (callback)=>+setTimeout(callback, 16);
let caf = (num)=>clearTimeout(num);
if (typeof window !== 'undefined' && 'requestAnimationFrame' in window) {
    raf = (callback)=>window.requestAnimationFrame(callback);
    caf = (handle)=>window.cancelAnimationFrame(handle);
}
let rafUUID = 0;
const rafIds = new Map();
function cleanup(id) {
    rafIds.delete(id);
}
const wrapperRaf = (callback, times = 1)=>{
    rafUUID += 1;
    const id = rafUUID;
    function callRef(leftTimes) {
        if (leftTimes === 0) {
            // Clean up
            cleanup(id);
            // Trigger
            callback();
        } else {
            // Next raf
            const realId = raf(()=>{
                callRef(leftTimes - 1);
            });
            // Bind real raf id
            rafIds.set(id, realId);
        }
    }
    callRef(times);
    return id;
};
wrapperRaf.cancel = (id)=>{
    const realId = rafIds.get(id);
    cleanup(id);
    return caf(realId);
};
wrapperRaf.ids = ()=>rafIds;
var _default = wrapperRaf;

},
"node_modules/@rc-component/util/es/ref.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    composeRef: function() {
        return composeRef;
    },
    fillRef: function() {
        return fillRef;
    },
    getNodeRef: function() {
        return getNodeRef;
    },
    supportNodeRef: function() {
        return supportNodeRef;
    },
    supportRef: function() {
        return supportRef;
    },
    useComposeRef: function() {
        return useComposeRef;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _react = __mako_require__("node_modules/react/index.js");
var _reactis = __mako_require__("node_modules/react-is/index.js");
var _useMemo = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/hooks/useMemo.js"));
var _isFragment = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/React/isFragment.js"));
const ReactMajorVersion = Number(_react.version.split('.')[0]);
const fillRef = (ref, node)=>{
    if (typeof ref === 'function') ref(node);
    else if (typeof ref === 'object' && ref && 'current' in ref) ref.current = node;
};
const composeRef = (...refs)=>{
    const refList = refs.filter(Boolean);
    if (refList.length <= 1) return refList[0];
    return (node)=>{
        refs.forEach((ref)=>{
            fillRef(ref, node);
        });
    };
};
const useComposeRef = (...refs)=>{
    return (0, _useMemo.default)(()=>composeRef(...refs), // eslint-disable-next-line react-hooks/exhaustive-deps
    refs, (prev, next)=>prev.length !== next.length || prev.every((ref, i)=>ref !== next[i]));
};
const supportRef = (nodeOrComponent)=>{
    var _type_prototype, _nodeOrComponent_prototype;
    if (!nodeOrComponent) return false;
    // React 19 no need `forwardRef` anymore. So just pass if is a React element.
    if (isReactElement(nodeOrComponent) && ReactMajorVersion >= 19) return true;
    const type = (0, _reactis.isMemo)(nodeOrComponent) ? nodeOrComponent.type.type : nodeOrComponent.type;
    // Function component node
    if (typeof type === 'function' && !((_type_prototype = type.prototype) === null || _type_prototype === void 0 ? void 0 : _type_prototype.render) && type.$$typeof !== _reactis.ForwardRef) return false;
    // Class component
    if (typeof nodeOrComponent === 'function' && !((_nodeOrComponent_prototype = nodeOrComponent.prototype) === null || _nodeOrComponent_prototype === void 0 ? void 0 : _nodeOrComponent_prototype.render) && nodeOrComponent.$$typeof !== _reactis.ForwardRef) return false;
    return true;
};
function isReactElement(node) {
    return /*#__PURE__*/ (0, _react.isValidElement)(node) && !(0, _isFragment.default)(node);
}
const supportNodeRef = (node)=>{
    return isReactElement(node) && supportRef(node);
};
const getNodeRef = (node)=>{
    if (node && isReactElement(node)) {
        const ele = node;
        // Source from:
        // https://github.com/mui/material-ui/blob/master/packages/mui-utils/src/getReactNodeRef/getReactNodeRef.ts
        return ele.props.propertyIsEnumerable('ref') ? ele.props.ref : ele.ref;
    }
    return null;
};

},
"node_modules/@rc-component/util/es/utils/get.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return get;
    }
});
function get(entity, path) {
    let current = entity;
    for(let i = 0; i < path.length; i += 1){
        if (current === null || current === undefined) return undefined;
        current = current[path[i]];
    }
    return current;
}

},
"node_modules/@rc-component/util/es/utils/set.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    default: function() {
        return set;
    },
    merge: function() {
        return merge;
    },
    mergeWith: function() {
        return mergeWith;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _get = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@rc-component/util/es/utils/get.js"));
function internalSet(entity, paths, value, removeIfUndefined) {
    if (!paths.length) return value;
    const [path, ...restPath] = paths;
    let clone;
    if (!entity && typeof path === 'number') clone = [];
    else if (Array.isArray(entity)) clone = [
        ...entity
    ];
    else clone = {
        ...entity
    };
    // Delete prop if `removeIfUndefined` and value is undefined
    if (removeIfUndefined && value === undefined && restPath.length === 1) delete clone[path][restPath[0]];
    else clone[path] = internalSet(clone[path], restPath, value, removeIfUndefined);
    return clone;
}
function set(entity, paths, value, removeIfUndefined = false) {
    // Do nothing if `removeIfUndefined` and parent object not exist
    if (paths.length && removeIfUndefined && value === undefined && !(0, _get.default)(entity, paths.slice(0, -1))) return entity;
    return internalSet(entity, paths, value, removeIfUndefined);
}
function isObject(obj) {
    return typeof obj === 'object' && obj !== null && Object.getPrototypeOf(obj) === Object.prototype;
}
function createEmpty(source) {
    return Array.isArray(source) ? [] : {};
}
const keys = typeof Reflect === 'undefined' ? Object.keys : Reflect.ownKeys;
function mergeWith(sources, config = {}) {
    const { prepareArray } = config;
    const finalPrepareArray = prepareArray || (()=>[]);
    let clone = createEmpty(sources[0]);
    sources.forEach((src)=>{
        function internalMerge(path, parentLoopSet) {
            const loopSet = new Set(parentLoopSet);
            const value = (0, _get.default)(src, path);
            const isArr = Array.isArray(value);
            if (isArr || isObject(value)) // Only add not loop obj
            {
                if (!loopSet.has(value)) {
                    loopSet.add(value);
                    const originValue = (0, _get.default)(clone, path);
                    if (isArr) // Array will always be override
                    clone = set(clone, path, finalPrepareArray(originValue, value));
                    else if (!originValue || typeof originValue !== 'object') // Init container if not exist
                    clone = set(clone, path, createEmpty(value));
                    keys(value).forEach((key)=>{
                        internalMerge([
                            ...path,
                            key
                        ], loopSet);
                    });
                }
            } else clone = set(clone, path, value);
        }
        internalMerge([]);
    });
    return clone;
}
function merge(...sources) {
    return mergeWith(sources);
}

},
"node_modules/@rc-component/util/es/warning.js": function (module, exports, __mako_require__){
/* eslint-disable no-console */ "use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    call: function() {
        return call;
    },
    default: function() {
        return _default;
    },
    note: function() {
        return note;
    },
    noteOnce: function() {
        return noteOnce;
    },
    preMessage: function() {
        return preMessage;
    },
    resetWarned: function() {
        return resetWarned;
    },
    warning: function() {
        return warning;
    },
    warningOnce: function() {
        return warningOnce;
    }
});
let warned = {};
const preWarningFns = [];
const preMessage = (fn)=>{
    preWarningFns.push(fn);
};
function warning(valid, message) {
    if (!valid && console !== undefined) {
        const finalMessage = preWarningFns.reduce((msg, preMessageFn)=>preMessageFn(msg ?? '', 'warning'), message);
        if (finalMessage) console.error(`Warning: ${finalMessage}`);
    }
}
function note(valid, message) {
    if (!valid && console !== undefined) {
        const finalMessage = preWarningFns.reduce((msg, preMessageFn)=>preMessageFn(msg ?? '', 'note'), message);
        if (finalMessage) console.warn(`Note: ${finalMessage}`);
    }
}
function resetWarned() {
    warned = {};
}
function call(method, valid, message) {
    if (!valid && !warned[message]) {
        method(false, message);
        warned[message] = true;
    }
}
function warningOnce(valid, message) {
    call(warning, valid, message);
}
function noteOnce(valid, message) {
    call(note, valid, message);
}
warningOnce.preMessage = preMessage;
warningOnce.resetWarned = resetWarned;
warningOnce.noteOnce = noteOnce;
var _default = warningOnce;

},
"node_modules/@rc-component/util/lib/Dom/contains.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
exports.default = contains;
function contains(root, n) {
    if (!root) return false;
    // Use native if support
    if (root.contains) return root.contains(n);
    // `document.contains` not support with IE11
    let node = n;
    while(node){
        if (node === root) return true;
        node = node.parentNode;
    }
    return false;
}

},
"node_modules/@rc-component/util/lib/Dom/focus.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
exports.getFocusNodeList = getFocusNodeList;
exports.lockFocus = lockFocus;
exports.triggerFocus = triggerFocus;
exports.useLockFocus = useLockFocus;
var _react = __mako_require__("node_modules/react/index.js");
var _isVisible = _interopRequireDefault(__mako_require__("node_modules/@rc-component/util/lib/Dom/isVisible.js"));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function focusable(node, includePositive = false) {
    if ((0, _isVisible.default)(node)) {
        const nodeName = node.nodeName.toLowerCase();
        const isFocusableElement = // Focusable element
        [
            'input',
            'select',
            'textarea',
            'button'
        ].includes(nodeName) || // Editable element
        node.isContentEditable || // Anchor with href element
        nodeName === 'a' && !!node.getAttribute('href');
        // Get tabIndex
        const tabIndexAttr = node.getAttribute('tabindex');
        const tabIndexNum = Number(tabIndexAttr);
        // Parse as number if validate
        let tabIndex = null;
        if (tabIndexAttr && !Number.isNaN(tabIndexNum)) tabIndex = tabIndexNum;
        else if (isFocusableElement && tabIndex === null) tabIndex = 0;
        // Block focusable if disabled
        if (isFocusableElement && node.disabled) tabIndex = null;
        return tabIndex !== null && (tabIndex >= 0 || includePositive && tabIndex < 0);
    }
    return false;
}
function getFocusNodeList(node, includePositive = false) {
    const res = [
        ...node.querySelectorAll('*')
    ].filter((child)=>{
        return focusable(child, includePositive);
    });
    if (focusable(node, includePositive)) res.unshift(node);
    return res;
}
// Used for `rc-input` `rc-textarea` `rc-input-number`
/**
 * Focus element and set cursor position for input/textarea elements.
 */ function triggerFocus(element, option) {
    if (!element) return;
    element.focus(option);
    // Selection content
    const { cursor } = option || {};
    if (cursor && (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement)) {
        const len = element.value.length;
        switch(cursor){
            case 'start':
                element.setSelectionRange(0, 0);
                break;
            case 'end':
                element.setSelectionRange(len, len);
                break;
            default:
                element.setSelectionRange(0, len);
        }
    }
}
// ======================================================
// ==                    Lock Focus                    ==
// ======================================================
let lastFocusElement = null;
let focusElements = [];
function getLastElement() {
    return focusElements[focusElements.length - 1];
}
function hasFocus(element) {
    const { activeElement } = document;
    return element === activeElement || element.contains(activeElement);
}
function syncFocus() {
    const lastElement = getLastElement();
    const { activeElement } = document;
    if (lastElement && !hasFocus(lastElement)) {
        const focusableList = getFocusNodeList(lastElement);
        const matchElement = focusableList.includes(lastFocusElement) ? lastFocusElement : focusableList[0];
        matchElement === null || matchElement === void 0 || matchElement.focus();
    } else lastFocusElement = activeElement;
}
function onWindowKeyDown(e) {
    if (e.key === 'Tab') {
        const { activeElement } = document;
        const lastElement = getLastElement();
        const focusableList = getFocusNodeList(lastElement);
        const last = focusableList[focusableList.length - 1];
        if (e.shiftKey && activeElement === focusableList[0]) // Tab backward on first focusable element
        lastFocusElement = last;
        else if (!e.shiftKey && activeElement === last) // Tab forward on last focusable element
        lastFocusElement = focusableList[0];
    }
}
/**
 * Lock focus in the element.
 * It will force back to the first focusable element when focus leaves the element.
 */ function lockFocus(element) {
    if (element) {
        // Refresh focus elements
        focusElements = focusElements.filter((ele)=>ele !== element);
        focusElements.push(element);
        // Just add event since it will de-duplicate
        window.addEventListener('focusin', syncFocus);
        window.addEventListener('keydown', onWindowKeyDown, true);
        syncFocus();
    }
    // Always return unregister function
    return ()=>{
        lastFocusElement = null;
        focusElements = focusElements.filter((ele)=>ele !== element);
        if (focusElements.length === 0) {
            window.removeEventListener('focusin', syncFocus);
            window.removeEventListener('keydown', onWindowKeyDown, true);
        }
    };
}
/**
 * Lock focus within an element.
 * When locked, focus will be restricted to focusable elements within the specified element.
 * If multiple elements are locked, only the last locked element will be effective.
 */ function useLockFocus(lock, getElement) {
    (0, _react.useEffect)(()=>{
        if (lock) {
            const element = getElement();
            if (element) return lockFocus(element);
        }
    }, [
        lock
    ]);
}

},
"node_modules/@rc-component/util/lib/Dom/isVisible.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _default = (element)=>{
    if (!element) return false;
    if (element instanceof Element) {
        if (element.offsetParent) return true;
        if (element.getBBox) {
            const { width, height } = element.getBBox();
            if (width || height) return true;
        }
        if (element.getBoundingClientRect) {
            const { width, height } = element.getBoundingClientRect();
            if (width || height) return true;
        }
    }
    return false;
};
exports.default = _default;

},
"node_modules/@rc-component/util/lib/KeyCode.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
exports.default = void 0;
/**
 * @ignore
 * some key-codes definition and utils from closure-library
 * @author yiminghe@gmail.com
 */ const KeyCode = {
    /**
   * MAC_ENTER
   */ MAC_ENTER: 3,
    /**
   * BACKSPACE
   */ BACKSPACE: 8,
    /**
   * TAB
   */ TAB: 9,
    /**
   * NUMLOCK on FF/Safari Mac
   */ NUM_CENTER: 12,
    // NUMLOCK on FF/Safari Mac
    /**
   * ENTER
   */ ENTER: 13,
    /**
   * SHIFT
   */ SHIFT: 16,
    /**
   * CTRL
   */ CTRL: 17,
    /**
   * ALT
   */ ALT: 18,
    /**
   * PAUSE
   */ PAUSE: 19,
    /**
   * CAPS_LOCK
   */ CAPS_LOCK: 20,
    /**
   * ESC
   */ ESC: 27,
    /**
   * SPACE
   */ SPACE: 32,
    /**
   * PAGE_UP
   */ PAGE_UP: 33,
    // also NUM_NORTH_EAST
    /**
   * PAGE_DOWN
   */ PAGE_DOWN: 34,
    // also NUM_SOUTH_EAST
    /**
   * END
   */ END: 35,
    // also NUM_SOUTH_WEST
    /**
   * HOME
   */ HOME: 36,
    // also NUM_NORTH_WEST
    /**
   * LEFT
   */ LEFT: 37,
    // also NUM_WEST
    /**
   * UP
   */ UP: 38,
    // also NUM_NORTH
    /**
   * RIGHT
   */ RIGHT: 39,
    // also NUM_EAST
    /**
   * DOWN
   */ DOWN: 40,
    // also NUM_SOUTH
    /**
   * PRINT_SCREEN
   */ PRINT_SCREEN: 44,
    /**
   * INSERT
   */ INSERT: 45,
    // also NUM_INSERT
    /**
   * DELETE
   */ DELETE: 46,
    // also NUM_DELETE
    /**
   * ZERO
   */ ZERO: 48,
    /**
   * ONE
   */ ONE: 49,
    /**
   * TWO
   */ TWO: 50,
    /**
   * THREE
   */ THREE: 51,
    /**
   * FOUR
   */ FOUR: 52,
    /**
   * FIVE
   */ FIVE: 53,
    /**
   * SIX
   */ SIX: 54,
    /**
   * SEVEN
   */ SEVEN: 55,
    /**
   * EIGHT
   */ EIGHT: 56,
    /**
   * NINE
   */ NINE: 57,
    /**
   * QUESTION_MARK
   */ QUESTION_MARK: 63,
    // needs localization
    /**
   * A
   */ A: 65,
    /**
   * B
   */ B: 66,
    /**
   * C
   */ C: 67,
    /**
   * D
   */ D: 68,
    /**
   * E
   */ E: 69,
    /**
   * F
   */ F: 70,
    /**
   * G
   */ G: 71,
    /**
   * H
   */ H: 72,
    /**
   * I
   */ I: 73,
    /**
   * J
   */ J: 74,
    /**
   * K
   */ K: 75,
    /**
   * L
   */ L: 76,
    /**
   * M
   */ M: 77,
    /**
   * N
   */ N: 78,
    /**
   * O
   */ O: 79,
    /**
   * P
   */ P: 80,
    /**
   * Q
   */ Q: 81,
    /**
   * R
   */ R: 82,
    /**
   * S
   */ S: 83,
    /**
   * T
   */ T: 84,
    /**
   * U
   */ U: 85,
    /**
   * V
   */ V: 86,
    /**
   * W
   */ W: 87,
    /**
   * X
   */ X: 88,
    /**
   * Y
   */ Y: 89,
    /**
   * Z
   */ Z: 90,
    /**
   * META
   */ META: 91,
    // WIN_KEY_LEFT
    /**
   * WIN_KEY_RIGHT
   */ WIN_KEY_RIGHT: 92,
    /**
   * CONTEXT_MENU
   */ CONTEXT_MENU: 93,
    /**
   * NUM_ZERO
   */ NUM_ZERO: 96,
    /**
   * NUM_ONE
   */ NUM_ONE: 97,
    /**
   * NUM_TWO
   */ NUM_TWO: 98,
    /**
   * NUM_THREE
   */ NUM_THREE: 99,
    /**
   * NUM_FOUR
   */ NUM_FOUR: 100,
    /**
   * NUM_FIVE
   */ NUM_FIVE: 101,
    /**
   * NUM_SIX
   */ NUM_SIX: 102,
    /**
   * NUM_SEVEN
   */ NUM_SEVEN: 103,
    /**
   * NUM_EIGHT
   */ NUM_EIGHT: 104,
    /**
   * NUM_NINE
   */ NUM_NINE: 105,
    /**
   * NUM_MULTIPLY
   */ NUM_MULTIPLY: 106,
    /**
   * NUM_PLUS
   */ NUM_PLUS: 107,
    /**
   * NUM_MINUS
   */ NUM_MINUS: 109,
    /**
   * NUM_PERIOD
   */ NUM_PERIOD: 110,
    /**
   * NUM_DIVISION
   */ NUM_DIVISION: 111,
    /**
   * F1
   */ F1: 112,
    /**
   * F2
   */ F2: 113,
    /**
   * F3
   */ F3: 114,
    /**
   * F4
   */ F4: 115,
    /**
   * F5
   */ F5: 116,
    /**
   * F6
   */ F6: 117,
    /**
   * F7
   */ F7: 118,
    /**
   * F8
   */ F8: 119,
    /**
   * F9
   */ F9: 120,
    /**
   * F10
   */ F10: 121,
    /**
   * F11
   */ F11: 122,
    /**
   * F12
   */ F12: 123,
    /**
   * NUMLOCK
   */ NUMLOCK: 144,
    /**
   * SEMICOLON
   */ SEMICOLON: 186,
    // needs localization
    /**
   * DASH
   */ DASH: 189,
    // needs localization
    /**
   * EQUALS
   */ EQUALS: 187,
    // needs localization
    /**
   * COMMA
   */ COMMA: 188,
    // needs localization
    /**
   * PERIOD
   */ PERIOD: 190,
    // needs localization
    /**
   * SLASH
   */ SLASH: 191,
    // needs localization
    /**
   * APOSTROPHE
   */ APOSTROPHE: 192,
    // needs localization
    /**
   * SINGLE_QUOTE
   */ SINGLE_QUOTE: 222,
    // needs localization
    /**
   * OPEN_SQUARE_BRACKET
   */ OPEN_SQUARE_BRACKET: 219,
    // needs localization
    /**
   * BACKSLASH
   */ BACKSLASH: 220,
    // needs localization
    /**
   * CLOSE_SQUARE_BRACKET
   */ CLOSE_SQUARE_BRACKET: 221,
    // needs localization
    /**
   * WIN_KEY
   */ WIN_KEY: 224,
    /**
   * MAC_FF_META
   */ MAC_FF_META: 224,
    // Firefox (Gecko) fires this for the meta key instead of 91
    /**
   * WIN_IME
   */ WIN_IME: 229,
    // ======================== Function ========================
    /**
   * whether text and modified key is entered at the same time.
   */ isTextModifyingKeyEvent: function isTextModifyingKeyEvent(e) {
        const { keyCode } = e;
        if (e.altKey && !e.ctrlKey || e.metaKey || // Function keys don't generate text
        keyCode >= KeyCode.F1 && keyCode <= KeyCode.F12) return false;
        // The following keys are quite harmless, even in combination with
        // CTRL, ALT or SHIFT.
        switch(keyCode){
            case KeyCode.ALT:
            case KeyCode.CAPS_LOCK:
            case KeyCode.CONTEXT_MENU:
            case KeyCode.CTRL:
            case KeyCode.DOWN:
            case KeyCode.END:
            case KeyCode.ESC:
            case KeyCode.HOME:
            case KeyCode.INSERT:
            case KeyCode.LEFT:
            case KeyCode.MAC_FF_META:
            case KeyCode.META:
            case KeyCode.NUMLOCK:
            case KeyCode.NUM_CENTER:
            case KeyCode.PAGE_DOWN:
            case KeyCode.PAGE_UP:
            case KeyCode.PAUSE:
            case KeyCode.PRINT_SCREEN:
            case KeyCode.RIGHT:
            case KeyCode.SHIFT:
            case KeyCode.UP:
            case KeyCode.WIN_KEY:
            case KeyCode.WIN_KEY_RIGHT:
                return false;
            default:
                return true;
        }
    },
    /**
   * whether character is entered.
   */ isCharacterKey: function isCharacterKey(keyCode) {
        if (keyCode >= KeyCode.ZERO && keyCode <= KeyCode.NINE) return true;
        if (keyCode >= KeyCode.NUM_ZERO && keyCode <= KeyCode.NUM_MULTIPLY) return true;
        if (keyCode >= KeyCode.A && keyCode <= KeyCode.Z) return true;
        // Safari sends zero key code for non-latin characters.
        if (window.navigator.userAgent.indexOf('WebKit') !== -1 && keyCode === 0) return true;
        switch(keyCode){
            case KeyCode.SPACE:
            case KeyCode.QUESTION_MARK:
            case KeyCode.NUM_PLUS:
            case KeyCode.NUM_MINUS:
            case KeyCode.NUM_PERIOD:
            case KeyCode.NUM_DIVISION:
            case KeyCode.SEMICOLON:
            case KeyCode.DASH:
            case KeyCode.EQUALS:
            case KeyCode.COMMA:
            case KeyCode.PERIOD:
            case KeyCode.SLASH:
            case KeyCode.APOSTROPHE:
            case KeyCode.SINGLE_QUOTE:
            case KeyCode.OPEN_SQUARE_BRACKET:
            case KeyCode.BACKSLASH:
            case KeyCode.CLOSE_SQUARE_BRACKET:
                return true;
            default:
                return false;
        }
    }
};
var _default = exports.default = KeyCode;

},
"node_modules/@rc-component/util/lib/React/isFragment.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
exports.default = isFragment;
const REACT_ELEMENT_TYPE_18 = Symbol.for('react.element');
const REACT_ELEMENT_TYPE_19 = Symbol.for('react.transitional.element');
const REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
/**
 * Compatible with React 18 or 19 to check if node is a Fragment.
 */ function isFragment(object) {
    return(// Base object type
    object && typeof object === 'object' && // React Element type
    (object.$$typeof === REACT_ELEMENT_TYPE_18 || object.$$typeof === REACT_ELEMENT_TYPE_19) && // React Fragment type
    object.type === REACT_FRAGMENT_TYPE);
}

},
"node_modules/@rc-component/util/lib/hooks/useId.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
exports.default = void 0;
exports.resetUuid = resetUuid;
var React = _interopRequireWildcard(__mako_require__("node_modules/react/index.js"));
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
function getUseId() {
    // We need fully clone React function here to avoid webpack warning React 17 do not export `useId`
    const fullClone = {
        ...React
    };
    return fullClone.useId;
}
let uuid = 0;
/** @private Note only worked in develop env. Not work in production. */ function resetUuid() {
    uuid = 0;
}
const useOriginId = getUseId();
var _default = exports.default = useOriginId ? // Use React `useId`
function useId(id) {
    const reactId = useOriginId();
    // Developer passed id is single source of truth
    if (id) return id;
    return reactId;
} : // Use compatible of `useId`
function useCompatId(id) {
    // Inner id for accessibility usage. Only work in client side
    const [innerId, setInnerId] = React.useState('ssr-id');
    React.useEffect(()=>{
        const nextId = uuid;
        uuid += 1;
        setInnerId(`rc_unique_${nextId}`);
    }, []);
    // Developer passed id is single source of truth
    if (id) return id;
    // Return react native id or inner id
    return innerId;
};

},
"node_modules/@rc-component/util/lib/hooks/useMemo.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
exports.default = useMemo;
var React = _interopRequireWildcard(__mako_require__("node_modules/react/index.js"));
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
function useMemo(getValue, condition, shouldUpdate) {
    const cacheRef = React.useRef({});
    if (!('value' in cacheRef.current) || shouldUpdate(cacheRef.current.condition, condition)) {
        cacheRef.current.value = getValue();
        cacheRef.current.condition = condition;
    }
    return cacheRef.current.value;
}

},
"node_modules/@rc-component/util/lib/pickAttrs.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
exports.default = pickAttrs;
const attributes = `accept acceptCharset accessKey action allowFullScreen allowTransparency
    alt async autoComplete autoFocus autoPlay capture cellPadding cellSpacing challenge
    charSet checked classID className colSpan cols content contentEditable contextMenu
    controls coords crossOrigin data dateTime default defer dir disabled download draggable
    encType form formAction formEncType formMethod formNoValidate formTarget frameBorder
    headers height hidden high href hrefLang htmlFor httpEquiv icon id inputMode integrity
    is keyParams keyType kind label lang list loop low manifest marginHeight marginWidth max maxLength media
    mediaGroup method min minLength multiple muted name noValidate nonce open
    optimum pattern placeholder poster preload radioGroup readOnly rel required
    reversed role rowSpan rows sandbox scope scoped scrolling seamless selected
    shape size sizes span spellCheck src srcDoc srcLang srcSet start step style
    summary tabIndex target title type useMap value width wmode wrap`;
const eventsName = `onCopy onCut onPaste onCompositionEnd onCompositionStart onCompositionUpdate onKeyDown
    onKeyPress onKeyUp onFocus onBlur onChange onInput onSubmit onClick onContextMenu onDoubleClick
    onDrag onDragEnd onDragEnter onDragExit onDragLeave onDragOver onDragStart onDrop onMouseDown
    onMouseEnter onMouseLeave onMouseMove onMouseOut onMouseOver onMouseUp onSelect onTouchCancel
    onTouchEnd onTouchMove onTouchStart onScroll onWheel onAbort onCanPlay onCanPlayThrough
    onDurationChange onEmptied onEncrypted onEnded onError onLoadedData onLoadedMetadata
    onLoadStart onPause onPlay onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend onTimeUpdate onVolumeChange onWaiting onLoad onError`;
const propList = `${attributes} ${eventsName}`.split(/[\s\n]+/);
/* eslint-enable max-len */ const ariaPrefix = 'aria-';
const dataPrefix = 'data-';
function match(key, prefix) {
    return key.indexOf(prefix) === 0;
}
/**
 * Picker props from exist props with filter
 * @param props Passed props
 * @param ariaOnly boolean | { aria?: boolean; data?: boolean; attr?: boolean; } filter config
 */ function pickAttrs(props, ariaOnly = false) {
    let mergedConfig;
    if (ariaOnly === false) mergedConfig = {
        aria: true,
        data: true,
        attr: true
    };
    else if (ariaOnly === true) mergedConfig = {
        aria: true
    };
    else mergedConfig = {
        ...ariaOnly
    };
    const attrs = {};
    Object.keys(props).forEach((key)=>{
        if (// Aria
        mergedConfig.aria && (key === 'role' || match(key, ariaPrefix)) || // Data
        mergedConfig.data && match(key, dataPrefix) || // Attr
        mergedConfig.attr && propList.includes(key)) attrs[key] = props[key];
    });
    return attrs;
}

},
"node_modules/@rc-component/util/lib/ref.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
exports.useComposeRef = exports.supportRef = exports.supportNodeRef = exports.getNodeRef = exports.fillRef = exports.composeRef = void 0;
var _react = __mako_require__("node_modules/react/index.js");
var _reactIs = __mako_require__("node_modules/react-is/index.js");
var _useMemo = _interopRequireDefault(__mako_require__("node_modules/@rc-component/util/lib/hooks/useMemo.js"));
var _isFragment = _interopRequireDefault(__mako_require__("node_modules/@rc-component/util/lib/React/isFragment.js"));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const ReactMajorVersion = Number(_react.version.split('.')[0]);
const fillRef = (ref, node)=>{
    if (typeof ref === 'function') ref(node);
    else if (typeof ref === 'object' && ref && 'current' in ref) ref.current = node;
};
/**
 * Merge refs into one ref function to support ref passing.
 */ exports.fillRef = fillRef;
const composeRef = (...refs)=>{
    const refList = refs.filter(Boolean);
    if (refList.length <= 1) return refList[0];
    return (node)=>{
        refs.forEach((ref)=>{
            fillRef(ref, node);
        });
    };
};
exports.composeRef = composeRef;
const useComposeRef = (...refs)=>{
    return (0, _useMemo.default)(()=>composeRef(...refs), // eslint-disable-next-line react-hooks/exhaustive-deps
    refs, (prev, next)=>prev.length !== next.length || prev.every((ref, i)=>ref !== next[i]));
};
exports.useComposeRef = useComposeRef;
const supportRef = (nodeOrComponent)=>{
    var _type_prototype, _nodeOrComponent_prototype;
    if (!nodeOrComponent) return false;
    // React 19 no need `forwardRef` anymore. So just pass if is a React element.
    if (isReactElement(nodeOrComponent) && ReactMajorVersion >= 19) return true;
    const type = (0, _reactIs.isMemo)(nodeOrComponent) ? nodeOrComponent.type.type : nodeOrComponent.type;
    // Function component node
    if (typeof type === 'function' && !((_type_prototype = type.prototype) === null || _type_prototype === void 0 ? void 0 : _type_prototype.render) && type.$$typeof !== _reactIs.ForwardRef) return false;
    // Class component
    if (typeof nodeOrComponent === 'function' && !((_nodeOrComponent_prototype = nodeOrComponent.prototype) === null || _nodeOrComponent_prototype === void 0 ? void 0 : _nodeOrComponent_prototype.render) && nodeOrComponent.$$typeof !== _reactIs.ForwardRef) return false;
    return true;
};
exports.supportRef = supportRef;
function isReactElement(node) {
    return /*#__PURE__*/ (0, _react.isValidElement)(node) && !(0, _isFragment.default)(node);
}
const supportNodeRef = (node)=>{
    return isReactElement(node) && supportRef(node);
};
/**
 * In React 19. `ref` is not a property from node.
 * But a property from `props.ref`.
 * To check if `props.ref` exist or fallback to `ref`.
 */ exports.supportNodeRef = supportNodeRef;
const getNodeRef = (node)=>{
    if (node && isReactElement(node)) {
        const ele = node;
        // Source from:
        // https://github.com/mui/material-ui/blob/master/packages/mui-utils/src/getReactNodeRef/getReactNodeRef.ts
        return ele.props.propertyIsEnumerable('ref') ? ele.props.ref : ele.ref;
    }
    return null;
};
exports.getNodeRef = getNodeRef;

},
"node_modules/@rc-component/util/lib/warning.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
exports.call = call;
exports.default = void 0;
exports.note = note;
exports.noteOnce = noteOnce;
exports.preMessage = void 0;
exports.resetWarned = resetWarned;
exports.warning = warning;
exports.warningOnce = warningOnce;
/* eslint-disable no-console */ let warned = {};
const preWarningFns = [];
/**
 * Pre warning enable you to parse content before console.error.
 * Modify to null will prevent warning.
 */ const preMessage = (fn)=>{
    preWarningFns.push(fn);
};
/**
 * Warning if condition not match.
 * @param valid Condition
 * @param message Warning message
 * @example
 * ```js
 * warning(false, 'some error'); // print some error
 * warning(true, 'some error'); // print nothing
 * warning(1 === 2, 'some error'); // print some error
 * ```
 */ exports.preMessage = preMessage;
function warning(valid, message) {
    if (!valid && console !== undefined) {
        const finalMessage = preWarningFns.reduce((msg, preMessageFn)=>preMessageFn(msg ?? '', 'warning'), message);
        if (finalMessage) console.error(`Warning: ${finalMessage}`);
    }
}
/** @see Similar to {@link warning} */ function note(valid, message) {
    if (!valid && console !== undefined) {
        const finalMessage = preWarningFns.reduce((msg, preMessageFn)=>preMessageFn(msg ?? '', 'note'), message);
        if (finalMessage) console.warn(`Note: ${finalMessage}`);
    }
}
function resetWarned() {
    warned = {};
}
function call(method, valid, message) {
    if (!valid && !warned[message]) {
        method(false, message);
        warned[message] = true;
    }
}
/** @see Same as {@link warning}, but only warn once for the same message */ function warningOnce(valid, message) {
    call(warning, valid, message);
}
/** @see Same as {@link warning}, but only warn once for the same message */ function noteOnce(valid, message) {
    call(note, valid, message);
}
warningOnce.preMessage = preMessage;
warningOnce.resetWarned = resetWarned;
warningOnce.noteOnce = noteOnce;
var _default = exports.default = warningOnce;

},
"node_modules/animated-scroll-to/dist/esm/index.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
// --------- HELPERS
function getElementOffset(el) {
    let top = 0;
    let left = 0;
    let element = el;
    // Loop through the DOM tree
    // and add it's parent's offset to get page offset
    do {
        top += element.offsetTop || 0;
        left += element.offsetLeft || 0;
        element = element.offsetParent;
    }while (element)
    return {
        top,
        left
    };
}
// --------- SCROLL INTERFACES
// ScrollDomElement and ScrollWindow have identical interfaces
class ScrollDomElement {
    constructor(element){
        this.element = element;
    }
    getHorizontalScroll() {
        return this.element.scrollLeft;
    }
    getVerticalScroll() {
        return this.element.scrollTop;
    }
    getMaxHorizontalScroll() {
        return this.element.scrollWidth - this.element.clientWidth;
    }
    getMaxVerticalScroll() {
        return this.element.scrollHeight - this.element.clientHeight;
    }
    getHorizontalElementScrollOffset(elementToScrollTo, elementToScroll) {
        return getElementOffset(elementToScrollTo).left - getElementOffset(elementToScroll).left;
    }
    getVerticalElementScrollOffset(elementToScrollTo, elementToScroll) {
        return getElementOffset(elementToScrollTo).top - getElementOffset(elementToScroll).top;
    }
    scrollTo(x, y) {
        this.element.scrollLeft = x;
        this.element.scrollTop = y;
    }
}
class ScrollWindow {
    constructor(){
        this.element = window;
    }
    getHorizontalScroll() {
        return window.scrollX || document.documentElement.scrollLeft;
    }
    getVerticalScroll() {
        return window.scrollY || document.documentElement.scrollTop;
    }
    getMaxHorizontalScroll() {
        return Math.max(document.body.scrollWidth, document.documentElement.scrollWidth, document.body.offsetWidth, document.documentElement.offsetWidth, document.body.clientWidth, document.documentElement.clientWidth) - window.innerWidth;
    }
    getMaxVerticalScroll() {
        return Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight) - window.innerHeight;
    }
    getHorizontalElementScrollOffset(elementToScrollTo) {
        const scrollLeft = window.scrollX || document.documentElement.scrollLeft;
        return scrollLeft + elementToScrollTo.getBoundingClientRect().left;
    }
    getVerticalElementScrollOffset(elementToScrollTo) {
        const scrollTop = window.scrollY || document.documentElement.scrollTop;
        return scrollTop + elementToScrollTo.getBoundingClientRect().top;
    }
    scrollTo(x, y) {
        window.scrollTo(x, y);
    }
}
const activeAnimations = {
    elements: [],
    cancelMethods: [],
    add: (element, cancelAnimation)=>{
        activeAnimations.elements.push(element);
        activeAnimations.cancelMethods.push(cancelAnimation);
    },
    remove: (element, shouldStop)=>{
        const index = activeAnimations.elements.indexOf(element);
        if (index > -1) {
            // Stop animation
            if (shouldStop) activeAnimations.cancelMethods[index]();
            // Remove it
            activeAnimations.elements.splice(index, 1);
            activeAnimations.cancelMethods.splice(index, 1);
        }
    }
};
// --------- CHECK IF CODE IS RUNNING IN A BROWSER
const WINDOW_EXISTS = typeof window !== 'undefined';
// --------- ANIMATE SCROLL TO
const defaultOptions = {
    cancelOnUserAction: true,
    easing: (t)=>--t * t * t + 1,
    elementToScroll: WINDOW_EXISTS ? window : null,
    horizontalOffset: 0,
    maxDuration: 3000,
    minDuration: 250,
    speed: 500,
    verticalOffset: 0
};
function animateScrollTo(numberOrCoordsOrElement_1) {
    return __awaiter(this, arguments, void 0, function*(numberOrCoordsOrElement, userOptions = {}) {
        // Check for server rendering
        if (!WINDOW_EXISTS) // @ts-ignore
        // If it still gets called on server, return Promise for API consistency
        return new Promise((resolve)=>{
            resolve(false); // Returning false on server
        });
        else if (!window.Promise) throw "Browser doesn't support Promises, and animated-scroll-to depends on it, please provide a polyfill.";
        let x;
        let y;
        let scrollToElement;
        let options = Object.assign(Object.assign({}, defaultOptions), userOptions);
        const isWindow = options.elementToScroll === window;
        const isElement = !!options.elementToScroll.nodeName;
        if (!isWindow && !isElement) throw 'Element to scroll needs to be either window or DOM element.';
        // Check for a few properties that can break the animation
        // "scroll-behavior: smooth"
        // "scroll-snap-type: [x/y] mandatory"
        // https://github.com/Stanko/animated-scroll-to/issues/55
        // https://github.com/Stanko/animated-scroll-to/issues/71
        const WARN_ABOUT = [
            {
                property: 'scroll-behavior',
                value: 'smooth'
            },
            {
                property: 'scroll-snap-type',
                value: 'mandatory'
            }
        ];
        const scrollBehaviorElement = isWindow ? document.documentElement : options.elementToScroll;
        const computedStyles = getComputedStyle(scrollBehaviorElement);
        WARN_ABOUT.forEach(({ property, value })=>{
            const cssValue = computedStyles.getPropertyValue(property);
            if (cssValue.includes(value)) console.warn(`${scrollBehaviorElement.tagName} has "${property}: ${cssValue}" which can break animated-scroll-to's animations`);
        });
        // Select the correct scrolling interface
        const elementToScroll = isWindow ? new ScrollWindow() : new ScrollDomElement(options.elementToScroll);
        if (numberOrCoordsOrElement instanceof Element) {
            scrollToElement = numberOrCoordsOrElement;
            // If "elementToScroll" is not a parent of "scrollToElement"
            if (isElement && (!options.elementToScroll.contains(scrollToElement) || options.elementToScroll.isSameNode(scrollToElement))) throw 'options.elementToScroll has to be a parent of scrollToElement';
            x = elementToScroll.getHorizontalElementScrollOffset(scrollToElement, options.elementToScroll);
            y = elementToScroll.getVerticalElementScrollOffset(scrollToElement, options.elementToScroll);
        } else if (typeof numberOrCoordsOrElement === 'number') {
            x = elementToScroll.getHorizontalScroll();
            y = numberOrCoordsOrElement;
        } else if (Array.isArray(numberOrCoordsOrElement) && numberOrCoordsOrElement.length === 2) {
            x = numberOrCoordsOrElement[0] === null ? elementToScroll.getHorizontalScroll() : numberOrCoordsOrElement[0];
            y = numberOrCoordsOrElement[1] === null ? elementToScroll.getVerticalScroll() : numberOrCoordsOrElement[1];
        } else // ERROR
        throw "Wrong function signature. Check documentation.\nAvailable method signatures are:\n  animateScrollTo(y:number, options)\n  animateScrollTo([x:number | null, y:number | null], options)\n  animateScrollTo(scrollToElement:Element, options)";
        // Add offsets
        x += options.horizontalOffset;
        y += options.verticalOffset;
        // Horizontal scroll distance
        const maxHorizontalScroll = elementToScroll.getMaxHorizontalScroll();
        const initialHorizontalScroll = elementToScroll.getHorizontalScroll();
        // If user specified scroll position is greater than maximum available scroll
        if (x > maxHorizontalScroll) x = maxHorizontalScroll;
        // Calculate distance to scroll
        const horizontalDistanceToScroll = x - initialHorizontalScroll;
        // Vertical scroll distance distance
        const maxVerticalScroll = elementToScroll.getMaxVerticalScroll();
        const initialVerticalScroll = elementToScroll.getVerticalScroll();
        // If user specified scroll position is greater than maximum available scroll
        if (y > maxVerticalScroll) y = maxVerticalScroll;
        // Calculate distance to scroll
        const verticalDistanceToScroll = y - initialVerticalScroll;
        // Calculate duration of the scroll
        const horizontalDuration = Math.abs(Math.round(horizontalDistanceToScroll / 1000 * options.speed));
        const verticalDuration = Math.abs(Math.round(verticalDistanceToScroll / 1000 * options.speed));
        let duration = horizontalDuration > verticalDuration ? horizontalDuration : verticalDuration;
        // Set minimum and maximum duration
        if (duration < options.minDuration) duration = options.minDuration;
        else if (duration > options.maxDuration) duration = options.maxDuration;
        // @ts-ignore
        return new Promise((resolve, reject)=>{
            // Scroll is already in place, nothing to do
            if (horizontalDistanceToScroll === 0 && verticalDistanceToScroll === 0) // Resolve promise with a boolean hasScrolledToPosition set to true
            resolve(true);
            // Cancel existing animation if it is already running on the same element
            activeAnimations.remove(elementToScroll.element, true);
            // To cancel animation we have to store request animation frame ID
            let requestID;
            // Cancel animation handler
            const cancelAnimation = ()=>{
                removeListeners();
                cancelAnimationFrame(requestID);
                // Resolve promise with a boolean hasScrolledToPosition set to false
                resolve(false);
            };
            // Registering animation so it can be canceled if function
            // gets called again on the same element
            activeAnimations.add(elementToScroll.element, cancelAnimation);
            // Prevent user actions handler
            const preventDefaultHandler = (e)=>e.preventDefault();
            const handler = options.cancelOnUserAction ? cancelAnimation : preventDefaultHandler;
            // If animation is not cancelable by the user, we can't use passive events
            const eventOptions = options.cancelOnUserAction ? {
                passive: true
            } : {
                passive: false
            };
            const events = [
                'wheel',
                'touchstart',
                'keydown',
                'mousedown'
            ];
            // Function to remove listeners after animation is finished
            const removeListeners = ()=>{
                events.forEach((eventName)=>{
                    elementToScroll.element.removeEventListener(eventName, handler, eventOptions);
                });
            };
            // Add listeners
            events.forEach((eventName)=>{
                elementToScroll.element.addEventListener(eventName, handler, eventOptions);
            });
            // Animation
            const startingTime = Date.now();
            const step = ()=>{
                var timeDiff = Date.now() - startingTime;
                var t = timeDiff / duration;
                const horizontalScrollPosition = Math.round(initialHorizontalScroll + horizontalDistanceToScroll * options.easing(t));
                const verticalScrollPosition = Math.round(initialVerticalScroll + verticalDistanceToScroll * options.easing(t));
                if (timeDiff < duration && (horizontalScrollPosition !== x || verticalScrollPosition !== y)) {
                    // If scroll didn't reach desired position or time is not elapsed
                    // Scroll to a new position
                    elementToScroll.scrollTo(horizontalScrollPosition, verticalScrollPosition);
                    // And request a new step
                    requestID = requestAnimationFrame(step);
                } else {
                    // If the time elapsed or we reached the desired offset
                    // Set scroll to the desired offset (when rounding made it to be off a pixel or two)
                    // Clear animation frame to be sure
                    elementToScroll.scrollTo(x, y);
                    cancelAnimationFrame(requestID);
                    // Remove listeners
                    removeListeners();
                    // Remove animation from the active animations coordinator
                    activeAnimations.remove(elementToScroll.element, false);
                    // Resolve promise with a boolean hasScrolledToPosition set to true
                    resolve(true);
                }
            };
            // Start animating scroll
            requestID = requestAnimationFrame(step);
        });
    });
}
var _default = animateScrollTo;

},
"node_modules/base64-js/index.js": function (module, exports, __mako_require__){
'use strict';
exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for(var i = 0, len = code.length; i < len; ++i){
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
}
// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;
function getLens(b64) {
    var len = b64.length;
    if (len % 4 > 0) throw new Error('Invalid string. Length must be a multiple of 4');
    // Trim off extra bytes after placeholder bytes are found
    // See: https://github.com/beatgammit/base64-js/issues/42
    var validLen = b64.indexOf('=');
    if (validLen === -1) validLen = len;
    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
    return [
        validLen,
        placeHoldersLen
    ];
}
// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    // if there are placeholders, only get up to the last complete 4 chars
    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i;
    for(i = 0; i < len; i += 4){
        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
        arr[curByte++] = tmp >> 16 & 0xFF;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    return arr;
}
function tripletToBase64(num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}
function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for(var i = start; i < end; i += 3){
        tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
        output.push(tripletToBase64(tmp));
    }
    return output.join('');
}
function fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
    ;
    var parts = [];
    var maxChunkLength = 16383 // must be multiple of 3
    ;
    // go through the array every three bytes, we'll deal with trailing stuff later
    for(var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength)parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
        tmp = uint8[len - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
    } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
    }
    return parts.join('');
}

},
"node_modules/bootstrap/dist/css/bootstrap.css?asmodule": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
"";
var _default = {
    "sticky-xl-bottom": `sticky-xl-bottom-Mi7TVmtx`,
    "justify-content-md-center": `justify-content-md-center-jppYad2t`,
    "d-sm-flex": `d-sm-flex-emU7U6RT`,
    "pb-lg-5": `pb-lg-5-fqk0U3F3`,
    "px-1": `px-1-hgxBwiwr`,
    "offset-lg-6": `offset-lg-6-zCWV1yBo`,
    "px-2": `px-2-L1IWyr_E`,
    "px-3": `px-3-WZkff6s_`,
    "text-danger": `text-danger-Z9M7NgJx`,
    "placeholder-sm": `placeholder-sm-fMtjYf0o`,
    "align-self-lg-stretch": `align-self-lg-stretch-OSo1Knx6`,
    "mx-md-3": `mx-md-3-GraGJkqG`,
    "pe-xl-4": `pe-xl-4-YmKBZelR`,
    "align-items-xxl-center": `align-items-xxl-center-uu9XYPkF`,
    "offset-md-3": `offset-md-3-Ievdv-af`,
    "toast-body": `toast-body-R7cI8scG`,
    "align-items-baseline": `align-items-baseline-cXVzPvmH`,
    "row-cols-xl-3": `row-cols-xl-3-TI_PITUz`,
    "text-white-50": `text-white-50-6V9VCzUQ`,
    "gy-sm-3": `gy-sm-3-zQZUMYPo`,
    "table-light": `table-light-ohK9uzge`,
    "me-md-1": `me-md-1-lw5NNXxI`,
    "ms-md-auto": `ms-md-auto-HJtVJE3v`,
    "gx-xxl-2": `gx-xxl-2-6SnoloUZ`,
    "d-lg-block": `d-lg-block-qJpebHuw`,
    "gap-xl-4": `gap-xl-4-O-d2ggMv`,
    "order-4": `order-4-hbE_SEgk`,
    "row-gap-lg-2": `row-gap-lg-2-7p6fcYFD`,
    "align-content-xxl-center": `align-content-xxl-center-poRyaD-c`,
    "px-4": `px-4-nuFUSueK`,
    "px-5": `px-5-y4q7W23W`,
    "py-0": `py-0-fs_qSyA7`,
    "py-1": `py-1-3CPPjw8b`,
    "float-xl-none": `float-xl-none-MCAfmNSs`,
    "py-2": `py-2-egaMu9YU`,
    "py-3": `py-3-R8eed8_t`,
    "py-md-4": `py-md-4-WajjKt-0`,
    "row-gap-md-4": `row-gap-md-4-RWARyja8`,
    "border-opacity-100": `border-opacity-100-cuQm_Hp3`,
    "pt-sm-0": `pt-sm-0-kcKpuxAC`,
    "order-xxl-5": `order-xxl-5-PYjZb6P1`,
    "d-print-table": `d-print-table-537LPRHk`,
    "column-gap-md-1": `column-gap-md-1-04jo8Tg-`,
    "gy-xl-4": `gy-xl-4-YxGZDm6P`,
    "rounded-end-3": `rounded-end-3-Mzt-sFYt`,
    "mt-lg-3": `mt-lg-3-lMsggiaY`,
    "pagination-sm": `pagination-sm-braD5_-a`,
    "ps-lg-1": `ps-lg-1-NF99O2JO`,
    "min-vh-100": `min-vh-100-mKD1YcSO`,
    "d-inline-block": `d-inline-block-WTZ38jkH`,
    "column-gap-1": `column-gap-1-LEJUEsIt`,
    "py-sm-3": `py-sm-3-sZvcg7eG`,
    "flex-xxl-column-reverse": `flex-xxl-column-reverse-jIn_xQer`,
    "order-xl-3": `order-xl-3-vsMDs5Sm`,
    "gy-xxl-1": `gy-xxl-1-o9GvdZVh`,
    "dropdown-item-text": `dropdown-item-text-SY3_vCB6`,
    "btn-danger": `btn-danger-9uh-h1Xy`,
    "py-4": `py-4-FGDcYPqr`,
    "py-5": `py-5-2MyDjK4g`,
    "pt-0": `pt-0-iG-1HwDA`,
    "justify-content-xxl-end": `justify-content-xxl-end-JTuwymIe`,
    "order-sm-0": `order-sm-0-jkdzTujD`,
    "offset-sm-1": `offset-sm-1-icmTxRSH`,
    "px-sm-3": `px-sm-3-GRgS14VQ`,
    "order-lg-first": `order-lg-first-X5TCDi6f`,
    "d-lg-inline-block": `d-lg-inline-block-mTzn60Im`,
    "offset-md-11": `offset-md-11-A7DVHzxj`,
    "focus-ring-dark": `focus-ring-dark-43GRCgtv`,
    "flex-md-grow-1": `flex-md-grow-1-LyDXyiG6`,
    "mx-lg-5": `mx-lg-5-5kNev5h5`,
    "mt-xl-0": `mt-xl-0-lQKEnEoB`,
    "justify-content-xxl-evenly": `justify-content-xxl-evenly-9H5S3ywt`,
    "text-md-start": `text-md-start-alqQ8fNR`,
    "row-gap-1": `row-gap-1-XyQ-cQPG`,
    "offset-xl-8": `offset-xl-8-rYyAnBKw`,
    "col-md-10": `col-md-10-Gbjr7gKP`,
    "opacity-25": `opacity-25-02Qpmbwn`,
    "me-sm-auto": `me-sm-auto-JTfXsB5u`,
    "me-sm-1": `me-sm-1-2cUMGadj`,
    "object-fit-xxl-none": `object-fit-xxl-none-lS5nkrRr`,
    "offset-lg-11": `offset-lg-11-ewh9q-tM`,
    "align-content-md-stretch": `align-content-md-stretch-bWB3Al02`,
    "order-xl-5": `order-xl-5-lax2F6WO`,
    "col-xl-5": `col-xl-5-N3WZXeTG`,
    "text-reset": `text-reset-tY_htjmB`,
    "figure": `figure-Box7DkQ4`,
    "vstack": `vstack-D14vdx7o`,
    "vw-100": `vw-100-etn9YrIp`,
    "vh-100": `vh-100-ieLmB9WM`,
    "pt-md-3": `pt-md-3-LWbW1RmM`,
    "col-xxl-8": `col-xxl-8-m60dqeVI`,
    "gx-md-1": `gx-md-1-xLTfq6y_`,
    "gx-sm-4": `gx-sm-4-yqjNqhQj`,
    "row": `row-DZSA79v4`,
    "btn": `btn-KpI73p0U`,
    "border-primary-subtle": `border-primary-subtle-TRi9rYpq`,
    "flex-sm-wrap": `flex-sm-wrap-1GzuqCho`,
    "flex-lg-grow-1": `flex-lg-grow-1-cX79Kkm4`,
    "spinner-grow": `spinner-grow-rU1tkb95`,
    "align-self-lg-auto": `align-self-lg-auto-gxrV0ahT`,
    "text-lg-start": `text-lg-start-ri0sbQEh`,
    "object-fit-xxl-cover": `object-fit-xxl-cover-pAFT5xls`,
    "column-gap-xxl-1": `column-gap-xxl-1-WSj6Zv-U`,
    "fixed-bottom": `fixed-bottom-Z-9E7K_T`,
    "align-self-xl-baseline": `align-self-xl-baseline-9eof7VxX`,
    "align-items-md-start": `align-items-md-start-TN6RW62T`,
    "flex-xxl-wrap": `flex-xxl-wrap-uMTTOoJ6`,
    "row-cols-lg-5": `row-cols-lg-5-hiZUnal4`,
    "row-gap-lg-3": `row-gap-lg-3-lwNnxQQQ`,
    "ps-xl-5": `ps-xl-5-kVfYCl6_`,
    "row-cols-xl-1": `row-cols-xl-1-R-z7vm6z`,
    "row-gap-md-5": `row-gap-md-5-lxTMCR5X`,
    "pe-lg-1": `pe-lg-1-G1_JWlm7`,
    "overflow-x-auto": `overflow-x-auto-wJom69wM`,
    "dropdown-header": `dropdown-header-1Zcm_Gl3`,
    "align-self-lg-baseline": `align-self-lg-baseline-8spl6Rln`,
    "flex-row": `flex-row-h97EspO1`,
    "column-gap-0": `column-gap-0-qLDyU3tL`,
    "order-lg-4": `order-lg-4-136IHG33`,
    "align-content-around": `align-content-around-wZPlgPrM`,
    "mb-sm-5": `mb-sm-5-DkWlSY6S`,
    "column-gap-xxl-4": `column-gap-xxl-4-fgs07cI2`,
    "dropdown-menu-xxl-end": `dropdown-menu-xxl-end-Pib7lLi2`,
    "col-sm-4": `col-sm-4-6vC0EgKX`,
    "link-body-emphasis": `link-body-emphasis-wRSOh6bt`,
    "pe-sm-2": `pe-sm-2-MDdr_WIz`,
    "gy-xl-2": `gy-xl-2-Xo49z8kg`,
    "form-select-sm": `form-select-sm-0sof28cX`,
    "invalid-feedback": `invalid-feedback-4tXlvlfr`,
    "gap-sm-1": `gap-sm-1-JcioXHo5`,
    "justify-content-md-start": `justify-content-md-start-RpXEaicT`,
    "d-xl-grid": `d-xl-grid-ywkBig_B`,
    "justify-content-lg-between": `justify-content-lg-between-dC6xGMyl`,
    "ps-lg-3": `ps-lg-3-dXkELTR-`,
    "mt-3": `mt-3-AmBk6TLn`,
    "mt-4": `mt-4-TC3LcuzT`,
    "mt-5": `mt-5-5hUPfnPa`,
    "me-0": `me-0-VGCQAc1S`,
    "me-1": `me-1-W60Gb1ZI`,
    "mark": `mark-f2yUtUEc`,
    "mx-0": `mx-0-EjbZtjKy`,
    "mx-1": `mx-1-ZeKsw-Xz`,
    "mx-2": `mx-2-zHdLZRcz`,
    "dropdown-divider": `dropdown-divider-_B1kyoKm`,
    "mx-3": `mx-3-wAUhrN1v`,
    "link-opacity-75-hover": `link-opacity-75-hover-mGY86jTq`,
    "flex-fill": `flex-fill-9b1KDVaA`,
    "visible": `visible-i59DsXwa`,
    "ps-md-5": `ps-md-5-gfRYeQMJ`,
    "dropdown-center": `dropdown-center-R8g5cSo4`,
    "align-items-md-baseline": `align-items-md-baseline-KDuYDDEP`,
    "column-gap-xl-2": `column-gap-xl-2-2MttgF7o`,
    "form-control-plaintext": `form-control-plaintext-b8gnLYc-`,
    "offset-sm-3": `offset-sm-3-LMhbBE9S`,
    "mx-4": `mx-4-eEMycQrt`,
    "mx-5": `mx-5-EFZPdT5Q`,
    "my-0": `my-0-iME_woVA`,
    "my-1": `my-1-ln5C3b1T`,
    "navbar-nav-scroll": `navbar-nav-scroll-IRCp9k_h`,
    "my-2": `my-2-gTWuG21X`,
    "col-sm-9": `col-sm-9-iGgXxCSY`,
    "me-2": `me-2-HtQr7Zfa`,
    "float-xxl-end": `float-xxl-end-9vfRXnTR`,
    "d-print-inline-flex": `d-print-inline-flex-hSXB-3Kx`,
    "row-gap-3": `row-gap-3-g7zDpttO`,
    "flex-sm-wrap-reverse": `flex-sm-wrap-reverse-R5EzZbNI`,
    "col-md-12": `col-md-12-ClI1UITv`,
    "gap-xxl-3": `gap-xxl-3-jxuNos_P`,
    "me-sm-3": `me-sm-3-Rld88_er`,
    "g-xxl-5": `g-xxl-5-rYRWLAcN`,
    "me-3": `me-3-syfwiXxU`,
    "me-4": `me-4-Z9opwhzA`,
    "row-cols-sm-1": `row-cols-sm-1-3yly7S-S`,
    "me-5": `me-5-ePi7Nm7X`,
    "mb-0": `mb-0-1C5hU2Vu`,
    "offset-lg-2": `offset-lg-2-Sf5NuCiJ`,
    "user-select-none": `user-select-none-KUnFEB_F`,
    "my-3": `my-3-IifuFJf7`,
    "align-content-end": `align-content-end-jaUJjFAM`,
    "order-xxl-first": `order-xxl-first-D6Ye_0Z9`,
    "px-md-4": `px-md-4-m6d-fkQk`,
    "object-fit-xl-fill": `object-fit-xl-fill-GgyG5v7c`,
    "gy-lg-4": `gy-lg-4-lSUjbsAB`,
    "col-sm-2": `col-sm-2-A_7ZJ1mp`,
    "gx-xxl-1": `gx-xxl-1-R-a6Z0mE`,
    "pb-md-4": `pb-md-4-iXtLOa9g`,
    "gap-xl-3": `gap-xl-3-A5vQ2RAu`,
    "float-sm-start": `float-sm-start-7j34JN0G`,
    "d-print-flex": `d-print-flex-siTcTpwG`,
    "h-100": `h-100-L_CMoTiz`,
    "table-primary": `table-primary-htyOY-rU`,
    "mb-auto": `mb-auto-zwnSh6Ky`,
    "my-4": `my-4-bggTM33x`,
    "my-5": `my-5-cVFngSmf`,
    "mb-1": `mb-1-iettuJZq`,
    "pt-lg-0": `pt-lg-0-9ezM5voK`,
    "btn-secondary": `btn-secondary-y84R1d8D`,
    "align-baseline": `align-baseline-LhVpd0qP`,
    "py-md-0": `py-md-0-ALrxZlvN`,
    "border-bottom": `border-bottom-vFX1nC5J`,
    "p-xxl-5": `p-xxl-5-39aOjCz6`,
    "btn-light": `btn-light-ORtjmW3n`,
    "column-gap-md-5": `column-gap-md-5-TSk7YteO`,
    "list-unstyled": `list-unstyled-LMkBOqFn`,
    "row-cols-md-4": `row-cols-md-4-YC0VhXcx`,
    "dropdown-menu-end": `dropdown-menu-end-PimVuWRY`,
    "justify-content-xl-around": `justify-content-xl-around-Ht5I2LBh`,
    "gx-xl-4": `gx-xl-4-4d1Nrmr8`,
    "list-group-horizontal": `list-group-horizontal-8m4x_Rqf`,
    "min-vw-100": `min-vw-100-PJQUgNws`,
    "col-md-2": `col-md-2-rAqqpR5a`,
    "col-lg-5": `col-lg-5-5ETHGig3`,
    "gy-xxl-0": `gy-xxl-0-BzRd-Y1g`,
    "rounded-3": `rounded-3-hhbwd1U-`,
    "mb-2": `mb-2-9Q5n4LmJ`,
    "mb-3": `mb-3-wRlsoHk3`,
    "mb-4": `mb-4-FkrygTDK`,
    "position-sticky": `position-sticky-S65EcYA3`,
    "gap-lg-2": `gap-lg-2-Y74QN1-v`,
    "mb-5": `mb-5-5gsE06Pr`,
    "ms-0": `ms-0-ajDVmjRz`,
    "d-md-table": `d-md-table-pJXH2mQT`,
    "me-xl-5": `me-xl-5-tv01zZhF`,
    "text-xl-end": `text-xl-end-2mnNwUAT`,
    "m-sm-auto": `m-sm-auto-7btIfVnR`,
    "ms-xl-3": `ms-xl-3-76EVlhLd`,
    "dropdown-menu-sm-end": `dropdown-menu-sm-end-3FyKWMvK`,
    "pe-sm-4": `pe-sm-4-p0MQLVK1`,
    "pe-md-3": `pe-md-3-6Gd8TP0K`,
    "alert-info": `alert-info-90WO8JDr`,
    "rounded-top-1": `rounded-top-1-Y7L1S5td`,
    "start-0": `start-0-HKxn5uZk`,
    "col-xxl-auto": `col-xxl-auto-DCnFf70i`,
    "px-xl-5": `px-xl-5-Ar98xqm3`,
    "border-top-0": `border-top-0-Le7SLfyZ`,
    "btn-close": `btn-close-PfOeryY7`,
    "col-md-7": `col-md-7-Vx6hzb4w`,
    "gy-xxl-5": `gy-xxl-5-Asdi9ptG`,
    "col-lg": `col-lg--G8pa5rP`,
    "col-10": `col-10-EBmgdCRv`,
    "col-11": `col-11-yaZPcllJ`,
    "col-12": `col-12-IVav1Tgm`,
    "col-sm": `col-sm-cwhhOcbV`,
    "col-md": `col-md-lM532R_Q`,
    "input-group-text": `input-group-text-WGHedNFM`,
    "col-xl-4": `col-xl-4-ubzL2sV4`,
    "col-xl": `col-xl-hC2glfu2`,
    "shadow": `shadow-jF5FVjKI`,
    "ratio-4x3": `ratio-4x3-JmMMNJqM`,
    "mx-md-5": `mx-md-5-oWUjgx8x`,
    "my-md-1": `my-md-1-_uU2o20f`,
    "column-gap-lg-1": `column-gap-lg-1-FqPKQNAG`,
    "mt-0": `mt-0-LkGMOqt5`,
    "object-fit-lg-scale": `object-fit-lg-scale-CljH3Vrl`,
    "column-gap-xl-4": `column-gap-xl-4-kowsEN6E`,
    "link-underline-opacity-50-hover": `link-underline-opacity-50-hover-ejvrQP_y`,
    "align-self-xxl-center": `align-self-xxl-center-FYPLw2wE`,
    "ms-lg-4": `ms-lg-4-vW7Pqc8n`,
    "gap-md-4": `gap-md-4-s80xHOkN`,
    "gap-xl-1": `gap-xl-1-NubHuA6O`,
    "collapsed": `collapsed-wcfZ4KCy`,
    "position-absolute": `position-absolute-POXUVWTQ`,
    "row-cols-sm-3": `row-cols-sm-3-Jl6TSFwb`,
    "col-lg-3": `col-lg-3-gimK14Az`,
    "col-xl-9": `col-xl-9-syK4UUqQ`,
    "sticky-sm-top": `sticky-sm-top-_p0FQ9HM`,
    "object-fit-fill": `object-fit-fill-N3j61UPd`,
    "flex-sm-grow-1": `flex-sm-grow-1-IrUvG6k9`,
    "mx-sm-4": `mx-sm-4-_yFzEE-w`,
    "table-hover": `table-hover-Nppo4EAz`,
    "mt-lg-5": `mt-lg-5-4aO2gU5m`,
    "ps-xl-1": `ps-xl-1-u390R18B`,
    "offset-11": `offset-11-dgQS0-uD`,
    "text-primary-emphasis": `text-primary-emphasis-P-LWd6eU`,
    "mt-1": `mt-1-ofy8mANC`,
    "mt-2": `mt-2-61MFNJRE`,
    "ms-1": `ms-1-EjNgWxuT`,
    "ms-2": `ms-2-leSge6lF`,
    "tab-content": `tab-content-P4QdRY8x`,
    "border-primary": `border-primary-uQrmLYqi`,
    "ms-3": `ms-3-htyQtmPY`,
    "flex-md-column": `flex-md-column-yopgz3_U`,
    "rounded-bottom-1": `rounded-bottom-1-7nJKgye1`,
    "flex-md-wrap-reverse": `flex-md-wrap-reverse-UruXL24Z`,
    "offset-xl-10": `offset-xl-10-GcZcKyHb`,
    "table-striped": `table-striped-1E21IguM`,
    "bg-warning": `bg-warning-frV7c3m2`,
    "py-md-2": `py-md-2-YhLO3SHD`,
    "has-validation": `has-validation-FCJkPABj`,
    "col-lg-8": `col-lg-8-Ow_LXyuj`,
    "row-cols-lg-1": `row-cols-lg-1-QSFBvz58`,
    "rounded-end-4": `rounded-end-4-9X32acan`,
    "flex-sm-column": `flex-sm-column-3okGeqH4`,
    "my-md-auto": `my-md-auto-TrD6e34o`,
    "ms-xl-2": `ms-xl-2-t2xjxXv0`,
    "container-md": `container-md-aLSdBt9V`,
    "overflow-y-auto": `overflow-y-auto-1NO4EYAA`,
    "z-n1": `z-n1-69fwX3OM`,
    "d-md-inline-grid": `d-md-inline-grid-fD3vDok4`,
    "dropdown-menu-xl-end": `dropdown-menu-xl-end-ADM3tw01`,
    "flex-row-reverse": `flex-row-reverse-auBmTtwi`,
    "rounded-1": `rounded-1-MLksR55f`,
    "btn-toolbar": `btn-toolbar-4iQ3ftVV`,
    "offset-sm-7": `offset-sm-7-7A-0saOg`,
    "mx-lg-2": `mx-lg-2-gHzWmKa6`,
    "ms-4": `ms-4-dfk1FWKe`,
    "ms-5": `ms-5-eL_LYv9Z`,
    "offset-xl-1": `offset-xl-1-VLD3YIUn`,
    "valid-tooltip": `valid-tooltip-ml_l3sIn`,
    "column-gap-lg-0": `column-gap-lg-0-gOCq-vgY`,
    "list-group-item-info": `list-group-item-info-qvtOvm9k`,
    "g-xxl-1": `g-xxl-1-72cXw64l`,
    "mb-md-3": `mb-md-3-Y_OpfLq2`,
    "nav-item": `nav-item-cq21Aiph`,
    "rounded-start-5": `rounded-start-5-Y30IQcFO`,
    "my-md-3": `my-md-3-Fv9ynhOU`,
    "text-bg-primary": `text-bg-primary-QhsY1E9t`,
    "col-xxl-7": `col-xxl-7-ywnhjHck`,
    "justify-content-lg-center": `justify-content-lg-center-wHiiURYY`,
    "rounded-bottom-3": `rounded-bottom-3-hzRXWc9D`,
    "align-self-xl-start": `align-self-xl-start-L8oxhkm6`,
    "py-xl-0": `py-xl-0-7teXYXYS`,
    "row-gap-xl-0": `row-gap-xl-0-hWYjlmeF`,
    "flex-xl-nowrap": `flex-xl-nowrap-XniK-bR3`,
    "offset-xxl-11": `offset-xxl-11-HzxRK4iY`,
    "d-xxl-inline-block": `d-xxl-inline-block-nvA36Vag`,
    "end-0": `end-0-FiZK-1qg`,
    "d-md-inline-block": `d-md-inline-block-tWLkW_HN`,
    "m-xxl-1": `m-xxl-1-IItrG2m-`,
    "d-lg-inline-grid": `d-lg-inline-grid-7ZmFp-AX`,
    "p-xxl-1": `p-xxl-1-JfuGCX6U`,
    "d-sm-grid": `d-sm-grid-Q90U32jN`,
    "mb-lg-auto": `mb-lg-auto-vXY5mIFk`,
    "border-4": `border-4-y7qtw6QW`,
    "mt-sm-1": `mt-sm-1-kRMLyN-G`,
    "my-xl-auto": `my-xl-auto-349FjI4K`,
    "text-opacity-50": `text-opacity-50-gmX9Ki5K`,
    "display-2": `display-2-6vx4o5dn`,
    "pb-sm-5": `pb-sm-5-wo-Omtty`,
    "float-lg-end": `float-lg-end-RjqJwFDu`,
    "d-xxl-inline": `d-xxl-inline-CFh4ldmA`,
    "initialism": `initialism-8MdX5wOd`,
    "my-xl-0": `my-xl-0-jycYWTE2`,
    "align-content-sm-center": `align-content-sm-center-h0w2SGRs`,
    "border-bottom-0": `border-bottom-0-evtDWOLO`,
    "order-xxl-0": `order-xxl-0-Piwb9Gvc`,
    "dropdown-menu-md-end": `dropdown-menu-md-end-VIflwWF2`,
    "d-lg-inline": `d-lg-inline-xQ26z1cb`,
    "overflow-x-hidden": `overflow-x-hidden-R5gjJrmu`,
    "p-xl-5": `p-xl-5-E51O3u28`,
    "p-sm-0": `p-sm-0-ybEre9CI`,
    "flex-sm-grow-0": `flex-sm-grow-0-O80LEWgS`,
    "p-sm-1": `p-sm-1-vWHkaGsH`,
    "p-sm-2": `p-sm-2-_KejOfiN`,
    "p-sm-3": `p-sm-3-hzvESfq_`,
    "p-sm-4": `p-sm-4-e_UVbF1Z`,
    "mx-md-1": `mx-md-1-nvqWGmPF`,
    "p-sm-5": `p-sm-5-u9tmY9Jt`,
    "p-md-0": `p-md-0-aAMz0_Zp`,
    "collapse-horizontal": `collapse-horizontal-rGv9ZB11`,
    "offset-sm-9": `offset-sm-9-pG_O3aaT`,
    "btn-group": `btn-group-Se655dXK`,
    "rounded-top-circle": `rounded-top-circle-2jItHV1B`,
    "d-md-block": `d-md-block-JEL3ftDL`,
    "align-self-lg-end": `align-self-lg-end-LKElfQXv`,
    "d-xxl-table-row": `d-xxl-table-row-7KErI1bB`,
    "offset-xl-3": `offset-xl-3-jPIcq3in`,
    "p-md-1": `p-md-1-_GHI-2MR`,
    "p-md-2": `p-md-2-BLWZ44j3`,
    "me-sm-4": `me-sm-4-wnF9gl-Z`,
    "p-md-3": `p-md-3-ehVgrJlb`,
    "p-md-4": `p-md-4-erknvEZx`,
    "p-md-5": `p-md-5-9Xf0GzSJ`,
    "btn-info": `btn-info-qEdf5bdf`,
    "border-2": `border-2-RTbZ0aQJ`,
    "row-gap-xl-1": `row-gap-xl-1-IQ_F7ONl`,
    "g-xxl-3": `g-xxl-3-iIjYzxsO`,
    "pt-sm-2": `pt-sm-2-9k0r2bdQ`,
    "px-md-3": `px-md-3-CbVBw5sB`,
    "col-lg-11": `col-lg-11-KnPEVcnY`,
    "translate-middle-x": `translate-middle-x-qbQU2m10`,
    "overflow-y-scroll": `overflow-y-scroll-FJGSw3Md`,
    "p-lg-0": `p-lg-0-K2hAIHDt`,
    "p-lg-1": `p-lg-1-_Pc_bOCE`,
    "p-lg-2": `p-lg-2-KLMJAY0V`,
    "p-lg-3": `p-lg-3-u1rxCy5o`,
    "p-lg-4": `p-lg-4-wH2IPeXp`,
    "card-body": `card-body-8NANrjew`,
    "p-lg-5": `p-lg-5-PTE1vUJK`,
    "p-xl-0": `p-xl-0-Ngq6aN9e`,
    "ms-sm-3": `ms-sm-3-PNECydwr`,
    "offset-xxl-0": `offset-xxl-0-G08phhAp`,
    "offset-xxl-9": `offset-xxl-9-7QSe1lVl`,
    "table-active": `table-active-S8NuTbxB`,
    "pb-md-2": `pb-md-2-aq4zeSfr`,
    "d-sm-table": `d-sm-table-jIpRAtav`,
    "mb-lg-0": `mb-lg-0-Hhzjla0T`,
    "link-opacity-100": `link-opacity-100-5njasmoq`,
    "p-xxl-3": `p-xxl-3-JJlegHyL`,
    "align-content-lg-around": `align-content-lg-around-9POCfckD`,
    "float-md-end": `float-md-end-enDLygTC`,
    "p-xl-1": `p-xl-1-_IRfVT4z`,
    "p-xl-2": `p-xl-2-G142pBWs`,
    "p-xl-3": `p-xl-3-eIuG9Vqd`,
    "p-xl-4": `p-xl-4-J0UyVmKF`,
    "row-cols-md-3": `row-cols-md-3-L95zhhJW`,
    "me-lg-0": `me-lg-0-u9zAWIox`,
    "px-xxl-4": `px-xxl-4-frDkJcyX`,
    "pe-xxl-1": `pe-xxl-1-PbwdI8-z`,
    "ps-xxl-3": `ps-xxl-3-fdTLUOpD`,
    "mt-sm-3": `mt-sm-3-2LPI5V4z`,
    "container-xl": `container-xl-uBbfY197`,
    "gy-5": `gy-5-eyXmDE-v`,
    "gx-0": `gx-0-kkZD2s6-`,
    "gy-0": `gy-0-OKBfCkhO`,
    "gx-1": `gx-1-QdQWXhDw`,
    "gy-1": `gy-1--IAx4vW_`,
    "gx-2": `gx-2-bU0nL8Yd`,
    "gy-2": `gy-2-HqOSJFSV`,
    "gx-3": `gx-3-_gHO4zua`,
    "gy-3": `gy-3-VQvZXiIA`,
    "gx-4": `gx-4-onaJ2dkh`,
    "gy-4": `gy-4-MN8Pyj5c`,
    "gx-5": `gx-5-4VmWEavR`,
    "nav-tabs": `nav-tabs-YEU7YL-W`,
    "float-end": `float-end-FHhqENHn`,
    "rounded-5": `rounded-5-SDTb0WAn`,
    "shadow-lg": `shadow-lg-k0pCxXMp`,
    "border-opacity-25": `border-opacity-25-p8-wE_Qu`,
    "me-xl-3": `me-xl-3-6DEuB4Tv`,
    "pb-xl-5": `pb-xl-5-PT63oApN`,
    "order-xxl-1": `order-xxl-1-9lulPtTu`,
    "btn-link": `btn-link-WIgguq3j`,
    "w-25": `w-25-0fqjW51f`,
    "d-block": `d-block-2W6V4sIY`,
    "row-cols-sm-auto": `row-cols-sm-auto-3xFz5LtA`,
    "w-50": `w-50-aJxbcoVy`,
    "w-75": `w-75-uoEnXgOR`,
    "m-xl-auto": `m-xl-auto-ALawBn5m`,
    "my-xl-2": `my-xl-2-9WRqDFhQ`,
    "ps-sm-5": `ps-sm-5-15wRBeam`,
    "py-xxl-3": `py-xxl-3-Ox8-jusF`,
    "pt-xxl-2": `pt-xxl-2-w9295IGz`,
    "modal-fullscreen-md-down": `modal-fullscreen-md-down-wi8_hZZ3`,
    "container-sm": `container-sm-HLi1DGMf`,
    "btn-outline-dark": `btn-outline-dark-vT0V15Wv`,
    "alert-warning": `alert-warning-gOjTi5tP`,
    "pt-md-4": `pt-md-4-gnakOxIp`,
    "object-fit-md-contain": `object-fit-md-contain-oIPw_hVq`,
    "table-bordered": `table-bordered-L6TkELZ9`,
    "offset-4": `offset-4-LrsI27Ib`,
    "align-items-xl-end": `align-items-xl-end-e4yM_a0U`,
    "me-md-auto": `me-md-auto-x_5h5fTG`,
    "rounded-bottom-4": `rounded-bottom-4-S-KItxBm`,
    "align-items-stretch": `align-items-stretch-McihIwTC`,
    "rounded-end": `rounded-end-Lu9W6LED`,
    "row-cols-1": `row-cols-1-a1HZhMcl`,
    "ps-xxl-1": `ps-xxl-1-GBhf7wv4`,
    "border-start-0": `border-start-0-o9nzlNc3`,
    "dropdown-item": `dropdown-item-wasBBdAm`,
    "align-items-xxl-end": `align-items-xxl-end-OQALCPa6`,
    "opacity-75": `opacity-75-WZEG4sW_`,
    "col-form-label": `col-form-label-SqFQgJkZ`,
    "dropdown-toggle": `dropdown-toggle-TK6y0s81`,
    "order-0": `order-0-YdyoJw-N`,
    "column-gap-sm-4": `column-gap-sm-4-7MpVkvw6`,
    "badge": `badge-t5rbOpzB`,
    "gy-md-1": `gy-md-1-8mbyvXFK`,
    "card-header-tabs": `card-header-tabs-ZZGcBSL0`,
    "card-img-bottom": `card-img-bottom-BtMRhgjR`,
    "list-group-item-dark": `list-group-item-dark-WWZ7_T-G`,
    "ratio": `ratio-GdF3_4Hu`,
    "my-lg-auto": `my-lg-auto-5m5jfpjg`,
    "row-cols-sm-4": `row-cols-sm-4-6kal2CK8`,
    "pb-lg-4": `pb-lg-4-IEaOFtqC`,
    "pe-xl-5": `pe-xl-5-Ew4rP2IW`,
    "offset-lg-5": `offset-lg-5-zh9M_r78`,
    "offset-xxl-1": `offset-xxl-1-sNi7y1-m`,
    "pt-sm-4": `pt-sm-4-0X2HM4s6`,
    "m-xxl-5": `m-xxl-5-Duz6qWdZ`,
    "justify-content-lg-end": `justify-content-lg-end-7UAjYl9F`,
    "flex-md-row": `flex-md-row-p4qQu8aL`,
    "gy-xl-0": `gy-xl-0-UsXuyGTl`,
    "d-xl-inline-flex": `d-xl-inline-flex-cLBnuZas`,
    "offset-9": `offset-9-TWok1eEW`,
    "col-xxl-11": `col-xxl-11-byNYgXnO`,
    "bg-light": `bg-light-x-nqGpG3`,
    "list-group-item-danger": `list-group-item-danger-w7MxL_ka`,
    "offcanvas-title": `offcanvas-title-sJDYKq6z`,
    "row-cols-xl-auto": `row-cols-xl-auto-fIhvIyST`,
    "modal-body": `modal-body-K4INu9AT`,
    "focus-ring-success": `focus-ring-success-HO3cw_eR`,
    "pt-xxl-0": `pt-xxl-0-urQQe1vC`,
    "mb-lg-2": `mb-lg-2-5EYCQUUK`,
    "justify-content-xl-center": `justify-content-xl-center-3TlwFnwe`,
    "bs-popover-start": `bs-popover-start-mmLKoIXJ`,
    "modal-fullscreen-xxl-down": `modal-fullscreen-xxl-down-ygj4b-gE`,
    "row-gap-xxl-2": `row-gap-xxl-2-oICY2kLp`,
    "row-cols-md-1": `row-cols-md-1-1epb4Euk`,
    "form-control-sm": `form-control-sm-2QiKsd7q`,
    "rounded-end-2": `rounded-end-2-nQAmayDo`,
    "me-lg-2": `me-lg-2-vJK78Lhu`,
    "d-xl-inline-block": `d-xl-inline-block-2GtWGaQf`,
    "mx-xl-0": `mx-xl-0-VHzUYThN`,
    "mt-xl-4": `mt-xl-4-SoZ0Obaw`,
    "navbar-text": `navbar-text-5IlfqFcy`,
    "py-sm-0": `py-sm-0-cAtgLFqD`,
    "table-responsive": `table-responsive-ElbRCwbw`,
    "pt-xxl-5": `pt-xxl-5-AnIefc60`,
    "d-print-grid": `d-print-grid-sVgS4iIW`,
    "mw-100": `mw-100-gSe0ItIY`,
    "mh-100": `mh-100-THHYXPV4`,
    "m-auto": `m-auto-42N7kmtU`,
    "m-sm-0": `m-sm-0-epPBGi42`,
    "m-sm-1": `m-sm-1-xUQ0NBNV`,
    "m-sm-2": `m-sm-2-NxxQ0NJU`,
    "m-sm-3": `m-sm-3-DS8l2Q2B`,
    "modal-fullscreen-lg-down": `modal-fullscreen-lg-down-MzkRGrkm`,
    "m-sm-4": `m-sm-4-wHnAoLw3`,
    "offcanvas-start": `offcanvas-start-HtItPV8T`,
    "m-sm-5": `m-sm-5-LtvruiMp`,
    "pe-sm-1": `pe-sm-1-wwyM5Qcn`,
    "input-group": `input-group-1rXi8Jir`,
    "btn-group-lg": `btn-group-lg-evCP6L3U`,
    "m-md-0": `m-md-0-rMAoPd8j`,
    "m-md-1": `m-md-1-QsI2Ztv2`,
    "flex-lg-row-reverse": `flex-lg-row-reverse-1_y0poet`,
    "mt-xxl-4": `mt-xxl-4-tZdQILBn`,
    "showing": `showing-AsAABKC0`,
    "rounded-top-4": `rounded-top-4-bqMJlNje`,
    "offcanvas-md": `offcanvas-md--FhvMfTD`,
    "border-end": `border-end-B8-jnHa0`,
    "m-md-2": `m-md-2-9eVriQso`,
    "rounded-start-pill": `rounded-start-pill-OV7Ys0Rz`,
    "m-md-3": `m-md-3-PZnvU2nU`,
    "me-sm-0": `me-sm-0-sHiI2vYb`,
    "m-md-4": `m-md-4-eIaJ_6zd`,
    "m-md-5": `m-md-5-Frl4Be_X`,
    "m-lg-0": `m-lg-0-4MVoIHG-`,
    "m-lg-1": `m-lg-1-k_1ag_R3`,
    "border-1": `border-1-SdfBQCBj`,
    "progress-bar-striped": `progress-bar-striped-X9789p7x`,
    "justify-content-sm-end": `justify-content-sm-end-V3_0t_6i`,
    "card-img-top": `card-img-top-XZ3s8rzf`,
    "mb-md-5": `mb-md-5-362WprnG`,
    "justify-content-start": `justify-content-start-l0tOWHth`,
    "text-muted": `text-muted-RwWvg5hB`,
    "pt-lg-2": `pt-lg-2-zw1bQkii`,
    "pb-xxl-1": `pb-xxl-1-P3nq2zVD`,
    "accordion-flush": `accordion-flush-25rB3xJw`,
    "list-group-item-primary": `list-group-item-primary-APAr9_7b`,
    "my-sm-1": `my-sm-1-vzY2_x6a`,
    "btn-outline-success": `btn-outline-success-LIBKvI_T`,
    "mt-md-5": `mt-md-5-Lin6Hnz0`,
    "mb-xxl-0": `mb-xxl-0-lybHTmu4`,
    "m-lg-2": `m-lg-2-Gd2tA23g`,
    "m-lg-3": `m-lg-3-muHolSP1`,
    "m-lg-4": `m-lg-4-aMiH5_1g`,
    "align-items-lg-end": `align-items-lg-end-mXFZj2_O`,
    "m-lg-5": `m-lg-5-C_1Ff_13`,
    "row-cols-xl-5": `row-cols-xl-5-815POCM_`,
    "fw-medium": `fw-medium-1PusbK4E`,
    "m-xl-0": `m-xl-0-JC_ZIBYG`,
    "offset-xxl-6": `offset-xxl-6-vAY1eLvT`,
    "card-group": `card-group-x42-uh84`,
    "d-lg-table": `d-lg-table-y5WFDjeO`,
    "mb-xl-3": `mb-xl-3-eSi2alJK`,
    "row-cols-sm-6": `row-cols-sm-6-YHv0a4Le`,
    "mt-xxl-auto": `mt-xxl-auto-ZCAdE3qu`,
    "m-xl-1": `m-xl-1-hkX-8a_1`,
    "row-cols-md-auto": `row-cols-md-auto-s1PL9tiZ`,
    "link-dark": `link-dark-lwQ4vTZj`,
    "m-xl-2": `m-xl-2-_juKnQZZ`,
    "m-xl-3": `m-xl-3-3XjQg6Jy`,
    "m-xl-4": `m-xl-4-6TLQsOlg`,
    "m-xl-5": `m-xl-5-YdVBGJKM`,
    "d-xxl-none": `d-xxl-none-ky1_5go5`,
    "px-xxl-3": `px-xxl-3-KMOPXS3E`,
    "modal-lg": `modal-lg-MORxbo-J`,
    "link-info": `link-info-ENC8QDHN`,
    "mb-xxl-5": `mb-xxl-5-Rofy3sIm`,
    "gy-sm-2": `gy-sm-2-2C1n_ixC`,
    "link-offset-2": `link-offset-2-3tsqRG66`,
    "border-success-subtle": `border-success-subtle-2H23-UaS`,
    "ratio-21x9": `ratio-21x9-UjqAxcli`,
    "form-check-input": `form-check-input-kJ2KxanH`,
    "float-lg-none": `float-lg-none-8N99CBx0`,
    "gx-lg-1": `gx-lg-1-SKOmG2ba`,
    "px-lg-2": `px-lg-2-4n5pvjtx`,
    "py-lg-4": `py-lg-4-wmzUE97O`,
    "text-body-secondary": `text-body-secondary-gDE1OAHk`,
    "float-none": `float-none-97p-Gc2u`,
    "d-xl-block": `d-xl-block-lcQXEmUL`,
    "card-img-overlay": `card-img-overlay-SiRlcxgo`,
    "align-self-auto": `align-self-auto-xpNRqqg2`,
    "row-cols-2": `row-cols-2-Ir28wpA2`,
    "py-xxl-2": `py-xxl-2-cvCYl0Le`,
    "pe-xxl-5": `pe-xxl-5-iL3RI5Y-`,
    "link-opacity-10-hover": `link-opacity-10-hover-yIVj_-IL`,
    "bg-dark-subtle": `bg-dark-subtle-5oS5QJlG`,
    "nav-underline": `nav-underline-GqRpeJTY`,
    "align-items-end": `align-items-end-9fILKlbZ`,
    "spinner-border": `spinner-border-KZ1jWmcn`,
    "py-sm-2": `py-sm-2-1y5oVowX`,
    "bg-success": `bg-success-zIaxoa14`,
    "row-gap-sm-1": `row-gap-sm-1-OeQ6c9ZR`,
    "justify-content-xxl-center": `justify-content-xxl-center--UCi1gL3`,
    "mb-md-4": `mb-md-4-jNMmS-7f`,
    "pagination": `pagination-1FmJmkI_`,
    "page-link": `page-link-cA4jIXAq`,
    "gy-lg-0": `gy-lg-0-W06IyL1a`,
    "offcanvas-body": `offcanvas-body-7gAjWN2y`,
    "align-self-baseline": `align-self-baseline-LGA86VVn`,
    "row-cols-4": `row-cols-4-fqdeTsnL`,
    "px-xxl-1": `px-xxl-1-NASwYciE`,
    "ps-xxl-0": `ps-xxl-0-NVJAMbZ-`,
    "flex-lg-wrap-reverse": `flex-lg-wrap-reverse-0ei6nfzM`,
    "text-center": `text-center--8WgoLRe`,
    "align-content-sm-stretch": `align-content-sm-stretch-77FctWgR`,
    "me-sm-2": `me-sm-2-1fiAVjbh`,
    "align-items-lg-start": `align-items-lg-start-_yQ9okm1`,
    "flex-grow-0": `flex-grow-0-_uomjmy2`,
    "align-content-lg-end": `align-content-lg-end-KOZD17tP`,
    "mx-xxl-0": `mx-xxl-0-Qxm75_6c`,
    "gap-xxl-0": `gap-xxl-0-c4VFYrMp`,
    "rounded-start-0": `rounded-start-0-JOpjtpoW`,
    "offset-md-7": `offset-md-7-p4lHLT9T`,
    "flex-lg-shrink-1": `flex-lg-shrink-1-IYGFOkBy`,
    "rounded-bottom-pill": `rounded-bottom-pill-MZwknJek`,
    "order-md-1": `order-md-1-_p-_O8Qa`,
    "row-cols-lg-3": `row-cols-lg-3-hxRNMm1u`,
    "row-cols-xxl-6": `row-cols-xxl-6-brYjs5Fg`,
    "justify-content-evenly": `justify-content-evenly-uvbWYbST`,
    "bg-success-subtle": `bg-success-subtle-Ps1ZJCLS`,
    "navbar-expand-lg": `navbar-expand-lg-YDJupLYR`,
    "gx-xl-0": `gx-xl-0-TItR4dmd`,
    "list-group-horizontal-lg": `list-group-horizontal-lg-UNsEJbQb`,
    "sticky-sm-bottom": `sticky-sm-bottom-v4JC3z_U`,
    "row-cols-lg-auto": `row-cols-lg-auto-FxZnidbx`,
    "py-xxl-0": `py-xxl-0-Wt3EXBPP`,
    "pe-xxl-3": `pe-xxl-3-uZHtcP5z`,
    "align-self-sm-start": `align-self-sm-start-DICKN2FB`,
    "ps-xxl-5": `ps-xxl-5-mwDdJivb`,
    "mx-xxl-5": `mx-xxl-5-yeZcsLL9`,
    "rounded-end-circle": `rounded-end-circle-Xl1-LG3z`,
    "me-xxl-2": `me-xxl-2-IFGJUSX5`,
    "mb-xl-1": `mb-xl-1-utiyh6Sb`,
    "ms-xxl-4": `ms-xxl-4-sCkgafeC`,
    "ratio-16x9": `ratio-16x9-aHeqOxtO`,
    "col-xl-11": `col-xl-11-w8QViczP`,
    "flex-xl-row": `flex-xl-row-6P4NdgD7`,
    "text-lowercase": `text-lowercase-4XVlIcyW`,
    "row-cols-md-5": `row-cols-md-5-YonCKH5D`,
    "text-black-50": `text-black-50-jsbpiMAJ`,
    "modal-header": `modal-header-cl-swoyQ`,
    "ps-xl-4": `ps-xl-4-szusqrhm`,
    "modal-dialog-scrollable": `modal-dialog-scrollable-KeQrApzj`,
    "mt-sm-4": `mt-sm-4-7WfArVSq`,
    "ps-sm-2": `ps-sm-2-HcQZt-PH`,
    "d-xl-inline": `d-xl-inline-G-CaU7eW`,
    "px-xl-1": `px-xl-1-k4RN5faH`,
    "toast-container": `toast-container-Qr8SapmS`,
    "link-opacity-100-hover": `link-opacity-100-hover-pVPLLsR0`,
    "is-valid": `is-valid-gHloTC6w`,
    "container-xxl": `container-xxl-75dNV7mR`,
    "popover-header": `popover-header-2OlT6uIK`,
    "flex-shrink-1": `flex-shrink-1-FQQp6iCJ`,
    "my-xxl-4": `my-xxl-4-1bMvfDK0`,
    "mt-xxl-3": `mt-xxl-3-FuL-6F6k`,
    "my-xl-5": `my-xl-5-UPlbZ-lk`,
    "pe-sm-5": `pe-sm-5-5qkipWV2`,
    "link-underline-secondary": `link-underline-secondary-Fib-0V66`,
    "btn-outline-info": `btn-outline-info-n0sfskfQ`,
    "table-info": `table-info-q8ixErH7`,
    "pe-md-0": `pe-md-0-6WsEbjAJ`,
    "rounded-top-0": `rounded-top-0-ffWldjrh`,
    "row-gap-sm-2": `row-gap-sm-2-RocyueLi`,
    "opacity-50": `opacity-50-uwkgheZZ`,
    "flex-xl-grow-0": `flex-xl-grow-0-JSaYMMQa`,
    "d-xxl-table": `d-xxl-table-Tz6Z-Aqw`,
    "placeholder-lg": `placeholder-lg-e3A6x59K`,
    "object-fit-lg-fill": `object-fit-lg-fill-XQyjlPxC`,
    "pe-xl-3": `pe-xl-3-J38s6GtZ`,
    "flex-lg-nowrap": `flex-lg-nowrap-t2gZy4Gw`,
    "d-xxl-grid": `d-xxl-grid-crAMWrbX`,
    "bottom-100": `bottom-100-3Fgm2HAQ`,
    "d-md-table-row": `d-md-table-row-FIwEUB6K`,
    "column-gap-xl-5": `column-gap-xl-5-8gMdYCuw`,
    "col-xxl-4": `col-xxl-4-WKb2EIku`,
    "pagination-lg": `pagination-lg-IMd9UwUg`,
    "object-fit-xl-scale": `object-fit-xl-scale-jGUdgIms`,
    "text-decoration-underline": `text-decoration-underline-ghpvJNDH`,
    "float-md-none": `float-md-none-q4U4onNn`,
    "ms-xxl-2": `ms-xxl-2-UIdRuFEf`,
    "offset-sm-10": `offset-sm-10-CsC1tgTn`,
    "gy-lg-2": `gy-lg-2-K35bIzH7`,
    "progress-bar-animated": `progress-bar-animated-XxQcGHZf`,
    "dropdown-menu": `dropdown-menu-LRedvQAR`,
    "gap-xxl-2": `gap-xxl-2-c0ehAqLx`,
    "dropdown-menu-xxl-start": `dropdown-menu-xxl-start-_kj10xNO`,
    "offset-lg-4": `offset-lg-4-m0nP9hV1`,
    "row-gap-lg-4": `row-gap-lg-4-r3SK5MZr`,
    "navbar-expand-xl": `navbar-expand-xl-sZgRNxp2`,
    "rounded-start-2": `rounded-start-2-5YCLgMsa`,
    "row-cols-sm-2": `row-cols-sm-2-QUPuOSDf`,
    "ms-md-5": `ms-md-5-2X3aaOS-`,
    "order-sm-1": `order-sm-1-tBY6srxC`,
    "blockquote-footer": `blockquote-footer-dYaPU9Ek`,
    "offset-md-5": `offset-md-5-oCKfBCqn`,
    "link-underline-opacity-10-hover": `link-underline-opacity-10-hover-8pzrWtmg`,
    "mt-md-1": `mt-md-1-oBTuVUwN`,
    "bs-popover-end": `bs-popover-end-G6LUAXSm`,
    "carousel-control-prev-icon": `carousel-control-prev-icon-9lvoVlgC`,
    "me-md-3": `me-md-3-LUQ550rs`,
    "mt-xxl-1": `mt-xxl-1-hO7x2aiK`,
    "mb-xxl-4": `mb-xxl-4-bSGmHLg4`,
    "gx-xl-2": `gx-xl-2-zyupd2OQ`,
    "link-offset-3-hover": `link-offset-3-hover-ht3tSGvh`,
    "pt-xl-2": `pt-xl-2-9i29dwKl`,
    "pb-md-5": `pb-md-5-QRJ62TG2`,
    "text-sm-end": `text-sm-end-oEiQXe04`,
    "order-xl-4": `order-xl-4-89TskDK3`,
    "rounded-pill": `rounded-pill-Xe5brxMM`,
    "navbar-collapse": `navbar-collapse-pXXV-O4G`,
    "navbar-expand-md": `navbar-expand-md--ACyM6N3`,
    "ratio-1x1": `ratio-1x1-Lqe1uoKA`,
    "table-success": `table-success-s1w9FgDL`,
    "btn-primary": `btn-primary-Nsdjb_jH`,
    "bg-primary": `bg-primary-qLA4uPka`,
    "row-gap-md-3": `row-gap-md-3-Lo1r982p`,
    "mt-xl-3": `mt-xl-3-I85fo36i`,
    "offset-xl-5": `offset-xl-5-9seoz5ug`,
    "ps-sm-0": `ps-sm-0-TT7T5GRW`,
    "text-truncate": `text-truncate-t98pDtxJ`,
    "flex-lg-grow-0": `flex-lg-grow-0-YEMzuC8L`,
    "ps-md-1": `ps-md-1-iYO5tTrl`,
    "px-xl-3": `px-xl-3-gJwWstjU`,
    "bottom-50": `bottom-50-3k4_urHv`,
    "rounded-2": `rounded-2-mJEUQQf1`,
    "me-xl-4": `me-xl-4-VhzjinmY`,
    "text-body-tertiary": `text-body-tertiary-z_R2WAdL`,
    "order-lg-3": `order-lg-3-ZAm-vqak`,
    "row-gap-sm-3": `row-gap-sm-3-iOrC1f_e`,
    "link-underline-danger": `link-underline-danger-dCcEjj40`,
    "fixed-top": `fixed-top-Kxev30xk`,
    "flex-xxl-grow-0": `flex-xxl-grow-0-5B1QTncU`,
    "object-fit-sm-cover": `object-fit-sm-cover-Y3FQ3reA`,
    "gx-md-4": `gx-md-4-elDpsrEv`,
    "gx-sm-3": `gx-sm-3-7jPdIkZT`,
    "lh-base": `lh-base-gXp8DEEf`,
    "pe-md-2": `pe-md-2-69tMkcWY`,
    "text-opacity-100": `text-opacity-100-jXFwYijY`,
    "lh-sm": `lh-sm-Xq1621aP`,
    "lh-lg": `lh-lg-o68O_Zw6`,
    "mb-xxl-2": `mb-xxl-2-IW7wj6nk`,
    "offset-sm-11": `offset-sm-11-7umMn4RW`,
    "mx-sm-auto": `mx-sm-auto-izjzlMYH`,
    "pt-md-1": `pt-md-1-rqffo9Cz`,
    "my-md-0": `my-md-0-2-XhbgN-`,
    "shadow-none": `shadow-none-BKCZg3K8`,
    "border-black": `border-black-RtwXGx40`,
    "col-xxl-6": `col-xxl-6-uWAWTHE0`,
    "modal-fullscreen": `modal-fullscreen-edyUiZyT`,
    "h3": `h3-u1tl_zTg`,
    "h2": `h2-9iIFGxB1`,
    "h1": `h1-mp-qK8h3`,
    "h6": `h6-UMkR-8zP`,
    "h5": `h5-SY0qkvsd`,
    "h4": `h4-_Qt6GoqH`,
    "row-cols-xxl-3": `row-cols-xxl-3-3XtIRf7A`,
    "popover-arrow": `popover-arrow-gvnvuwkA`,
    "order-md-4": `order-md-4-LP15pAk5`,
    "row-gap-lg-5": `row-gap-lg-5-y1G3BxFH`,
    "order-xl-first": `order-xl-first-MhSoG6lj`,
    "order-lg-5": `order-lg-5-0Hqvt5lH`,
    "column-gap-xxl-2": `column-gap-xxl-2-IrxL-B9A`,
    "pe-lg-2": `pe-lg-2-y0Q-DkNd`,
    "order-5": `order-5-oe9LSKdW`,
    "align-self-xxl-end": `align-self-xxl-end-Yr0Pbr9B`,
    "m-xxl-2": `m-xxl-2-HmXLfcmF`,
    "list-inline": `list-inline-a-bbQ5S0`,
    "pb-sm-1": `pb-sm-1-KRlGSZ-_`,
    "sticky-lg-bottom": `sticky-lg-bottom-MFtr-CzH`,
    "d-xl-table": `d-xl-table-TC4XGjxQ`,
    "gy-xl-5": `gy-xl-5-SFYCTXDo`,
    "column-gap-xxl-5": `column-gap-xxl-5-di2kVJbS`,
    "text-end": `text-end-o4P8nw92`,
    "mt-lg-4": `mt-lg-4-npd1DjuS`,
    "flex-xl-wrap-reverse": `flex-xl-wrap-reverse-39THXl2s`,
    "bg-opacity-10": `bg-opacity-10-OWLNcS3s`,
    "border-start": `border-start-oO48-Ktd`,
    "mt-sm-0": `mt-sm-0-v7Is4kJe`,
    "gap-sm-0": `gap-sm-0-DM_tzMwS`,
    "accordion-header": `accordion-header-EQbFEL2j`,
    "sticky-bottom": `sticky-bottom-eCEDvUI7`,
    "display-3": `display-3-UFO0w_8A`,
    "g-xl-5": `g-xl-5-4ARr7eZa`,
    "g-md-4": `g-md-4-aclBmSz7`,
    "g-md-5": `g-md-5-AMq5fO-m`,
    "g-lg-0": `g-lg-0-CIcLOIxO`,
    "g-sm-0": `g-sm-0-pwctzASD`,
    "g-sm-1": `g-sm-1-iI_45x0f`,
    "g-sm-2": `g-sm-2-f2kf40PB`,
    "g-sm-3": `g-sm-3-ns0zi9kG`,
    "g-sm-4": `g-sm-4-EihpllqS`,
    "g-sm-5": `g-sm-5-RueH8QP3`,
    "g-lg-1": `g-lg-1-tNRM8mWl`,
    "g-md-0": `g-md-0-2t5nTmIm`,
    "sticky-top": `sticky-top-c698i5Pu`,
    "g-md-1": `g-md-1-QxniAApe`,
    "g-md-2": `g-md-2-WgY9fj47`,
    "text-decoration-line-through": `text-decoration-line-through-Cl-hizdD`,
    "col": `col-9SsdD__7`,
    "rounded": `rounded-WBzCMhnI`,
    "my-xl-1": `my-xl-1-AkPfh4uX`,
    "alert-primary": `alert-primary-RllHwZMQ`,
    "text-md-end": `text-md-end-axjmpTOp`,
    "tab-pane": `tab-pane-o8iX7k1Z`,
    "offset-xl-7": `offset-xl-7-R0ZSTY2W`,
    "g-md-3": `g-md-3-bxhOxeU4`,
    "g-lg-2": `g-lg-2-ksrYqgbY`,
    "g-lg-3": `g-lg-3-wgLFd2w4`,
    "g-lg-4": `g-lg-4-Hb2t_tR6`,
    "dropdown-toggle-split": `dropdown-toggle-split-srvaPEAe`,
    "gap-md-0": `gap-md-0-SpNStgTv`,
    "g-lg-5": `g-lg-5-7DzAAt-c`,
    "g-xl-0": `g-xl-0-T2GEbhoE`,
    "gap-lg-3": `gap-lg-3-rUnyBJH8`,
    "order-sm-2": `order-sm-2-2gl6lEqx`,
    "my-lg-4": `my-lg-4-m2NScakU`,
    "fw-semibold": `fw-semibold-XOuJvHaO`,
    "g-xl-1": `g-xl-1-5iR59WNE`,
    "g-xl-2": `g-xl-2-34dUs6X_`,
    "g-xl-3": `g-xl-3-9kHtQ1mL`,
    "form-text": `form-text-gq25wjnm`,
    "text-wrap": `text-wrap-i8Z5lv3X`,
    "justify-content-xl-end": `justify-content-xl-end-lO2ihWij`,
    "g-xl-4": `g-xl-4-KQp6_5lZ`,
    "align-self-sm-baseline": `align-self-sm-baseline-xoQmQqe5`,
    "flex-xl-row-reverse": `flex-xl-row-reverse-mpF2UR_a`,
    "table-warning": `table-warning-p-oe_rhb`,
    "align-self-xxl-start": `align-self-xxl-start-s2jnaAPB`,
    "list-group-item-light": `list-group-item-light-f78zBKj4`,
    "col-md-8": `col-md-8-LUG6vNTa`,
    "gx-xxl-0": `gx-xxl-0-vD7Aqhof`,
    "gap-md-5": `gap-md-5-gss7_vra`,
    "gap-xl-2": `gap-xl-2-RpcKItSJ`,
    "mb-md-2": `mb-md-2-hdynPJG3`,
    "pt-lg-5": `pt-lg-5-KqMTAO0S`,
    "accordion-button": `accordion-button-7ThHVeAt`,
    "img-thumbnail": `img-thumbnail-VFLgLq1i`,
    "rounded-top": `rounded-top-La2iCb-h`,
    "w-auto": `w-auto-jNsXVqK_`,
    "order-sm-4": `order-sm-4-7bnSes-N`,
    "ms-md-1": `ms-md-1-8roZ6Ehc`,
    "alert-light": `alert-light-nkg32PzU`,
    "justify-content-lg-evenly": `justify-content-lg-evenly-QfaXouPF`,
    "order-first": `order-first-jKTGOWGP`,
    "text-danger-emphasis": `text-danger-emphasis-FSZbhGx3`,
    "dropdown-menu-start": `dropdown-menu-start-OW3BWfIw`,
    "column-gap-5": `column-gap-5-AhoITkkw`,
    "pb-sm-3": `pb-sm-3-nkF2vy76`,
    "col-md-1": `col-md-1-MM7NwVom`,
    "col-lg-4": `col-lg-4-DXd9pRTy`,
    "gx-xxl-5": `gx-xxl-5-wAnzJMgi`,
    "collapse": `collapse-1Lobm4JT`,
    "placeholder-glow": `placeholder-glow-83pnea2I`,
    "gap-lg-1": `gap-lg-1-1eM09Ut_`,
    "pe-sm-3": `pe-sm-3-d2wmRU3g`,
    "align-bottom": `align-bottom-cH30EgHo`,
    "text-xl-center": `text-xl-center-bsiy3baO`,
    "m-lg-auto": `m-lg-auto-wuZL-L7K`,
    "ps-lg-0": `ps-lg-0-uvtXmpRV`,
    "bg-secondary": `bg-secondary-1K5gV24C`,
    "mt-sm-2": `mt-sm-2-nfA6BDz2`,
    "ps-sm-4": `ps-sm-4-1NMkpiXv`,
    "gx-lg-4": `gx-lg-4-b4T8d6q9`,
    "table-dark": `table-dark-Ls-u1cLn`,
    "ms-lg-1": `ms-lg-1-TwFC1wlp`,
    "column-gap-xl-3": `column-gap-xl-3-_Rn9ZBxD`,
    "order-lg-0": `order-lg-0-QjeiTCK8`,
    "progress-bar": `progress-bar-YML6U5IO`,
    "rounded-top-pill": `rounded-top-pill-GnBLtZ7X`,
    "card-subtitle": `card-subtitle-7dMGoLes`,
    "my-sm-3": `my-sm-3-AZDfkrlk`,
    "col-md-6": `col-md-6-YNhi17TN`,
    "col-lg-9": `col-lg-9-rGh2BKGb`,
    "col-xl-3": `col-xl-3-EfKMTffC`,
    "gy-xxl-4": `gy-xxl-4-Lx-WiJu4`,
    "flex-column": `flex-column-YxP6lwa7`,
    "align-items-sm-baseline": `align-items-sm-baseline-KzYX7Nnw`,
    "align-content-md-between": `align-content-md-between-L_uO3u-J`,
    "column-gap-lg-4": `column-gap-lg-4-yvwac4bT`,
    "object-fit-xl-cover": `object-fit-xl-cover-KcBfFB1U`,
    "align-items-xxl-baseline": `align-items-xxl-baseline-5pQR8O6O`,
    "align-items-xxl-stretch": `align-items-xxl-stretch-0ZLx3oS0`,
    "d-md-table-cell": `d-md-table-cell-wrWgK5lb`,
    "col-md-11": `col-md-11-2DW0n2gf`,
    "modal-footer": `modal-footer-jlvrBGbH`,
    "column-gap-sm-0": `column-gap-sm-0-XSUJl73y`,
    "align-self-md-center": `align-self-md-center-BhcnH8Sa`,
    "btn-outline-danger": `btn-outline-danger-OT8M37V-`,
    "pt-md-5": `pt-md-5-TdMYxwoT`,
    "text-md-center": `text-md-center-yH-CWJeN`,
    "column-gap-xxl-3": `column-gap-xxl-3-bGzLhu5h`,
    "link-underline-info": `link-underline-info-0-pGsjzB`,
    "align-content-md-end": `align-content-md-end-A_1COMoa`,
    "align-content-sm-around": `align-content-sm-around-vR42ecIl`,
    "gy-lg-5": `gy-lg-5-369N-Qp2`,
    "col-xl-8": `col-xl-8-X1BShK4E`,
    "carousel": `carousel-yTyTYOG3`,
    "d-lg-flex": `d-lg-flex-WelhMi-8`,
    "gx-md-0": `gx-md-0-6Tm-awMi`,
    "me-lg-auto": `me-lg-auto-7ya3vg2J`,
    "align-content-xl-around": `align-content-xl-around-MFR8n5px`,
    "tooltip": `tooltip-8VI6YUhA`,
    "col-xl-auto": `col-xl-auto-1RRK5AVs`,
    "col-form-label-lg": `col-form-label-lg-mDBYQn5i`,
    "order-1": `order-1-P0hHlb2h`,
    "text-info-emphasis": `text-info-emphasis-_5wDatPx`,
    "align-self-sm-auto": `align-self-sm-auto-jLP1iamh`,
    "pt-sm-5": `pt-sm-5-b6ipUYO8`,
    "link-underline-opacity-75": `link-underline-opacity-75-ZRH9PxTR`,
    "row-gap-xl-5": `row-gap-xl-5-cqQH69Yi`,
    "align-content-xxl-end": `align-content-xxl-end-U8AINPlf`,
    "row-cols-lg-6": `row-cols-lg-6-iP9iJw8F`,
    "gy-xl-1": `gy-xl-1-7zwgom-i`,
    "column-gap-3": `column-gap-3-vX_Yww6S`,
    "column-gap-4": `column-gap-4-MDMfmZBP`,
    "link-underline-primary": `link-underline-primary-P6mHlbO5`,
    "mx-xl-4": `mx-xl-4-ClWuTj7N`,
    "gx-xl-5": `gx-xl-5-Ay9Ei1Pv`,
    "focus-ring-warning": `focus-ring-warning-m54L73gO`,
    "pt-xl-5": `pt-xl-5-0wP7lyPh`,
    "accordion": `accordion-AnAbS-w3`,
    "pb-xl-3": `pb-xl-3-YoK1JAzw`,
    "justify-content-md-between": `justify-content-md-between-DQVP-vW5`,
    "dropup": `dropup-9Ser2Sxk`,
    "d-grid": `d-grid-bN5gzTmC`,
    "d-flex": `d-flex-DTfNnM2_`,
    "d-none": `d-none-qqYVogti`,
    "top-50": `top-50-E2PpGn3e`,
    "mb-lg-1": `mb-lg-1-cH19TXhI`,
    "bg-secondary-subtle": `bg-secondary-subtle-rL_dhLEa`,
    "bg-danger-subtle": `bg-danger-subtle-JAwD5mtu`,
    "overflow-y-visible": `overflow-y-visible-Meq2FS3w`,
    "ms-xl-4": `ms-xl-4-dfo-ColX`,
    "text-bg-success": `text-bg-success-8PuEOXsk`,
    "focus-ring-primary": `focus-ring-primary-4iN6QOju`,
    "p-0": `p-0-kNTmbFHE`,
    "p-1": `p-1-DaVgHO2N`,
    "p-2": `p-2-GMthWo4R`,
    "p-3": `p-3-Vgw1-vdd`,
    "p-4": `p-4-8rAY9J1U`,
    "p-5": `p-5-aQxXSFj5`,
    "px-xl-4": `px-xl-4-a6402hQV`,
    "col-sm-7": `col-sm-7-Ianpf96e`,
    "gap-sm-4": `gap-sm-4-DcKgKtnW`,
    "flex-xxl-row-reverse": `flex-xxl-row-reverse-GzsIb3Jx`,
    "object-fit-cover": `object-fit-cover-xYs0kKSR`,
    "row-cols-xxl-auto": `row-cols-xxl-auto-k63LPq0Y`,
    "text-xxl-center": `text-xxl-center-G2DvQAXn`,
    "d-sm-inline": `d-sm-inline-UwakkHdL`,
    "ms-lg-3": `ms-lg-3-MZoJXFD3`,
    "d-md-inline-flex": `d-md-inline-flex-q91aDYHO`,
    "offset-sm-5": `offset-sm-5-AEjPWedX`,
    "bs-popover-top": `bs-popover-top-RAD3tSoK`,
    "text-bg-warning": `text-bg-warning-ClLvwJ0C`,
    "align-middle": `align-middle-Z3Rr0fCy`,
    "user-select-auto": `user-select-auto-FF2eMtbh`,
    "my-lg-0": `my-lg-0-C-ILZUGh`,
    "mb-xl-auto": `mb-xl-auto-1YhLv567`,
    "justify-content-xxl-start": `justify-content-xxl-start-lPRMNw0X`,
    "d-sm-inline-block": `d-sm-inline-block-jUR5mfxy`,
    "d-table-row": `d-table-row-tFYvZ74R`,
    "flex-xxl-shrink-0": `flex-xxl-shrink-0-mErL_AkO`,
    "text-decoration-none": `text-decoration-none-akMjP8bL`,
    "d-inline-grid": `d-inline-grid-hiaaA7wd`,
    "link-opacity-50-hover": `link-opacity-50-hover-UBXvAfev`,
    "rounded-circle": `rounded-circle-KUd7vW0T`,
    "table-sm": `table-sm-yL2djsk0`,
    "align-items-sm-center": `align-items-sm-center-3WR0DuRO`,
    "column-gap-sm-2": `column-gap-sm-2-Hn7huSQj`,
    "column-gap-xxl-0": `column-gap-xxl-0-GFz86Vac`,
    "opacity-0": `opacity-0-GIzLRmiB`,
    "offset-lg-3": `offset-lg-3-IO-VElEd`,
    "d-xl-flex": `d-xl-flex-oPm9OIBd`,
    "m-md-auto": `m-md-auto-HdJS2LEi`,
    "carousel-control-prev": `carousel-control-prev-YiXMtoUa`,
    "ps-xl-2": `ps-xl-2-hiOCRIXd`,
    "row-cols-xl-4": `row-cols-xl-4-lOCVuEie`,
    "flex-sm-row-reverse": `flex-sm-row-reverse-u8e_VpzC`,
    "navbar-nav": `navbar-nav-D5hsLHY8`,
    "offset-10": `offset-10-EV1kl9KW`,
    "pe-lg-5": `pe-lg-5-diNuB6k2`,
    "m-xxl-3": `m-xxl-3-RjHU3kvq`,
    "order-3": `order-3-IrXk9WYX`,
    "align-content-between": `align-content-between-uENJKdKp`,
    "progress-stacked": `progress-stacked-yvehsKh3`,
    "link-opacity-75": `link-opacity-75--DvgVZms`,
    "col-auto": `col-auto-WIsGcIP_`,
    "col-sm-5": `col-sm-5-qFu0QBQg`,
    "gx-xxl-4": `gx-xxl-4-SzrT7Sao`,
    "modal-title": `modal-title-F_iVS8Ac`,
    "gap-lg-0": `gap-lg-0-FXrvuCPa`,
    "align-items-xxl-start": `align-items-xxl-start-IXrdP6Ii`,
    "dropdown": `dropdown-ODtEalKM`,
    "row-gap-xxl-4": `row-gap-xxl-4-1rJByo2L`,
    "ms-xl-auto": `ms-xl-auto-_QyIvM3l`,
    "display-4": `display-4-VvsoIcBZ`,
    "gx-lg-0": `gx-lg-0-hlR-Zh3z`,
    "px-lg-3": `px-lg-3-vN_2QkMk`,
    "align-self-xl-center": `align-self-xl-center-OadQ-zku`,
    "border-top": `border-top-l8lFXRzf`,
    "list-group-numbered": `list-group-numbered-md7eqo07`,
    "col-md-5": `col-md-5-NpiIS-EI`,
    "offset-sm-4": `offset-sm-4-_oaDT1rO`,
    "col-xl-2": `col-xl-2-LU8nYnY8`,
    "translate-middle-y": `translate-middle-y-hH84dFc5`,
    "align-content-sm-start": `align-content-sm-start-LQzDBTjc`,
    "offset-xl-0": `offset-xl-0-KSO_BH_z`,
    "gap-xxl-4": `gap-xxl-4-y1w5ndNQ`,
    "align-items-xl-start": `align-items-xl-start-smC5j3Mm`,
    "px-md-0": `px-md-0-u08_sCaX`,
    "bs-tooltip-start": `bs-tooltip-start-Fnw1NlGp`,
    "icon-link": `icon-link-YHAtBimE`,
    "my-lg-2": `my-lg-2-MogBKJzt`,
    "bi": `bi-bEyMTZ6V`,
    "accordion-body": `accordion-body-Z9keK83X`,
    "mt-md-3": `mt-md-3-8R7JvJjH`,
    "py-xl-1": `py-xl-1-UdzGFa7E`,
    "gy-lg-1": `gy-lg-1-CEIP-C2g`,
    "bg-info": `bg-info-6DK5owwG`,
    "col-lg-1": `col-lg-1-VhsZ9alN`,
    "col-xl-7": `col-xl-7-zxHMvoii`,
    "table-responsive-lg": `table-responsive-lg-CSlTMKWi`,
    "container": `container-laOj7C9P`,
    "text-dark": `text-dark-RWOdPpzs`,
    "table-responsive-xxl": `table-responsive-xxl-6D4BMYAH`,
    "offset-xxl-10": `offset-xxl-10-c2u2PoB5`,
    "pt-lg-4": `pt-lg-4-NkZSeseT`,
    "spinner-grow-sm": `spinner-grow-sm-Sm5iL8Zo`,
    "mt-lg-auto": `mt-lg-auto-StwMrIX8`,
    "mb-xl-5": `mb-xl-5-kk64GETU`,
    "mx-sm-2": `mx-sm-2-aYCurPb9`,
    "list-group-item-action": `list-group-item-action-Ywj53IcM`,
    "link-underline-opacity-100-hover": `link-underline-opacity-100-hover-bpiWNWB3`,
    "row-cols-lg-2": `row-cols-lg-2-bck3mxeO`,
    "overflow-x-visible": `overflow-x-visible-TDqnCfuH`,
    "border-opacity-50": `border-opacity-50--wtawygR`,
    "rounded-bottom-circle": `rounded-bottom-circle-0xaFIxiC`,
    "ps-xl-0": `ps-xl-0-ccYVkIMH`,
    "gx-xl-1": `gx-xl-1-awyCmFTQ`,
    "col-md-3": `col-md-3-S1ivCnpj`,
    "col-lg-6": `col-lg-6-zgss5-Vq`,
    "border-secondary": `border-secondary-VoBzt1Qt`,
    "justify-content-xl-between": `justify-content-xl-between-S41-lJDO`,
    "pb-sm-4": `pb-sm-4-NEpdDD4M`,
    "active": `active-raRRVdQp`,
    "focus-ring-info": `focus-ring-info-6zRNYgeE`,
    "object-fit-xxl-contain": `object-fit-xxl-contain-18p1lRnj`,
    "align-items-sm-start": `align-items-sm-start-pGxoIHFi`,
    "order-lg-last": `order-lg-last-ev1EaIPE`,
    "spinner-border-sm": `spinner-border-sm-kvwYbd5S`,
    "align-self-stretch": `align-self-stretch-iO0Yt3wW`,
    "m-0": `m-0-slvCdVe4`,
    "m-1": `m-1-QR6IS5xX`,
    "m-2": `m-2-SE6ixZ1K`,
    "m-3": `m-3-UWbYrY5W`,
    "m-4": `m-4-0ck1RJEC`,
    "m-5": `m-5-w5U9bZxs`,
    "link-underline-opacity-0": `link-underline-opacity-0--6P1JQxY`,
    "pe-md-4": `pe-md-4-VhnfzYJL`,
    "object-fit-xxl-scale": `object-fit-xxl-scale-SP-Va6LA`,
    "px-xl-0": `px-xl-0-Vmz-CTrF`,
    "flex-lg-column-reverse": `flex-lg-column-reverse-nDGQgCkh`,
    "form-label": `form-label-Fuq9uDm2`,
    "gx-lg-2": `gx-lg-2-7wSB62Dk`,
    "btn-outline-light": `btn-outline-light-EL2n-GUt`,
    "px-lg-1": `px-lg-1-9K1nsZfX`,
    "link-underline-opacity-25-hover": `link-underline-opacity-25-hover-D-ZdFIMn`,
    "py-lg-3": `py-lg-3-FURhcPmI`,
    "flex-xxl-fill": `flex-xxl-fill-UTEfEvkP`,
    "border-dark-subtle": `border-dark-subtle-7FNyeieG`,
    "mx-md-2": `mx-md-2-9V9o2jed`,
    "text-light-emphasis": `text-light-emphasis-jCs3XBgE`,
    "flex-xl-column": `flex-xl-column-W9fy2BVS`,
    "d-md-grid": `d-md-grid-GejSldPf`,
    "overflow-y-hidden": `overflow-y-hidden-nlLyZ9bE`,
    "rounded-bottom-5": `rounded-bottom-5-TKpMn8lD`,
    "form-control": `form-control-aMnwB9CF`,
    "gy-md-4": `gy-md-4-JskAg1OQ`,
    "bg-dark": `bg-dark-yFRU1gqW`,
    "flex-md-row-reverse": `flex-md-row-reverse-8dH2_8p9`,
    "pe-xl-0": `pe-xl-0-R-HELdwX`,
    "my-sm-5": `my-sm-5-z4Sny0dj`,
    "link-underline-light": `link-underline-light-spwlLT_7`,
    "d-table": `d-table-Q-tDALfs`,
    "pt-sm-3": `pt-sm-3-IzdQtPNb`,
    "px-md-2": `px-md-2-LwD-hcZz`,
    "offset-md-1": `offset-md-1-Xu30daiM`,
    "border-info": `border-info-1OFox6co`,
    "border-secondary-subtle": `border-secondary-subtle-xhROOQEb`,
    "ms-sm-4": `ms-sm-4-VSkzhSdq`,
    "h-25": `h-25-8OS-gE8G`,
    "h-50": `h-50-G3mU3t-H`,
    "flex-nowrap": `flex-nowrap-wEllxF-E`,
    "h-75": `h-75-Qg7hx70n`,
    "bs-tooltip-auto": `bs-tooltip-auto-4ypwxqT8`,
    "pb-md-1": `pb-md-1-9zXCAZBL`,
    "rounded-bottom-0": `rounded-bottom-0-aipE4nLL`,
    "pb-xxl-2": `pb-xxl-2-1q4qdyNv`,
    "flex-grow-1": `flex-grow-1-ob_A7qo8`,
    "m-xxl-auto": `m-xxl-auto-L-4X0ZEI`,
    "mx-sm-0": `mx-sm-0-qApyxXMM`,
    "mt-lg-1": `mt-lg-1-huWSKwaV`,
    "me-md-2": `me-md-2-73wtctHH`,
    "gx-xl-3": `gx-xl-3-F8uoOURl`,
    "pt-xl-3": `pt-xl-3-H5IumFL6`,
    "pb-xl-4": `pb-xl-4-vWTqauVD`,
    "my-sm-auto": `my-sm-auto-UBQ_06p2`,
    "bs-popover-auto": `bs-popover-auto-9AUUE5YN`,
    "mx-lg-auto": `mx-lg-auto-4FepLrM_`,
    "me-xl-0": `me-xl-0-6FydFD6a`,
    "border-success": `border-success-7ME4gB5q`,
    "align-content-xl-between": `align-content-xl-between-dhrONbQD`,
    "px-sm-1": `px-sm-1-YzQPMII1`,
    "collapsing": `collapsing-LtKQ1Sk8`,
    "rounded-end-0": `rounded-end-0-Y21aSSDU`,
    "navbar-expand-xxl": `navbar-expand-xxl-_PZTIobt`,
    "mx-xl-2": `mx-xl-2-T1-4dD4X`,
    "d-xxl-inline-flex": `d-xxl-inline-flex-OtCAYKbQ`,
    "form-control-lg": `form-control-lg-ix_tDXKa`,
    "pe-auto": `pe-auto-dAqxKps8`,
    "align-items-xl-baseline": `align-items-xl-baseline-rP_wIGDt`,
    "flex-wrap": `flex-wrap-zmVPplfa`,
    "offset-xl-4": `offset-xl-4-RDBA3jyN`,
    "bg-opacity-75": `bg-opacity-75-MJXGomjs`,
    "ps-sm-3": `ps-sm-3-PvskjRd-`,
    "flex-xxl-column": `flex-xxl-column-1GYTl3UM`,
    "table-responsive-sm": `table-responsive-sm-tQ43NoYD`,
    "px-xl-2": `px-xl-2-6E-iodVH`,
    "small": `small-km6Aq8Hf`,
    "col-1": `col-1-qLhWazKh`,
    "col-2": `col-2-xdEcVBBh`,
    "col-3": `col-3-U-Sgm1Xf`,
    "col-4": `col-4-OEnyTZFx`,
    "col-5": `col-5-KyA7OWQj`,
    "col-6": `col-6-k4lIK3GH`,
    "col-7": `col-7-qasf3uUi`,
    "col-8": `col-8-Se9arRy-`,
    "col-9": `col-9-iTN9cf9w`,
    "d-md-inline": `d-md-inline-4czsHseq`,
    "border-0": `border-0-4Pna4o1K`,
    "order-md-first": `order-md-first-nsboKrP8`,
    "my-md-4": `my-md-4-TiRwjM6F`,
    "mb-md-0": `mb-md-0-hSOq0XRM`,
    "overflow-x-scroll": `overflow-x-scroll-hB9vtYBY`,
    "mx-md-0": `mx-md-0-K5vklQIL`,
    "input-group-lg": `input-group-lg-vhaogHjR`,
    "flex-xxl-wrap-reverse": `flex-xxl-wrap-reverse-AtgBATc4`,
    "mb-sm-auto": `mb-sm-auto-VhqBOWa9`,
    "align-self-sm-end": `align-self-sm-end-RSfXlUXk`,
    "justify-content-lg-around": `justify-content-lg-around-_jS4PmH1`,
    "column-gap-sm-5": `column-gap-sm-5-R00Suew-`,
    "gy-md-2": `gy-md-2-8aOuzu4U`,
    "overflow-hidden": `overflow-hidden-RIkiTTeQ`,
    "d-xxl-block": `d-xxl-block-yGq_380P`,
    "my-xxl-auto": `my-xxl-auto-19a7smE1`,
    "border-5": `border-5-t4MtdyzO`,
    "btn-check": `btn-check-rLOHWFMn`,
    "row-cols-3": `row-cols-3-j5tT7r18`,
    "mt-lg-0": `mt-lg-0-HAaJPrZK`,
    "d-xl-table-row": `d-xl-table-row-m8oy43N5`,
    "btn-success": `btn-success-sftsrB1Z`,
    "align-content-xl-end": `align-content-xl-end-ZRut4ETe`,
    "px-xxl-2": `px-xxl-2-ZqAunk2k`,
    "ms-sm-2": `ms-sm-2-k24UxkKv`,
    "modal-fullscreen-sm-down": `modal-fullscreen-sm-down-7HFJpA8H`,
    "px-lg-5": `px-lg-5-roUj9ZxU`,
    "pe-lg-3": `pe-lg-3-1grJHBc4`,
    "mx-xxl-auto": `mx-xxl-auto-vT7QfZzz`,
    "list-group": `list-group-0nQpPGCf`,
    "navbar": `navbar-KPsqrllc`,
    "card-link": `card-link-lr_QaDxN`,
    "object-fit-xl-none": `object-fit-xl-none-FmvBdV_u`,
    "row-gap-xxl-3": `row-gap-xxl-3-ukDtjRid`,
    "offcanvas-xxl": `offcanvas-xxl-le0pxvdc`,
    "rounded-end-1": `rounded-end-1-efvW8bNW`,
    "gy-sm-0": `gy-sm-0--w8vKoRf`,
    "z-0": `z-0-V87Fb6SV`,
    "z-1": `z-1-oCfjc-u5`,
    "z-2": `z-2-FGjumVaH`,
    "accordion-item": `accordion-item-0mMrYU8A`,
    "z-3": `z-3-BPLEIruY`,
    "mx-xl-1": `mx-xl-1-Q1D36Um2`,
    "row-gap-2": `row-gap-2-pWvQ09Gg`,
    "py-xxl-1": `py-xxl-1-4VoOqjoO`,
    "ms-lg-auto": `ms-lg-auto-clp7Giv8`,
    "pe-xxl-4": `pe-xxl-4-rPLKmujl`,
    "fst-italic": `fst-italic-Kk4uehJO`,
    "ms-sm-auto": `ms-sm-auto-dimrC6vz`,
    "dropend": `dropend-oDbOjb6z`,
    "align-items-xl-stretch": `align-items-xl-stretch-MkGjR6vI`,
    "rounded-4": `rounded-4-_PsFvj0Q`,
    "me-xl-2": `me-xl-2-eN5Eo2hj`,
    "gx-md-2": `gx-md-2-lJHpZvrh`,
    "bg-transparent": `bg-transparent-dlQ4Yht5`,
    "offset-2": `offset-2-ulHOAeE1`,
    "dropdown-menu-lg-start": `dropdown-menu-lg-start-pLL5Q3Zp`,
    "offset-xl-6": `offset-xl-6-nEYdJre1`,
    "align-items-lg-stretch": `align-items-lg-stretch-6HrEvWHS`,
    "text-opacity-25": `text-opacity-25-fc0NDU2i`,
    "my-xxl-5": `my-xxl-5-tfI4BhW4`,
    "mx-xl-auto": `mx-xl-auto-tAngT93q`,
    "carousel-item-next": `carousel-item-next-lSx_Cg05`,
    "toast-header": `toast-header-63HVQhtt`,
    "carousel-item-end": `carousel-item-end-Sbo5GzPS`,
    "offcanvas": `offcanvas-oQ6ANZXp`,
    "fw-bold": `fw-bold-g2tF28BD`,
    "align-self-lg-center": `align-self-lg-center-Flsgrz7N`,
    "offset-7": `offset-7-bI7WPRbP`,
    "top-100": `top-100-CB48Qa8G`,
    "alert-secondary": `alert-secondary-_eRMgF0z`,
    "gy-md-0": `gy-md-0-U1OSDfpt`,
    "m-xxl-4": `m-xxl-4-i9o_UF8X`,
    "progress": `progress-0jAIovXH`,
    "mb-lg-3": `mb-lg-3-h29oPpQ1`,
    "ps-xxl-4": `ps-xxl-4-D2zf6s0v`,
    "mb-xl-2": `mb-xl-2-FriV7cu3`,
    "align-content-lg-between": `align-content-lg-between-eUYb5hdw`,
    "me-xxl-1": `me-xxl-1-mHTJoDSZ`,
    "ms-xxl-3": `ms-xxl-3-vj1twIAs`,
    "flex-sm-shrink-1": `flex-sm-shrink-1-IjX0xGLU`,
    "me-auto": `me-auto-d5NbAd03`,
    "input-group-sm": `input-group-sm-8dgyR30N`,
    "flex-lg-wrap": `flex-lg-wrap-HUmieH8L`,
    "bg-gradient": `bg-gradient-hjisVrYc`,
    "flex-xl-grow-1": `flex-xl-grow-1-P3fIlwVd`,
    "align-content-xxl-between": `align-content-xxl-between-OkztxKYx`,
    "align-self-md-auto": `align-self-md-auto-UKuAdpgI`,
    "list-group-item": `list-group-item-NcQmkL33`,
    "list-group-horizontal-md": `list-group-horizontal-md-Grg9ZfDC`,
    "bg-white": `bg-white-cTECjmbF`,
    "text-start": `text-start-Mg7as4-L`,
    "pb-sm-2": `pb-sm-2-QoXTfyr_`,
    "py-lg-5": `py-lg-5-gDdqm7nL`,
    "pt-xxl-3": `pt-xxl-3-TIkOS34o`,
    "me-lg-4": `me-lg-4-Dm6WVFBi`,
    "modal-dialog": `modal-dialog-8xVN9t02`,
    "object-fit-sm-contain": `object-fit-sm-contain-4HC9eKE5`,
    "mt-xxl-2": `mt-xxl-2-SI6p2YzS`,
    "row-gap-xxl-1": `row-gap-xxl-1-_uSc0BFm`,
    "bg-body-tertiary": `bg-body-tertiary-qgadTm7E`,
    "row-gap-sm-4": `row-gap-sm-4-z4W_1Mss`,
    "d-print-table-row": `d-print-table-row-Lok_R0Bw`,
    "page-item": `page-item-1QxSp1BH`,
    "column-gap-xl-0": `column-gap-xl-0-vK9q1rcW`,
    "d-lg-table-cell": `d-lg-table-cell-OFaKNE1z`,
    "flex-xxl-row": `flex-xxl-row-Va5eD-6Q`,
    "rounded-top-2": `rounded-top-2-d_IoTmZp`,
    "table-danger": `table-danger-IjpT3JFC`,
    "justify-content-sm-between": `justify-content-sm-between-JmHqfhsL`,
    "align-content-md-start": `align-content-md-start-lofVC_ZS`,
    "link-secondary": `link-secondary-TDt4lXTG`,
    "gap-xxl-1": `gap-xxl-1-nnQE27QY`,
    "rounded-bottom": `rounded-bottom-2lhS2TIs`,
    "object-fit-contain": `object-fit-contain-sMg0awnX`,
    "pb-lg-0": `pb-lg-0-wnjMdE51`,
    "pe-xl-1": `pe-xl-1-cLU3sDq6`,
    "offset-lg-9": `offset-lg-9-4uzaV0VI`,
    "offset-xxl-8": `offset-xxl-8-a0DOiyeg`,
    "placeholder": `placeholder-G96V1_0J`,
    "pt-lg-3": `pt-lg-3-n6NcFPF5`,
    "text-xl-start": `text-xl-start-mqQWZtLj`,
    "align-self-md-baseline": `align-self-md-baseline-jMy5JhfA`,
    "offset-md-6": `offset-md-6-YG0gcbBM`,
    "list-group-horizontal-xl": `list-group-horizontal-xl-HcVX2yKU`,
    "mb-xxl-auto": `mb-xxl-auto-BjpLuWgq`,
    "me-md-4": `me-md-4-JsXp20Xp`,
    "float-xxl-none": `float-xxl-none-owCcC38A`,
    "row-cols-6": `row-cols-6-92iaatii`,
    "link-primary": `link-primary-KOGiYA9E`,
    "pb-xxl-4": `pb-xxl-4-f2jXsWpx`,
    "form-select": `form-select-ijewiSuh`,
    "modal-static": `modal-static-Y0GdR-yZ`,
    "mb-xxl-3": `mb-xxl-3-gyqtI2md`,
    "mb-sm-2": `mb-sm-2-XirA5oDO`,
    "mb-lg-5": `mb-lg-5-pWUHd5mT`,
    "mb-xl-0": `mb-xl-0-zmHYKKsU`,
    "flex-md-shrink-1": `flex-md-shrink-1-lX9GkPT0`,
    "offcanvas-backdrop": `offcanvas-backdrop-uSpRby9H`,
    "order-md-3": `order-md-3-7so4nNG-`,
    "ms-xl-0": `ms-xl-0-s6O12cTy`,
    "row-cols-md-6": `row-cols-md-6-O9TywH5R`,
    "g-0": `g-0-WleZi6Cw`,
    "g-1": `g-1-AdnppQT6`,
    "g-2": `g-2-7xwJRc5F`,
    "g-3": `g-3-_5w4EkwW`,
    "g-4": `g-4-KF3vFa9M`,
    "g-5": `g-5-RtJZndkh`,
    "col-xxl-10": `col-xxl-10-IQ6E5Czv`,
    "bs-tooltip-top": `bs-tooltip-top-HK9FYbyI`,
    "bg-opacity-50": `bg-opacity-50-_YjIrd42`,
    "align-items-sm-end": `align-items-sm-end-HgiS4m3J`,
    "ps-md-2": `ps-md-2-rTLIy5i4`,
    "d-sm-inline-flex": `d-sm-inline-flex-rDS700RZ`,
    "pb-xl-2": `pb-xl-2-W81go5z6`,
    "font-monospace": `font-monospace-ApvoZoL_`,
    "text-xxl-end": `text-xxl-end-3PqHfAzA`,
    "carousel-control-next": `carousel-control-next-K-_efDXR`,
    "row-gap-sm-5": `row-gap-sm-5-kmlpEZAL`,
    "mx-lg-0": `mx-lg-0-q4vjdibb`,
    "d-inline-flex": `d-inline-flex-Af4w6HRe`,
    "order-md-5": `order-md-5-u_cZYBqY`,
    "flex-md-fill": `flex-md-fill-t3cG5Gcz`,
    "column-gap-lg-2": `column-gap-lg-2-7S3eKGFN`,
    "row-cols-xxl-2": `row-cols-xxl-2-Be6A6L2-`,
    "text-sm-start": `text-sm-start-o18jYaMM`,
    "pe-md-1": `pe-md-1-YwbsYAoC`,
    "was-validated": `was-validated-ZtCPVc7O`,
    "navbar-expand-sm": `navbar-expand-sm-i6QZ10rs`,
    "flex-xl-shrink-1": `flex-xl-shrink-1-ATYivhXI`,
    "link-opacity-50": `link-opacity-50-oUqd6ekC`,
    "align-content-xxl-around": `align-content-xxl-around-aKFW0pQl`,
    "d-print-block": `d-print-block-FhI5VSjr`,
    "progress-bar-stripes": `progress-bar-stripes-r55Gfldz`,
    "col-xxl-3": `col-xxl-3-2gm65o7l`,
    "py-xl-2": `py-xl-2-i92XzvlN`,
    "alert-dark": `alert-dark-tN0mX_gy`,
    "gx-sm-1": `gx-sm-1-BhvTM4c-`,
    "mb-md-auto": `mb-md-auto-hQiXlXsC`,
    "float-sm-none": `float-sm-none-sqhGvjWZ`,
    "flex-xxl-shrink-1": `flex-xxl-shrink-1-y-f_Yd1T`,
    "column-gap-sm-3": `column-gap-sm-3-LMiL1rvo`,
    "pb-lg-2": `pb-lg-2-Dg2ZC3qR`,
    "align-self-xl-end": `align-self-xl-end-n3QHpu32`,
    "d-print-table-cell": `d-print-table-cell-aU05Nu6r`,
    "float-xxl-start": `float-xxl-start-u0-NeU0t`,
    "border-danger": `border-danger-iG8t9wlr`,
    "offset-md-4": `offset-md-4-clth_-nX`,
    "text-bg-dark": `text-bg-dark-2qJfPKm7`,
    "mx-xxl-3": `mx-xxl-3-0Mw40Cr5`,
    "me-xxl-0": `me-xxl-0-mUEK4H_e`,
    "table-responsive-xl": `table-responsive-xl-fNfi5uaX`,
    "ps-xl-3": `ps-xl-3-tl2nId5w`,
    "flex-xl-column-reverse": `flex-xl-column-reverse-ceewxr-o`,
    "accordion-collapse": `accordion-collapse--OfQxaKc`,
    "object-fit-md-scale": `object-fit-md-scale--HOuWE18`,
    "mb-sm-0": `mb-sm-0-K_QyBVna`,
    "py-lg-1": `py-lg-1-NHZCs8xv`,
    "order-sm-3": `order-sm-3-_SHRz7Ig`,
    "card-title": `card-title-hKcyvpdf`,
    "flex-md-column-reverse": `flex-md-column-reverse-iLYGAGv7`,
    "ps-lg-4": `ps-lg-4-9sSJkNcE`,
    "d-xl-table-cell": `d-xl-table-cell-fKus7BWR`,
    "row-gap-xxl-5": `row-gap-xxl-5-HXb6DS88`,
    "visually-hidden": `visually-hidden-ham8RnMb`,
    "my-xxl-2": `my-xxl-2-NDgphOG0`,
    "me-xxl-5": `me-xxl-5-OPoNAgcO`,
    "col-sm-10": `col-sm-10-0HQ1OHAD`,
    "pt-xl-4": `pt-xl-4-UJtF5nMt`,
    "modal": `modal-i54AHRUQ`,
    "ps-md-0": `ps-md-0-vqZo1ohq`,
    "overflow-auto": `overflow-auto-5SyvwazV`,
    "px-sm-4": `px-sm-4-z9tGVJhU`,
    "flex-shrink-0": `flex-shrink-0-tvgeYKjY`,
    "justify-content-between": `justify-content-between-77OIHhPz`,
    "row-gap-4": `row-gap-4-JaoKVnRm`,
    "ms-xxl-0": `ms-xxl-0-MO8USKU0`,
    "text-uppercase": `text-uppercase-Wpd_ny0J`,
    "d-table-cell": `d-table-cell-NcCFk9ZE`,
    "gap-xxl-5": `gap-xxl-5-yJHBmQqp`,
    "dropdown-menu-xl-start": `dropdown-menu-xl-start-6xea_zH6`,
    "justify-content-center": `justify-content-center-x5kxNRuK`,
    "btn-outline-warning": `btn-outline-warning-JkXM6V4M`,
    "ms-md-4": `ms-md-4--EJkJM3N`,
    "blockquote": `blockquote-0I-OAWGk`,
    "btn-warning": `btn-warning-dT9yCD00`,
    "offset-md-2": `offset-md-2-5FiuxK-f`,
    "col-xxl-5": `col-xxl-5-HOh_yfSd`,
    "py-xl-4": `py-xl-4-17ZCyFjW`,
    "btn-outline-secondary": `btn-outline-secondary-uPVGKT-F`,
    "flex-sm-fill": `flex-sm-fill-pO0kiwXV`,
    "fw-normal": `fw-normal-fJGf7LJN`,
    "mt-md-2": `mt-md-2-F-GLb_8i`,
    "link-underline-opacity-0-hover": `link-underline-opacity-0-hover-mqMz5UHv`,
    "dropdown-menu-dark": `dropdown-menu-dark-wIMxf0c-`,
    "float-md-start": `float-md-start-nSVVuDiC`,
    "dropdown-menu-lg-end": `dropdown-menu-lg-end-2NRmaAxb`,
    "align-content-lg-stretch": `align-content-lg-stretch-xxJjYmPv`,
    "ms-xxl-5": `ms-xxl-5-m5msnXcs`,
    "navbar-toggler-icon": `navbar-toggler-icon-pIncXDxE`,
    "align-items-start": `align-items-start-xvDk3pB8`,
    "rounded-start-4": `rounded-start-4-kRONb2ll`,
    "hiding": `hiding-lkphtr0h`,
    "hstack": `hstack-jYkj5DSG`,
    "h-auto": `h-auto-fJjoHsTr`,
    "text-break": `text-break-GUGyFPzA`,
    "position-fixed": `position-fixed-h09cyNVd`,
    "flex-sm-nowrap": `flex-sm-nowrap-IePTBR2k`,
    "card-header": `card-header-E1jfmYtj`,
    "border-warning-subtle": `border-warning-subtle-DCDDCLkZ`,
    "column-gap-md-2": `column-gap-md-2-pu_Hlc84`,
    "mb-xl-4": `mb-xl-4-C0By6yyx`,
    "row-cols-xl-2": `row-cols-xl-2-TqlAvBGU`,
    "row-cols-xxl-5": `row-cols-xxl-5-LZiC8Bjc`,
    "navbar-dark": `navbar-dark-ItOp5pEk`,
    "border-white": `border-white-7cg_ktM8`,
    "ps-sm-1": `ps-sm-1-ELfKSYv5`,
    "text-warning-emphasis": `text-warning-emphasis-4fuE2OEQ`,
    "row-gap-md-0": `row-gap-md-0-jj2i49rc`,
    "order-xxl-3": `order-xxl-3-Cq4ROGdr`,
    "pe-lg-4": `pe-lg-4-SWovdVsl`,
    "align-self-md-start": `align-self-md-start-jMkKMmXv`,
    "justify-content-xxl-between": `justify-content-xxl-between-HTg-oiWF`,
    "carousel-item-start": `carousel-item-start-Y3o4t-MB`,
    "bg-warning-subtle": `bg-warning-subtle-jHcRzSvE`,
    "d-md-flex": `d-md-flex-zkcfbKM4`,
    "align-top": `align-top-Tvg7DVxa`,
    "px-sm-2": `px-sm-2-TYX6IR5T`,
    "flex-md-nowrap": `flex-md-nowrap-lfXWnVaR`,
    "form-check-label": `form-check-label-Lb3g-uuq`,
    "me-xl-auto": `me-xl-auto-gYwd706C`,
    "dropdown-menu-md-start": `dropdown-menu-md-start-yRiOYeFj`,
    "row-gap-sm-0": `row-gap-sm-0-z7_JTBpb`,
    "mx-lg-4": `mx-lg-4-PNxOu7pH`,
    "gy-xxl-3": `gy-xxl-3-TuyEvP0z`,
    "text-dark-emphasis": `text-dark-emphasis-I4X33leg`,
    "pe-md-5": `pe-md-5-vuiStPkB`,
    "d-xxl-table-cell": `d-xxl-table-cell-pohDmmvX`,
    "is-invalid": `is-invalid-MMCvKwji`,
    "col-sm-12": `col-sm-12-yUUs3P9M`,
    "focus-ring-light": `focus-ring-light-1sCnU0Ar`,
    "alert-success": `alert-success-HjKy9svj`,
    "column-gap-xl-1": `column-gap-xl-1-aDgEu0QE`,
    "pt-md-0": `pt-md-0-tUoJ8vuW`,
    "d-sm-inline-grid": `d-sm-inline-grid-LYv0zle9`,
    "border-info-subtle": `border-info-subtle-_pXuGMFD`,
    "gx-sm-5": `gx-sm-5-V_lUA8wl`,
    "flex-xxl-grow-1": `flex-xxl-grow-1-958pU0-D`,
    "order-xl-last": `order-xl-last-QFoa9y0g`,
    "text-body-emphasis": `text-body-emphasis-C-7vtgqI`,
    "ms-sm-0": `ms-sm-0-7vciwJCJ`,
    "gap-sm-5": `gap-sm-5-MI6ffKYh`,
    "form-range": `form-range-4rukTTOl`,
    "list-group-item-success": `list-group-item-success-6CY8krU6`,
    "bs-tooltip-bottom": `bs-tooltip-bottom-Kw3kUlhW`,
    "figure-img": `figure-img-pqYDzNh-`,
    "carousel-item": `carousel-item-4FG1rHDI`,
    "offset-lg-7": `offset-lg-7-TmIDZEPZ`,
    "px-md-1": `px-md-1-KLMyurIu`,
    "ms-md-2": `ms-md-2-yzOaQuAk`,
    "col-lg-auto": `col-lg-auto-Ngk_Aa55`,
    "offset-md-0": `offset-md-0-uVrupAwb`,
    "align-content-sm-between": `align-content-sm-between-OJ2WerEb`,
    "align-self-xl-auto": `align-self-xl-auto-WlRNmZuc`,
    "align-self-md-end": `align-self-md-end-p4uxDCXj`,
    "btn-group-vertical": `btn-group-vertical-ui4twVOZ`,
    "order-xl-1": `order-xl-1-DP3vp96O`,
    "col-sm-1": `col-sm-1-S6KSLc58`,
    "pb-md-0": `pb-md-0-06z8ATUY`,
    "text-success-emphasis": `text-success-emphasis-BX55UkII`,
    "py-md-5": `py-md-5-RwyAALm6`,
    "mb-sm-4": `mb-sm-4-y9sXvms7`,
    "carousel-item-prev": `carousel-item-prev-qFcb6zrq`,
    "column-gap-md-0": `column-gap-md-0-N55pmG_n`,
    "row-cols-lg-4": `row-cols-lg-4-sbUZIKNo`,
    "gy-xl-3": `gy-xl-3-dhLrPsm0`,
    "row-gap-md-1": `row-gap-md-1-tM3iTK73`,
    "sticky-xxl-bottom": `sticky-xxl-bottom-K9dcNb1u`,
    "align-items-md-end": `align-items-md-end-1eYxV7xy`,
    "offset-xl-11": `offset-xl-11-c5QgJbhj`,
    "pb-xl-1": `pb-xl-1-ph0jE34Z`,
    "card-footer": `card-footer-P1xNgAim`,
    "overflow-visible": `overflow-visible-oBO7DozM`,
    "flex-sm-row": `flex-sm-row-1Nd1EBoz`,
    "ps-md-4": `ps-md-4-o_SAf09d`,
    "user-select-all": `user-select-all-68ZUq9cL`,
    "object-fit-sm-scale": `object-fit-sm-scale-Ss6x8c5q`,
    "col-sm-6": `col-sm-6-PbiNPAiJ`,
    "card-img": `card-img-LPzSumrI`,
    "gap-sm-3": `gap-sm-3-maMSjADw`,
    "object-fit-lg-contain": `object-fit-lg-contain-6IFr3V5n`,
    "ms-lg-0": `ms-lg-0-mRVUKeRo`,
    "me-xl-1": `me-xl-1-1PrA1Ag-`,
    "offset-sm-0": `offset-sm-0-Jhj2qbJC`,
    "my-lg-5": `my-lg-5-64lEKrgO`,
    "px-sm-0": `px-sm-0-eiLuG9pF`,
    "vr": `vr-FQNPnENP`,
    "mt-md-auto": `mt-md-auto-n3GD0Rrj`,
    "align-self-xl-stretch": `align-self-xl-stretch-xhtj_b2m`,
    "sticky-xl-top": `sticky-xl-top-6_c2S00I`,
    "placeholder-xs": `placeholder-xs-XEwGrhaC`,
    "column-gap-lg-5": `column-gap-lg-5-SkKYYlrS`,
    "bg-body-secondary": `bg-body-secondary-yFy9xoYz`,
    "object-fit-xl-contain": `object-fit-xl-contain-qwWaJTSC`,
    "fw-light": `fw-light-ME1aVcwh`,
    "order-lg-2": `order-lg-2-LZM0N_64`,
    "pt-md-2": `pt-md-2-utiBPugy`,
    "my-md-5": `my-md-5-IUxjOp7T`,
    "text-light": `text-light-q3X3dlgk`,
    "gap-md-3": `gap-md-3-x9mkQD63`,
    "bg-primary-subtle": `bg-primary-subtle-xLUg6X0n`,
    "col-xxl-9": `col-xxl-9-qRS1Z90_`,
    "gap-xl-0": `gap-xl-0-J14qyOaO`,
    "form-select-lg": `form-select-lg-nSkdZgv5`,
    "dropstart": `dropstart-45Ds8Y8a`,
    "flex-xl-fill": `flex-xl-fill-8G-Sxpvt`,
    "border-warning": `border-warning-dZ1_60E9`,
    "gy-md-3": `gy-md-3-t7TtIWEr`,
    "end-50": `end-50-q9tlB7UL`,
    "align-content-xl-start": `align-content-xl-start-8dL6XG7z`,
    "offset-lg-1": `offset-lg-1-53kPO8CH`,
    "invisible": `invisible-erkAz7DR`,
    "navbar-brand": `navbar-brand-tDqPmoat`,
    "d-sm-block": `d-sm-block-PogrKL0C`,
    "row-cols-auto": `row-cols-auto-qteWY8QG`,
    "ms-md-0": `ms-md-0-bBmeTxsX`,
    "col-lg-2": `col-lg-2-ItuT8vg7`,
    "gx-xxl-3": `gx-xxl-3-hdV27pic`,
    "row-cols-xl-6": `row-cols-xl-6-7tmSLFnw`,
    "gap-xl-5": `gap-xl-5-g7Q8WKV5`,
    "gy-sm-4": `gy-sm-4-nIWzXYGK`,
    "object-fit-md-none": `object-fit-md-none-Ciz-lDVk`,
    "align-self-xxl-baseline": `align-self-xxl-baseline-VJ0Vi4cA`,
    "table-borderless": `table-borderless-x5JvIxm0`,
    "row-gap-md-2": `row-gap-md-2-0zHT0QEf`,
    "gx-lg-5": `gx-lg-5-D5b4I5Iy`,
    "text-lg-center": `text-lg-center-brq0gmP0`,
    "ms-xl-5": `ms-xl-5-csFJA7UF`,
    "col-md-4": `col-md-4-wTGoXgPn`,
    "col-lg-7": `col-lg-7-dIH9nmWn`,
    "col-xl-1": `col-xl-1-3-O3J_mN`,
    "gy-xxl-2": `gy-xxl-2-P0WU7VdK`,
    "offcanvas-top": `offcanvas-top-yXcrVuGH`,
    "link-offset-1": `link-offset-1-BaBq_y4o`,
    "py-sm-4": `py-sm-4-qdJC4_Zw`,
    "text-white": `text-white-18M2H9Su`,
    "gap-md-1": `gap-md-1-a6P47Pzy`,
    "link-underline": `link-underline--RP3FB67`,
    "gap-lg-4": `gap-lg-4-uXCsLQzZ`,
    "bg-light-subtle": `bg-light-subtle-Ncd2wKlM`,
    "ms-lg-2": `ms-lg-2-ShmBEO-v`,
    "link-underline-opacity-75-hover": `link-underline-opacity-75-hover-dI38rD6n`,
    "offset-sm-2": `offset-sm-2-onHJy3zR`,
    "align-items-center": `align-items-center-6r6XB_HX`,
    "mt-auto": `mt-auto-WAYvpNit`,
    "gx-md-3": `gx-md-3-fwstq0yD`,
    "rounded-start-circle": `rounded-start-circle-kBW52btx`,
    "form-floating": `form-floating-ljGfeGon`,
    "focus-ring-danger": `focus-ring-danger-oYVIbK3T`,
    "lead": `lead-mE47bXjP`,
    "lh-1": `lh-1-dYIPvrER`,
    "col-md-9": `col-md-9--_0DdXuZ`,
    "col-xl-6": `col-xl-6-TqmIfTZZ`,
    "g-xxl-4": `g-xxl-4-STTjnvdE`,
    "bg-opacity-25": `bg-opacity-25-1Axw8FpN`,
    "d-inline": `d-inline-kn6KA_MI`,
    "mx-md-auto": `mx-md-auto-NAsToGRs`,
    "link-opacity-25": `link-opacity-25-rgEYYKdF`,
    "flex-xl-wrap": `flex-xl-wrap-x6lluKiI`,
    "row-gap-xl-2": `row-gap-xl-2-GiFt7vz_`,
    "object-fit-lg-none": `object-fit-lg-none-l58AHYxS`,
    "object-fit-none": `object-fit-none-1Vrx6u7i`,
    "align-content-xxl-start": `align-content-xxl-start-4SI5H48a`,
    "img-fluid": `img-fluid-D6zkf15w`,
    "p-xxl-4": `p-xxl-4-IdjEbomK`,
    "text-bg-danger": `text-bg-danger-Ptnoilzk`,
    "d-sm-table-cell": `d-sm-table-cell-53URzgmb`,
    "align-content-lg-start": `align-content-lg-start-9BZ4Pj4V`,
    "carousel-control-next-icon": `carousel-control-next-icon-UA7QLFbT`,
    "bg-danger": `bg-danger-BRWX6emH`,
    "order-xxl-4": `order-xxl-4-cCOutZ7Q`,
    "link-underline-opacity-10": `link-underline-opacity-10-hHRyt7vL`,
    "display-5": `display-5-k-Et_dCP`,
    "w-100": `w-100-FQudn4NW`,
    "gap-0": `gap-0-EMtjfkq4`,
    "gap-1": `gap-1-fuVBvNTp`,
    "list-group-horizontal-xxl": `list-group-horizontal-xxl-yutVRRdd`,
    "gap-2": `gap-2--LhahjLL`,
    "gap-3": `gap-3-bmXz-wJr`,
    "gap-4": `gap-4-IT9n4fH1`,
    "gap-5": `gap-5-fguL9FJ1`,
    "bg-opacity-100": `bg-opacity-100-e85XAJfS`,
    "gap-sm-2": `gap-sm-2-raPDFzWK`,
    "object-fit-scale": `object-fit-scale-fvtplGMG`,
    "px-lg-4": `px-lg-4-5Bpsu3U1`,
    "flex-lg-row": `flex-lg-row-TrheupRh`,
    "alert-heading": `alert-heading-oxo5PVqy`,
    "col-md-auto": `col-md-auto-de3nVJI_`,
    "tooltip-arrow": `tooltip-arrow-EuxYmpNX`,
    "justify-content-sm-center": `justify-content-sm-center-zobU3TB0`,
    "justify-content-lg-start": `justify-content-lg-start-oevb71Z3`,
    "link-offset-3": `link-offset-3-st_uigtB`,
    "float-start": `float-start-km6nCsTz`,
    "d-sm-table-row": `d-sm-table-row-qW0cjSF6`,
    "d-print-inline-block": `d-print-inline-block-mDK4cBvh`,
    "text-xxl-start": `text-xxl-start-O13CXM5e`,
    "text-opacity-75": `text-opacity-75-7Q5S1Ty7`,
    "modal-dialog-centered": `modal-dialog-centered-APjYE8Mb`,
    "text-secondary": `text-secondary-CYxK8CT5`,
    "justify-content-md-end": `justify-content-md-end-JgpDOh5x`,
    "mx-md-4": `mx-md-4-1BggiPte`,
    "placeholder-wave": `placeholder-wave-lWTqyK91`,
    "my-lg-1": `my-lg-1-GtZ1BcHi`,
    "align-content-md-center": `align-content-md-center-TfgtBZew`,
    "align-text-bottom": `align-text-bottom-9MHqt6__`,
    "alert-link": `alert-link-GGFAULr4`,
    "ms-xxl-auto": `ms-xxl-auto-jzOk_Iuu`,
    "text-lg-end": `text-lg-end-TNeILGdh`,
    "text-secondary-emphasis": `text-secondary-emphasis-fBQV3oIO`,
    "order-xxl-last": `order-xxl-last-TZDeoJ23`,
    "offset-lg-8": `offset-lg-8-MbHnJR1S`,
    "btn-lg": `btn-lg-C1NEU_XV`,
    "btn-sm": `btn-sm-2QvgY5mc`,
    "border": `border-R4ZlSQ6K`,
    "pt-sm-1": `pt-sm-1-e1Px68LU`,
    "row-gap-xl-3": `row-gap-xl-3-QLpbfn-v`,
    "fw-bolder": `fw-bolder-wFUdL_ry`,
    "mx-sm-5": `mx-sm-5-PFDPCa6Y`,
    "col-sm-3": `col-sm-3-RwmgsdAI`,
    "clearfix": `clearfix-JGdVBylV`,
    "nav": `nav-JY0U5t4U`,
    "text-success": `text-success-dN_-YPR4`,
    "align-self-xxl-auto": `align-self-xxl-auto-W1nT8qas`,
    "col-sm-auto": `col-sm-auto-NOssg7Wl`,
    "object-fit-lg-cover": `object-fit-lg-cover-PpI4eNhK`,
    "alert-danger": `alert-danger-m3Ahy6aL`,
    "alert-dismissible": `alert-dismissible-rVuJaTV4`,
    "mb-lg-4": `mb-lg-4-UuPpUkf9`,
    "flex-wrap-reverse": `flex-wrap-reverse-k_Jvi-sY`,
    "align-items-xl-center": `align-items-xl-center-_sB7EiRG`,
    "rounded-end-5": `rounded-end-5-O5QIOEg-`,
    "ms-xl-1": `ms-xl-1-XkXQhlKg`,
    "mt-xl-1": `mt-xl-1-h1zyPhoI`,
    "sticky-md-bottom": `sticky-md-bottom-fOr9eeDl`,
    "form-check-inline": `form-check-inline-erDYCmmF`,
    "col-sm-8": `col-sm-8-k3_93ZlD`,
    "link-underline-warning": `link-underline-warning-k7F4V9zP`,
    "pt-xl-1": `pt-xl-1-H2G2AjZJ`,
    "translate-middle": `translate-middle-BTIK2tDN`,
    "end-100": `end-100-WLiajIIb`,
    "rounded-0": `rounded-0-tYAlj_ZH`,
    "align-self-start": `align-self-start-pNY2pznl`,
    "d-lg-table-row": `d-lg-table-row-Dp9IzS5G`,
    "carousel-dark": `carousel-dark-n6lSKBAT`,
    "bg-info-subtle": `bg-info-subtle-33lJk-q9`,
    "carousel-caption": `carousel-caption-7OquWTNw`,
    "col-xl-10": `col-xl-10-LN6s0pWl`,
    "float-xl-start": `float-xl-start-AHhe2uGd`,
    "mt-xl-auto": `mt-xl-auto-kyGrks4D`,
    "mx-lg-3": `mx-lg-3-ePeE3n6k`,
    "bs-tooltip-end": `bs-tooltip-end-Fmxm8AMl`,
    "link-underline-opacity-100": `link-underline-opacity-100-LLhcMLyF`,
    "column-gap-lg-3": `column-gap-lg-3-SY1CkS84`,
    "gy-md-5": `gy-md-5-wjl1uqR-`,
    "disabled": `disabled-zfGVqwwd`,
    "my-md-2": `my-md-2-LK5f_soH`,
    "my-sm-4": `my-sm-4-eIbSCcjq`,
    "col-lg-10": `col-lg-10-7P6UUXpu`,
    "d-lg-inline-flex": `d-lg-inline-flex-Le2_qZ5h`,
    "float-lg-start": `float-lg-start-jCIIceSh`,
    "offset-3": `offset-3--b-X29iM`,
    "nav-pills": `nav-pills-89vZJW0d`,
    "my-auto": `my-auto-h8Zt7V0r`,
    "row-gap-xl-4": `row-gap-xl-4-B19ZwBh-`,
    "dropup-center": `dropup-center-vghEfT2T`,
    "ms-sm-5": `ms-sm-5-plSumA0O`,
    "justify-content-md-evenly": `justify-content-md-evenly-LfQkSd_R`,
    "justify-content-sm-start": `justify-content-sm-start-MnFtnRpe`,
    "m-xxl-0": `m-xxl-0-WCz-hGlR`,
    "pb-lg-1": `pb-lg-1-vkGbFqjQ`,
    "align-content-center": `align-content-center-YZg2j-qO`,
    "table-responsive-md": `table-responsive-md-5mJYGAP6`,
    "order-sm-last": `order-sm-last-E1C75bUz`,
    "valid-feedback": `valid-feedback-hzKbESK4`,
    "align-items-md-stretch": `align-items-md-stretch-5GQzy3VN`,
    "offset-xxl-7": `offset-xxl-7-MD6Dh6Tc`,
    "nav-fill": `nav-fill-isl3uvTo`,
    "text-warning": `text-warning-q5SDh6sQ`,
    "mx-sm-3": `mx-sm-3-JGRINJVt`,
    "mt-lg-2": `mt-lg-2-Er-5_LIE`,
    "me-md-5": `me-md-5-zvZGTiu_`,
    "offset-8": `offset-8-L51skUqt`,
    "pt-xl-0": `pt-xl-0-8CqX5J8R`,
    "caption-top": `caption-top-AV9xZJk7`,
    "table": `table-s1aok2Sl`,
    "display-1": `display-1-LfMOdwvm`,
    "toast": `toast-Uh03JfPK`,
    "top-0": `top-0-UwvBeWUL`,
    "mb-sm-3": `mb-sm-3-9pxVInTd`,
    "my-xl-3": `my-xl-3-NIAEQkoQ`,
    "form-switch": `form-switch-ovXBwXAm`,
    "pe-none": `pe-none-sAWmVgNF`,
    "mx-xl-3": `mx-xl-3-MfV0AE6s`,
    "row-gap-0": `row-gap-0-FzW02UZY`,
    "card-text": `card-text-OA1_wPv0`,
    "offcanvas-lg": `offcanvas-lg-UEj47PcN`,
    "align-self-end": `align-self-end-dM11hoJp`,
    "offset-1": `offset-1-ndVesHOw`,
    "justify-content-xl-start": `justify-content-xl-start-mpWDeNKO`,
    "ps-md-3": `ps-md-3-X017B3mq`,
    "carousel-indicators": `carousel-indicators-LSFXcRS_`,
    "mb-md-1": `mb-md-1-oSkjB2vA`,
    "py-xxl-5": `py-xxl-5-r_YLP56n`,
    "pt-xxl-4": `pt-xxl-4-egxIBS1W`,
    "start-100": `start-100-OtNZFIpM`,
    "breadcrumb": `breadcrumb-FH6giBu8`,
    "sticky-xxl-top": `sticky-xxl-top-UvTj7eZ1`,
    "offset-sm-8": `offset-sm-8-bKf6CQR1`,
    "mx-lg-1": `mx-lg-1-9O6RauUY`,
    "align-content-xxl-stretch": `align-content-xxl-stretch-UwTmBjHh`,
    "carousel-fade": `carousel-fade-OLMRt8_E`,
    "me-sm-5": `me-sm-5-iuEcKUkl`,
    "offcanvas-xl": `offcanvas-xl-X8LUg390`,
    "offcanvas-sm": `offcanvas-sm-gWDLZh1d`,
    "justify-content-xxl-around": `justify-content-xxl-around-m6uw7SDq`,
    "align-items-sm-stretch": `align-items-sm-stretch-_KllGKhV`,
    "offset-6": `offset-6-Xp2_ompZ`,
    "table-secondary": `table-secondary-wZ4Mo3uE`,
    "border-dark": `border-dark-B_2C_Tqx`,
    "rounded-bottom-2": `rounded-bottom-2-1XQCmZ4X`,
    "col-lg-12": `col-lg-12-02WXpFrz`,
    "object-fit-xxl-fill": `object-fit-xxl-fill-Kw9a4b01`,
    "pb-xxl-0": `pb-xxl-0-1avAEEP6`,
    "align-content-lg-center": `align-content-lg-center-wyME1sxG`,
    "py-xl-5": `py-xl-5-2tk0vv9p`,
    "rounded-start": `rounded-start-Fae2YeOm`,
    "flex-sm-shrink-0": `flex-sm-shrink-0-LS82ZHYQ`,
    "container-lg": `container-lg--S0rCxAt`,
    "d-xl-none": `d-xl-none-eSZ5xTM0`,
    "offset-xxl-4": `offset-xxl-4-vF_GmvYp`,
    "tooltip-inner": `tooltip-inner-wcDl7XD5`,
    "link-underline-dark": `link-underline-dark-ipD_iYKN`,
    "pe-lg-0": `pe-lg-0-zOQ1SgrH`,
    "link-underline-success": `link-underline-success-ZuvbrJs1`,
    "float-sm-end": `float-sm-end-T1ageBAQ`,
    "link-offset-2-hover": `link-offset-2-hover-Ns3VlxMO`,
    "d-xxl-inline-grid": `d-xxl-inline-grid-xd3sZImX`,
    "d-xl-inline-grid": `d-xl-inline-grid-yOzG4qOz`,
    "row-cols-md-2": `row-cols-md-2-ggdybpmp`,
    "align-items-lg-center": `align-items-lg-center-MQsqJzz_`,
    "me-lg-1": `me-lg-1-BIpSzWkf`,
    "mt-xl-5": `mt-xl-5-t4vZ_uqZ`,
    "pb-xxl-5": `pb-xxl-5-iuinWLKy`,
    "sticky-lg-top": `sticky-lg-top-bizt3PGv`,
    "ps-lg-2": `ps-lg-2-u2tadtPb`,
    "gy-sm-1": `gy-sm-1-H6_bLoHF`,
    "order-xxl-2": `order-xxl-2-L23bVAQH`,
    "link-opacity-10": `link-opacity-10-W2Q4Yov6`,
    "opacity-100": `opacity-100-2Cj6qAis`,
    "list-group-flush": `list-group-flush-0dECZaSh`,
    "text-black": `text-black-am5W2wH-`,
    "pb-sm-0": `pb-sm-0-32d2wE-N`,
    "offcanvas-bottom": `offcanvas-bottom-4cgQNvCV`,
    "btn-dark": `btn-dark-o0smK-xq`,
    "bottom-0": `bottom-0-2dkSx3Ww`,
    "bg-black": `bg-black-z-URWZ7T`,
    "card-header-pills": `card-header-pills-Ofy7jA-Q`,
    "align-content-md-around": `align-content-md-around-ef-ufTn1`,
    "row-cols-5": `row-cols-5-O7zIQr7x`,
    "fade": `fade-6PAsJa_U`,
    "fs-1": `fs-1-XZqH9MZu`,
    "fs-2": `fs-2-HJI6EX9s`,
    "fs-3": `fs-3-yoDGey4B`,
    "col-sm-11": `col-sm-11-RWrSNhWH`,
    "fs-4": `fs-4-u3WUhUPd`,
    "fs-5": `fs-5-pcAnhLdg`,
    "fs-6": `fs-6-Rd1yPpNh`,
    "py-sm-1": `py-sm-1-gbhDhMVu`,
    "align-self-sm-center": `align-self-sm-center-DECESttN`,
    "list-group-item-secondary": `list-group-item-secondary-HKNQu0eN`,
    "invalid-tooltip": `invalid-tooltip-J12aIp25`,
    "my-sm-0": `my-sm-0-QY6sYuJO`,
    "px-md-5": `px-md-5-QzJB5B8F`,
    "stretched-link": `stretched-link-GrNRAF2s`,
    "justify-content-sm-evenly": `justify-content-sm-evenly-gGpCIWm6`,
    "link-warning": `link-warning-72cdu-fC`,
    "border-3": `border-3-Qh4FHgmN`,
    "ms-sm-1": `ms-sm-1-C348wHBh`,
    "align-self-lg-start": `align-self-lg-start-1TyhCtur`,
    "px-xxl-0": `px-xxl-0-wMT9znEq`,
    "pb-xxl-3": `pb-xxl-3-TJhUsLUJ`,
    "pt-lg-1": `pt-lg-1-MS5ULjh7`,
    "row-cols-sm-5": `row-cols-sm-5-XAD7xAwq`,
    "py-md-1": `py-md-1-Mh4zb6l7`,
    "align-items-lg-baseline": `align-items-lg-baseline-ePR_P5OT`,
    "offset-md-8": `offset-md-8-4onlTiZ8`,
    "modal-fullscreen-xl-down": `modal-fullscreen-xl-down-1vdnIr2C`,
    "column-gap-md-4": `column-gap-md-4-Ixy3cDzm`,
    "ms-md-3": `ms-md-3-YWu2cC63`,
    "mt-md-4": `mt-md-4-quZ3wzkz`,
    "offset-xxl-2": `offset-xxl-2-pD0XUEJ9`,
    "offset-xxl-5": `offset-xxl-5-8hnm_QQj`,
    "nav-link": `nav-link-0seA2n67`,
    "offcanvas-header": `offcanvas-header-a8G-_9dg`,
    "border-light": `border-light-49LEBv97`,
    "justify-content-around": `justify-content-around-q4rGCw0A`,
    "flex-lg-fill": `flex-lg-fill-d9p1d313`,
    "border-light-subtle": `border-light-subtle-reQuDuIx`,
    "modal-content": `modal-content-ILotUloM`,
    "btn-outline-primary": `btn-outline-primary-rP8Ytgaw`,
    "alert": `alert-0IAb2ji7`,
    "modal-backdrop": `modal-backdrop-B2AvW5wO`,
    "carousel-inner": `carousel-inner-_FYX-6g8`,
    "link-success": `link-success--jvCZZ3v`,
    "px-xxl-5": `px-xxl-5-l66RKtJs`,
    "pe-xxl-2": `pe-xxl-2-PL5dxeGK`,
    "align-self-sm-stretch": `align-self-sm-stretch-LpC7FF0s`,
    "mx-xxl-4": `mx-xxl-4-QkaClzWz`,
    "text-bg-info": `text-bg-info-6DAFAYPl`,
    "me-lg-3": `me-lg-3-S4jxnVbr`,
    "mx-auto": `mx-auto-N0A-5LJm`,
    "list-group-item-warning": `list-group-item-warning-R_yveOqK`,
    "fst-normal": `fst-normal-iqHQ5B11`,
    "flex-xl-shrink-0": `flex-xl-shrink-0--KpLZO2J`,
    "pb-xl-0": `pb-xl-0--UwrEndM`,
    "ms-lg-5": `ms-lg-5-BCZkClBy`,
    "d-lg-none": `d-lg-none-U9GDaCSo`,
    "flex-sm-column-reverse": `flex-sm-column-reverse-vEGOK4-e`,
    "align-content-xl-stretch": `align-content-xl-stretch-gAqq-4wc`,
    "py-xxl-4": `py-xxl-4-jWcFLlTP`,
    "pe-sm-0": `pe-sm-0-ayB992sC`,
    "my-xxl-3": `my-xxl-3-e9KQGEXn`,
    "align-content-stretch": `align-content-stretch-dAhTwi5c`,
    "text-bg-secondary": `text-bg-secondary-GJgK83U3`,
    "rounded-top-5": `rounded-top-5-DN3BUP1o`,
    "offcanvas-end": `offcanvas-end-xdT5N57w`,
    "object-fit-md-cover": `object-fit-md-cover-bCodLu0v`,
    "d-print-inline-grid": `d-print-inline-grid-5o47N0yy`,
    "align-self-center": `align-self-center-bqs4FE9P`,
    "order-2": `order-2-1DwMMosJ`,
    "text-primary": `text-primary-7RrjjYa9`,
    "offset-5": `offset-5-nlCEUg_s`,
    "pointer-event": `pointer-event-j0XDRmPG`,
    "col-xxl-1": `col-xxl-1-aJacyELr`,
    "breadcrumb-item": `breadcrumb-item-5jGpPLZW`,
    "my-sm-2": `my-sm-2-0Xi-pu_O`,
    "offset-md-9": `offset-md-9-iqzdPagO`,
    "nav-justified": `nav-justified-gOfDz1GM`,
    "list-inline-item": `list-inline-item-RSv1Mf0Z`,
    "border-opacity-75": `border-opacity-75-Z-P978A4`,
    "ms-auto": `ms-auto-sJYOvDMf`,
    "pe-xxl-0": `pe-xxl-0-aHupnf9B`,
    "ps-xxl-2": `ps-xxl-2-VojOvtbQ`,
    "mx-xxl-2": `mx-xxl-2-LDFlppyC`,
    "ms-xxl-1": `ms-xxl-1-uGdULJKp`,
    "column-gap-sm-1": `column-gap-sm-1-nobERDT3`,
    "btn-group-sm": `btn-group-sm-gz60hKs7`,
    "offset-xxl-3": `offset-xxl-3-IlWdyIJn`,
    "py-md-3": `py-md-3-lFj4-DhL`,
    "offset-lg-0": `offset-lg-0-_I41h-wN`,
    "order-last": `order-last-ddpEBC3w`,
    "list-group-horizontal-sm": `list-group-horizontal-sm-1ZW5b_Ls`,
    "focus-ring-secondary": `focus-ring-secondary-k6u2wm5R`,
    "row-gap-xxl-0": `row-gap-xxl-0-_B7XaFRA`,
    "pt-xxl-1": `pt-xxl-1-h3iqKEOC`,
    "gy-sm-5": `gy-sm-5-i571NLTW`,
    "object-fit-sm-fill": `object-fit-sm-fill-tvJ-UXTU`,
    "flex-lg-column": `flex-lg-column-YZ_xptJe`,
    "float-xl-end": `float-xl-end-cpydoeOj`,
    "container-fluid": `container-fluid-ex1ew-OQ`,
    "icon-link-hover": `icon-link-hover-uadk1icH`,
    "my-xxl-1": `my-xxl-1-TMJBzgnc`,
    "mt-xxl-0": `mt-xxl-0-euzlvlwy`,
    "form-control-color": `form-control-color-D9_3zkqa`,
    "me-xxl-4": `me-xxl-4-swkqbrv3`,
    "navbar-expand": `navbar-expand-_CPKgFS6`,
    "link-opacity-25-hover": `link-opacity-25-hover-l0RjQHYu`,
    "form-check-reverse": `form-check-reverse-cuOhH78o`,
    "rounded-end-pill": `rounded-end-pill-ZQJi6-M1`,
    "bg-body": `bg-body-2P9mkJnb`,
    "justify-content-xl-evenly": `justify-content-xl-evenly-Xdjjo9Qm`,
    "offset-sm-6": `offset-sm-6-DQnnfDhm`,
    "my-lg-3": `my-lg-3-TUaBo_31`,
    "me-lg-5": `me-lg-5-Cr8anqet`,
    "col-xxl-12": `col-xxl-12-vtWut998`,
    "mx-xl-5": `mx-xl-5-Gs_PaCzS`,
    "offset-xl-2": `offset-xl-2-2tuH3GMk`,
    "show": `show-zds30gJP`,
    "card": `card-aGST8Smo`,
    "py-sm-5": `py-sm-5-CyCwe1n9`,
    "offset-xl-9": `offset-xl-9-EGuAqsDE`,
    "justify-content-sm-around": `justify-content-sm-around-jHIRQaU8`,
    "g-xxl-0": `g-xxl-0-EKb4fyXS`,
    "bs-popover-bottom": `bs-popover-bottom-TwI8bPkM`,
    "modal-sm": `modal-sm-rl0D3nh5`,
    "mt-xxl-5": `mt-xxl-5-GUaTGzN0`,
    "sticky-md-top": `sticky-md-top-mevnxPfx`,
    "figure-caption": `figure-caption-XmmVUN6_`,
    "align-items-md-center": `align-items-md-center-ldj1jAB7`,
    "col-xxl-2": `col-xxl-2-HMUE3d5e`,
    "mt-sm-auto": `mt-sm-auto-7rp-UaRI`,
    "align-self-md-stretch": `align-self-md-stretch-yBs7RHOJ`,
    "gy-lg-3": `gy-lg-3-mNCZK8m1`,
    "popover": `popover-JVMp0xDB`,
    "text-capitalize": `text-capitalize-Gcj13V-J`,
    "justify-content-md-around": `justify-content-md-around-AY2fKBZ2`,
    "row-cols-xxl-4": `row-cols-xxl-4-6JHscu0q`,
    "position-static": `position-static-Dqs3YToJ`,
    "py-xl-3": `py-xl-3-oO8jodZB`,
    "justify-content-end": `justify-content-end-4ShUG2wI`,
    "rounded-top-3": `rounded-top-3-UO7vtRf5`,
    "object-fit-sm-none": `object-fit-sm-none-MwhjlJSY`,
    "text-info": `text-info-3n_u9qrM`,
    "d-sm-none": `d-sm-none-fzjKUWlE`,
    "rounded-start-1": `rounded-start-1-8If7PtJ_`,
    "p-xxl-0": `p-xxl-0-Kk2GZucW`,
    "align-text-top": `align-text-top-IpcWpQRu`,
    "mb-xxl-1": `mb-xxl-1-hNfZeuXf`,
    "mt-md-0": `mt-md-0-VxViFKqI`,
    "navbar-toggler": `navbar-toggler-Puw4BWrN`,
    "me-xxl-auto": `me-xxl-auto-Y7U4EBPE`,
    "row-gap-lg-0": `row-gap-lg-0-20Sxx-r-`,
    "d-md-none": `d-md-none-4prs97LI`,
    "gx-lg-3": `gx-lg-3-M1a6jqp_`,
    "px-lg-0": `px-lg-0-mSdaYRMW`,
    "link-offset-1-hover": `link-offset-1-hover-kFDClEea`,
    "d-lg-grid": `d-lg-grid-hS7woNYA`,
    "py-lg-2": `py-lg-2-qYlMYf9x`,
    "align-content-sm-end": `align-content-sm-end-_7gtW5dy`,
    "col-xl-12": `col-xl-12-bnclcl2F`,
    "ps-lg-5": `ps-lg-5-OAOF9U9_`,
    "mt-sm-5": `mt-sm-5-16wGc7Lo`,
    "flex-md-wrap": `flex-md-wrap-iReDRVKB`,
    "shadow-sm": `shadow-sm-y-ZZoNsP`,
    "display-6": `display-6-2DAnpDO1`,
    "flex-xxl-nowrap": `flex-xxl-nowrap-iUcYNhKV`,
    "link-underline-opacity-25": `link-underline-opacity-25-tBZuPmO9`,
    "my-xl-4": `my-xl-4-By-HlIFF`,
    "gx-sm-0": `gx-sm-0-dp6_jitn`,
    "row-gap-5": `row-gap-5-kHN4mFIj`,
    "form-check": `form-check-8etvROxb`,
    "link-danger": `link-danger-tVbHThZU`,
    "flex-column-reverse": `flex-column-reverse-cTv04qzR`,
    "align-self-xxl-stretch": `align-self-xxl-stretch-I9JinQ3J`,
    "order-xl-0": `order-xl-0--_EeBQ7b`,
    "g-xxl-2": `g-xxl-2-f0gyQMK3`,
    "link-underline-opacity-50": `link-underline-opacity-50-N_ncWNYH`,
    "pb-lg-3": `pb-lg-3-X_Rug2r9`,
    "order-xl-2": `order-xl-2-IzuvOgoj`,
    "pe-xl-2": `pe-xl-2-2-orUZ2s`,
    "text-sm-center": `text-sm-center-TJg-lAi0`,
    "order-sm-5": `order-sm-5-AvUg6v8b`,
    "text-nowrap": `text-nowrap-_2f2fRNg`,
    "mx-sm-1": `mx-sm-1--HHBMzcc`,
    "gx-md-5": `gx-md-5-V29UaH31`,
    "flex-md-grow-0": `flex-md-grow-0-H7IcD2vZ`,
    "modal-xl": `modal-xl-giXxoA0Q`,
    "text-body": `text-body-LbtBK9Np`,
    "mx-xxl-1": `mx-xxl-1-8QU7ufky`,
    "pb-md-3": `pb-md-3-Y23qOKrj`,
    "order-md-last": `order-md-last--W2WJgYF`,
    "popover-body": `popover-body-3_fKmnGY`,
    "text-bg-light": `text-bg-light-kPQTrg0O`,
    "flex-md-shrink-0": `flex-md-shrink-0-aWDBnYXO`,
    "flex-lg-shrink-0": `flex-lg-shrink-0-tHEDjgBo`,
    "rounded-start-3": `rounded-start-3-fNT7QAds`,
    "col-form-label-sm": `col-form-label-sm-nY397Ket`,
    "mb-sm-1": `mb-sm-1-dkqOB9Sq`,
    "dropdown-menu-sm-start": `dropdown-menu-sm-start-P1qBrMJV`,
    "btn-close-white": `btn-close-white-t8aJiYem`,
    "column-gap-md-3": `column-gap-md-3-nx7AlBNa`,
    "p-xxl-2": `p-xxl-2-IHzt2XHF`,
    "row-gap-lg-1": `row-gap-lg-1-CUMV0yjY`,
    "me-md-0": `me-md-0-51K8VFf3`,
    "d-print-none": `d-print-none-GyT-wL9Y`,
    "align-content-start": `align-content-start-ItbdXMRA`,
    "align-content-xl-center": `align-content-xl-center-Pc9BHMcl`,
    "d-print-inline": `d-print-inline-1_raoAZQ`,
    "table-striped-columns": `table-striped-columns-8CippxVO`,
    "col-xxl": `col-xxl-aLJL6j0-`,
    "order-sm-first": `order-sm-first-P2Ix1J74`,
    "my-xxl-0": `my-xxl-0-tiO2-Of1`,
    "me-xxl-3": `me-xxl-3-1IPIowzY`,
    "link-light": `link-light-IRNTWuO3`,
    "start-50": `start-50-P0L52OKF`,
    "visually-hidden-focusable": `visually-hidden-focusable-1G58ofsm`,
    "overflow-scroll": `overflow-scroll-WQXIu7d2`,
    "column-gap-2": `column-gap-2-0xGUG3xv`,
    "border-danger-subtle": `border-danger-subtle-Ao9ynen0`,
    "order-lg-1": `order-lg-1-V4Xc98eI`,
    "py-lg-0": `py-lg-0-_sM5HGhk`,
    "px-sm-5": `px-sm-5-ooeL1KcA`,
    "order-md-0": `order-md-0-HyZXDfqr`,
    "border-end-0": `border-end-0-dEigjGxN`,
    "order-md-2": `order-md-2-T28aqs9w`,
    "table-group-divider": `table-group-divider-SA5WWCvQ`,
    "mt-xl-2": `mt-xl-2-3dJKb0QV`,
    "pt-1": `pt-1-uIPaKTlD`,
    "pt-2": `pt-2-u760jX2j`,
    "pt-3": `pt-3-LD7qYrt1`,
    "pt-4": `pt-4-EOwuwjOX`,
    "pt-5": `pt-5-EvtXk5h-`,
    "pe-0": `pe-0-Hh9Z93Vt`,
    "pe-1": `pe-1--Aym79OQ`,
    "pe-2": `pe-2-1bLNjJB9`,
    "pe-3": `pe-3-J1a845mn`,
    "pe-4": `pe-4-J533b9xl`,
    "pe-5": `pe-5-w3K4Qgay`,
    "pb-0": `pb-0-rCuC0x8V`,
    "pb-1": `pb-1-u-QOPVyb`,
    "pb-2": `pb-2-uJXNJJYu`,
    "pb-3": `pb-3-JCcW1Whf`,
    "pb-4": `pb-4-dzaRmaOM`,
    "position-relative": `position-relative-6xZahBQC`,
    "border-opacity-10": `border-opacity-10-Xc7Hu0nr`,
    "offset-md-10": `offset-md-10-2I0PdyaJ`,
    "d-xxl-flex": `d-xxl-flex-QK9qVLHS`,
    "offset-lg-10": `offset-lg-10-ChwH29kX`,
    "pb-5": `pb-5-oTIdgM6N`,
    "ps-0": `ps-0-lRtQ-1_P`,
    "ps-1": `ps-1-fPxza_xJ`,
    "ps-2": `ps-2-D8pDIwxo`,
    "ps-3": `ps-3-ZlkHwwYR`,
    "ps-4": `ps-4-QzxiuWuQ`,
    "ps-5": `ps-5-1vC5ElsN`,
    "px-0": `px-0-QfXgIUD0`,
    "fw-lighter": `fw-lighter-xBo1fx4n`,
    "gx-sm-2": `gx-sm-2-a7N1kvWt`,
    "row-cols-xxl-1": `row-cols-xxl-1-2RFiYgzN`,
    "gap-md-2": `gap-md-2-bMEb0-AY`,
    "gap-lg-5": `gap-lg-5-4Xu0dvSh`,
    "focus-ring": `focus-ring-y8kPXMY4`,
    "object-fit-md-fill": `object-fit-md-fill--X3R0GMH`
};

},
"node_modules/buffer-okam/index.js": function (module, exports, __mako_require__){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */ /* eslint-disable no-proto */ const global = __mako_require__("node_modules/node-libs-browser-okam/polyfill/global.js");
'use strict';
var base64 = __mako_require__("node_modules/base64-js/index.js");
var ieee754 = __mako_require__("node_modules/ieee754/index.js");
var isArray = __mako_require__("node_modules/buffer-okam/node_modules/isarray/index.js");
exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */ Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();
/*
 * Export kMaxLength after typed array support is determined.
 */ exports.kMaxLength = kMaxLength();
function typedArraySupport() {
    try {
        var arr = new Uint8Array(1);
        arr.__proto__ = {
            __proto__: Uint8Array.prototype,
            foo: function() {
                return 42;
            }
        };
        return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
        ;
    } catch (e) {
        return false;
    }
}
function kMaxLength() {
    return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
}
function createBuffer(that, length) {
    if (kMaxLength() < length) throw new RangeError('Invalid typed array length');
    if (Buffer.TYPED_ARRAY_SUPPORT) {
        // Return an augmented `Uint8Array` instance, for best performance
        that = new Uint8Array(length);
        that.__proto__ = Buffer.prototype;
    } else {
        // Fallback: Return an object instance of the Buffer class
        if (that === null) that = new Buffer(length);
        that.length = length;
    }
    return that;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */ function Buffer(arg, encodingOrOffset, length) {
    if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) return new Buffer(arg, encodingOrOffset, length);
    // Common case.
    if (typeof arg === 'number') {
        if (typeof encodingOrOffset === 'string') throw new Error('If encoding is specified then the first argument must be a string');
        return allocUnsafe(this, arg);
    }
    return from(this, arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192 // not used by this implementation
;
// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function(arr) {
    arr.__proto__ = Buffer.prototype;
    return arr;
};
function from(that, value, encodingOrOffset, length) {
    if (typeof value === 'number') throw new TypeError('"value" argument must not be a number');
    if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) return fromArrayBuffer(that, value, encodingOrOffset, length);
    if (typeof value === 'string') return fromString(that, value, encodingOrOffset);
    return fromObject(that, value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/ Buffer.from = function(value, encodingOrOffset, length) {
    return from(null, value, encodingOrOffset, length);
};
if (Buffer.TYPED_ARRAY_SUPPORT) {
    Buffer.prototype.__proto__ = Uint8Array.prototype;
    Buffer.__proto__ = Uint8Array;
    if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
        value: null,
        configurable: true
    });
}
function assertSize(size) {
    if (typeof size !== 'number') throw new TypeError('"size" argument must be a number');
    else if (size < 0) throw new RangeError('"size" argument must not be negative');
}
function alloc(that, size, fill, encoding) {
    assertSize(size);
    if (size <= 0) return createBuffer(that, size);
    if (fill !== undefined) // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
    return createBuffer(that, size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/ Buffer.alloc = function(size, fill, encoding) {
    return alloc(null, size, fill, encoding);
};
function allocUnsafe(that, size) {
    assertSize(size);
    that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT) for(var i = 0; i < size; ++i)that[i] = 0;
    return that;
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */ Buffer.allocUnsafe = function(size) {
    return allocUnsafe(null, size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */ Buffer.allocUnsafeSlow = function(size) {
    return allocUnsafe(null, size);
};
function fromString(that, string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8';
    if (!Buffer.isEncoding(encoding)) throw new TypeError('"encoding" must be a valid string encoding');
    var length = byteLength(string, encoding) | 0;
    that = createBuffer(that, length);
    var actual = that.write(string, encoding);
    if (actual !== length) // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
    return that;
}
function fromArrayLike(that, array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    that = createBuffer(that, length);
    for(var i = 0; i < length; i += 1)that[i] = array[i] & 255;
    return that;
}
function fromArrayBuffer(that, array, byteOffset, length) {
    array.byteLength // this throws if `array` is not a valid ArrayBuffer
    ;
    if (byteOffset < 0 || array.byteLength < byteOffset) throw new RangeError('\'offset\' is out of bounds');
    if (array.byteLength < byteOffset + (length || 0)) throw new RangeError('\'length\' is out of bounds');
    if (byteOffset === undefined && length === undefined) array = new Uint8Array(array);
    else if (length === undefined) array = new Uint8Array(array, byteOffset);
    else array = new Uint8Array(array, byteOffset, length);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
        // Return an augmented `Uint8Array` instance, for best performance
        that = array;
        that.__proto__ = Buffer.prototype;
    } else // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array);
    return that;
}
function fromObject(that, obj) {
    if (Buffer.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        that = createBuffer(that, len);
        if (that.length === 0) return that;
        obj.copy(that, 0, 0, len);
        return that;
    }
    if (obj) {
        if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
            if (typeof obj.length !== 'number' || isnan(obj.length)) return createBuffer(that, 0);
            return fromArrayLike(that, obj);
        }
        if (obj.type === 'Buffer' && isArray(obj.data)) return fromArrayLike(that, obj.data);
    }
    throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
}
function checked(length) {
    // Note: cannot use `length < kMaxLength()` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= kMaxLength()) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + ' bytes');
    return length | 0;
}
function SlowBuffer(length) {
    if (+length != length) length = 0;
    return Buffer.alloc(+length);
}
Buffer.isBuffer = function isBuffer(b) {
    return !!(b != null && b._isBuffer);
};
Buffer.compare = function compare(a, b) {
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) throw new TypeError('Arguments must be Buffers');
    if (a === b) return 0;
    var x = a.length;
    var y = b.length;
    for(var i = 0, len = Math.min(x, y); i < len; ++i)if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
    switch(String(encoding).toLowerCase()){
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return true;
        default:
            return false;
    }
};
Buffer.concat = function concat(list, length) {
    if (!isArray(list)) throw new TypeError('"list" argument must be an Array of Buffers');
    if (list.length === 0) return Buffer.alloc(0);
    var i;
    if (length === undefined) {
        length = 0;
        for(i = 0; i < list.length; ++i)length += list[i].length;
    }
    var buffer = Buffer.allocUnsafe(length);
    var pos = 0;
    for(i = 0; i < list.length; ++i){
        var buf = list[i];
        if (!Buffer.isBuffer(buf)) throw new TypeError('"list" argument must be an Array of Buffers');
        buf.copy(buffer, pos);
        pos += buf.length;
    }
    return buffer;
};
function byteLength(string, encoding) {
    if (Buffer.isBuffer(string)) return string.length;
    if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) return string.byteLength;
    if (typeof string !== 'string') string = '' + string;
    var len = string.length;
    if (len === 0) return 0;
    // Use a for loop to avoid recursion
    var loweredCase = false;
    for(;;)switch(encoding){
        case 'ascii':
        case 'latin1':
        case 'binary':
            return len;
        case 'utf8':
        case 'utf-8':
        case undefined:
            return utf8ToBytes(string).length;
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return len * 2;
        case 'hex':
            return len >>> 1;
        case 'base64':
            return base64ToBytes(string).length;
        default:
            if (loweredCase) return utf8ToBytes(string).length // assume utf8
            ;
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
    }
}
Buffer.byteLength = byteLength;
function slowToString(encoding, start, end) {
    var loweredCase = false;
    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.
    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) start = 0;
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) return '';
    if (end === undefined || end > this.length) end = this.length;
    if (end <= 0) return '';
    // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;
    if (end <= start) return '';
    if (!encoding) encoding = 'utf8';
    while(true)switch(encoding){
        case 'hex':
            return hexSlice(this, start, end);
        case 'utf8':
        case 'utf-8':
            return utf8Slice(this, start, end);
        case 'ascii':
            return asciiSlice(this, start, end);
        case 'latin1':
        case 'binary':
            return latin1Slice(this, start, end);
        case 'base64':
            return base64Slice(this, start, end);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return utf16leSlice(this, start, end);
        default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
            encoding = (encoding + '').toLowerCase();
            loweredCase = true;
    }
}
// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
}
Buffer.prototype.swap16 = function swap16() {
    var len = this.length;
    if (len % 2 !== 0) throw new RangeError('Buffer size must be a multiple of 16-bits');
    for(var i = 0; i < len; i += 2)swap(this, i, i + 1);
    return this;
};
Buffer.prototype.swap32 = function swap32() {
    var len = this.length;
    if (len % 4 !== 0) throw new RangeError('Buffer size must be a multiple of 32-bits');
    for(var i = 0; i < len; i += 4){
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
    }
    return this;
};
Buffer.prototype.swap64 = function swap64() {
    var len = this.length;
    if (len % 8 !== 0) throw new RangeError('Buffer size must be a multiple of 64-bits');
    for(var i = 0; i < len; i += 8){
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
    }
    return this;
};
Buffer.prototype.toString = function toString() {
    var length = this.length | 0;
    if (length === 0) return '';
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
};
Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
    if (this === b) return true;
    return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
    var str = '';
    var max = exports.INSPECT_MAX_BYTES;
    if (this.length > 0) {
        str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
        if (this.length > max) str += ' ... ';
    }
    return '<Buffer ' + str + '>';
};
Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (!Buffer.isBuffer(target)) throw new TypeError('Argument must be a Buffer');
    if (start === undefined) start = 0;
    if (end === undefined) end = target ? target.length : 0;
    if (thisStart === undefined) thisStart = 0;
    if (thisEnd === undefined) thisEnd = this.length;
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw new RangeError('out of range index');
    if (thisStart >= thisEnd && start >= end) return 0;
    if (thisStart >= thisEnd) return -1;
    if (start >= end) return 1;
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    var x = thisEnd - thisStart;
    var y = end - start;
    var len = Math.min(x, y);
    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);
    for(var i = 0; i < len; ++i)if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1;
    // Normalize byteOffset
    if (typeof byteOffset === 'string') {
        encoding = byteOffset;
        byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff;
    else if (byteOffset < -2147483648) byteOffset = -2147483648;
    byteOffset = +byteOffset // Coerce to Number.
    ;
    if (isNaN(byteOffset)) // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
    }
    // Normalize val
    if (typeof val === 'string') val = Buffer.from(val, encoding);
    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) return -1;
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === 'number') {
        val = val & 0xFF // Search for a byte value [0-255]
        ;
        if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
            if (dir) return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            else return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
        return arrayIndexOf(buffer, [
            val
        ], byteOffset, encoding, dir);
    }
    throw new TypeError('val must be string, number or Buffer');
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;
    if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
            if (arr.length < 2 || val.length < 2) return -1;
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
        }
    }
    function read(buf, i) {
        if (indexSize === 1) return buf[i];
        else return buf.readUInt16BE(i * indexSize);
    }
    var i;
    if (dir) {
        var foundIndex = -1;
        for(i = byteOffset; i < arrLength; i++)if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
        }
    } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for(i = byteOffset; i >= 0; i--){
            var found = true;
            for(var j = 0; j < valLength; j++)if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
            }
            if (found) return i;
        }
    }
    return -1;
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) length = remaining;
    else {
        length = Number(length);
        if (length > remaining) length = remaining;
    }
    // must be an even number of digits
    var strLen = string.length;
    if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');
    if (length > strLen / 2) length = strLen / 2;
    for(var i = 0; i < length; ++i){
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (isNaN(parsed)) return i;
        buf[offset + i] = parsed;
    }
    return i;
}
function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function latin1Write(buf, string, offset, length) {
    return asciiWrite(buf, string, offset, length);
}
function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
        encoding = 'utf8';
        length = this.length;
        offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === 'string') {
        encoding = offset;
        length = this.length;
        offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
        offset = offset | 0;
        if (isFinite(length)) {
            length = length | 0;
            if (encoding === undefined) encoding = 'utf8';
        } else {
            encoding = length;
            length = undefined;
        }
    // legacy write(string, encoding, offset, length) - remove in v0.13
    } else throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
    var remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) throw new RangeError('Attempt to write outside buffer bounds');
    if (!encoding) encoding = 'utf8';
    var loweredCase = false;
    for(;;)switch(encoding){
        case 'hex':
            return hexWrite(this, string, offset, length);
        case 'utf8':
        case 'utf-8':
            return utf8Write(this, string, offset, length);
        case 'ascii':
            return asciiWrite(this, string, offset, length);
        case 'latin1':
        case 'binary':
            return latin1Write(this, string, offset, length);
        case 'base64':
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return ucs2Write(this, string, offset, length);
        default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
    }
};
Buffer.prototype.toJSON = function toJSON() {
    return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) return base64.fromByteArray(buf);
    else return base64.fromByteArray(buf.slice(start, end));
}
function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i = start;
    while(i < end){
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
        if (i + bytesPerSequence <= end) {
            var secondByte, thirdByte, fourthByte, tempCodePoint;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 0x80) codePoint = firstByte;
                    break;
                case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
                        if (tempCodePoint > 0x7F) codePoint = tempCodePoint;
                    }
                    break;
                case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) codePoint = tempCodePoint;
                    }
                    break;
                case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) codePoint = tempCodePoint;
                    }
            }
        }
        if (codePoint === null) {
            // we did not generate a valid codePoint so insert a
            // replacement char (U+FFFD) and advance only 1 byte
            codePoint = 0xFFFD;
            bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
            // encode to utf16 (surrogate pair dance)
            codePoint -= 0x10000;
            res.push(codePoint >>> 10 & 0x3FF | 0xD800);
            codePoint = 0xDC00 | codePoint & 0x3FF;
        }
        res.push(codePoint);
        i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
}
// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;
function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    ;
    // Decode in chunks to avoid "call stack size exceeded".
    var res = '';
    var i = 0;
    while(i < len)res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    return res;
}
function asciiSlice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);
    for(var i = start; i < end; ++i)ret += String.fromCharCode(buf[i] & 0x7F);
    return ret;
}
function latin1Slice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);
    for(var i = start; i < end; ++i)ret += String.fromCharCode(buf[i]);
    return ret;
}
function hexSlice(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    var out = '';
    for(var i = start; i < end; ++i)out += toHex(buf[i]);
    return out;
}
function utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = '';
    for(var i = 0; i < bytes.length; i += 2)res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    return res;
}
Buffer.prototype.slice = function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) start = 0;
    } else if (start > len) start = len;
    if (end < 0) {
        end += len;
        if (end < 0) end = 0;
    } else if (end > len) end = len;
    if (end < start) end = start;
    var newBuf;
    if (Buffer.TYPED_ARRAY_SUPPORT) {
        newBuf = this.subarray(start, end);
        newBuf.__proto__ = Buffer.prototype;
    } else {
        var sliceLen = end - start;
        newBuf = new Buffer(sliceLen, undefined);
        for(var i = 0; i < sliceLen; ++i)newBuf[i] = this[i + start];
    }
    return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */ function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}
Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    return val;
};
Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset + --byteLength];
    var mul = 1;
    while(byteLength > 0 && (mul *= 0x100))val += this[offset + --byteLength] * mul;
    return val;
};
Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
};
Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
};
Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
};
Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};
Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];
    while(i > 0 && (mul *= 0x100))val += this[offset + --i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return this[offset];
    return (0xff - this[offset] + 1) * -1;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset] | this[offset + 1] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | this[offset] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
}
Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    var mul = 1;
    var i = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    this[offset] = value & 0xff;
    return offset + 1;
};
function objectWriteUInt16(buf, value, offset, littleEndian) {
    if (value < 0) value = 0xffff + value + 1;
    for(var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i)buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
}
Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 0xff;
        this[offset + 1] = value >>> 8;
    } else objectWriteUInt16(this, value, offset, true);
    return offset + 2;
};
Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 8;
        this[offset + 1] = value & 0xff;
    } else objectWriteUInt16(this, value, offset, false);
    return offset + 2;
};
function objectWriteUInt32(buf, value, offset, littleEndian) {
    if (value < 0) value = 0xffffffff + value + 1;
    for(var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i)buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
}
Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 0xff;
    } else objectWriteUInt32(this, value, offset, true);
    return offset + 4;
};
Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 0xff;
    } else objectWriteUInt32(this, value, offset, false);
    return offset + 4;
};
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i = byteLength - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -128);
    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 0xff;
        this[offset + 1] = value >>> 8;
    } else objectWriteUInt16(this, value, offset, true);
    return offset + 2;
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 8;
        this[offset + 1] = value & 0xff;
    } else objectWriteUInt16(this, value, offset, false);
    return offset + 2;
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 0xff;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
    } else objectWriteUInt32(this, value, offset, true);
    return offset + 4;
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    if (value < 0) value = 0xffffffff + value + 1;
    if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 0xff;
    } else objectWriteUInt32(this, value, offset, false);
    return offset + 4;
};
function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
    if (offset < 0) throw new RangeError('Index out of range');
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -340282346638528860000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
}
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
}
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
};
// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    // Copy 0 bytes; we're done
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    // Fatal error conditions
    if (targetStart < 0) throw new RangeError('targetStart out of bounds');
    if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
    if (end < 0) throw new RangeError('sourceEnd out of bounds');
    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) end = target.length - targetStart + start;
    var len = end - start;
    var i;
    if (this === target && start < targetStart && targetStart < end) // descending copy from end
    for(i = len - 1; i >= 0; --i)target[i + targetStart] = this[i + start];
    else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) // ascending copy from start
    for(i = 0; i < len; ++i)target[i + targetStart] = this[i + start];
    else Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
    return len;
};
// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === 'string') {
        if (typeof start === 'string') {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === 'string') {
            encoding = end;
            end = this.length;
        }
        if (val.length === 1) {
            var code = val.charCodeAt(0);
            if (code < 256) val = code;
        }
        if (encoding !== undefined && typeof encoding !== 'string') throw new TypeError('encoding must be a string');
        if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) throw new TypeError('Unknown encoding: ' + encoding);
    } else if (typeof val === 'number') val = val & 255;
    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) throw new RangeError('Out of range index');
    if (end <= start) return this;
    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val) val = 0;
    var i;
    if (typeof val === 'number') for(i = start; i < end; ++i)this[i] = val;
    else {
        var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
        var len = bytes.length;
        for(i = 0; i < end - start; ++i)this[i + start] = bytes[i % len];
    }
    return this;
};
// HELPER FUNCTIONS
// ================
var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
function base64clean(str) {
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = stringtrim(str).replace(INVALID_BASE64_RE, '');
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return '';
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while(str.length % 4 !== 0)str = str + '=';
    return str;
}
function stringtrim(str) {
    if (str.trim) return str.trim();
    return str.replace(/^\s+|\s+$/g, '');
}
function toHex(n) {
    if (n < 16) return '0' + n.toString(16);
    return n.toString(16);
}
function utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];
    for(var i = 0; i < length; ++i){
        codePoint = string.charCodeAt(i);
        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
            // last char was a lead
            if (!leadSurrogate) {
                // no lead yet
                if (codePoint > 0xDBFF) {
                    // unexpected trail
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                } else if (i + 1 === length) {
                    // unpaired lead
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                }
                // valid lead
                leadSurrogate = codePoint;
                continue;
            }
            // 2 leads in a row
            if (codePoint < 0xDC00) {
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                leadSurrogate = codePoint;
                continue;
            }
            // valid surrogate pair
            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) // valid bmp char, but last char was a lead
        {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }
        leadSurrogate = null;
        // encode utf8
        if (codePoint < 0x80) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
        } else if (codePoint < 0x800) {
            if ((units -= 2) < 0) break;
            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
            if ((units -= 3) < 0) break;
            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
            if ((units -= 4) < 0) break;
            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else throw new Error('Invalid code point');
    }
    return bytes;
}
function asciiToBytes(str) {
    var byteArray = [];
    for(var i = 0; i < str.length; ++i)// Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
    return byteArray;
}
function utf16leToBytes(str, units) {
    var c, hi, lo;
    var byteArray = [];
    for(var i = 0; i < str.length; ++i){
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return byteArray;
}
function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
    for(var i = 0; i < length; ++i){
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
    }
    return i;
}
function isnan(val) {
    return val !== val // eslint-disable-line no-self-compare
    ;
}

},
"node_modules/buffer-okam/node_modules/isarray/index.js": function (module, exports, __mako_require__){
var toString = {}.toString;
module.exports = Array.isArray || function(arr) {
    return toString.call(arr) == '[object Array]';
};

},
"node_modules/clsx/dist/clsx.js": function (module, exports, __mako_require__){
function r(e) {
    var o, t, f = "";
    if ("string" == typeof e || "number" == typeof e) f += e;
    else if ("object" == typeof e) {
        if (Array.isArray(e)) {
            var n = e.length;
            for(o = 0; o < n; o++)e[o] && (t = r(e[o])) && (f && (f += " "), f += t);
        } else for(t in e)e[t] && (f && (f += " "), f += t);
    }
    return f;
}
function e() {
    for(var e, o, t = 0, f = "", n = arguments.length; t < n; t++)(e = arguments[t]) && (o = r(e)) && (f && (f += " "), f += o);
    return f;
}
module.exports = e, module.exports.clsx = e;

},
"node_modules/clsx/dist/clsx.mjs": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    clsx: function() {
        return clsx;
    },
    default: function() {
        return _default;
    }
});
function r(e) {
    var t, f, n = "";
    if ("string" == typeof e || "number" == typeof e) n += e;
    else if ("object" == typeof e) {
        if (Array.isArray(e)) {
            var o = e.length;
            for(t = 0; t < o; t++)e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
        } else for(f in e)e[f] && (n && (n += " "), n += f);
    }
    return n;
}
function clsx() {
    for(var e, t, f = 0, n = "", o = arguments.length; f < o; f++)(e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
    return n;
}
var _default = clsx;

},
"node_modules/dumi/theme-default/builtins/API/index.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _dumi = __mako_require__(".dumi/tmp/dumi/exports.ts");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
var _Badge = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/dumi/theme-default/builtins/Badge/index.js"));
var _Table = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/dumi/theme-default/builtins/Table/index.js"));
"";
function _typeof(obj) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, _typeof(obj);
}
function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _iterableToArrayLimit(arr, i) {
    var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
    if (null != _i) {
        var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1;
        try {
            if (_x = (_i = _i.call(arr)).next, 0 === i) {
                if (Object(_i) !== _i) return;
                _n = !1;
            } else for(; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);
        } catch (err) {
            _d = !0, _e = err;
        } finally{
            try {
                if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;
            } finally{
                if (_d) throw _e;
            }
        }
        return _arr;
    }
}
function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
}
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {
            _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
        var res = prim.call(input, hint || "default");
        if (_typeof(res) !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
}
function Token(_ref) {
    var children = _ref.children;
    return /*#__PURE__*/ _react.default.createElement("span", {
        "data-token": children
    }, children);
}
// https://github.com/umijs/dumi/issues/1957
function fixArg(arg) {
    if (arg.hasQuestionToken && typeof arg.type === 'string') arg.type = arg.type.replace(/\s+\|\s+undefined\s*$/i, '');
    return arg;
}
// Usually handles types other than basic types, either interfaces or type aliases
var CompositeType = function CompositeType(prop) {
    var _prop$source;
    var intl = (0, _dumi.useIntl)();
    var _useSiteData = (0, _dumi.useSiteData)(), themeConfig = _useSiteData.themeConfig;
    return (_prop$source = prop.source) !== null && _prop$source !== void 0 && _prop$source[0] && themeConfig.sourceLink ? /*#__PURE__*/ _react.default.createElement("a", {
        className: "dumi-default-api-link",
        href: intl.formatMessage({
            id: '$internal.api.sourceLink'
        }, _objectSpread({}, prop.source[0])),
        target: "_blank",
        rel: "noreferrer"
    }, prop.className) : prop.className;
};
var HANDLERS = {
    // entry method
    toNode: function toNode(prop) {
        if (typeof prop.type === 'string' && prop.type in this) {
            // value from TypeMap
            if ('enum' in prop) return this.enum(prop);
            return this[prop.type](prop);
        } else if (prop.type) // non-parsed type, such as ReactNode
        return this.getValidClassName(prop) || /*#__PURE__*/ _react.default.createElement("span", null, prop.type);
        else if ('const' in prop) // const value
        return /*#__PURE__*/ _react.default.createElement("span", null, prop.const);
        else if ('oneOf' in prop) // oneOf value
        return this.oneOf(prop);
        // unknown type
        return /*#__PURE__*/ _react.default.createElement("span", null, "unknown");
    },
    // type handlers
    string: function string(prop) {
        return /*#__PURE__*/ _react.default.createElement("span", null, prop.type);
    },
    number: function number(prop) {
        return /*#__PURE__*/ _react.default.createElement("span", null, prop.type);
    },
    boolean: function boolean(prop) {
        return /*#__PURE__*/ _react.default.createElement("span", null, prop.type);
    },
    any: function any(prop) {
        return /*#__PURE__*/ _react.default.createElement("span", null, prop.type);
    },
    object: function object(prop) {
        var _this = this;
        var entries = Object.entries(prop.properties || {});
        var props = entries.map(function(_ref2, index) {
            var _prop$required;
            var _ref3 = _slicedToArray(_ref2, 2), key = _ref3[0], value = _ref3[1];
            // skip nested object type
            return /*#__PURE__*/ _react.default.createElement("span", {
                key: key
            }, /*#__PURE__*/ _react.default.createElement("span", null, key), !((_prop$required = prop.required) !== null && _prop$required !== void 0 && _prop$required.includes(key)) && /*#__PURE__*/ _react.default.createElement(Token, null, "?"), /*#__PURE__*/ _react.default.createElement(Token, null, ":"), value.type === 'object' ? /*#__PURE__*/ _react.default.createElement("span", null, "object") : _this.toNode(value), index < entries.length - 1 && /*#__PURE__*/ _react.default.createElement(Token, null, ";"));
        });
        return /*#__PURE__*/ _react.default.createElement("span", null, /*#__PURE__*/ _react.default.createElement(Token, null, '{'), props, /*#__PURE__*/ _react.default.createElement(Token, null, '}'));
    },
    array: function array(prop) {
        var _this2 = this;
        var arrayType = /*#__PURE__*/ _react.default.createElement("span", null, "any");
        if (prop.items) {
            if (Array.isArray(prop.items)) return /*#__PURE__*/ _react.default.createElement("span", null, /*#__PURE__*/ _react.default.createElement(Token, null, '['), prop.items.map(function(item, i) {
                return /*#__PURE__*/ _react.default.createElement("span", {
                    key: "".concat(i)
                }, i > 0 && ', ', _this2.toNode(item));
            }), /*#__PURE__*/ _react.default.createElement(Token, null, ']'));
            var className = this.getValidClassName(prop.items);
            arrayType = className !== null && className !== void 0 ? className : this.toNode(prop.items);
        }
        return /*#__PURE__*/ _react.default.createElement("span", null, arrayType, /*#__PURE__*/ _react.default.createElement(Token, null, '['), /*#__PURE__*/ _react.default.createElement(Token, null, ']'));
    },
    // FIXME: extract real type
    element: function element(prop) {
        return /*#__PURE__*/ _react.default.createElement("span", null, /*#__PURE__*/ _react.default.createElement(Token, null, "<"), /*#__PURE__*/ _react.default.createElement("span", null, prop.componentName), /*#__PURE__*/ _react.default.createElement(Token, null, ">"));
    },
    // FIXME: extract real type
    function: function _function(_ref4) {
        var _this3 = this;
        var signature = _ref4.signature;
        // handle Function type without signature
        if (!signature) return /*#__PURE__*/ _react.default.createElement("span", null, "Function");
        var signatures = 'oneOf' in signature ? signature.oneOf : [
            signature
        ];
        return signatures.map(function(signature, si) {
            return /*#__PURE__*/ _react.default.createElement("span", {
                key: "".concat(si)
            }, signature.isAsync ? /*#__PURE__*/ _react.default.createElement(Token, null, "async") : '', /*#__PURE__*/ _react.default.createElement(Token, null, '('), signature.arguments.map(function(arg, ai) {
                return /*#__PURE__*/ _react.default.createElement("span", {
                    key: "".concat(si).concat(ai)
                }, /*#__PURE__*/ _react.default.createElement("span", null, arg.key), arg.hasQuestionToken && /*#__PURE__*/ _react.default.createElement(Token, null, "?"), /*#__PURE__*/ _react.default.createElement(Token, null, ":"), _this3.toNode(!!arg.schema ? arg.schema : fixArg(arg)), ai < signature.arguments.length - 1 && /*#__PURE__*/ _react.default.createElement(Token, null, ","));
            }), /*#__PURE__*/ _react.default.createElement(Token, null, ')'), /*#__PURE__*/ _react.default.createElement(Token, null, "=>"), _this3.toNode(signature.returnType), si < signatures.length - 1 && /*#__PURE__*/ _react.default.createElement(Token, null, "|"));
        });
    },
    // FIXME: extract real type
    dom: function dom(prop) {
        return /*#__PURE__*/ _react.default.createElement("span", null, prop.className || 'DOM');
    },
    // special handlers
    enum: function _enum(prop) {
        var enumStringArray = prop.enum.map(function(v) {
            return JSON.stringify(v);
        });
        return /*#__PURE__*/ _react.default.createElement("span", null, enumStringArray.map(function(e, i) {
            return /*#__PURE__*/ _react.default.createElement("span", {
                key: i
            }, /*#__PURE__*/ _react.default.createElement("span", null, e), i < enumStringArray.length - 1 && /*#__PURE__*/ _react.default.createElement(Token, null, "|"));
        }));
    },
    oneOf: function oneOf(prop) {
        var _this4 = this;
        return prop.oneOf.map(function(v, i) {
            return /*#__PURE__*/ _react.default.createElement("span", {
                key: i
            }, _this4.getValidClassName(v) || _this4.toNode(v), i < prop.oneOf.length - 1 && /*#__PURE__*/ _react.default.createElement(Token, null, "|"));
        });
    },
    reference: function reference(prop) {
        var _this5 = this;
        var typeParameters = prop.typeParameters || [];
        var params = typeParameters.map(function(param, i) {
            return /*#__PURE__*/ _react.default.createElement("span", {
                key: i
            }, _this5.toNode(param), i < typeParameters.length - 1 && /*#__PURE__*/ _react.default.createElement(Token, null, ","));
        });
        return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/ _react.default.createElement("a", {
            className: "dumi-default-api-link",
            href: prop.externalUrl,
            target: "_blank",
            rel: "noreferrer"
        }, prop.name), params.length ? /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/ _react.default.createElement(Token, null, "<"), params, /*#__PURE__*/ _react.default.createElement(Token, null, ">")) : '');
    },
    // utils
    getValidClassName: function getValidClassName(prop) {
        if ('className' in prop && typeof prop.className === 'string' && prop.className !== '__type') return /*#__PURE__*/ _react.default.createElement(CompositeType, prop);
        return null;
    }
};
var APIType = function APIType(prop) {
    var _useState = (0, _react.useState)(function() {
        return HANDLERS.toNode(prop);
    }), _useState2 = _slicedToArray(_useState, 2), type = _useState2[0], setType = _useState2[1];
    (0, _react.useEffect)(function() {
        setType(HANDLERS.toNode(prop));
    }, [
        prop
    ]);
    return /*#__PURE__*/ _react.default.createElement("code", {
        className: "dumi-default-api-type"
    }, type);
};
function getReleaseAndVersionInfo(props) {
    var releaseInfo = {};
    Object.entries(props).forEach(function(_ref5) {
        var _schema$tags, _schema$tags2;
        var _ref6 = _slicedToArray(_ref5, 2), prop = _ref6[0], schema = _ref6[1];
        var modiferTags = (_schema$tags = schema.tags) === null || _schema$tags === void 0 ? void 0 : _schema$tags.modifierTags;
        var blockTags = (_schema$tags2 = schema.tags) === null || _schema$tags2 === void 0 ? void 0 : _schema$tags2.blockTags;
        modiferTags === null || modiferTags === void 0 || modiferTags.forEach(function(tag) {
            if (tag === 'alpha' || tag === 'beta' || tag === 'experimental') releaseInfo[prop] = [
                tag
            ];
        });
        blockTags === null || blockTags === void 0 || blockTags.forEach(function(_ref7) {
            var tag = _ref7.tag, content = _ref7.content;
            if (tag === 'deprecated' || tag === 'since') {
                var textContent = content.map(function(item) {
                    return item.text;
                }).join('');
                releaseInfo[prop] = [
                    tag,
                    textContent
                ];
            }
        });
    });
    return releaseInfo;
}
var APIRelease = function APIRelease(_ref8) {
    var name = _ref8.name, info = _ref8.info;
    var intl = (0, _dumi.useIntl)();
    var _info = _slicedToArray(info, 2), modifer = _info[0], text = _info[1];
    var modiferProps = _defineProperty({
        className: 'dumi-default-api-release-modifer'
    }, 'data-release', modifer);
    if (text && modifer === 'deprecated') modiferProps['data-dumi-tooltip'] = text;
    var modiferText = modifer === 'since' ? "".concat(text, "+") : intl.formatMessage({
        id: "api.component.release.".concat(modifer)
    });
    return /*#__PURE__*/ _react.default.createElement("span", {
        className: "dumi-default-api-release"
    }, /*#__PURE__*/ _react.default.createElement("span", {
        className: "dumi-default-api-release-name",
        "data-release": modifer
    }, name), /*#__PURE__*/ _react.default.createElement("span", modiferProps, modifer === 'deprecated' ? modiferText : /*#__PURE__*/ _react.default.createElement(_Badge.default, {
        type: "info"
    }, modiferText)));
};
var API = function API(props) {
    var _useRouteMeta = (0, _dumi.useRouteMeta)(), frontmatter = _useRouteMeta.frontmatter;
    var _useAtomAssets = (0, _dumi.useAtomAssets)(), components = _useAtomAssets.components;
    var id = props.id || frontmatter.atomId;
    var intl = (0, _dumi.useIntl)();
    if (!id) throw new Error('`id` properties if required for API component!');
    var definition = components === null || components === void 0 ? void 0 : components[id];
    var properties = {};
    var type = (props.type || 'props').toLowerCase();
    if (definition) {
        var _definition$key;
        var key = "".concat(type, "Config");
        properties = ((_definition$key = definition[key]) === null || _definition$key === void 0 ? void 0 : _definition$key.properties) || {};
    }
    var releaseInfo = (0, _react.useMemo)(function() {
        return getReleaseAndVersionInfo(properties);
    }, [
        properties
    ]);
    return /*#__PURE__*/ _react.default.createElement("div", {
        className: "markdown"
    }, /*#__PURE__*/ _react.default.createElement(_Table.default, null, /*#__PURE__*/ _react.default.createElement("thead", null, /*#__PURE__*/ _react.default.createElement("tr", null, /*#__PURE__*/ _react.default.createElement("th", null, intl.formatMessage({
        id: 'api.component.name'
    })), /*#__PURE__*/ _react.default.createElement("th", null, intl.formatMessage({
        id: 'api.component.description'
    })), /*#__PURE__*/ _react.default.createElement("th", null, intl.formatMessage({
        id: 'api.component.type'
    })), type === 'props' && /*#__PURE__*/ _react.default.createElement("th", null, intl.formatMessage({
        id: 'api.component.default'
    })))), /*#__PURE__*/ _react.default.createElement("tbody", null, Object.keys(properties).length ? Object.entries(properties).map(function(_ref9) {
        var _definition$propsConf;
        var _ref10 = _slicedToArray(_ref9, 2), name = _ref10[0], prop = _ref10[1];
        return /*#__PURE__*/ _react.default.createElement("tr", {
            key: name
        }, /*#__PURE__*/ _react.default.createElement("td", null, releaseInfo[name] ? /*#__PURE__*/ _react.default.createElement(APIRelease, {
            name: name,
            info: releaseInfo[name]
        }) : name), /*#__PURE__*/ _react.default.createElement("td", null, prop.description || '--'), /*#__PURE__*/ _react.default.createElement("td", null, /*#__PURE__*/ _react.default.createElement(APIType, prop)), type === 'props' && /*#__PURE__*/ _react.default.createElement("td", null, /*#__PURE__*/ _react.default.createElement("code", null, (_definition$propsConf = definition.propsConfig.required) !== null && _definition$propsConf !== void 0 && _definition$propsConf.includes(name) ? intl.formatMessage({
            id: 'api.component.required'
        }) : JSON.stringify(prop.default) || '--')));
    }) : /*#__PURE__*/ _react.default.createElement("tr", null, /*#__PURE__*/ _react.default.createElement("td", {
        colSpan: 4
    }, intl.formatMessage({
        id: "api.component.".concat(components ? 'not.found' : 'unavailable')
    }, {
        id: id
    }))))));
};
var _default = API;

},
"node_modules/dumi/theme-default/builtins/Badge/index.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _react = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/react/index.js"));
"";
function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
var Badge = function Badge(props) {
    return /*#__PURE__*/ _react.default.createElement("span", _extends({
        className: "dumi-default-badge"
    }, props));
};
var _default = Badge;

},
"node_modules/dumi/theme-default/builtins/CodeGroup/index.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _Tabs = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/dumi/theme-default/slots/Tabs/index.js"));
var _SourceCode = /*#__PURE__*/ _interop_require_default._(__mako_require__(".dumi/tmp/dumi/theme/builtins/SourceCode.ts"));
var _toArray = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/rc-util/lib/Children/toArray.js"));
var _react = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/react/index.js"));
function _typeof(obj) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, _typeof(obj);
}
function CodeGroup(props) {
    var children = props.children;
    var usefulChildren = (0, _toArray.default)(children).filter(function(child) {
        var _child$type;
        return _typeof(child) === 'object' && typeof child.type === 'function' && ((_child$type = child.type) === null || _child$type === void 0 ? void 0 : _child$type.name) === _SourceCode.default.name;
    });
    var items = usefulChildren.map(function(child, idx) {
        var _child$props, _child$key;
        var _ref = (_child$props = child.props) !== null && _child$props !== void 0 ? _child$props : {}, lang = _ref.lang, title = _ref.title;
        return {
            key: String((_child$key = child.key) !== null && _child$key !== void 0 ? _child$key : idx),
            label: title || lang || 'txt',
            // fallback to txt if no lang and title
            children: child
        };
    });
    return /*#__PURE__*/ _react.default.createElement(_Tabs.default, {
        className: "dumi-default-code-group",
        items: items
    });
}
var _default = CodeGroup;

},
"node_modules/dumi/theme-default/builtins/Table/index.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _lodashthrottle = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/lodash.throttle/index.js"));
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
"";
var _excluded = [
    "children"
];
function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _iterableToArrayLimit(arr, i) {
    var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
    if (null != _i) {
        var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1;
        try {
            if (_x = (_i = _i.call(arr)).next, 0 === i) {
                if (Object(_i) !== _i) return;
                _n = !1;
            } else for(; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);
        } catch (err) {
            _d = !0, _e = err;
        } finally{
            try {
                if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;
            } finally{
                if (_d) throw _e;
            }
        }
        return _arr;
    }
}
function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
}
function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};
    var target = _objectWithoutPropertiesLoose(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for(i = 0; i < sourceSymbolKeys.length; i++){
            key = sourceSymbolKeys[i];
            if (excluded.indexOf(key) >= 0) continue;
            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
            target[key] = source[key];
        }
    }
    return target;
}
function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for(i = 0; i < sourceKeys.length; i++){
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
    }
    return target;
}
var Table = function Table(_ref) {
    var children = _ref.children, props = _objectWithoutProperties(_ref, _excluded);
    var container = (0, _react.useRef)(null);
    var _useState = (0, _react.useState)(false), _useState2 = _slicedToArray(_useState, 2), leftFolded = _useState2[0], setLeftFolded = _useState2[1];
    var _useState3 = (0, _react.useState)(false), _useState4 = _slicedToArray(_useState3, 2), rightFolded = _useState4[0], setRightFolded = _useState4[1];
    // watch content scroll to render folded shadow
    (0, _react.useEffect)(function() {
        var elm = container.current;
        if (elm) {
            var handler = (0, _lodashthrottle.default)(function() {
                setLeftFolded(elm.scrollLeft > 0);
                setRightFolded(elm.scrollLeft < elm.scrollWidth - elm.offsetWidth);
            }, 100);
            handler();
            elm.addEventListener('scroll', handler);
            window.addEventListener('resize', handler);
            return function() {
                elm.removeEventListener('scroll', handler);
                window.removeEventListener('resize', handler);
            };
        }
    }, []);
    return /*#__PURE__*/ _react.default.createElement("div", {
        className: "dumi-default-table"
    }, /*#__PURE__*/ _react.default.createElement("div", {
        className: "dumi-default-table-content",
        ref: container,
        "data-left-folded": leftFolded || undefined,
        "data-right-folded": rightFolded || undefined
    }, /*#__PURE__*/ _react.default.createElement("table", props, children)));
};
var _default = Table;

},
"node_modules/dumi/theme-default/builtins/Tree/index.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _filesvg = __mako_require__("node_modules/@ant-design/icons-svg/inline-svg/outlined/file.svg");
var _folderopensvg = __mako_require__("node_modules/@ant-design/icons-svg/inline-svg/outlined/folder-open.svg");
var _foldersvg = __mako_require__("node_modules/@ant-design/icons-svg/inline-svg/outlined/folder.svg");
var _minussquaresvg = __mako_require__("node_modules/@ant-design/icons-svg/inline-svg/outlined/minus-square.svg");
var _plussquaresvg = __mako_require__("node_modules/@ant-design/icons-svg/inline-svg/outlined/plus-square.svg");
var _rctree = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/rc-tree/es/index.js"));
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
"";
function _typeof(obj) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, _typeof(obj);
}
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {
            _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
        var res = prim.call(input, hint || "default");
        if (_typeof(res) !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
}
function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArrayLimit(arr, i) {
    var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
    if (null != _i) {
        var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1;
        try {
            if (_x = (_i = _i.call(arr)).next, 0 === i) {
                if (Object(_i) !== _i) return;
                _n = !1;
            } else for(; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);
        } catch (err) {
            _d = !0, _e = err;
        } finally{
            try {
                if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;
            } finally{
                if (_d) throw _e;
            }
        }
        return _arr;
    }
}
function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
}
function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function getTreeFromList(nodes) {
    var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    var data = [];
    [].concat(nodes).forEach(function(node, i) {
        var key = "".concat(prefix ? "".concat(prefix, "-") : '').concat(i);
        switch(node === null || node === void 0 ? void 0 : node.type){
            case 'ul':
                var _data;
                var parent = ((_data = data[data.length - 1]) === null || _data === void 0 ? void 0 : _data.children) || data;
                var ulLeafs = getTreeFromList(node.props.children || [], key);
                parent.push.apply(parent, _toConsumableArray(ulLeafs));
                break;
            case 'li':
                var _node$props$children, _node$props$children$;
                var hasEmptyUl = (_node$props$children = node.props.children) === null || _node$props$children === void 0 ? void 0 : (_node$props$children$ = _node$props$children.some) === null || _node$props$children$ === void 0 ? void 0 : _node$props$children$.call(_node$props$children, function(child) {
                    var _child$props$children;
                    return child.type === 'ul' && !((_child$props$children = child.props.children) !== null && _child$props$children !== void 0 && _child$props$children.length);
                });
                var title = [].concat(node.props.children).filter(function(child) {
                    return child.type !== 'ul';
                });
                var children = hasEmptyUl ? [] : getTreeFromList(node.props.children, key);
                data.push({
                    title: title,
                    key: key,
                    children: children,
                    isLeaf: !hasEmptyUl && !children.length,
                    switcherIcon: hasEmptyUl ? /*#__PURE__*/ _react.default.createElement("span", {
                        className: "tree-switcher-leaf-line"
                    }) : undefined
                });
                break;
            default:
        }
    });
    return data;
}
var useListToTree = function useListToTree(nodes) {
    var _useState = (0, _react.useState)(getTreeFromList(nodes)), _useState2 = _slicedToArray(_useState, 2), tree = _useState2[0], setTree = _useState2[1];
    (0, _react.useEffect)(function() {
        setTree(getTreeFromList(nodes));
    }, [
        nodes
    ]);
    return tree;
};
var getIcon = function getIcon(props) {
    var _data$children;
    var isLeaf = props.isLeaf, expanded = props.expanded, data = props.data;
    if (isLeaf) return /*#__PURE__*/ _react.default.createElement("span", {
        className: "dumi-default-tree-icon"
    }, /*#__PURE__*/ _react.default.createElement(_filesvg.ReactComponent, {
        fill: "currentColor"
    }));
    return !expanded || !(data !== null && data !== void 0 && (_data$children = data.children) !== null && _data$children !== void 0 && _data$children.length) ? /*#__PURE__*/ _react.default.createElement("span", {
        className: "dumi-default-tree-icon"
    }, /*#__PURE__*/ _react.default.createElement(_foldersvg.ReactComponent, {
        fill: "currentColor"
    })) : /*#__PURE__*/ _react.default.createElement("span", {
        className: "dumi-default-tree-icon"
    }, /*#__PURE__*/ _react.default.createElement(_folderopensvg.ReactComponent, {
        fill: "currentColor"
    }));
};
var renderSwitcherIcon = function renderSwitcherIcon(props) {
    var isLeaf = props.isLeaf, expanded = props.expanded;
    if (isLeaf) return /*#__PURE__*/ _react.default.createElement("span", {
        className: "tree-switcher-leaf-line"
    });
    return expanded ? /*#__PURE__*/ _react.default.createElement("span", {
        className: "tree-switcher-line-icon"
    }, /*#__PURE__*/ _react.default.createElement("span", {
        className: "dumi-default-tree-icon"
    }, /*#__PURE__*/ _react.default.createElement(_minussquaresvg.ReactComponent, {
        fill: "currentColor"
    }))) : /*#__PURE__*/ _react.default.createElement("span", {
        className: "tree-switcher-line-icon"
    }, /*#__PURE__*/ _react.default.createElement("span", {
        className: "dumi-default-tree-icon"
    }, /*#__PURE__*/ _react.default.createElement(_plussquaresvg.ReactComponent, {
        fill: "currentColor"
    })));
};
// ================== Collapse Motion ==================
var getCollapsedHeight = function getCollapsedHeight() {
    return {
        height: 0,
        opacity: 0
    };
};
var getRealHeight = function getRealHeight(node) {
    var scrollHeight = node.scrollHeight;
    return {
        height: scrollHeight,
        opacity: 1
    };
};
var getCurrentHeight = function getCurrentHeight(node) {
    return {
        height: node ? node.offsetHeight : 0
    };
};
var skipOpacityTransition = function skipOpacityTransition(_, event) {
    return (event === null || event === void 0 ? void 0 : event.deadline) === true || event.propertyName === 'height';
};
var initCollapseMotion = {
    motionName: 'ant-motion-collapse',
    onAppearStart: getCollapsedHeight,
    onEnterStart: getCollapsedHeight,
    onAppearActive: getRealHeight,
    onEnterActive: getRealHeight,
    onLeaveStart: getCurrentHeight,
    onLeaveActive: getCollapsedHeight,
    onAppearEnd: skipOpacityTransition,
    onEnterEnd: skipOpacityTransition,
    onLeaveEnd: skipOpacityTransition,
    motionDeadline: 500
};
var _default = function(props) {
    var data = useListToTree(props.children);
    var treeRef = /*#__PURE__*/ (0, _react.createRef)();
    var onClick = function onClick(event, node) {
        var _node$children;
        var isLeaf = node.isLeaf;
        var isEmptyUl = !isLeaf && !((_node$children = node.children) !== null && _node$children !== void 0 && _node$children.length);
        if (isLeaf || isEmptyUl || event.shiftKey || event.metaKey || event.ctrlKey) return;
        treeRef.current.onNodeExpand(event, node);
    };
    return /*#__PURE__*/ _react.default.createElement(_rctree.default, {
        className: "dumi-default-tree",
        icon: getIcon,
        ref: treeRef,
        itemHeight: 20,
        showLine: true,
        selectable: false,
        virtual: false,
        motion: _objectSpread(_objectSpread({}, initCollapseMotion), {}, {
            motionAppear: false
        }),
        onClick: onClick,
        treeData: [
            {
                key: '0',
                title: props.title || '<root>',
                children: data
            }
        ],
        defaultExpandAll: true,
        switcherIcon: renderSwitcherIcon
    });
};

},
"node_modules/dumi/theme-default/slots/ColorSwitch/index.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _dumi = __mako_require__(".dumi/tmp/dumi/exports.ts");
var _react = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/react/index.js"));
"";
function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _iterableToArrayLimit(arr, i) {
    var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
    if (null != _i) {
        var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1;
        try {
            if (_x = (_i = _i.call(arr)).next, 0 === i) {
                if (Object(_i) !== _i) return;
                _n = !1;
            } else for(; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);
        } catch (err) {
            _d = !0, _e = err;
        } finally{
            try {
                if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;
            } finally{
                if (_d) throw _e;
            }
        }
        return _arr;
    }
}
function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
}
var IconDark = function IconDark() {
    return /*#__PURE__*/ _react.default.createElement("svg", {
        viewBox: "0 0 16 16"
    }, /*#__PURE__*/ _react.default.createElement("path", {
        d: "M8.218 1.455c3.527.109 6.327 3.018 6.327 6.545 0 3.6-2.945 6.545-6.545 6.545a6.562 6.562 0 0 1-6.036-4h.218c3.6 0 6.545-2.945 6.545-6.545 0-.91-.182-1.745-.509-2.545m0-1.455c-.473 0-.909.218-1.2.618-.29.4-.327.946-.145 1.382.254.655.4 1.31.4 2 0 2.8-2.291 5.09-5.091 5.09h-.218c-.473 0-.91.22-1.2.62-.291.4-.328.945-.146 1.38C1.891 14.074 4.764 16 8 16c4.4 0 8-3.6 8-8a7.972 7.972 0 0 0-7.745-8h-.037Z"
    }));
};
var IconLight = function IconLight() {
    return /*#__PURE__*/ _react.default.createElement("svg", {
        viewBox: "0 0 16 16"
    }, /*#__PURE__*/ _react.default.createElement("path", {
        d: "M8 13a1 1 0 0 1 1 1v1a1 1 0 1 1-2 0v-1a1 1 0 0 1 1-1ZM8 3a1 1 0 0 1-1-1V1a1 1 0 1 1 2 0v1a1 1 0 0 1-1 1Zm7 4a1 1 0 1 1 0 2h-1a1 1 0 1 1 0-2h1ZM3 8a1 1 0 0 1-1 1H1a1 1 0 1 1 0-2h1a1 1 0 0 1 1 1Zm9.95 3.536.707.707a1 1 0 0 1-1.414 1.414l-.707-.707a1 1 0 0 1 1.414-1.414Zm-9.9-7.072-.707-.707a1 1 0 0 1 1.414-1.414l.707.707A1 1 0 0 1 3.05 4.464Zm9.9 0a1 1 0 0 1-1.414-1.414l.707-.707a1 1 0 0 1 1.414 1.414l-.707.707Zm-9.9 7.072a1 1 0 0 1 1.414 1.414l-.707.707a1 1 0 0 1-1.414-1.414l.707-.707ZM8 4a4 4 0 1 0 0 8 4 4 0 0 0 0-8Zm0 6.5a2.5 2.5 0 1 1 0-5 2.5 2.5 0 0 1 0 5Z"
    }));
};
var IconAuto = function IconAuto() {
    return /*#__PURE__*/ _react.default.createElement("svg", {
        viewBox: "0 0 16 16"
    }, /*#__PURE__*/ _react.default.createElement("path", {
        d: "M14.595 8a6.595 6.595 0 1 1-13.19 0 6.595 6.595 0 0 1 13.19 0ZM8 0a8 8 0 1 0 0 16A8 8 0 0 0 8 0Zm0 2.014v11.972A5.986 5.986 0 0 0 8 2.014Z"
    }));
};
var ICON_MAPPING = {
    light: IconLight,
    dark: IconDark,
    auto: IconAuto
};
var ColorSwitch = function ColorSwitch() {
    var _useSiteData = (0, _dumi.useSiteData)(), defaultColor = _useSiteData.themeConfig.prefersColor.default;
    var intl = (0, _dumi.useIntl)();
    var _usePrefersColor = (0, _dumi.usePrefersColor)(), _usePrefersColor2 = _slicedToArray(_usePrefersColor, 3), _usePrefersColor2$ = _usePrefersColor2[1], prefersColor = _usePrefersColor2$ === void 0 ? defaultColor : _usePrefersColor2$, setPrefersColor = _usePrefersColor2[2];
    var Icon = ICON_MAPPING[prefersColor];
    return /*#__PURE__*/ _react.default.createElement("span", {
        className: "dumi-default-color-switch",
        "data-dumi-tooltip": intl.formatMessage({
            id: "header.color.mode.".concat(prefersColor)
        }),
        "data-dumi-tooltip-bottom": true
    }, Icon && /*#__PURE__*/ _react.default.createElement(Icon, null), /*#__PURE__*/ _react.default.createElement("select", {
        onChange: function onChange(ev) {
            return setPrefersColor(ev.target.value);
        },
        value: prefersColor,
        onClick: function onClick(e) {
            return e.stopPropagation();
        }
    }, [
        'light',
        'dark',
        'auto'
    ].map(function(c) {
        return /*#__PURE__*/ _react.default.createElement("option", {
            value: c,
            key: c
        }, intl.formatMessage({
            id: "header.color.mode.".concat(c)
        }));
    })));
};
var _default = ColorSwitch;

},
"node_modules/dumi/theme-default/slots/Content/index.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _dumi = __mako_require__(".dumi/tmp/dumi/exports.ts");
var _react = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/react/index.js"));
"";
"";
var Content = function Content(props) {
    var sidebar = (0, _dumi.useSidebarData)();
    var _useSiteData = (0, _dumi.useSiteData)(), themeConfig = _useSiteData.themeConfig;
    var _useRouteMeta = (0, _dumi.useRouteMeta)(), frontmatter = _useRouteMeta.frontmatter;
    return /*#__PURE__*/ _react.default.createElement("div", {
        className: "dumi-default-content",
        "data-no-sidebar": !sidebar || frontmatter.sidebar === false || undefined,
        "data-no-footer": themeConfig.footer === false || undefined
    }, props.children);
};
var _default = Content;

},
"node_modules/dumi/theme-default/slots/ContentFooter/index.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _arrowleftsvg = __mako_require__("node_modules/@ant-design/icons-svg/inline-svg/outlined/arrow-left.svg");
var _clockcirclesvg = __mako_require__("node_modules/@ant-design/icons-svg/inline-svg/outlined/clock-circle.svg");
var _editsvg = __mako_require__("node_modules/@ant-design/icons-svg/inline-svg/outlined/edit.svg");
var _dumi = __mako_require__(".dumi/tmp/dumi/exports.ts");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
"";
function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _iterableToArrayLimit(arr, i) {
    var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
    if (null != _i) {
        var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1;
        try {
            if (_x = (_i = _i.call(arr)).next, 0 === i) {
                if (Object(_i) !== _i) return;
                _n = !1;
            } else for(; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);
        } catch (err) {
            _d = !0, _e = err;
        } finally{
            try {
                if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;
            } finally{
                if (_d) throw _e;
            }
        }
        return _arr;
    }
}
function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
}
var ContentFooter = function ContentFooter() {
    var _useLocation = (0, _dumi.useLocation)(), pathname = _useLocation.pathname;
    var sidebar = (0, _dumi.useSidebarData)();
    var _useSiteData = (0, _dumi.useSiteData)(), themeConfig = _useSiteData.themeConfig;
    var _useRouteMeta = (0, _dumi.useRouteMeta)(), frontmatter = _useRouteMeta.frontmatter;
    var intl = (0, _dumi.useIntl)();
    var _useState = (0, _react.useState)(undefined), _useState2 = _slicedToArray(_useState, 2), prev = _useState2[0], setPrev = _useState2[1];
    var _useState3 = (0, _react.useState)(undefined), _useState4 = _slicedToArray(_useState3, 2), next = _useState4[0], setNext = _useState4[1];
    var _useState5 = (0, _react.useState)(''), _useState6 = _slicedToArray(_useState5, 2), isoLastUpdated = _useState6[0], setIsoLastUpdated = _useState6[1];
    var _useState7 = (0, _react.useState)(''), _useState8 = _slicedToArray(_useState7, 2), lastUpdated = _useState8[0], setLastUpdated = _useState8[1];
    var showEditLink = themeConfig.editLink && frontmatter.filename;
    var showLastUpdated = themeConfig.lastUpdated && frontmatter.lastUpdated;
    // calculate the previous and next page
    (0, _react.useLayoutEffect)(function() {
        if (sidebar) {
            var items = sidebar.reduce(function(ret, group) {
                return ret.concat(group.children);
            }, []);
            var current = items.findIndex(function(item) {
                return item.link === pathname;
            });
            setPrev(items[current - 1]);
            setNext(items[current + 1]);
        }
    }, [
        pathname,
        sidebar
    ]);
    // to avoid timestamp mismatched between server and client
    (0, _react.useLayoutEffect)(function() {
        if (showLastUpdated) {
            setIsoLastUpdated(new Date(frontmatter.lastUpdated).toISOString());
            setLastUpdated(new Intl.DateTimeFormat(undefined, {
                dateStyle: 'short',
                timeStyle: 'short'
            }).format(frontmatter.lastUpdated));
        }
    }, [
        showLastUpdated
    ]);
    return /*#__PURE__*/ _react.default.createElement("footer", {
        className: "dumi-default-content-footer"
    }, /*#__PURE__*/ _react.default.createElement("dl", null, showLastUpdated && /*#__PURE__*/ _react.default.createElement("dd", null, /*#__PURE__*/ _react.default.createElement(_clockcirclesvg.ReactComponent, null), /*#__PURE__*/ _react.default.createElement("span", {
        className: "dumi-default-mobile-hidden"
    }, /*#__PURE__*/ _react.default.createElement(_dumi.FormattedMessage, {
        id: "content.footer.last.updated"
    })), /*#__PURE__*/ _react.default.createElement("time", {
        dateTime: isoLastUpdated
    }, lastUpdated)), showEditLink && /*#__PURE__*/ _react.default.createElement("dd", null, /*#__PURE__*/ _react.default.createElement("a", {
        target: "_blank",
        href: "".concat(intl.formatMessage({
            id: '$internal.edit.link'
        }, {
            filename: frontmatter.filename
        })),
        rel: "noreferrer"
    }, /*#__PURE__*/ _react.default.createElement(_editsvg.ReactComponent, null), /*#__PURE__*/ _react.default.createElement(_dumi.FormattedMessage, {
        id: "content.footer.actions.edit"
    })))), /*#__PURE__*/ _react.default.createElement("nav", null, prev && /*#__PURE__*/ _react.default.createElement(_dumi.Link, {
        to: prev.link,
        "data-prev": true
    }, /*#__PURE__*/ _react.default.createElement("small", null, /*#__PURE__*/ _react.default.createElement(_arrowleftsvg.ReactComponent, null), /*#__PURE__*/ _react.default.createElement(_dumi.FormattedMessage, {
        id: "content.footer.actions.previous"
    })), prev.title), next && /*#__PURE__*/ _react.default.createElement(_dumi.Link, {
        to: next.link,
        "data-next": true
    }, /*#__PURE__*/ _react.default.createElement("small", null, /*#__PURE__*/ _react.default.createElement(_dumi.FormattedMessage, {
        id: "content.footer.actions.next"
    }), /*#__PURE__*/ _react.default.createElement(_arrowleftsvg.ReactComponent, null)), next.title)));
};
var _default = ContentFooter;

},
"node_modules/dumi/theme-default/slots/Features/index.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _dumi = __mako_require__(".dumi/tmp/dumi/exports.ts");
var _react = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/react/index.js"));
"";
var Features = function Features() {
    var _frontmatter$features;
    var _useRouteMeta = (0, _dumi.useRouteMeta)(), frontmatter = _useRouteMeta.frontmatter;
    return Boolean((_frontmatter$features = frontmatter.features) === null || _frontmatter$features === void 0 ? void 0 : _frontmatter$features.length) ? /*#__PURE__*/ _react.default.createElement("div", {
        className: "dumi-default-features",
        "data-cols": [
            3,
            2
        ].find(function(n) {
            return frontmatter.features.length % n === 0;
        }) || 3
    }, frontmatter.features.map(function(_ref) {
        var title = _ref.title, description = _ref.description, emoji = _ref.emoji, link = _ref.link;
        var titleWithLink;
        if (link) titleWithLink = /^(\w+:)\/\/|^(mailto|tel):/.test(link) ? /*#__PURE__*/ _react.default.createElement("a", {
            href: link,
            target: "_blank",
            rel: "noreferrer"
        }, title) : /*#__PURE__*/ _react.default.createElement(_dumi.Link, {
            to: link
        }, title);
        return /*#__PURE__*/ _react.default.createElement("div", {
            key: title,
            className: "dumi-default-features-item"
        }, emoji && /*#__PURE__*/ _react.default.createElement("i", null, emoji), title && /*#__PURE__*/ _react.default.createElement("h3", null, titleWithLink || title), description && /*#__PURE__*/ _react.default.createElement("p", {
            dangerouslySetInnerHTML: {
                __html: description
            }
        }));
    })) : null;
};
var _default = Features;

},
"node_modules/dumi/theme-default/slots/Footer/index.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _dumi = __mako_require__(".dumi/tmp/dumi/exports.ts");
var _react = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/react/index.js"));
"";
var Footer = function Footer() {
    var _useSiteData = (0, _dumi.useSiteData)(), themeConfig = _useSiteData.themeConfig;
    if (!themeConfig.footer) return null;
    return /*#__PURE__*/ _react.default.createElement("div", {
        className: "dumi-default-footer",
        dangerouslySetInnerHTML: {
            __html: themeConfig.footer
        }
    });
};
var _default = Footer;

},
"node_modules/dumi/theme-default/slots/Header/index.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _closesvg = __mako_require__("node_modules/@ant-design/icons-svg/inline-svg/outlined/close.svg");
var _menusvg = __mako_require__("node_modules/@ant-design/icons-svg/inline-svg/outlined/menu.svg");
var _dumi = __mako_require__(".dumi/tmp/dumi/exports.ts");
var _ColorSwitch = /*#__PURE__*/ _interop_require_default._(__mako_require__(".dumi/tmp/dumi/theme/slots/ColorSwitch.ts"));
var _HeaderExtra = /*#__PURE__*/ _interop_require_default._(__mako_require__(".dumi/tmp/dumi/theme/slots/HeaderExtra.ts"));
var _LangSwitch = /*#__PURE__*/ _interop_require_default._(__mako_require__(".dumi/tmp/dumi/theme/slots/LangSwitch.ts"));
var _Logo = /*#__PURE__*/ _interop_require_default._(__mako_require__(".dumi/tmp/dumi/theme/slots/Logo.ts"));
var _Navbar = /*#__PURE__*/ _interop_require_default._(__mako_require__(".dumi/tmp/dumi/theme/slots/Navbar.ts"));
var _RtlSwitch = /*#__PURE__*/ _interop_require_default._(__mako_require__(".dumi/tmp/dumi/theme/slots/RtlSwitch.ts"));
var _SearchBar = /*#__PURE__*/ _interop_require_default._(__mako_require__(".dumi/tmp/dumi/theme/slots/SearchBar.ts"));
var _SocialIcon = /*#__PURE__*/ _interop_require_default._(__mako_require__(".dumi/tmp/dumi/theme/slots/SocialIcon.ts"));
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
"";
function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _iterableToArrayLimit(arr, i) {
    var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
    if (null != _i) {
        var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1;
        try {
            if (_x = (_i = _i.call(arr)).next, 0 === i) {
                if (Object(_i) !== _i) return;
                _n = !1;
            } else for(; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);
        } catch (err) {
            _d = !0, _e = err;
        } finally{
            try {
                if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;
            } finally{
                if (_d) throw _e;
            }
        }
        return _arr;
    }
}
function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
}
var Header = function Header() {
    var _useRouteMeta = (0, _dumi.useRouteMeta)(), frontmatter = _useRouteMeta.frontmatter;
    var _useState = (0, _react.useState)(false), _useState2 = _slicedToArray(_useState, 2), showMenu = _useState2[0], setShowMenu = _useState2[1];
    var _useSiteData = (0, _dumi.useSiteData)(), themeConfig = _useSiteData.themeConfig;
    var socialIcons = (0, _react.useMemo)(function() {
        return themeConfig.socialLinks ? Object.keys(themeConfig.socialLinks).slice(0, 5).map(function(key) {
            return {
                icon: key,
                link: themeConfig.socialLinks[key]
            };
        }) : [];
    }, [
        themeConfig.socialLinks
    ]);
    return /*#__PURE__*/ _react.default.createElement("div", {
        className: "dumi-default-header",
        "data-static": Boolean(frontmatter.hero) || undefined,
        "data-mobile-active": showMenu || undefined,
        onClick: function onClick() {
            return setShowMenu(false);
        }
    }, /*#__PURE__*/ _react.default.createElement("div", {
        className: "dumi-default-header-content"
    }, /*#__PURE__*/ _react.default.createElement("section", {
        className: "dumi-default-header-left"
    }, /*#__PURE__*/ _react.default.createElement(_Logo.default, null)), /*#__PURE__*/ _react.default.createElement("section", {
        className: "dumi-default-header-right"
    }, /*#__PURE__*/ _react.default.createElement(_Navbar.default, null), /*#__PURE__*/ _react.default.createElement("div", {
        className: "dumi-default-header-right-aside"
    }, /*#__PURE__*/ _react.default.createElement(_SearchBar.default, null), /*#__PURE__*/ _react.default.createElement(_LangSwitch.default, null), /*#__PURE__*/ _react.default.createElement(_RtlSwitch.default, null), themeConfig.prefersColor.switch && /*#__PURE__*/ _react.default.createElement(_ColorSwitch.default, null), socialIcons.map(function(item) {
        return /*#__PURE__*/ _react.default.createElement(_SocialIcon.default, {
            icon: item.icon,
            link: item.link,
            key: item.link
        });
    }), /*#__PURE__*/ _react.default.createElement(_HeaderExtra.default, null))), /*#__PURE__*/ _react.default.createElement("button", {
        type: "button",
        className: "dumi-default-header-menu-btn",
        onClick: function onClick(ev) {
            ev.stopPropagation();
            setShowMenu(function(v) {
                return !v;
            });
        }
    }, showMenu ? /*#__PURE__*/ _react.default.createElement(_closesvg.ReactComponent, null) : /*#__PURE__*/ _react.default.createElement(_menusvg.ReactComponent, null))));
};
var _default = Header;

},
"node_modules/dumi/theme-default/slots/HeaderExtra/index.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _react = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/react/index.js"));
var NavbarExtra = function NavbarExtra() {
    return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null);
};
var _default = NavbarExtra;

},
"node_modules/dumi/theme-default/slots/Hero/index.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _dumi = __mako_require__(".dumi/tmp/dumi/exports.ts");
var _HeroTitle = /*#__PURE__*/ _interop_require_default._(__mako_require__(".dumi/tmp/dumi/theme/slots/HeroTitle.ts"));
var _react = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/react/index.js"));
"";
var Hero = function Hero() {
    var _actions;
    var _useRouteMeta = (0, _dumi.useRouteMeta)(), frontmatter = _useRouteMeta.frontmatter;
    if (!('hero' in frontmatter)) return null;
    return /*#__PURE__*/ _react.default.createElement("div", {
        className: "dumi-default-hero"
    }, frontmatter.hero.title && /*#__PURE__*/ _react.default.createElement(_HeroTitle.default, null, frontmatter.hero.title), frontmatter.hero.description && /*#__PURE__*/ _react.default.createElement("p", {
        dangerouslySetInnerHTML: {
            __html: frontmatter.hero.description
        }
    }), Boolean((_actions = frontmatter.hero.actions) === null || _actions === void 0 ? void 0 : _actions.length) && /*#__PURE__*/ _react.default.createElement("div", {
        className: "dumi-default-hero-actions"
    }, frontmatter.hero.actions.map(function(_ref) {
        var text = _ref.text, link = _ref.link;
        return /^(\w+:)\/\/|^(mailto|tel):/.test(link) ? /*#__PURE__*/ _react.default.createElement("a", {
            href: link,
            target: "_blank",
            rel: "noreferrer",
            key: text
        }, text) : /*#__PURE__*/ _react.default.createElement(_dumi.Link, {
            key: text,
            to: link
        }, text);
    })));
};
var _default = Hero;

},
"node_modules/dumi/theme-default/slots/HeroTitle/index.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _react = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/react/index.js"));
"";
var HeroTitle = function HeroTitle(props) {
    return /*#__PURE__*/ _react.default.createElement("h1", {
        className: "dumi-default-hero-title"
    }, /*#__PURE__*/ _react.default.createElement("span", null, props.children));
};
var _default = HeroTitle;

},
"node_modules/dumi/theme-default/slots/LangSwitch/index.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _downsvg = __mako_require__("node_modules/@ant-design/icons-svg/inline-svg/outlined/down.svg");
var _dumi = __mako_require__(".dumi/tmp/dumi/exports.ts");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
"";
function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _iterableToArrayLimit(arr, i) {
    var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
    if (null != _i) {
        var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1;
        try {
            if (_x = (_i = _i.call(arr)).next, 0 === i) {
                if (Object(_i) !== _i) return;
                _n = !1;
            } else for(; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);
        } catch (err) {
            _d = !0, _e = err;
        } finally{
            try {
                if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;
            } finally{
                if (_d) throw _e;
            }
        }
        return _arr;
    }
}
function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
}
function getTargetLocalePath(_ref) {
    var pathname = _ref.pathname, current = _ref.current, target = _ref.target;
    var clearPath = 'base' in current ? // handle '/en-US/a' => '/a' or '/en-US' => '' => '/'
    pathname.replace(current.base.replace(/\/$/, ''), '') || '/' : pathname.replace(new RegExp("".concat(current.suffix, "$")), '');
    return 'base' in target ? "".concat(// for `/` base, strip duplicated leading slash
    target.base.replace(/\/$/, '')).concat(clearPath) // for `/` clearPath, strip duplicated ending slash
    .replace(/([^/])\/$/, '$1') : "".concat(clearPath).concat(target.suffix);
}
var SingleSwitch = function SingleSwitch(_ref2) {
    var locale = _ref2.locale, current = _ref2.current;
    var _useLocation = (0, _dumi.useLocation)(), pathname = _useLocation.pathname;
    var _useState = (0, _react.useState)(function() {
        return getTargetLocalePath({
            pathname: pathname,
            current: current,
            target: locale
        });
    }), _useState2 = _slicedToArray(_useState, 2), path = _useState2[0], setPath = _useState2[1];
    (0, _react.useEffect)(function() {
        setPath(getTargetLocalePath({
            pathname: pathname,
            current: current,
            target: locale
        }));
    }, [
        pathname,
        current.id,
        locale.id
    ]);
    return /*#__PURE__*/ _react.default.createElement(_dumi.Link, {
        className: "dumi-default-lang-switch",
        to: path
    }, locale.name);
};
var LangSwitch = function LangSwitch() {
    var _useSiteData = (0, _dumi.useSiteData)(), locales = _useSiteData.locales;
    var _useIntl = (0, _dumi.useIntl)(), locale = _useIntl.locale;
    var current = (0, _dumi.useLocale)();
    // do not render in single language
    if (locales.length <= 1) return null;
    return locales.length > 2 ? /*#__PURE__*/ _react.default.createElement("div", {
        className: "dumi-default-lang-select"
    }, /*#__PURE__*/ _react.default.createElement("select", {
        defaultValue: locale,
        onChange: function onChange(ev) {
            _dumi.history.push(getTargetLocalePath({
                pathname: _dumi.history.location.pathname,
                current: current,
                target: locales.find(function(_ref3) {
                    var id = _ref3.id;
                    return id === ev.target.value;
                })
            }));
        }
    }, locales.map(function(item) {
        return /*#__PURE__*/ _react.default.createElement("option", {
            key: item.id,
            value: item.id
        }, item.name);
    })), /*#__PURE__*/ _react.default.createElement(_downsvg.ReactComponent, null)) : /*#__PURE__*/ // single language switch
    _react.default.createElement(SingleSwitch, {
        locale: locales.find(function(_ref4) {
            var id = _ref4.id;
            return id !== locale;
        }),
        current: current
    });
};
var _default = LangSwitch;

},
"node_modules/dumi/theme-default/slots/Logo/index.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _dumi = __mako_require__(".dumi/tmp/dumi/exports.ts");
var _react = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/react/index.js"));
"";
var Logo = function Logo() {
    var _useSiteData = (0, _dumi.useSiteData)(), themeConfig = _useSiteData.themeConfig;
    var locale = (0, _dumi.useLocale)();
    return /*#__PURE__*/ _react.default.createElement(_dumi.Link, {
        className: "dumi-default-logo",
        to: 'base' in locale ? locale.base : '/'
    }, themeConfig.logo !== false && /*#__PURE__*/ _react.default.createElement("img", {
        src: themeConfig.logo || 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIQAAACCCAMAAACww5CIAAACf1BMVEUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8YkP8AAAACCxMamv/6+voaGhoXi/YYjv8aoP8cq/8dr/8bo/8cqP8bpv8Ykv8drv8BAwUcrP8Zlf8Xjf/s7OzLy8scp/8anP8ZmP/d3d0BBArg4ODT09O7u7sEGCsKCgoanf8YlP/8/Pz09PTIyMgMTIV1dXUGKEVEREQ0NDQODg4GBgYdsv8dsf8Zl//m5uYVgOXj4+MWgtfW1tYTc87BwcERbLWzs7Ovr6+np6cQX6OgoKCTk5MMSXlwcHBra2tiYmIVFRUetf/39/fp6ekWhOkXi+QVfNvY2NjPz88TdcUSb7u6urq3t7cPYK0NUJGQkJCLi4ttbW0JO2cINFtVVVVRUVEHMFEHLEs6OjoEHDEiIiIcHBwXj/vx8fEWh+4Sb8gRbL+rq6upqakOVZiWlpaJiYmGhoYMSIF9fX15eXkKPnQLRHJMTExHR0c9PT0FHzkqKiomJiYEFyUBBw8bovfu7u4Wht4UedsUeMrFxcW9vb0RZrOkpKSampoPXZqAgIALQmtlZWUJOGJZWVkIMFcFIUExMTEwMDAtLS0DEh8Zl/v4+PgXj/QWhvEWhvAYku8YjuwUfNcUfNAVfc0RaLkSaKsRZ6kPWqENUYlbW1sCEBhkSPCkAAAAOHRSTlMA87y4BeKrltbFnUDo0MCup6D67t7ayZKGemtmWS8rEwLNso1wVEpFGaR+UDUlHwmBYls5i1oN/DMym4YAAAfTSURBVHjaxNndS1NxHMfxX5s6t1Kz1KzsuazMnqjgyxv03ovtQrYxUBEfLkREVBQf0AsFBRUUQvEiSVFQ0YsuiiIiqKC/oH+o31lzjtPZg55zttfVNnbx5ffw+X53pmx5UFl2+XLZ4zpVOPWlJFTntYyiBwF/VbX39Sv9upYU9/QHjbXe6qqayrrnylXXi0kov3GVuFiMuNqbHhIu3FcuuohZZ+jDh7mdXkwqlGtKMGmOSFzrGiYe5ZL4+vdsd/SHFyYxtIQlIdiD4ftCa39osTlxRtzwHO1tUOLm0XYk6T3asMRtdKHdUs6qv+L1l/vKgak2SYjqN+1yYg2G5NgR4Pd5/F7fk9sO3YhSkoYkaW40KCk2Rj9KUoikqmtOn8YpydE6J7xFyq5yUhxIjvZJcUfZ5EOb6oxGQmPdtEQlR4Mxupc6IoOdzWiVypabaF1BiesIS876OiSufRXtvO0DcSi2dAN+ZcclYFZsCaOps3nYUOKprDTiSWzqAioCnpIX9ep03pxkw7jYtMWx0pdn7Jb2i1jixN3cM6OGFCti0zgpyopOsw6xiZHoyHIPLIhNHdD7bWR+c7znFD3+PNp+vxhmRkNi28BoWAzBPbQHKhdlQLe4ogsoVTl4ijYjrmiKATdUdvfjh9Ely8DVHFvWe3HJMBBQ2QWAd+KSeeBxjtuxKC7ZzG07Ht0DusQlfwDfs2wZ4b2EYVBcESHO81BlcIWESXHFV7Qss5aXY1FxRSj7L7QAhv3tsaVBMVn8Ou1MFUtjW3sYKjL0jO6QWJiA7iZxysBbtDplpRT4KZbQWkUbHRMnGFUUKwuNaH1iaRJ+Tf8bDbqcWJH2HuCV+l9DpkuxtdsuGlpYHNAJ1FqNMjnE9QocOXJCPwJ309zPT9la8e5yUJwwC/jTBNWQ5EkIqEyzHROSJzvWSeFDW5M8OUArsdgMq2EmanOyGB4WSyMYAhZp2TwkJouw2mZvmusUSwtraA//m7DXZ8SsBxiQM5tGSxNuv3+ZU/NmIpfN9qDXxp1sO4LDNrE202J6cHE1TVq2f1uNiA39K9/7JJ0JwGe6nvOSZ4OA1/R0bFbyrBWoMUX2nOTZAOA3pcSXjFW7UOJnU17VAYeZv98pTvsB1KsTRVXAtqQVA/rFWSNo11SKiuRYZeknEBRn7WJ4rZKuX8pcROvBj6g4rLUZQ8NJYBo2Jb/ax2KkhKYf6I1I3oWngKqUhfgkBTCL1pics1elICaS/5Y9jk+XBdEBeJKhHZGCCLZAWTIkBqQgNlr+NbGi2wHgS1tTAbQNAxW3i1R58WWgd725ANZ7gXPFNaqagrvwt1t7aW0qiOIAPlErPqJCq6JWrW8r1ar1xf0n4NxnnpCELEKyCNmkJZSQRSCbQltooS4sVApiC10U2kWhFRUEEdGF4vuNH8g7c9NQ2pjepPcB/r5ADjlnzp2ZM+QMXHeYb+1WfO5hi5QfveYe33XJ4+d8a3MNQHbI75KhMt9z9wF4FRNcIi3wO94bAHJiQHCHNgmgh3QD8D1MCK6I+KeNCUgbgFFRcEX8Qwhov014o/juUlEoxeqrgpsA7oWp4AZprnpv1ANgShFcoU4a+36jMgOuVGYmnuJ1Wb0hKWqCC8QCgI4dqyfRbNCFoqDBX7Xz6C0AS660K3UKQCdhuqAbdqFT+B8mAXQTbhtbpM7ng4Yn1oytOwFMu5AP9QGAa4Qz8lFwvFWIH6G7Qjijc8/LDueDyvd4z151EYBvwOF+lRFTAK6TGi+ACWdLk0ozANqvkpojAFJKRnCSlFt3m8pLc9bJTylVn64ty9rJfEl1cpVKbH3uJ2v1QleUqOCI2h9xeeP0aVqLCA4JSLk6s7hu6CbkqOAIGpyB7iRZ5xLvFWlHEkITyjK/41/v9h0AC3lngpCz0PXWf0yDUcmBhFDt0T/flx8CkNL8VLAZjUhvAHSQek5AtyALdqP5e9BdbPCkZsbuFRKVvlRHs/W1AfC902yNgoriWwCeqw1fSL+J2VkWNBF8vckr6mPQ3ZcjtkVBA/3z4Ju6Bs5ANzck2BQFpUMTxlVZQ4ege95vUxRUHoPOe5s01OWBbryf2hEFDX4Fc4Vs4gaYZ3ZEQeXBJPgMcFPnwYzJVmeE6jGsGCNAE/rAlPIBamkMQv9YCLpzxJRjYMr5BLXyg5EvgTlKTOoEkw2LUct6dTz4ojqCNO04mMm4ZE150mhMuQ+jHppwAUxqUM5QK9qkPLIE5jhpygkvmHJYiW45FaL8IwmdZy9pUtc2MK9HtvgloZngJyMVp3tJ846ASb7Q1NYrg1JN+ukDs4e05LwHTO5bUKG0tRBEeXAKzJ3rpEXdB8C9fBIWKW0hhOBIBdy2K6R11zvALY6EFYE21yHF4OdKEkz7ObIlXXvAhV4OquoApaYbpCo9qayA29lLturibhimSgOSFjG1ILRwYnwShn09xArnT8PwdnHML6n+hl+2gD8Wjj+rLMOwq49Y5dZpVKUWS++VcCwdCdT5/Uhck5SH45VpVO3qJFbq2Y5Vvly2VBgQY5KqKWI6HY+n06KiqVJMSQyP/37wB6v29xGrnThyEDWh5dyr+fJscbQw/OjRcGG0OFvO3n+QSqKm7exlYgsvNgolkyFs1HGV2OQgTGsjNjnVBtO8Owj3nwbhgWnttgWxy2PaoWaC+AuAXqWYKHupMgAAAABJRU5ErkJggg==',
        alt: themeConfig.name
    }), themeConfig.name);
};
var _default = Logo;

},
"node_modules/dumi/theme-default/slots/Navbar/index.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _downsvg = __mako_require__("node_modules/@ant-design/icons-svg/inline-svg/outlined/down.svg");
var _dumi = __mako_require__(".dumi/tmp/dumi/exports.ts");
var _NavbarExtra = /*#__PURE__*/ _interop_require_default._(__mako_require__(".dumi/tmp/dumi/theme/slots/NavbarExtra.ts"));
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
"";
function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _iterableToArrayLimit(arr, i) {
    var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
    if (null != _i) {
        var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1;
        try {
            if (_x = (_i = _i.call(arr)).next, 0 === i) {
                if (Object(_i) !== _i) return;
                _n = !1;
            } else for(; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);
        } catch (err) {
            _d = !0, _e = err;
        } finally{
            try {
                if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;
            } finally{
                if (_d) throw _e;
            }
        }
        return _arr;
    }
}
function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
}
var NavbarItem = function NavbarItem(_ref) {
    var data = _ref.data;
    var _useLocation = (0, _dumi.useLocation)(), pathname = _useLocation.pathname;
    var _useState = (0, _react.useState)(function() {
        var _data$children;
        return (_data$children = data.children) === null || _data$children === void 0 ? void 0 : _data$children.some(function(item) {
            var activePath = item.activePath || item.link;
            return activePath && pathname.startsWith(activePath);
        });
    }), _useState2 = _slicedToArray(_useState, 2), isCollapsed = _useState2[0], setIsCollapsed = _useState2[1];
    var CollapsedBtn = data.children && /*#__PURE__*/ _react.default.createElement("button", {
        className: "dumi-default-navbar-collapse-btn",
        type: "button",
        onClick: function onClick(e) {
            e.stopPropagation();
            setIsCollapsed(function(v) {
                return !v;
            });
        },
        "data-collapsed": isCollapsed || undefined
    }, /*#__PURE__*/ _react.default.createElement(_downsvg.ReactComponent, null));
    var NestedNav = data.children && /*#__PURE__*/ _react.default.createElement("ul", {
        className: "dumi-default-navbar-dropdown",
        "data-collapsed": isCollapsed || undefined
    }, /*#__PURE__*/ _react.default.createElement(NavbarContent, {
        data: data.children
    }));
    // user custom nav has no activePath, so fallback to link
    var activePath = data.activePath || data.link;
    var extraProps = activePath && pathname.startsWith(activePath) ? {
        className: 'active'
    } : {};
    return data.link ? /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/ _react.default.createElement(_dumi.Link, _extends({
        to: data.link
    }, extraProps), data.title), CollapsedBtn, NestedNav) : /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/ _react.default.createElement("span", _extends({
        onClick: function onClick(e) {
            e.stopPropagation();
            setIsCollapsed(function(v) {
                return !v;
            });
        }
    }, extraProps), data.title), CollapsedBtn, NestedNav);
};
var NavbarContent = function NavbarContent(_ref2) {
    var data = _ref2.data;
    return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, data.map(function(item) {
        return /*#__PURE__*/ _react.default.createElement("li", {
            key: item.activePath || item.link || item.title
        }, item.link && /^(\w+:)\/\/|^(mailto|tel):/.test(item.link) ? /*#__PURE__*/ _react.default.createElement("a", {
            href: item.link,
            target: "_blank",
            rel: "noreferrer"
        }, item.title) : /*#__PURE__*/ _react.default.createElement(NavbarItem, {
            data: item
        }));
    }));
};
var Navbar = function Navbar() {
    var nav = (0, _dumi.useNavData)();
    return /*#__PURE__*/ _react.default.createElement("ul", {
        className: "dumi-default-navbar"
    }, /*#__PURE__*/ _react.default.createElement(NavbarContent, {
        data: nav
    }), /*#__PURE__*/ _react.default.createElement(_NavbarExtra.default, null));
};
var _default = Navbar;

},
"node_modules/dumi/theme-default/slots/NavbarExtra/index.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _react = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/react/index.js"));
var NavbarExtra = function NavbarExtra() {
    return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null);
};
var _default = NavbarExtra;

},
"node_modules/dumi/theme-default/slots/NotFound/index.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _dumi = __mako_require__(".dumi/tmp/dumi/exports.ts");
var _react = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/react/index.js"));
"";
var Page404 = function Page404() {
    var intl = (0, _dumi.useIntl)();
    var locale = (0, _dumi.useLocale)();
    return /*#__PURE__*/ _react.default.createElement("div", {
        className: "dumi-default-not-found"
    }, /*#__PURE__*/ _react.default.createElement("h1", null, intl.formatMessage({
        id: '404.title'
    })), /*#__PURE__*/ _react.default.createElement(_dumi.Link, {
        to: 'base' in locale ? locale.base : '/',
        replace: true
    }, intl.formatMessage({
        id: '404.back'
    }), " \u2192"));
};
var _default = Page404;

},
"node_modules/dumi/theme-default/slots/RtlSwitch/index.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _dumi = __mako_require__(".dumi/tmp/dumi/exports.ts");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
"";
function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _iterableToArrayLimit(arr, i) {
    var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
    if (null != _i) {
        var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1;
        try {
            if (_x = (_i = _i.call(arr)).next, 0 === i) {
                if (Object(_i) !== _i) return;
                _n = !1;
            } else for(; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);
        } catch (err) {
            _d = !0, _e = err;
        } finally{
            try {
                if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;
            } finally{
                if (_d) throw _e;
            }
        }
        return _arr;
    }
}
function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
}
var IconRtl = function IconRtl() {
    return /*#__PURE__*/ _react.default.createElement("svg", {
        viewBox: "0 0 14 16"
    }, /*#__PURE__*/ _react.default.createElement("path", {
        d: "M5.003 6.39v3.594c0 .4.275.674.674.674.4 0 .674-.274.674-.674V1.323h1.997v8.661c0 .4.274.674.674.674s.674-.274.674-.674V1.323h3.295c.399 0 .674-.275.674-.674 0-.4-.275-.649-.674-.649H4.928C3.131 0 1.733 1.398 1.733 3.195S3.206 6.39 5.003 6.39Zm0-5.067v3.72c-1.073 0-1.922-.8-1.922-1.873s.799-1.847 1.922-1.847Zm7.988 11.332H2.73l.8-.674c.274-.2.324-.674.124-.923-.2-.275-.674-.325-.923-.125L.735 12.53c-.275.275-.4.525-.4.874 0 .325.125.674.4.874l1.997 1.597a.829.829 0 0 0 .4.125c.199 0 .398-.075.523-.275.2-.274.2-.723-.125-.923l-.998-.799h10.459c.399 0 .674-.274.674-.674 0-.424-.275-.674-.674-.674Z"
    }));
};
var IconLtr = function IconLtr() {
    return /*#__PURE__*/ _react.default.createElement("svg", {
        viewBox: "0 0 14 16"
    }, /*#__PURE__*/ _react.default.createElement("path", {
        d: "M5.003 6.39v3.594c0 .4.275.674.674.674.4 0 .674-.274.674-.674V1.323h1.997v8.661c0 .4.274.674.674.674s.674-.274.674-.674V1.323h3.295c.399 0 .674-.275.674-.674 0-.4-.275-.649-.674-.649H4.928C3.131 0 1.733 1.398 1.733 3.195S3.206 6.39 5.003 6.39Zm0-5.067v3.72c-1.073 0-1.922-.8-1.922-1.873s.799-1.847 1.922-1.847ZM1.01 12.655h10.26l-.8-.674c-.274-.2-.324-.674-.124-.923.2-.275.674-.325.923-.125l1.997 1.597c.275.275.4.525.4.874 0 .325-.125.674-.4.874l-1.997 1.597a.829.829 0 0 1-.399.125.59.59 0 0 1-.524-.275c-.2-.274-.2-.723.125-.923l.998-.799H1.009c-.399 0-.674-.274-.674-.674 0-.424.275-.674.674-.674Z"
    }));
};
var LS_RTL_KEY = 'dumi:rtl';
var RtlSwitch = function RtlSwitch() {
    var _useState = (0, _react.useState)(false), _useState2 = _slicedToArray(_useState, 2), rtl = _useState2[0], setRtl = _useState2[1];
    var _useSiteData = (0, _dumi.useSiteData)(), themeConfig = _useSiteData.themeConfig;
    (0, _react.useEffect)(function() {
        if (localStorage.getItem(LS_RTL_KEY)) {
            setRtl(true);
            document.documentElement.setAttribute('data-direction', 'rtl');
        }
    }, []);
    if (!themeConfig.rtl) return null;
    return /*#__PURE__*/ _react.default.createElement("button", {
        type: "button",
        className: "dumi-default-rtl-switch",
        onClick: function onClick() {
            if (rtl) {
                document.documentElement.removeAttribute('data-direction');
                localStorage.removeItem(LS_RTL_KEY);
            } else {
                document.documentElement.setAttribute('data-direction', 'rtl');
                localStorage.setItem(LS_RTL_KEY, '1');
            }
            setRtl(!rtl);
        },
        "data-dumi-tooltip": rtl ? 'RTL' : 'LTR',
        "data-dumi-tooltip-bottom": true
    }, rtl ? /*#__PURE__*/ _react.default.createElement(IconRtl, null) : /*#__PURE__*/ _react.default.createElement(IconLtr, null));
};
var _default = RtlSwitch;

},
"node_modules/dumi/theme-default/slots/SearchBar/Input.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "Input", {
    enumerable: true,
    get: function() {
        return Input;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _dumi = __mako_require__(".dumi/tmp/dumi/exports.ts");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
var Input = /*#__PURE__*/ (0, _react.forwardRef)(function(props, ref) {
    var intl = (0, _dumi.useIntl)();
    var imeWaiting = (0, _react.useRef)(false);
    var nativeInputRef = (0, _react.useRef)(null);
    (0, _react.useImperativeHandle)(ref, function() {
        return nativeInputRef.current;
    });
    return /*#__PURE__*/ _react.default.createElement("input", {
        className: "dumi-default-search-bar-input",
        onCompositionStart: function onCompositionStart() {
            return imeWaiting.current = true;
        },
        onCompositionEnd: function onCompositionEnd(ev) {
            imeWaiting.current = false;
            // special case: press Enter open IME panel will not trigger onChange
            props.onChange(ev.currentTarget.value);
        },
        onFocus: props.onFocus,
        onBlur: props.onBlur,
        onMouseEnter: props.onMouseEnter,
        onKeyDown: function onKeyDown(ev) {
            if ([
                'ArrowDown',
                'ArrowUp'
            ].includes(ev.key)) ev.preventDefault();
            // esc to blur input
            if (ev.key === 'Escape' && !imeWaiting.current) ev.currentTarget.blur();
        },
        onChange: function onChange(ev) {
            // wait for onCompositionEnd event be triggered
            var value = ev.target.value;
            setTimeout(function() {
                if (!imeWaiting.current) props.onChange(value);
            }, 1);
        },
        placeholder: intl.formatMessage({
            id: 'header.search.placeholder'
        }),
        ref: nativeInputRef
    });
});

},
"node_modules/dumi/theme-default/slots/SearchBar/Mask.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "Mask", {
    enumerable: true,
    get: function() {
        return Mask;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
var Mask = function Mask(props) {
    (0, _react.useEffect)(function() {
        if (props.visible) document.body.style.overflow = 'hidden';
        else if (document.body.style.overflow) {
            var _props$onClose;
            document.body.style.overflow = '';
            (_props$onClose = props.onClose) === null || _props$onClose === void 0 || _props$onClose.call(props);
        }
    }, [
        props.visible
    ]);
    return props.visible ? /*#__PURE__*/ _react.default.createElement("div", {
        className: "dumi-default-search-modal"
    }, /*#__PURE__*/ _react.default.createElement("div", {
        className: "dumi-default-search-modal-mask",
        onClick: props.onMaskClick
    }), /*#__PURE__*/ _react.default.createElement("div", {
        className: "dumi-default-search-modal-content"
    }, props.children)) : null;
};

},
"node_modules/dumi/theme-default/slots/SearchBar/index.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    SearchInput: function() {
        return _Input.Input;
    },
    SearchMask: function() {
        return _Mask.Mask;
    },
    default: function() {
        return _default;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _arrowdownsvg = __mako_require__("node_modules/@ant-design/icons-svg/inline-svg/outlined/arrow-down.svg");
var _arrowupsvg = __mako_require__("node_modules/@ant-design/icons-svg/inline-svg/outlined/arrow-up.svg");
var _searchsvg = __mako_require__("node_modules/@ant-design/icons-svg/inline-svg/outlined/search.svg");
var _dumi = __mako_require__(".dumi/tmp/dumi/exports.ts");
var _SearchResult = /*#__PURE__*/ _interop_require_default._(__mako_require__(".dumi/tmp/dumi/theme/slots/SearchResult.ts"));
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
var _Input = __mako_require__("node_modules/dumi/theme-default/slots/SearchBar/Input.js");
var _Mask = __mako_require__("node_modules/dumi/theme-default/slots/SearchBar/Mask.js");
"";
var _navigator;
function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _iterableToArrayLimit(arr, i) {
    var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
    if (null != _i) {
        var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1;
        try {
            if (_x = (_i = _i.call(arr)).next, 0 === i) {
                if (Object(_i) !== _i) return;
                _n = !1;
            } else for(; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);
        } catch (err) {
            _d = !0, _e = err;
        } finally{
            try {
                if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;
            } finally{
                if (_d) throw _e;
            }
        }
        return _arr;
    }
}
function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
}
var isAppleDevice = /(mac|iphone|ipod|ipad)/i.test(typeof navigator !== 'undefined' ? (_navigator = navigator) === null || _navigator === void 0 ? void 0 : _navigator.platform : '');
/** Determine if the element that triggered the event is an input element */ var isInput = function isInput(target) {
    return [
        'TEXTAREA',
        'INPUT'
    ].includes(target.tagName) || target.contentEditable === 'true';
};
var SearchBar = function SearchBar() {
    var _useState = (0, _react.useState)(false), _useState2 = _slicedToArray(_useState, 2), focusing = _useState2[0], setFocusing = _useState2[1];
    var inputRef = (0, _react.useRef)(null);
    var modalInputRef = (0, _react.useRef)(null);
    var _useState3 = (0, _react.useState)(''), _useState4 = _slicedToArray(_useState3, 2), symbol = _useState4[0], setSymbol = _useState4[1];
    var _useSiteSearch = (0, _dumi.useSiteSearch)(), keywords = _useSiteSearch.keywords, setKeywords = _useSiteSearch.setKeywords, result = _useSiteSearch.result, loading = _useSiteSearch.loading, loadSearchData = _useSiteSearch.load;
    var _useState5 = (0, _react.useState)(false), _useState6 = _slicedToArray(_useState5, 2), modalVisible = _useState6[0], setModalVisible = _useState6[1];
    (0, _react.useEffect)(function() {
        // why put useEffect?
        // to avoid Text content mismatch between server & client in ssr
        if (!isAppleDevice) setSymbol('Ctrl');
        var handler = function handler(ev) {
            if ((isAppleDevice ? ev.metaKey : ev.ctrlKey) && ev.key === 'k' || ev.key === '/' && !isInput(ev.target)) {
                ev.preventDefault();
                if (inputRef.current) {
                    var _inputRef$current$get = inputRef.current.getBoundingClientRect(), top = _inputRef$current$get.top, bottom = _inputRef$current$get.bottom, left = _inputRef$current$get.left, right = _inputRef$current$get.right;
                    var isInViewport = top >= 0 && left >= 0 && bottom <= window.innerHeight && right <= window.innerWidth;
                    if (isInViewport) inputRef.current.focus();
                    else {
                        setKeywords('');
                        setModalVisible(true);
                        setTimeout(function() {
                            var _modalInputRef$curren;
                            (_modalInputRef$curren = modalInputRef.current) === null || _modalInputRef$curren === void 0 || _modalInputRef$curren.focus();
                        });
                    }
                }
            }
            if (ev.key === 'Escape') {
                ev.preventDefault();
                setModalVisible(false);
            }
        };
        document.addEventListener('keydown', handler);
        return function() {
            return document.removeEventListener('keydown', handler);
        };
    }, []);
    return /*#__PURE__*/ _react.default.createElement("div", {
        className: "dumi-default-search-bar"
    }, /*#__PURE__*/ _react.default.createElement(_searchsvg.ReactComponent, {
        className: "dumi-default-search-bar-svg"
    }), /*#__PURE__*/ _react.default.createElement(_Input.Input, {
        onFocus: function onFocus() {
            setFocusing(true);
            loadSearchData();
        },
        onMouseEnter: function onMouseEnter() {
            loadSearchData();
        },
        onBlur: function onBlur() {
            // wait for item click
            setTimeout(function() {
                setFocusing(false);
            }, 1);
        },
        onChange: function onChange(keywords) {
            return setKeywords(keywords);
        },
        ref: inputRef
    }), /*#__PURE__*/ _react.default.createElement("span", {
        className: "dumi-default-search-shortcut"
    }, symbol, " K"), keywords.trim() && focusing && !modalVisible && /*#__PURE__*/ _react.default.createElement("div", {
        className: "dumi-default-search-popover"
    }, /*#__PURE__*/ _react.default.createElement("section", null, /*#__PURE__*/ _react.default.createElement(_SearchResult.default, {
        data: result,
        loading: loading
    }))), /*#__PURE__*/ _react.default.createElement(_Mask.Mask, {
        visible: modalVisible,
        onMaskClick: function onMaskClick() {
            setModalVisible(false);
        },
        onClose: function onClose() {
            return setKeywords('');
        }
    }, /*#__PURE__*/ _react.default.createElement("div", {
        style: {
            position: 'relative'
        }
    }, /*#__PURE__*/ _react.default.createElement(_searchsvg.ReactComponent, {
        className: "dumi-default-search-bar-svg"
    }), /*#__PURE__*/ _react.default.createElement(_Input.Input, {
        onFocus: function onFocus() {
            return setFocusing(true);
        },
        onBlur: function onBlur() {
            // wait for item click
            setTimeout(function() {
                setFocusing(false);
            }, 1);
        },
        onChange: function onChange(keywords) {
            return setKeywords(keywords);
        },
        ref: modalInputRef
    })), /*#__PURE__*/ _react.default.createElement(_SearchResult.default, {
        data: result,
        loading: loading,
        onItemSelect: function onItemSelect() {
            setModalVisible(false);
        }
    }), /*#__PURE__*/ _react.default.createElement("footer", null, /*#__PURE__*/ _react.default.createElement("ul", {
        className: "dumi-default-search-modal-commands"
    }, /*#__PURE__*/ _react.default.createElement("li", {
        className: "dumi-default-search-modal-commands-arrow"
    }, /*#__PURE__*/ _react.default.createElement("span", {
        className: "dumi-default-search-modal-shortcut"
    }, /*#__PURE__*/ _react.default.createElement(_arrowupsvg.ReactComponent, {
        width: "10px",
        height: "10px",
        fill: "rgba(0, 0, 0, 0.45)"
    })), /*#__PURE__*/ _react.default.createElement("span", {
        className: "dumi-default-search-modal-shortcut"
    }, /*#__PURE__*/ _react.default.createElement(_arrowdownsvg.ReactComponent, {
        width: "10px",
        height: "10px",
        fill: "rgba(0, 0, 0, 0.45)"
    })), /*#__PURE__*/ _react.default.createElement("span", {
        className: "dumi-default-search-modal-commands-text"
    }, "to navigate")), /*#__PURE__*/ _react.default.createElement("li", null, /*#__PURE__*/ _react.default.createElement("span", {
        className: "dumi-default-search-modal-shortcut"
    }, "esc"), /*#__PURE__*/ _react.default.createElement("span", {
        className: "dumi-default-search-modal-commands-text"
    }, "to close"))))));
};
var _default = SearchBar;

},
"node_modules/dumi/theme-default/slots/SearchResult/index.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _inboxsvg = __mako_require__("node_modules/@ant-design/icons-svg/inline-svg/outlined/inbox.svg");
var _animatedscrollto = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/animated-scroll-to/dist/esm/index.js"));
var _dumi = __mako_require__(".dumi/tmp/dumi/exports.ts");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
"";
function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _iterableToArrayLimit(arr, i) {
    var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
    if (null != _i) {
        var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1;
        try {
            if (_x = (_i = _i.call(arr)).next, 0 === i) {
                if (Object(_i) !== _i) return;
                _n = !1;
            } else for(; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);
        } catch (err) {
            _d = !0, _e = err;
        } finally{
            try {
                if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;
            } finally{
                if (_d) throw _e;
            }
        }
        return _arr;
    }
}
function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
}
var IconTitle = function IconTitle() {
    return /*#__PURE__*/ _react.default.createElement("svg", {
        viewBox: "0 0 32 32",
        xmlns: "http://www.w3.org/2000/svg"
    }, /*#__PURE__*/ _react.default.createElement("path", {
        d: "M5.333 10.667h21.334c.889 0 1.333.444 1.333 1.333s-.444 1.333-1.333 1.333H5.333C4.444 13.333 4 12.89 4 12s.444-1.333 1.333-1.333Z"
    }), /*#__PURE__*/ _react.default.createElement("path", {
        d: "M13.207 2.667h.126a1.206 1.206 0 0 1 1.2 1.326l-2.413 24.14a1.333 1.333 0 0 1-1.327 1.2h-.126a1.206 1.206 0 0 1-1.2-1.326l2.413-24.14c.068-.682.642-1.2 1.327-1.2Zm8 0h.126a1.206 1.206 0 0 1 1.2 1.326l-2.413 24.14a1.333 1.333 0 0 1-1.327 1.2h-.126a1.206 1.206 0 0 1-1.2-1.326l2.413-24.14c.068-.682.642-1.2 1.327-1.2Z"
    }), /*#__PURE__*/ _react.default.createElement("path", {
        d: "M5.333 18.667h21.334c.889 0 1.333.444 1.333 1.333s-.444 1.333-1.333 1.333H5.333C4.444 21.333 4 20.89 4 20s.444-1.333 1.333-1.333Z"
    }));
};
var IconPage = function IconPage() {
    return /*#__PURE__*/ _react.default.createElement("svg", {
        viewBox: "0 0 32 32",
        xmlns: "http://www.w3.org/2000/svg"
    }, /*#__PURE__*/ _react.default.createElement("path", {
        d: "M9.402 0h14.78L30 6.16V24.5c0 1.933-1.71 3.5-3.589 3.5H9.401C7.524 28 6 26.433 6 24.5v-21C6 1.567 7.523 0 9.402 0ZM23 2v4.183c0 .451.366.817.817.817H28l-5-5Zm3.333 24c.92 0 1.667-.768 1.667-1.714V8.857h-5c-.92 0-1.667-.767-1.667-1.714V2H9.667C8.747 2 8 2.768 8 3.714v20.572C8 25.232 8.746 26 9.667 26h16.666Z"
    }));
};
var IconContent = function IconContent() {
    return /*#__PURE__*/ _react.default.createElement("svg", {
        viewBox: "0 0 32 32",
        xmlns: "http://www.w3.org/2000/svg"
    }, /*#__PURE__*/ _react.default.createElement("path", {
        d: "M6.12 14.589h6.628l1.52 4.004h2.485l-5.938-15.19H8.053L2.115 18.732H4.6l1.52-4.143ZM8.88 6.855c.139-.414.277-.828.415-1.38h.138c0 .138.138.414.414 1.104 0 .138.138.276.138.276 0 .138.829 2.072 2.21 5.938H6.672c1.519-3.866 2.21-5.8 2.21-5.938Zm8.148 2.348h12.705v1.933H17.029V9.203ZM2.115 20.665h27.619v1.933H2.114v-1.933Zm14.914-5.662h12.705v1.933H17.029v-1.933ZM2.115 26.327h27.619v1.933H2.114v-1.933ZM17.029 3.54h12.705v1.934H17.029V3.54Z"
    }));
};
var IconDemo = function IconDemo() {
    return /*#__PURE__*/ _react.default.createElement("svg", {
        viewBox: "0 0 32 32",
        xmlns: "http://www.w3.org/2000/svg"
    }, /*#__PURE__*/ _react.default.createElement("path", {
        d: "M28 6h-5a5 5 0 0 0-10 0H8a2 2 0 0 0-2 2v5a5 5 0 0 0 0 10v5a2 2 0 0 0 2 2h7v-2a3 3 0 0 1 6 0v2h7a2 2 0 0 0 2-2v-7h-2a3 3 0 0 1 0-6h2V8a2 2 0 0 0-2-2Zm-5 12a5 5 0 0 0 5 5v5h-5a5 5 0 0 0-10 0H8v-7H6a3 3 0 0 1 0-6h2V8h7V6a3 3 0 0 1 6 0v2h7v5a5 5 0 0 0-5 5Z"
    }));
};
var ICONS_MAPPING = {
    title: IconTitle,
    page: IconPage,
    content: IconContent,
    demo: IconDemo
};
var Highlight = function Highlight(props) {
    return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, props.texts.map(function(text, idx) {
        return /*#__PURE__*/ _react.default.createElement(_react.Fragment, {
            key: idx
        }, text.highlighted ? /*#__PURE__*/ _react.default.createElement("mark", null, text.text) : text.text);
    }));
};
var useFlatSearchData = function useFlatSearchData(data) {
    var update = (0, _react.useCallback)(function() {
        var activeIndex = 0;
        var ret = [];
        data.forEach(function(item) {
            if (item.title) ret.push({
                type: 'title',
                value: {
                    title: item.title
                }
            });
            item.hints.forEach(function(hint) {
                ret.push({
                    type: 'hint',
                    activeIndex: activeIndex++,
                    value: hint
                });
            });
        });
        return [
            ret,
            activeIndex
        ];
    }, [
        data
    ]);
    var _useState = (0, _react.useState)(update), _useState2 = _slicedToArray(_useState, 2), flatData = _useState2[0], setFlatData = _useState2[1];
    (0, _react.useEffect)(function() {
        setFlatData(update);
    }, [
        data
    ]);
    return flatData;
};
var SearchResult = function SearchResult(props) {
    var _useFlatSearchData = useFlatSearchData(props.data), _useFlatSearchData2 = _slicedToArray(_useFlatSearchData, 2), data = _useFlatSearchData2[0], histsCount = _useFlatSearchData2[1];
    var _useState3 = (0, _react.useState)(-1), _useState4 = _slicedToArray(_useState3, 2), activeIndex = _useState4[0], setActiveIndex = _useState4[1];
    var _useLocation = (0, _dumi.useLocation)(), pathname = _useLocation.pathname;
    var onItemSelect = function onItemSelect(item) {
        var _props$onItemSelect;
        (_props$onItemSelect = props.onItemSelect) === null || _props$onItemSelect === void 0 || _props$onItemSelect.call(props, item);
        var url = new URL(item === null || item === void 0 ? void 0 : item.link, location.origin);
        if ((url === null || url === void 0 ? void 0 : url.pathname) === pathname && !url.hash) setTimeout(function() {
            (0, _animatedscrollto.default)(0, {
                maxDuration: 300
            });
        }, 1);
    };
    (0, _react.useEffect)(function() {
        var handler = function handler(ev) {
            // TODO: scroll into view for invisible items
            if (ev.key === 'ArrowDown') setActiveIndex((activeIndex + 1) % histsCount);
            else if (ev.key === 'ArrowUp') setActiveIndex((activeIndex + histsCount - 1) % histsCount);
            else if (ev.key === 'Enter' && activeIndex >= 0) {
                var _item = data.find(function(item) {
                    return item.type === 'hint' && item.activeIndex === activeIndex;
                }).value;
                _dumi.history.push(_item.link);
                onItemSelect === null || onItemSelect === void 0 || onItemSelect(_item);
                document.activeElement.blur();
            }
            if ([
                'Escape',
                'Enter'
            ].includes(ev.key)) setActiveIndex(-1);
        };
        document.addEventListener('keydown', handler);
        return function() {
            return document.removeEventListener('keydown', handler);
        };
    });
    var returnNode = null;
    if (props.loading) returnNode = /*#__PURE__*/ _react.default.createElement("div", {
        className: "dumi-default-search-empty"
    }, /*#__PURE__*/ _react.default.createElement(_inboxsvg.ReactComponent, null), /*#__PURE__*/ _react.default.createElement(_dumi.FormattedMessage, {
        id: "search.loading"
    }));
    else if (props.data.length) returnNode = /*#__PURE__*/ _react.default.createElement("dl", null, data.map(function(item, i) {
        return item.type === 'title' ? /*#__PURE__*/ _react.default.createElement("dt", {
            key: String(i)
        }, item.value.title) : /*#__PURE__*/ _react.default.createElement("dd", {
            key: String(i)
        }, /*#__PURE__*/ _react.default.createElement(_dumi.Link, {
            to: item.value.link,
            "data-active": activeIndex === item.activeIndex || undefined,
            onClick: function onClick() {
                return onItemSelect === null || onItemSelect === void 0 ? void 0 : onItemSelect(item.value);
            }
        }, /*#__PURE__*/ _react.default.createElement(ICONS_MAPPING[item.value.type]), /*#__PURE__*/ _react.default.createElement("h4", null, /*#__PURE__*/ _react.default.createElement(Highlight, {
            texts: item.value.highlightTitleTexts
        })), /*#__PURE__*/ _react.default.createElement("p", null, /*#__PURE__*/ _react.default.createElement(Highlight, {
            texts: item.value.highlightTexts
        }))));
    }));
    else returnNode = /*#__PURE__*/ _react.default.createElement("div", {
        className: "dumi-default-search-empty"
    }, /*#__PURE__*/ _react.default.createElement(_inboxsvg.ReactComponent, null), /*#__PURE__*/ _react.default.createElement(_dumi.FormattedMessage, {
        id: "search.not.found"
    }));
    return /*#__PURE__*/ _react.default.createElement("div", {
        className: "dumi-default-search-result",
        onMouseEnter: function onMouseEnter() {
            return setActiveIndex(-1);
        },
        onMouseDownCapture: function onMouseDownCapture(ev) {
            return ev.preventDefault();
        },
        onMouseUpCapture: function onMouseUpCapture() {
            document.activeElement.blur();
        }
    }, returnNode);
};
var _default = SearchResult;

},
"node_modules/dumi/theme-default/slots/Sidebar/index.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _dumi = __mako_require__(".dumi/tmp/dumi/exports.ts");
var _Toc = /*#__PURE__*/ _interop_require_default._(__mako_require__(".dumi/tmp/dumi/theme/slots/Toc.ts"));
var _react = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/react/index.js"));
"";
var Sidebar = function Sidebar() {
    var _useLocation = (0, _dumi.useLocation)(), pathname = _useLocation.pathname;
    var meta = (0, _dumi.useRouteMeta)();
    var sidebar = (0, _dumi.useSidebarData)();
    if (!sidebar) return null;
    return /*#__PURE__*/ _react.default.createElement("div", {
        className: "dumi-default-sidebar"
    }, sidebar.map(function(item, i) {
        return /*#__PURE__*/ _react.default.createElement("dl", {
            className: "dumi-default-sidebar-group",
            key: String(i)
        }, item.title && /*#__PURE__*/ _react.default.createElement("dt", null, item.title), item.children.map(function(child) {
            return /*#__PURE__*/ _react.default.createElement("dd", {
                key: child.link
            }, /*#__PURE__*/ _react.default.createElement(_dumi.NavLink, {
                to: child.link,
                title: child.title,
                end: true
            }, child.title), child.link === pathname && meta.frontmatter.toc === 'menu' && /*#__PURE__*/ _react.default.createElement(_Toc.default, null));
        }));
    }));
};
var _default = Sidebar;

},
"node_modules/dumi/theme-default/slots/SocialIcon/index.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _facebooksvg = __mako_require__("node_modules/@ant-design/icons-svg/inline-svg/outlined/facebook.svg");
var _githubsvg = __mako_require__("node_modules/@ant-design/icons-svg/inline-svg/outlined/github.svg");
var _gitlabsvg = __mako_require__("node_modules/@ant-design/icons-svg/inline-svg/outlined/gitlab.svg");
var _linkedinsvg = __mako_require__("node_modules/@ant-design/icons-svg/inline-svg/outlined/linkedin.svg");
var _weibosvg = __mako_require__("node_modules/@ant-design/icons-svg/inline-svg/outlined/weibo.svg");
var _xsvg = __mako_require__("node_modules/@ant-design/icons-svg/inline-svg/outlined/x.svg");
var _yuquesvg = __mako_require__("node_modules/@ant-design/icons-svg/inline-svg/outlined/yuque.svg");
var _zhihusvg = __mako_require__("node_modules/@ant-design/icons-svg/inline-svg/outlined/zhihu.svg");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
var _reactintl = __mako_require__("node_modules/react-intl/lib/index.js");
"";
var presetIconMap = {
    github: _githubsvg.ReactComponent,
    weibo: _weibosvg.ReactComponent,
    twitter: _xsvg.ReactComponent,
    x: _xsvg.ReactComponent,
    gitlab: _gitlabsvg.ReactComponent,
    facebook: _facebooksvg.ReactComponent,
    zhihu: _zhihusvg.ReactComponent,
    yuque: _yuquesvg.ReactComponent,
    linkedin: _linkedinsvg.ReactComponent
};
var SocialIcon = function SocialIcon(props) {
    var icon = props.icon, link = props.link;
    var intl = (0, _reactintl.useIntl)();
    var preset = (0, _react.useMemo)(function() {
        return {
            Icon: presetIconMap[icon],
            link: link
        };
    }, [
        icon,
        link
    ]);
    return /*#__PURE__*/ _react.default.createElement("a", {
        className: "dumi-default-icon",
        "data-dumi-tooltip": intl.formatMessage({
            id: "header.social.".concat(icon)
        }),
        "data-dumi-tooltip-bottom": true,
        target: "_blank",
        href: preset.link,
        rel: "noreferrer"
    }, /*#__PURE__*/ _react.default.createElement(preset.Icon, null));
};
var _default = SocialIcon;

},
"node_modules/dumi/theme-default/slots/Toc/index.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _ghostui = __mako_require__("node_modules/@makotot/ghostui/dist/ghostui.esm.js");
var _dumi = __mako_require__(".dumi/tmp/dumi/exports.ts");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
"";
function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _iterableToArrayLimit(arr, i) {
    var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
    if (null != _i) {
        var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1;
        try {
            if (_x = (_i = _i.call(arr)).next, 0 === i) {
                if (Object(_i) !== _i) return;
                _n = !1;
            } else for(; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);
        } catch (err) {
            _d = !0, _e = err;
        } finally{
            try {
                if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;
            } finally{
                if (_d) throw _e;
            }
        }
        return _arr;
    }
}
function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
}
var Toc = function Toc() {
    var _useLocation = (0, _dumi.useLocation)(), pathname = _useLocation.pathname, search = _useLocation.search, hash = _useLocation.hash;
    var meta = (0, _dumi.useRouteMeta)();
    var tabMeta = (0, _dumi.useTabMeta)();
    var _useSiteData = (0, _dumi.useSiteData)(), loading = _useSiteData.loading;
    var prevIndexRef = (0, _react.useRef)(0);
    var _useState = (0, _react.useState)([]), _useState2 = _slicedToArray(_useState, 2), sectionRefs = _useState2[0], setSectionRefs = _useState2[1];
    var _useState3 = (0, _react.useState)(0), _useState4 = _slicedToArray(_useState3, 2), headerHeight = _useState4[0], setHeaderHeight = _useState4[1];
    var memoToc = _react.default.useMemo(function() {
        var toc = meta.toc;
        if (tabMeta) toc = tabMeta.toc;
        // only render h2 ~ h4
        return toc.filter(function(_ref) {
            var depth = _ref.depth;
            return depth > 1 && depth < 4;
        });
    }, [
        meta,
        tabMeta
    ]);
    (0, _react.useEffect)(function() {
        // wait for page component ready (DOM ready)
        if (!loading) {
            // find all valid headings as ref elements
            var refs = memoToc.map(function(_ref2) {
                var id = _ref2.id;
                return {
                    current: document.getElementById(id)
                };
            });
            setSectionRefs(refs);
        }
    }, [
        pathname,
        search,
        loading,
        memoToc
    ]);
    (0, _react.useEffect)(function() {
        if (sectionRefs.length > 0) {
            // find the header height, and set it to scrollspy offset
            // because the header is sticky, so we need to set the offset to avoid the active item is hidden by the header
            var header = document.querySelector('.dumi-default-header');
            setHeaderHeight(header ? header.clientHeight : 0);
        }
    }, [
        sectionRefs
    ]);
    return sectionRefs.length ? /*#__PURE__*/ _react.default.createElement(_ghostui.Scrollspy, {
        sectionRefs: sectionRefs,
        offset: -headerHeight
    }, function(_ref3) {
        var currentElementIndexInViewport = _ref3.currentElementIndexInViewport;
        // for keep prev item active when no item in viewport
        if (currentElementIndexInViewport > -1) prevIndexRef.current = currentElementIndexInViewport;
        return /*#__PURE__*/ _react.default.createElement("ul", {
            className: "dumi-default-toc"
        }, memoToc.filter(function(_ref4) {
            var depth = _ref4.depth;
            return depth > 1 && depth < 4;
        }).map(function(item, i) {
            var link = "".concat(search, "#").concat(encodeURIComponent(item.id));
            var activeIndex = currentElementIndexInViewport > -1 ? currentElementIndexInViewport : prevIndexRef.current;
            return /*#__PURE__*/ _react.default.createElement("li", {
                key: item.id,
                "data-depth": item.depth
            }, /*#__PURE__*/ _react.default.createElement(_dumi.Link, _extends({
                to: link,
                onClickCapture: function onClickCapture() {
                    if (decodeURIComponent(hash).slice(1) === item.id) _dumi.history.replace("".concat(pathname).concat(search));
                },
                title: item.title
            }, activeIndex === i ? {
                className: 'active'
            } : {}), item.title));
        }));
    }) : null;
};
var _default = Toc;

},
"node_modules/ieee754/index.js": function (module, exports, __mako_require__){
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ exports.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);
    if (e === 0) e = 1 - eBias;
    else if (e === eMax) return m ? NaN : (s ? -1 : 1) * Infinity;
    else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
    } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
        }
        if (e + eBias >= 1) value += rt / c;
        else value += rt * Math.pow(2, 1 - eBias);
        if (value * c >= 2) {
            e++;
            c /= 2;
        }
        if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
        } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
        } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
        }
    }
    for(; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);
    e = e << mLen | m;
    eLen += mLen;
    for(; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);
    buffer[offset + i - d] |= s * 128;
};

},
"node_modules/is-mobile/index.js": function (module, exports, __mako_require__){
'use strict';
module.exports = isMobile;
module.exports.isMobile = isMobile;
module.exports.default = isMobile;
const mobileRE = /(android|bb\d+|meego).+mobile|armv7l|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|redmi|series[46]0|samsungbrowser.*mobile|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i;
const notMobileRE = /CrOS/;
const tabletRE = /android|ipad|playbook|silk/i;
function isMobile(opts) {
    if (!opts) opts = {};
    let ua = opts.ua;
    if (!ua && typeof navigator !== 'undefined') ua = navigator.userAgent;
    if (ua && ua.headers && typeof ua.headers['user-agent'] === 'string') ua = ua.headers['user-agent'];
    if (typeof ua !== 'string') return false;
    let result = mobileRE.test(ua) && !notMobileRE.test(ua) || !!opts.tablet && tabletRE.test(ua);
    if (!result && opts.tablet && opts.featureDetect && navigator && navigator.maxTouchPoints > 1 && ua.indexOf('Macintosh') !== -1 && ua.indexOf('Safari') !== -1) result = true;
    return result;
}

},
"node_modules/lines-and-columns/build/index.js": function (module, exports, __mako_require__){
"use strict";
exports.__esModule = true;
exports.LinesAndColumns = void 0;
var LF = '\n';
var CR = '\r';
var LinesAndColumns = function() {
    function LinesAndColumns(string) {
        this.string = string;
        var offsets = [
            0
        ];
        for(var offset = 0; offset < string.length;)switch(string[offset]){
            case LF:
                offset += LF.length;
                offsets.push(offset);
                break;
            case CR:
                offset += CR.length;
                if (string[offset] === LF) offset += LF.length;
                offsets.push(offset);
                break;
            default:
                offset++;
                break;
        }
        this.offsets = offsets;
    }
    LinesAndColumns.prototype.locationForIndex = function(index) {
        if (index < 0 || index > this.string.length) return null;
        var line = 0;
        var offsets = this.offsets;
        while(offsets[line + 1] <= index)line++;
        var column = index - offsets[line];
        return {
            line: line,
            column: column
        };
    };
    LinesAndColumns.prototype.indexForLocation = function(location) {
        var line = location.line, column = location.column;
        if (line < 0 || line >= this.offsets.length) return null;
        if (column < 0 || column > this.lengthOfLine(line)) return null;
        return this.offsets[line] + column;
    };
    LinesAndColumns.prototype.lengthOfLine = function(line) {
        var offset = this.offsets[line];
        var nextOffset = line === this.offsets.length - 1 ? this.string.length : this.offsets[line + 1];
        return nextOffset - offset;
    };
    return LinesAndColumns;
}();
exports.LinesAndColumns = LinesAndColumns;
exports["default"] = LinesAndColumns;

},
"node_modules/node-libs-browser-okam/polyfill/buffer.js": function (module, exports, __mako_require__){
module.exports = __mako_require__("node_modules/buffer-okam/index.js");

},
"node_modules/rc-tree/es/DropIndicator.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _react = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/react/index.js"));
var DropIndicator = function DropIndicator(props) {
    var dropPosition = props.dropPosition, dropLevelOffset = props.dropLevelOffset, indent = props.indent;
    var style = {
        pointerEvents: 'none',
        position: 'absolute',
        right: 0,
        backgroundColor: 'red',
        height: 2
    };
    switch(dropPosition){
        case -1:
            style.top = 0;
            style.left = -dropLevelOffset * indent;
            break;
        case 1:
            style.bottom = 0;
            style.left = -dropLevelOffset * indent;
            break;
        case 0:
            style.bottom = 0;
            style.left = indent;
            break;
    }
    return /*#__PURE__*/ _react.default.createElement("div", {
        style: style
    });
};
DropIndicator.displayName = 'DropIndicator';
var _default = DropIndicator;

},
"node_modules/rc-tree/es/Indent.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _defineProperty = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@babel/runtime/helpers/esm/defineProperty.js"));
var _classnames = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/classnames/index.js"));
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
var Indent = function Indent(_ref) {
    var prefixCls = _ref.prefixCls, level = _ref.level, isStart = _ref.isStart, isEnd = _ref.isEnd;
    var baseClassName = "".concat(prefixCls, "-indent-unit");
    var list = [];
    for(var i = 0; i < level; i += 1)list.push(/*#__PURE__*/ _react.createElement("span", {
        key: i,
        className: (0, _classnames.default)(baseClassName, (0, _defineProperty.default)((0, _defineProperty.default)({}, "".concat(baseClassName, "-start"), isStart[i]), "".concat(baseClassName, "-end"), isEnd[i]))
    }));
    return /*#__PURE__*/ _react.createElement("span", {
        "aria-hidden": "true",
        className: "".concat(prefixCls, "-indent")
    }, list);
};
var _default = /*#__PURE__*/ _react.memo(Indent);

},
"node_modules/rc-tree/es/MotionTreeNode.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _extends = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@babel/runtime/helpers/esm/extends.js"));
var _objectDestructuringEmpty = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@babel/runtime/helpers/esm/objectDestructuringEmpty.js"));
var _slicedToArray = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@babel/runtime/helpers/esm/slicedToArray.js"));
var _objectWithoutProperties = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js"));
var _classnames = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/classnames/index.js"));
var _rcmotion = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/rc-motion/es/index.js"));
var _useLayoutEffect = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/rc-util/es/hooks/useLayoutEffect.js"));
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
var _contextTypes = __mako_require__("node_modules/rc-tree/es/contextTypes.js");
var _TreeNode = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/rc-tree/es/TreeNode.js"));
var _useUnmount = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/rc-tree/es/useUnmount.js"));
var _treeUtil = __mako_require__("node_modules/rc-tree/es/utils/treeUtil.js");
var _excluded = [
    "className",
    "style",
    "motion",
    "motionNodes",
    "motionType",
    "onMotionStart",
    "onMotionEnd",
    "active",
    "treeNodeRequiredProps"
];
var MotionTreeNode = /*#__PURE__*/ _react.forwardRef(function(oriProps, ref) {
    var className = oriProps.className, style = oriProps.style, motion = oriProps.motion, motionNodes = oriProps.motionNodes, motionType = oriProps.motionType, onOriginMotionStart = oriProps.onMotionStart, onOriginMotionEnd = oriProps.onMotionEnd, active = oriProps.active, treeNodeRequiredProps = oriProps.treeNodeRequiredProps, props = (0, _objectWithoutProperties.default)(oriProps, _excluded);
    var _React$useState = _react.useState(true), _React$useState2 = (0, _slicedToArray.default)(_React$useState, 2), visible = _React$useState2[0], setVisible = _React$useState2[1];
    var _React$useContext = _react.useContext(_contextTypes.TreeContext), prefixCls = _React$useContext.prefixCls;
    // Calculate target visible here.
    // And apply in effect to make `leave` motion work.
    var targetVisible = motionNodes && motionType !== 'hide';
    (0, _useLayoutEffect.default)(function() {
        if (motionNodes) {
            if (targetVisible !== visible) setVisible(targetVisible);
        }
    }, [
        motionNodes
    ]);
    var triggerMotionStart = function triggerMotionStart() {
        if (motionNodes) onOriginMotionStart();
    };
    // Should only trigger once
    var triggerMotionEndRef = _react.useRef(false);
    var triggerMotionEnd = function triggerMotionEnd() {
        if (motionNodes && !triggerMotionEndRef.current) {
            triggerMotionEndRef.current = true;
            onOriginMotionEnd();
        }
    };
    // Effect if unmount
    (0, _useUnmount.default)(triggerMotionStart, triggerMotionEnd);
    // Motion end event
    var onVisibleChanged = function onVisibleChanged(nextVisible) {
        if (targetVisible === nextVisible) triggerMotionEnd();
    };
    if (motionNodes) return /*#__PURE__*/ _react.createElement(_rcmotion.default, (0, _extends.default)({
        ref: ref,
        visible: visible
    }, motion, {
        motionAppear: motionType === 'show',
        onVisibleChanged: onVisibleChanged
    }), function(_ref, motionRef) {
        var motionClassName = _ref.className, motionStyle = _ref.style;
        return /*#__PURE__*/ _react.createElement("div", {
            ref: motionRef,
            className: (0, _classnames.default)("".concat(prefixCls, "-treenode-motion"), motionClassName),
            style: motionStyle
        }, motionNodes.map(function(treeNode) {
            var restProps = Object.assign({}, ((0, _objectDestructuringEmpty.default)(treeNode.data), treeNode.data)), title = treeNode.title, key = treeNode.key, isStart = treeNode.isStart, isEnd = treeNode.isEnd;
            delete restProps.children;
            var treeNodeProps = (0, _treeUtil.getTreeNodeProps)(key, treeNodeRequiredProps);
            return /*#__PURE__*/ _react.createElement(_TreeNode.default, (0, _extends.default)({}, restProps, treeNodeProps, {
                title: title,
                active: active,
                data: treeNode.data,
                key: key,
                isStart: isStart,
                isEnd: isEnd
            }));
        }));
    });
    return /*#__PURE__*/ _react.createElement(_TreeNode.default, (0, _extends.default)({
        domRef: ref,
        className: className,
        style: style
    }, props, {
        active: active
    }));
});
MotionTreeNode.displayName = 'MotionTreeNode';
var _default = MotionTreeNode;

},
"node_modules/rc-tree/es/NodeList.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    MOTION_KEY: function() {
        return MOTION_KEY;
    },
    MotionEntity: function() {
        return MotionEntity;
    },
    default: function() {
        return _default;
    },
    getMinimumRangeTransitionRange: function() {
        return getMinimumRangeTransitionRange;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _extends = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@babel/runtime/helpers/esm/extends.js"));
var _objectDestructuringEmpty = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@babel/runtime/helpers/esm/objectDestructuringEmpty.js"));
var _slicedToArray = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@babel/runtime/helpers/esm/slicedToArray.js"));
var _objectWithoutProperties = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js"));
var _useLayoutEffect = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/rc-util/es/hooks/useLayoutEffect.js"));
var _rcvirtuallist = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/rc-virtual-list/es/index.js"));
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
var _MotionTreeNode = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/rc-tree/es/MotionTreeNode.js"));
var _diffUtil = __mako_require__("node_modules/rc-tree/es/utils/diffUtil.js");
var _treeUtil = __mako_require__("node_modules/rc-tree/es/utils/treeUtil.js");
var _excluded = [
    "prefixCls",
    "data",
    "selectable",
    "checkable",
    "expandedKeys",
    "selectedKeys",
    "checkedKeys",
    "loadedKeys",
    "loadingKeys",
    "halfCheckedKeys",
    "keyEntities",
    "disabled",
    "dragging",
    "dragOverNodeKey",
    "dropPosition",
    "motion",
    "height",
    "itemHeight",
    "virtual",
    "scrollWidth",
    "focusable",
    "activeItem",
    "focused",
    "tabIndex",
    "onKeyDown",
    "onFocus",
    "onBlur",
    "onActiveChange",
    "onListChangeStart",
    "onListChangeEnd"
];
var HIDDEN_STYLE = {
    width: 0,
    height: 0,
    display: 'flex',
    overflow: 'hidden',
    opacity: 0,
    border: 0,
    padding: 0,
    margin: 0
};
var noop = function noop() {};
var MOTION_KEY = "RC_TREE_MOTION_".concat(Math.random());
var MotionNode = {
    key: MOTION_KEY
};
var MotionEntity = {
    key: MOTION_KEY,
    level: 0,
    index: 0,
    pos: '0',
    node: MotionNode,
    nodes: [
        MotionNode
    ]
};
var MotionFlattenData = {
    parent: null,
    children: [],
    pos: MotionEntity.pos,
    data: MotionNode,
    title: null,
    key: MOTION_KEY,
    /** Hold empty list here since we do not use it */ isStart: [],
    isEnd: []
};
function getMinimumRangeTransitionRange(list, virtual, height, itemHeight) {
    if (virtual === false || !height) return list;
    return list.slice(0, Math.ceil(height / itemHeight) + 1);
}
function itemKey(item) {
    var key = item.key, pos = item.pos;
    return (0, _treeUtil.getKey)(key, pos);
}
function getAccessibilityPath(item) {
    var path = String(item.data.key);
    var current = item;
    while(current.parent){
        current = current.parent;
        path = "".concat(current.data.key, " > ").concat(path);
    }
    return path;
}
var NodeList = /*#__PURE__*/ _react.forwardRef(function(props, ref) {
    var prefixCls = props.prefixCls, data = props.data, selectable = props.selectable, checkable = props.checkable, expandedKeys = props.expandedKeys, selectedKeys = props.selectedKeys, checkedKeys = props.checkedKeys, loadedKeys = props.loadedKeys, loadingKeys = props.loadingKeys, halfCheckedKeys = props.halfCheckedKeys, keyEntities = props.keyEntities, disabled = props.disabled, dragging = props.dragging, dragOverNodeKey = props.dragOverNodeKey, dropPosition = props.dropPosition, motion = props.motion, height = props.height, itemHeight = props.itemHeight, virtual = props.virtual, scrollWidth = props.scrollWidth, focusable = props.focusable, activeItem = props.activeItem, focused = props.focused, tabIndex = props.tabIndex, onKeyDown = props.onKeyDown, onFocus = props.onFocus, onBlur = props.onBlur, onActiveChange = props.onActiveChange, onListChangeStart = props.onListChangeStart, onListChangeEnd = props.onListChangeEnd, domProps = (0, _objectWithoutProperties.default)(props, _excluded);
    // =============================== Ref ================================
    var listRef = _react.useRef(null);
    var indentMeasurerRef = _react.useRef(null);
    _react.useImperativeHandle(ref, function() {
        return {
            scrollTo: function scrollTo(scroll) {
                listRef.current.scrollTo(scroll);
            },
            getIndentWidth: function getIndentWidth() {
                return indentMeasurerRef.current.offsetWidth;
            }
        };
    });
    // ============================== Motion ==============================
    var _React$useState = _react.useState(expandedKeys), _React$useState2 = (0, _slicedToArray.default)(_React$useState, 2), prevExpandedKeys = _React$useState2[0], setPrevExpandedKeys = _React$useState2[1];
    var _React$useState3 = _react.useState(data), _React$useState4 = (0, _slicedToArray.default)(_React$useState3, 2), prevData = _React$useState4[0], setPrevData = _React$useState4[1];
    var _React$useState5 = _react.useState(data), _React$useState6 = (0, _slicedToArray.default)(_React$useState5, 2), transitionData = _React$useState6[0], setTransitionData = _React$useState6[1];
    var _React$useState7 = _react.useState([]), _React$useState8 = (0, _slicedToArray.default)(_React$useState7, 2), transitionRange = _React$useState8[0], setTransitionRange = _React$useState8[1];
    var _React$useState9 = _react.useState(null), _React$useState10 = (0, _slicedToArray.default)(_React$useState9, 2), motionType = _React$useState10[0], setMotionType = _React$useState10[1];
    // When motion end but data change, this will makes data back to previous one
    var dataRef = _react.useRef(data);
    dataRef.current = data;
    function onMotionEnd() {
        var latestData = dataRef.current;
        setPrevData(latestData);
        setTransitionData(latestData);
        setTransitionRange([]);
        setMotionType(null);
        onListChangeEnd();
    }
    // Do animation if expanded keys changed
    // layoutEffect here to avoid blink of node removing
    (0, _useLayoutEffect.default)(function() {
        setPrevExpandedKeys(expandedKeys);
        var diffExpanded = (0, _diffUtil.findExpandedKeys)(prevExpandedKeys, expandedKeys);
        if (diffExpanded.key !== null) {
            if (diffExpanded.add) {
                var keyIndex = prevData.findIndex(function(_ref) {
                    var key = _ref.key;
                    return key === diffExpanded.key;
                });
                var rangeNodes = getMinimumRangeTransitionRange((0, _diffUtil.getExpandRange)(prevData, data, diffExpanded.key), virtual, height, itemHeight);
                var newTransitionData = prevData.slice();
                newTransitionData.splice(keyIndex + 1, 0, MotionFlattenData);
                setTransitionData(newTransitionData);
                setTransitionRange(rangeNodes);
                setMotionType('show');
            } else {
                var _keyIndex = data.findIndex(function(_ref2) {
                    var key = _ref2.key;
                    return key === diffExpanded.key;
                });
                var _rangeNodes = getMinimumRangeTransitionRange((0, _diffUtil.getExpandRange)(data, prevData, diffExpanded.key), virtual, height, itemHeight);
                var _newTransitionData = data.slice();
                _newTransitionData.splice(_keyIndex + 1, 0, MotionFlattenData);
                setTransitionData(_newTransitionData);
                setTransitionRange(_rangeNodes);
                setMotionType('hide');
            }
        } else if (prevData !== data) {
            // If whole data changed, we just refresh the list
            setPrevData(data);
            setTransitionData(data);
        }
    }, [
        expandedKeys,
        data
    ]);
    // We should clean up motion if is changed by dragging
    _react.useEffect(function() {
        if (!dragging) onMotionEnd();
    }, [
        dragging
    ]);
    var mergedData = motion ? transitionData : data;
    var treeNodeRequiredProps = {
        expandedKeys: expandedKeys,
        selectedKeys: selectedKeys,
        loadedKeys: loadedKeys,
        loadingKeys: loadingKeys,
        checkedKeys: checkedKeys,
        halfCheckedKeys: halfCheckedKeys,
        dragOverNodeKey: dragOverNodeKey,
        dropPosition: dropPosition,
        keyEntities: keyEntities
    };
    return /*#__PURE__*/ _react.createElement(_react.Fragment, null, focused && activeItem && /*#__PURE__*/ _react.createElement("span", {
        style: HIDDEN_STYLE,
        "aria-live": "assertive"
    }, getAccessibilityPath(activeItem)), /*#__PURE__*/ _react.createElement("div", null, /*#__PURE__*/ _react.createElement("input", {
        style: HIDDEN_STYLE,
        disabled: focusable === false || disabled,
        tabIndex: focusable !== false ? tabIndex : null,
        onKeyDown: onKeyDown,
        onFocus: onFocus,
        onBlur: onBlur,
        value: "",
        onChange: noop,
        "aria-label": "for screen reader"
    })), /*#__PURE__*/ _react.createElement("div", {
        className: "".concat(prefixCls, "-treenode"),
        "aria-hidden": true,
        style: {
            position: 'absolute',
            pointerEvents: 'none',
            visibility: 'hidden',
            height: 0,
            overflow: 'hidden',
            border: 0,
            padding: 0
        }
    }, /*#__PURE__*/ _react.createElement("div", {
        className: "".concat(prefixCls, "-indent")
    }, /*#__PURE__*/ _react.createElement("div", {
        ref: indentMeasurerRef,
        className: "".concat(prefixCls, "-indent-unit")
    }))), /*#__PURE__*/ _react.createElement(_rcvirtuallist.default, (0, _extends.default)({}, domProps, {
        data: mergedData,
        itemKey: itemKey,
        height: height,
        fullHeight: false,
        virtual: virtual,
        itemHeight: itemHeight,
        scrollWidth: scrollWidth,
        prefixCls: "".concat(prefixCls, "-list"),
        ref: listRef,
        role: "tree",
        onVisibleChange: function onVisibleChange(originList) {
            // The best match is using `fullList` - `originList` = `restList`
            // and check the `restList` to see if has the MOTION_KEY node
            // but this will cause performance issue for long list compare
            // we just check `originList` and repeat trigger `onMotionEnd`
            if (originList.every(function(item) {
                return itemKey(item) !== MOTION_KEY;
            })) onMotionEnd();
        }
    }), function(treeNode) {
        var pos = treeNode.pos, restProps = Object.assign({}, ((0, _objectDestructuringEmpty.default)(treeNode.data), treeNode.data)), title = treeNode.title, key = treeNode.key, isStart = treeNode.isStart, isEnd = treeNode.isEnd;
        var mergedKey = (0, _treeUtil.getKey)(key, pos);
        delete restProps.key;
        delete restProps.children;
        var treeNodeProps = (0, _treeUtil.getTreeNodeProps)(mergedKey, treeNodeRequiredProps);
        return /*#__PURE__*/ _react.createElement(_MotionTreeNode.default, (0, _extends.default)({}, restProps, treeNodeProps, {
            title: title,
            active: !!activeItem && key === activeItem.key,
            pos: pos,
            data: treeNode.data,
            isStart: isStart,
            isEnd: isEnd,
            motion: motion,
            motionNodes: key === MOTION_KEY ? transitionRange : null,
            motionType: motionType,
            onMotionStart: onListChangeStart,
            onMotionEnd: onMotionEnd,
            treeNodeRequiredProps: treeNodeRequiredProps,
            onMouseMove: function onMouseMove() {
                onActiveChange(null);
            }
        }));
    }));
});
NodeList.displayName = 'NodeList';
var _default = NodeList;

},
"node_modules/rc-tree/es/Tree.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _extends = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@babel/runtime/helpers/esm/extends.js"));
var _typeof = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@babel/runtime/helpers/esm/typeof.js"));
var _objectSpread2 = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@babel/runtime/helpers/esm/objectSpread2.js"));
var _toConsumableArray = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@babel/runtime/helpers/esm/toConsumableArray.js"));
var _classCallCheck = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@babel/runtime/helpers/esm/classCallCheck.js"));
var _createClass = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@babel/runtime/helpers/esm/createClass.js"));
var _assertThisInitialized = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js"));
var _inherits = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@babel/runtime/helpers/esm/inherits.js"));
var _createSuper = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@babel/runtime/helpers/esm/createSuper.js"));
var _defineProperty = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@babel/runtime/helpers/esm/defineProperty.js"));
var _classnames = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/classnames/index.js"));
var _KeyCode = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/rc-util/es/KeyCode.js"));
var _pickAttrs = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/rc-util/es/pickAttrs.js"));
var _warning = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/rc-util/es/warning.js"));
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
var _contextTypes = __mako_require__("node_modules/rc-tree/es/contextTypes.js");
var _DropIndicator = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/rc-tree/es/DropIndicator.js"));
var _NodeList = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/rc-tree/es/NodeList.js"));
var _TreeNode = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/rc-tree/es/TreeNode.js"));
var _util = __mako_require__("node_modules/rc-tree/es/util.js");
var _conductUtil = __mako_require__("node_modules/rc-tree/es/utils/conductUtil.js");
var _keyUtil = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/rc-tree/es/utils/keyUtil.js"));
var _treeUtil = __mako_require__("node_modules/rc-tree/es/utils/treeUtil.js");
var MAX_RETRY_TIMES = 10;
var Tree = /*#__PURE__*/ function(_React$Component) {
    (0, _inherits.default)(Tree, _React$Component);
    var _super = (0, _createSuper.default)(Tree);
    function Tree() {
        var _this;
        (0, _classCallCheck.default)(this, Tree);
        for(var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++)_args[_key] = arguments[_key];
        _this = _super.call.apply(_super, [
            this
        ].concat(_args));
        (0, _defineProperty.default)((0, _assertThisInitialized.default)(_this), "destroyed", false);
        (0, _defineProperty.default)((0, _assertThisInitialized.default)(_this), "delayedDragEnterLogic", void 0);
        (0, _defineProperty.default)((0, _assertThisInitialized.default)(_this), "loadingRetryTimes", {});
        (0, _defineProperty.default)((0, _assertThisInitialized.default)(_this), "state", {
            keyEntities: {},
            indent: null,
            selectedKeys: [],
            checkedKeys: [],
            halfCheckedKeys: [],
            loadedKeys: [],
            loadingKeys: [],
            expandedKeys: [],
            draggingNodeKey: null,
            dragChildrenKeys: [],
            // dropTargetKey is the key of abstract-drop-node
            // the abstract-drop-node is the real drop node when drag and drop
            // not the DOM drag over node
            dropTargetKey: null,
            dropPosition: null,
            // the drop position of abstract-drop-node, inside 0, top -1, bottom 1
            dropContainerKey: null,
            // the container key of abstract-drop-node if dropPosition is -1 or 1
            dropLevelOffset: null,
            // the drop level offset of abstract-drag-over-node
            dropTargetPos: null,
            // the pos of abstract-drop-node
            dropAllowed: true,
            // if drop to abstract-drop-node is allowed
            // the abstract-drag-over-node
            // if mouse is on the bottom of top dom node or no the top of the bottom dom node
            // abstract-drag-over-node is the top node
            dragOverNodeKey: null,
            treeData: [],
            flattenNodes: [],
            focused: false,
            activeKey: null,
            listChanging: false,
            prevProps: null,
            fieldNames: (0, _treeUtil.fillFieldNames)()
        });
        (0, _defineProperty.default)((0, _assertThisInitialized.default)(_this), "dragStartMousePosition", null);
        (0, _defineProperty.default)((0, _assertThisInitialized.default)(_this), "dragNodeProps", null);
        (0, _defineProperty.default)((0, _assertThisInitialized.default)(_this), "currentMouseOverDroppableNodeKey", null);
        (0, _defineProperty.default)((0, _assertThisInitialized.default)(_this), "listRef", /*#__PURE__*/ _react.createRef());
        (0, _defineProperty.default)((0, _assertThisInitialized.default)(_this), "onNodeDragStart", function(event, nodeProps) {
            var _this$state = _this.state, expandedKeys = _this$state.expandedKeys, keyEntities = _this$state.keyEntities;
            var onDragStart = _this.props.onDragStart;
            var eventKey = nodeProps.eventKey;
            _this.dragNodeProps = nodeProps;
            _this.dragStartMousePosition = {
                x: event.clientX,
                y: event.clientY
            };
            var newExpandedKeys = (0, _util.arrDel)(expandedKeys, eventKey);
            _this.setState({
                draggingNodeKey: eventKey,
                dragChildrenKeys: (0, _util.getDragChildrenKeys)(eventKey, keyEntities),
                indent: _this.listRef.current.getIndentWidth()
            });
            _this.setExpandedKeys(newExpandedKeys);
            window.addEventListener('dragend', _this.onWindowDragEnd);
            onDragStart === null || onDragStart === void 0 || onDragStart({
                event: event,
                node: (0, _treeUtil.convertNodePropsToEventData)(nodeProps)
            });
        });
        /**
     * [Legacy] Select handler is smaller than node,
     * so that this will trigger when drag enter node or select handler.
     * This is a little tricky if customize css without padding.
     * Better for use mouse move event to refresh drag state.
     * But let's just keep it to avoid event trigger logic change.
     */ (0, _defineProperty.default)((0, _assertThisInitialized.default)(_this), "onNodeDragEnter", function(event, nodeProps) {
            var _this$state2 = _this.state, expandedKeys = _this$state2.expandedKeys, keyEntities = _this$state2.keyEntities, dragChildrenKeys = _this$state2.dragChildrenKeys, flattenNodes = _this$state2.flattenNodes, indent = _this$state2.indent;
            var _this$props = _this.props, onDragEnter = _this$props.onDragEnter, onExpand = _this$props.onExpand, allowDrop = _this$props.allowDrop, direction = _this$props.direction;
            var pos = nodeProps.pos, eventKey = nodeProps.eventKey;
            // record the key of node which is latest entered, used in dragleave event.
            if (_this.currentMouseOverDroppableNodeKey !== eventKey) _this.currentMouseOverDroppableNodeKey = eventKey;
            if (!_this.dragNodeProps) {
                _this.resetDragState();
                return;
            }
            var _calcDropPosition = (0, _util.calcDropPosition)(event, _this.dragNodeProps, nodeProps, indent, _this.dragStartMousePosition, allowDrop, flattenNodes, keyEntities, expandedKeys, direction), dropPosition = _calcDropPosition.dropPosition, dropLevelOffset = _calcDropPosition.dropLevelOffset, dropTargetKey = _calcDropPosition.dropTargetKey, dropContainerKey = _calcDropPosition.dropContainerKey, dropTargetPos = _calcDropPosition.dropTargetPos, dropAllowed = _calcDropPosition.dropAllowed, dragOverNodeKey = _calcDropPosition.dragOverNodeKey;
            if (// don't allow drop inside its children
            dragChildrenKeys.includes(dropTargetKey) || // don't allow drop when drop is not allowed caculated by calcDropPosition
            !dropAllowed) {
                _this.resetDragState();
                return;
            }
            // Side effect for delay drag
            if (!_this.delayedDragEnterLogic) _this.delayedDragEnterLogic = {};
            Object.keys(_this.delayedDragEnterLogic).forEach(function(key) {
                clearTimeout(_this.delayedDragEnterLogic[key]);
            });
            if (_this.dragNodeProps.eventKey !== nodeProps.eventKey) {
                // hoist expand logic here
                // since if logic is on the bottom
                // it will be blocked by abstract dragover node check
                //   => if you dragenter from top, you mouse will still be consider as in the top node
                event.persist();
                _this.delayedDragEnterLogic[pos] = window.setTimeout(function() {
                    if (_this.state.draggingNodeKey === null) return;
                    var newExpandedKeys = (0, _toConsumableArray.default)(expandedKeys);
                    var entity = (0, _keyUtil.default)(keyEntities, nodeProps.eventKey);
                    if (entity && (entity.children || []).length) newExpandedKeys = (0, _util.arrAdd)(expandedKeys, nodeProps.eventKey);
                    if (!_this.props.hasOwnProperty('expandedKeys')) _this.setExpandedKeys(newExpandedKeys);
                    onExpand === null || onExpand === void 0 || onExpand(newExpandedKeys, {
                        node: (0, _treeUtil.convertNodePropsToEventData)(nodeProps),
                        expanded: true,
                        nativeEvent: event.nativeEvent
                    });
                }, 800);
            }
            // Skip if drag node is self
            if (_this.dragNodeProps.eventKey === dropTargetKey && dropLevelOffset === 0) {
                _this.resetDragState();
                return;
            }
            // Update drag over node and drag state
            _this.setState({
                dragOverNodeKey: dragOverNodeKey,
                dropPosition: dropPosition,
                dropLevelOffset: dropLevelOffset,
                dropTargetKey: dropTargetKey,
                dropContainerKey: dropContainerKey,
                dropTargetPos: dropTargetPos,
                dropAllowed: dropAllowed
            });
            onDragEnter === null || onDragEnter === void 0 || onDragEnter({
                event: event,
                node: (0, _treeUtil.convertNodePropsToEventData)(nodeProps),
                expandedKeys: expandedKeys
            });
        });
        (0, _defineProperty.default)((0, _assertThisInitialized.default)(_this), "onNodeDragOver", function(event, nodeProps) {
            var _this$state3 = _this.state, dragChildrenKeys = _this$state3.dragChildrenKeys, flattenNodes = _this$state3.flattenNodes, keyEntities = _this$state3.keyEntities, expandedKeys = _this$state3.expandedKeys, indent = _this$state3.indent;
            var _this$props2 = _this.props, onDragOver = _this$props2.onDragOver, allowDrop = _this$props2.allowDrop, direction = _this$props2.direction;
            if (!_this.dragNodeProps) return;
            var _calcDropPosition2 = (0, _util.calcDropPosition)(event, _this.dragNodeProps, nodeProps, indent, _this.dragStartMousePosition, allowDrop, flattenNodes, keyEntities, expandedKeys, direction), dropPosition = _calcDropPosition2.dropPosition, dropLevelOffset = _calcDropPosition2.dropLevelOffset, dropTargetKey = _calcDropPosition2.dropTargetKey, dropContainerKey = _calcDropPosition2.dropContainerKey, dropTargetPos = _calcDropPosition2.dropTargetPos, dropAllowed = _calcDropPosition2.dropAllowed, dragOverNodeKey = _calcDropPosition2.dragOverNodeKey;
            if (dragChildrenKeys.includes(dropTargetKey) || !dropAllowed) // don't allow drop inside its children
            // don't allow drop when drop is not allowed calculated by calcDropPosition
            return;
            // Update drag position
            if (_this.dragNodeProps.eventKey === dropTargetKey && dropLevelOffset === 0) {
                if (!(_this.state.dropPosition === null && _this.state.dropLevelOffset === null && _this.state.dropTargetKey === null && _this.state.dropContainerKey === null && _this.state.dropTargetPos === null && _this.state.dropAllowed === false && _this.state.dragOverNodeKey === null)) _this.resetDragState();
            } else if (!(dropPosition === _this.state.dropPosition && dropLevelOffset === _this.state.dropLevelOffset && dropTargetKey === _this.state.dropTargetKey && dropContainerKey === _this.state.dropContainerKey && dropTargetPos === _this.state.dropTargetPos && dropAllowed === _this.state.dropAllowed && dragOverNodeKey === _this.state.dragOverNodeKey)) _this.setState({
                dropPosition: dropPosition,
                dropLevelOffset: dropLevelOffset,
                dropTargetKey: dropTargetKey,
                dropContainerKey: dropContainerKey,
                dropTargetPos: dropTargetPos,
                dropAllowed: dropAllowed,
                dragOverNodeKey: dragOverNodeKey
            });
            onDragOver === null || onDragOver === void 0 || onDragOver({
                event: event,
                node: (0, _treeUtil.convertNodePropsToEventData)(nodeProps)
            });
        });
        (0, _defineProperty.default)((0, _assertThisInitialized.default)(_this), "onNodeDragLeave", function(event, nodeProps) {
            // if it is outside the droppable area
            // currentMouseOverDroppableNodeKey will be updated in dragenter event when into another droppable receiver.
            if (_this.currentMouseOverDroppableNodeKey === nodeProps.eventKey && !event.currentTarget.contains(event.relatedTarget)) {
                _this.resetDragState();
                _this.currentMouseOverDroppableNodeKey = null;
            }
            var onDragLeave = _this.props.onDragLeave;
            onDragLeave === null || onDragLeave === void 0 || onDragLeave({
                event: event,
                node: (0, _treeUtil.convertNodePropsToEventData)(nodeProps)
            });
        });
        // since stopPropagation() is called in treeNode
        // if onWindowDrag is called, whice means state is keeped, drag state should be cleared
        (0, _defineProperty.default)((0, _assertThisInitialized.default)(_this), "onWindowDragEnd", function(event) {
            _this.onNodeDragEnd(event, null, true);
            window.removeEventListener('dragend', _this.onWindowDragEnd);
        });
        // if onNodeDragEnd is called, onWindowDragEnd won't be called since stopPropagation() is called
        (0, _defineProperty.default)((0, _assertThisInitialized.default)(_this), "onNodeDragEnd", function(event, nodeProps) {
            var onDragEnd = _this.props.onDragEnd;
            _this.setState({
                dragOverNodeKey: null
            });
            _this.cleanDragState();
            onDragEnd === null || onDragEnd === void 0 || onDragEnd({
                event: event,
                node: (0, _treeUtil.convertNodePropsToEventData)(nodeProps)
            });
            _this.dragNodeProps = null;
            window.removeEventListener('dragend', _this.onWindowDragEnd);
        });
        (0, _defineProperty.default)((0, _assertThisInitialized.default)(_this), "onNodeDrop", function(event, _) {
            var _this$getActiveItem;
            var outsideTree = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var _this$state4 = _this.state, dragChildrenKeys = _this$state4.dragChildrenKeys, dropPosition = _this$state4.dropPosition, dropTargetKey = _this$state4.dropTargetKey, dropTargetPos = _this$state4.dropTargetPos, dropAllowed = _this$state4.dropAllowed;
            if (!dropAllowed) return;
            var onDrop = _this.props.onDrop;
            _this.setState({
                dragOverNodeKey: null
            });
            _this.cleanDragState();
            if (dropTargetKey === null) return;
            var abstractDropNodeProps = (0, _objectSpread2.default)((0, _objectSpread2.default)({}, (0, _treeUtil.getTreeNodeProps)(dropTargetKey, _this.getTreeNodeRequiredProps())), {}, {
                active: ((_this$getActiveItem = _this.getActiveItem()) === null || _this$getActiveItem === void 0 ? void 0 : _this$getActiveItem.key) === dropTargetKey,
                data: (0, _keyUtil.default)(_this.state.keyEntities, dropTargetKey).node
            });
            var dropToChild = dragChildrenKeys.includes(dropTargetKey);
            (0, _warning.default)(!dropToChild, "Can not drop to dragNode's children node. This is a bug of rc-tree. Please report an issue.");
            var posArr = (0, _util.posToArr)(dropTargetPos);
            var dropResult = {
                event: event,
                node: (0, _treeUtil.convertNodePropsToEventData)(abstractDropNodeProps),
                dragNode: _this.dragNodeProps ? (0, _treeUtil.convertNodePropsToEventData)(_this.dragNodeProps) : null,
                dragNodesKeys: [
                    _this.dragNodeProps.eventKey
                ].concat(dragChildrenKeys),
                dropToGap: dropPosition !== 0,
                dropPosition: dropPosition + Number(posArr[posArr.length - 1])
            };
            if (!outsideTree) onDrop === null || onDrop === void 0 || onDrop(dropResult);
            _this.dragNodeProps = null;
        });
        (0, _defineProperty.default)((0, _assertThisInitialized.default)(_this), "cleanDragState", function() {
            var draggingNodeKey = _this.state.draggingNodeKey;
            if (draggingNodeKey !== null) _this.setState({
                draggingNodeKey: null,
                dropPosition: null,
                dropContainerKey: null,
                dropTargetKey: null,
                dropLevelOffset: null,
                dropAllowed: true,
                dragOverNodeKey: null
            });
            _this.dragStartMousePosition = null;
            _this.currentMouseOverDroppableNodeKey = null;
        });
        (0, _defineProperty.default)((0, _assertThisInitialized.default)(_this), "triggerExpandActionExpand", function(e, treeNode) {
            var _this$state5 = _this.state, expandedKeys = _this$state5.expandedKeys, flattenNodes = _this$state5.flattenNodes;
            var expanded = treeNode.expanded, key = treeNode.key, isLeaf = treeNode.isLeaf;
            if (isLeaf || e.shiftKey || e.metaKey || e.ctrlKey) return;
            var node = flattenNodes.filter(function(nodeItem) {
                return nodeItem.key === key;
            })[0];
            var eventNode = (0, _treeUtil.convertNodePropsToEventData)((0, _objectSpread2.default)((0, _objectSpread2.default)({}, (0, _treeUtil.getTreeNodeProps)(key, _this.getTreeNodeRequiredProps())), {}, {
                data: node.data
            }));
            _this.setExpandedKeys(expanded ? (0, _util.arrDel)(expandedKeys, key) : (0, _util.arrAdd)(expandedKeys, key));
            _this.onNodeExpand(e, eventNode);
        });
        (0, _defineProperty.default)((0, _assertThisInitialized.default)(_this), "onNodeClick", function(e, treeNode) {
            var _this$props3 = _this.props, onClick = _this$props3.onClick, expandAction = _this$props3.expandAction;
            if (expandAction === 'click') _this.triggerExpandActionExpand(e, treeNode);
            onClick === null || onClick === void 0 || onClick(e, treeNode);
        });
        (0, _defineProperty.default)((0, _assertThisInitialized.default)(_this), "onNodeDoubleClick", function(e, treeNode) {
            var _this$props4 = _this.props, onDoubleClick = _this$props4.onDoubleClick, expandAction = _this$props4.expandAction;
            if (expandAction === 'doubleClick') _this.triggerExpandActionExpand(e, treeNode);
            onDoubleClick === null || onDoubleClick === void 0 || onDoubleClick(e, treeNode);
        });
        (0, _defineProperty.default)((0, _assertThisInitialized.default)(_this), "onNodeSelect", function(e, treeNode) {
            var selectedKeys = _this.state.selectedKeys;
            var _this$state6 = _this.state, keyEntities = _this$state6.keyEntities, fieldNames = _this$state6.fieldNames;
            var _this$props5 = _this.props, onSelect = _this$props5.onSelect, multiple = _this$props5.multiple;
            var selected = treeNode.selected;
            var key = treeNode[fieldNames.key];
            var targetSelected = !selected;
            // Update selected keys
            if (!targetSelected) selectedKeys = (0, _util.arrDel)(selectedKeys, key);
            else if (!multiple) selectedKeys = [
                key
            ];
            else selectedKeys = (0, _util.arrAdd)(selectedKeys, key);
            // [Legacy] Not found related usage in doc or upper libs
            var selectedNodes = selectedKeys.map(function(selectedKey) {
                var entity = (0, _keyUtil.default)(keyEntities, selectedKey);
                return entity ? entity.node : null;
            }).filter(Boolean);
            _this.setUncontrolledState({
                selectedKeys: selectedKeys
            });
            onSelect === null || onSelect === void 0 || onSelect(selectedKeys, {
                event: 'select',
                selected: targetSelected,
                node: treeNode,
                selectedNodes: selectedNodes,
                nativeEvent: e.nativeEvent
            });
        });
        (0, _defineProperty.default)((0, _assertThisInitialized.default)(_this), "onNodeCheck", function(e, treeNode, checked) {
            var _this$state7 = _this.state, keyEntities = _this$state7.keyEntities, oriCheckedKeys = _this$state7.checkedKeys, oriHalfCheckedKeys = _this$state7.halfCheckedKeys;
            var _this$props6 = _this.props, checkStrictly = _this$props6.checkStrictly, onCheck = _this$props6.onCheck;
            var key = treeNode.key;
            // Prepare trigger arguments
            var checkedObj;
            var eventObj = {
                event: 'check',
                node: treeNode,
                checked: checked,
                nativeEvent: e.nativeEvent
            };
            if (checkStrictly) {
                var checkedKeys = checked ? (0, _util.arrAdd)(oriCheckedKeys, key) : (0, _util.arrDel)(oriCheckedKeys, key);
                var halfCheckedKeys = (0, _util.arrDel)(oriHalfCheckedKeys, key);
                checkedObj = {
                    checked: checkedKeys,
                    halfChecked: halfCheckedKeys
                };
                eventObj.checkedNodes = checkedKeys.map(function(checkedKey) {
                    return (0, _keyUtil.default)(keyEntities, checkedKey);
                }).filter(Boolean).map(function(entity) {
                    return entity.node;
                });
                _this.setUncontrolledState({
                    checkedKeys: checkedKeys
                });
            } else {
                // Always fill first
                var _conductCheck = (0, _conductUtil.conductCheck)([].concat((0, _toConsumableArray.default)(oriCheckedKeys), [
                    key
                ]), true, keyEntities), _checkedKeys = _conductCheck.checkedKeys, _halfCheckedKeys = _conductCheck.halfCheckedKeys;
                // If remove, we do it again to correction
                if (!checked) {
                    var keySet = new Set(_checkedKeys);
                    keySet.delete(key);
                    var _conductCheck2 = (0, _conductUtil.conductCheck)(Array.from(keySet), {
                        checked: false,
                        halfCheckedKeys: _halfCheckedKeys
                    }, keyEntities);
                    _checkedKeys = _conductCheck2.checkedKeys;
                    _halfCheckedKeys = _conductCheck2.halfCheckedKeys;
                }
                checkedObj = _checkedKeys;
                // [Legacy] This is used for `rc-tree-select`
                eventObj.checkedNodes = [];
                eventObj.checkedNodesPositions = [];
                eventObj.halfCheckedKeys = _halfCheckedKeys;
                _checkedKeys.forEach(function(checkedKey) {
                    var entity = (0, _keyUtil.default)(keyEntities, checkedKey);
                    if (!entity) return;
                    var node = entity.node, pos = entity.pos;
                    eventObj.checkedNodes.push(node);
                    eventObj.checkedNodesPositions.push({
                        node: node,
                        pos: pos
                    });
                });
                _this.setUncontrolledState({
                    checkedKeys: _checkedKeys
                }, false, {
                    halfCheckedKeys: _halfCheckedKeys
                });
            }
            onCheck === null || onCheck === void 0 || onCheck(checkedObj, eventObj);
        });
        (0, _defineProperty.default)((0, _assertThisInitialized.default)(_this), "onNodeLoad", function(treeNode) {
            var _entity$children;
            var key = treeNode.key;
            var keyEntities = _this.state.keyEntities;
            // Skip if has children already
            var entity = (0, _keyUtil.default)(keyEntities, key);
            if (entity !== null && entity !== void 0 && (_entity$children = entity.children) !== null && _entity$children !== void 0 && _entity$children.length) return;
            var loadPromise = new Promise(function(resolve, reject) {
                // We need to get the latest state of loading/loaded keys
                _this.setState(function(_ref) {
                    var _ref$loadedKeys = _ref.loadedKeys, loadedKeys = _ref$loadedKeys === void 0 ? [] : _ref$loadedKeys, _ref$loadingKeys = _ref.loadingKeys, loadingKeys = _ref$loadingKeys === void 0 ? [] : _ref$loadingKeys;
                    var _this$props7 = _this.props, loadData = _this$props7.loadData, onLoad = _this$props7.onLoad;
                    if (!loadData || loadedKeys.includes(key) || loadingKeys.includes(key)) return null;
                    // Process load data
                    var promise = loadData(treeNode);
                    promise.then(function() {
                        var currentLoadedKeys = _this.state.loadedKeys;
                        var newLoadedKeys = (0, _util.arrAdd)(currentLoadedKeys, key);
                        // onLoad should trigger before internal setState to avoid `loadData` trigger twice.
                        // https://github.com/ant-design/ant-design/issues/12464
                        onLoad === null || onLoad === void 0 || onLoad(newLoadedKeys, {
                            event: 'load',
                            node: treeNode
                        });
                        _this.setUncontrolledState({
                            loadedKeys: newLoadedKeys
                        });
                        _this.setState(function(prevState) {
                            return {
                                loadingKeys: (0, _util.arrDel)(prevState.loadingKeys, key)
                            };
                        });
                        resolve();
                    }).catch(function(e) {
                        _this.setState(function(prevState) {
                            return {
                                loadingKeys: (0, _util.arrDel)(prevState.loadingKeys, key)
                            };
                        });
                        // If exceed max retry times, we give up retry
                        _this.loadingRetryTimes[key] = (_this.loadingRetryTimes[key] || 0) + 1;
                        if (_this.loadingRetryTimes[key] >= MAX_RETRY_TIMES) {
                            var currentLoadedKeys = _this.state.loadedKeys;
                            (0, _warning.default)(false, 'Retry for `loadData` many times but still failed. No more retry.');
                            _this.setUncontrolledState({
                                loadedKeys: (0, _util.arrAdd)(currentLoadedKeys, key)
                            });
                            resolve();
                        }
                        reject(e);
                    });
                    return {
                        loadingKeys: (0, _util.arrAdd)(loadingKeys, key)
                    };
                });
            });
            // Not care warning if we ignore this
            loadPromise.catch(function() {});
            return loadPromise;
        });
        (0, _defineProperty.default)((0, _assertThisInitialized.default)(_this), "onNodeMouseEnter", function(event, node) {
            var onMouseEnter = _this.props.onMouseEnter;
            onMouseEnter === null || onMouseEnter === void 0 || onMouseEnter({
                event: event,
                node: node
            });
        });
        (0, _defineProperty.default)((0, _assertThisInitialized.default)(_this), "onNodeMouseLeave", function(event, node) {
            var onMouseLeave = _this.props.onMouseLeave;
            onMouseLeave === null || onMouseLeave === void 0 || onMouseLeave({
                event: event,
                node: node
            });
        });
        (0, _defineProperty.default)((0, _assertThisInitialized.default)(_this), "onNodeContextMenu", function(event, node) {
            var onRightClick = _this.props.onRightClick;
            if (onRightClick) {
                event.preventDefault();
                onRightClick({
                    event: event,
                    node: node
                });
            }
        });
        (0, _defineProperty.default)((0, _assertThisInitialized.default)(_this), "onFocus", function() {
            var onFocus = _this.props.onFocus;
            _this.setState({
                focused: true
            });
            for(var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++)args[_key2] = arguments[_key2];
            onFocus === null || onFocus === void 0 || onFocus.apply(void 0, args);
        });
        (0, _defineProperty.default)((0, _assertThisInitialized.default)(_this), "onBlur", function() {
            var onBlur = _this.props.onBlur;
            _this.setState({
                focused: false
            });
            _this.onActiveChange(null);
            for(var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++)args[_key3] = arguments[_key3];
            onBlur === null || onBlur === void 0 || onBlur.apply(void 0, args);
        });
        (0, _defineProperty.default)((0, _assertThisInitialized.default)(_this), "getTreeNodeRequiredProps", function() {
            var _this$state8 = _this.state, expandedKeys = _this$state8.expandedKeys, selectedKeys = _this$state8.selectedKeys, loadedKeys = _this$state8.loadedKeys, loadingKeys = _this$state8.loadingKeys, checkedKeys = _this$state8.checkedKeys, halfCheckedKeys = _this$state8.halfCheckedKeys, dragOverNodeKey = _this$state8.dragOverNodeKey, dropPosition = _this$state8.dropPosition, keyEntities = _this$state8.keyEntities;
            return {
                expandedKeys: expandedKeys || [],
                selectedKeys: selectedKeys || [],
                loadedKeys: loadedKeys || [],
                loadingKeys: loadingKeys || [],
                checkedKeys: checkedKeys || [],
                halfCheckedKeys: halfCheckedKeys || [],
                dragOverNodeKey: dragOverNodeKey,
                dropPosition: dropPosition,
                keyEntities: keyEntities
            };
        });
        // =========================== Expanded ===========================
        /** Set uncontrolled `expandedKeys`. This will also auto update `flattenNodes`. */ (0, _defineProperty.default)((0, _assertThisInitialized.default)(_this), "setExpandedKeys", function(expandedKeys) {
            var _this$state9 = _this.state, treeData = _this$state9.treeData, fieldNames = _this$state9.fieldNames;
            var flattenNodes = (0, _treeUtil.flattenTreeData)(treeData, expandedKeys, fieldNames);
            _this.setUncontrolledState({
                expandedKeys: expandedKeys,
                flattenNodes: flattenNodes
            }, true);
        });
        (0, _defineProperty.default)((0, _assertThisInitialized.default)(_this), "onNodeExpand", function(e, treeNode) {
            var expandedKeys = _this.state.expandedKeys;
            var _this$state10 = _this.state, listChanging = _this$state10.listChanging, fieldNames = _this$state10.fieldNames;
            var _this$props8 = _this.props, onExpand = _this$props8.onExpand, loadData = _this$props8.loadData;
            var expanded = treeNode.expanded;
            var key = treeNode[fieldNames.key];
            // Do nothing when motion is in progress
            if (listChanging) return;
            // Update selected keys
            var certain = expandedKeys.includes(key);
            var targetExpanded = !expanded;
            (0, _warning.default)(expanded && certain || !expanded && !certain, 'Expand state not sync with index check');
            expandedKeys = targetExpanded ? (0, _util.arrAdd)(expandedKeys, key) : (0, _util.arrDel)(expandedKeys, key);
            _this.setExpandedKeys(expandedKeys);
            onExpand === null || onExpand === void 0 || onExpand(expandedKeys, {
                node: treeNode,
                expanded: targetExpanded,
                nativeEvent: e.nativeEvent
            });
            // Async Load data
            if (targetExpanded && loadData) {
                var loadPromise = _this.onNodeLoad(treeNode);
                if (loadPromise) loadPromise.then(function() {
                    // [Legacy] Refresh logic
                    var newFlattenTreeData = (0, _treeUtil.flattenTreeData)(_this.state.treeData, expandedKeys, fieldNames);
                    _this.setUncontrolledState({
                        flattenNodes: newFlattenTreeData
                    });
                }).catch(function() {
                    var currentExpandedKeys = _this.state.expandedKeys;
                    var expandedKeysToRestore = (0, _util.arrDel)(currentExpandedKeys, key);
                    _this.setExpandedKeys(expandedKeysToRestore);
                });
            }
        });
        (0, _defineProperty.default)((0, _assertThisInitialized.default)(_this), "onListChangeStart", function() {
            _this.setUncontrolledState({
                listChanging: true
            });
        });
        (0, _defineProperty.default)((0, _assertThisInitialized.default)(_this), "onListChangeEnd", function() {
            setTimeout(function() {
                _this.setUncontrolledState({
                    listChanging: false
                });
            });
        });
        // =========================== Keyboard ===========================
        (0, _defineProperty.default)((0, _assertThisInitialized.default)(_this), "onActiveChange", function(newActiveKey) {
            var activeKey = _this.state.activeKey;
            var _this$props9 = _this.props, onActiveChange = _this$props9.onActiveChange, _this$props9$itemScro = _this$props9.itemScrollOffset, itemScrollOffset = _this$props9$itemScro === void 0 ? 0 : _this$props9$itemScro;
            if (activeKey === newActiveKey) return;
            _this.setState({
                activeKey: newActiveKey
            });
            if (newActiveKey !== null) _this.scrollTo({
                key: newActiveKey,
                offset: itemScrollOffset
            });
            onActiveChange === null || onActiveChange === void 0 || onActiveChange(newActiveKey);
        });
        (0, _defineProperty.default)((0, _assertThisInitialized.default)(_this), "getActiveItem", function() {
            var _this$state11 = _this.state, activeKey = _this$state11.activeKey, flattenNodes = _this$state11.flattenNodes;
            if (activeKey === null) return null;
            return flattenNodes.find(function(_ref2) {
                var key = _ref2.key;
                return key === activeKey;
            }) || null;
        });
        (0, _defineProperty.default)((0, _assertThisInitialized.default)(_this), "offsetActiveKey", function(offset) {
            var _this$state12 = _this.state, flattenNodes = _this$state12.flattenNodes, activeKey = _this$state12.activeKey;
            var index = flattenNodes.findIndex(function(_ref3) {
                var key = _ref3.key;
                return key === activeKey;
            });
            // Align with index
            if (index === -1 && offset < 0) index = flattenNodes.length;
            index = (index + offset + flattenNodes.length) % flattenNodes.length;
            var item = flattenNodes[index];
            if (item) {
                var _key4 = item.key;
                _this.onActiveChange(_key4);
            } else _this.onActiveChange(null);
        });
        (0, _defineProperty.default)((0, _assertThisInitialized.default)(_this), "onKeyDown", function(event) {
            var _this$state13 = _this.state, activeKey = _this$state13.activeKey, expandedKeys = _this$state13.expandedKeys, checkedKeys = _this$state13.checkedKeys, fieldNames = _this$state13.fieldNames;
            var _this$props10 = _this.props, onKeyDown = _this$props10.onKeyDown, checkable = _this$props10.checkable, selectable = _this$props10.selectable;
            // >>>>>>>>>> Direction
            switch(event.which){
                case _KeyCode.default.UP:
                    _this.offsetActiveKey(-1);
                    event.preventDefault();
                    break;
                case _KeyCode.default.DOWN:
                    _this.offsetActiveKey(1);
                    event.preventDefault();
                    break;
            }
            // >>>>>>>>>> Expand & Selection
            var activeItem = _this.getActiveItem();
            if (activeItem && activeItem.data) {
                var treeNodeRequiredProps = _this.getTreeNodeRequiredProps();
                var expandable = activeItem.data.isLeaf === false || !!(activeItem.data[fieldNames.children] || []).length;
                var eventNode = (0, _treeUtil.convertNodePropsToEventData)((0, _objectSpread2.default)((0, _objectSpread2.default)({}, (0, _treeUtil.getTreeNodeProps)(activeKey, treeNodeRequiredProps)), {}, {
                    data: activeItem.data,
                    active: true
                }));
                switch(event.which){
                    // >>> Expand
                    case _KeyCode.default.LEFT:
                        // Collapse if possible
                        if (expandable && expandedKeys.includes(activeKey)) _this.onNodeExpand({}, eventNode);
                        else if (activeItem.parent) _this.onActiveChange(activeItem.parent.key);
                        event.preventDefault();
                        break;
                    case _KeyCode.default.RIGHT:
                        // Expand if possible
                        if (expandable && !expandedKeys.includes(activeKey)) _this.onNodeExpand({}, eventNode);
                        else if (activeItem.children && activeItem.children.length) _this.onActiveChange(activeItem.children[0].key);
                        event.preventDefault();
                        break;
                    // Selection
                    case _KeyCode.default.ENTER:
                    case _KeyCode.default.SPACE:
                        if (checkable && !eventNode.disabled && eventNode.checkable !== false && !eventNode.disableCheckbox) _this.onNodeCheck({}, eventNode, !checkedKeys.includes(activeKey));
                        else if (!checkable && selectable && !eventNode.disabled && eventNode.selectable !== false) _this.onNodeSelect({}, eventNode);
                        break;
                }
            }
            onKeyDown === null || onKeyDown === void 0 || onKeyDown(event);
        });
        /**
     * Only update the value which is not in props
     */ (0, _defineProperty.default)((0, _assertThisInitialized.default)(_this), "setUncontrolledState", function(state) {
            var atomic = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
            var forceState = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
            if (!_this.destroyed) {
                var needSync = false;
                var allPassed = true;
                var newState = {};
                Object.keys(state).forEach(function(name) {
                    if (_this.props.hasOwnProperty(name)) {
                        allPassed = false;
                        return;
                    }
                    needSync = true;
                    newState[name] = state[name];
                });
                if (needSync && (!atomic || allPassed)) _this.setState((0, _objectSpread2.default)((0, _objectSpread2.default)({}, newState), forceState));
            }
        });
        (0, _defineProperty.default)((0, _assertThisInitialized.default)(_this), "scrollTo", function(scroll) {
            _this.listRef.current.scrollTo(scroll);
        });
        return _this;
    }
    (0, _createClass.default)(Tree, [
        {
            key: "componentDidMount",
            value: function componentDidMount() {
                this.destroyed = false;
                this.onUpdated();
            }
        },
        {
            key: "componentDidUpdate",
            value: function componentDidUpdate() {
                this.onUpdated();
            }
        },
        {
            key: "onUpdated",
            value: function onUpdated() {
                var _this$props11 = this.props, activeKey = _this$props11.activeKey, _this$props11$itemScr = _this$props11.itemScrollOffset, itemScrollOffset = _this$props11$itemScr === void 0 ? 0 : _this$props11$itemScr;
                if (activeKey !== undefined && activeKey !== this.state.activeKey) {
                    this.setState({
                        activeKey: activeKey
                    });
                    if (activeKey !== null) this.scrollTo({
                        key: activeKey,
                        offset: itemScrollOffset
                    });
                }
            }
        },
        {
            key: "componentWillUnmount",
            value: function componentWillUnmount() {
                window.removeEventListener('dragend', this.onWindowDragEnd);
                this.destroyed = true;
            }
        },
        {
            key: "resetDragState",
            value: function resetDragState() {
                this.setState({
                    dragOverNodeKey: null,
                    dropPosition: null,
                    dropLevelOffset: null,
                    dropTargetKey: null,
                    dropContainerKey: null,
                    dropTargetPos: null,
                    dropAllowed: false
                });
            }
        },
        {
            key: "render",
            value: function render() {
                var _this$state14 = this.state, focused = _this$state14.focused, flattenNodes = _this$state14.flattenNodes, keyEntities = _this$state14.keyEntities, draggingNodeKey = _this$state14.draggingNodeKey, activeKey = _this$state14.activeKey, dropLevelOffset = _this$state14.dropLevelOffset, dropContainerKey = _this$state14.dropContainerKey, dropTargetKey = _this$state14.dropTargetKey, dropPosition = _this$state14.dropPosition, dragOverNodeKey = _this$state14.dragOverNodeKey, indent = _this$state14.indent;
                var _this$props12 = this.props, prefixCls = _this$props12.prefixCls, className = _this$props12.className, style = _this$props12.style, showLine = _this$props12.showLine, focusable = _this$props12.focusable, _this$props12$tabInde = _this$props12.tabIndex, tabIndex = _this$props12$tabInde === void 0 ? 0 : _this$props12$tabInde, selectable = _this$props12.selectable, showIcon = _this$props12.showIcon, icon = _this$props12.icon, switcherIcon = _this$props12.switcherIcon, draggable = _this$props12.draggable, checkable = _this$props12.checkable, checkStrictly = _this$props12.checkStrictly, disabled = _this$props12.disabled, motion = _this$props12.motion, loadData = _this$props12.loadData, filterTreeNode = _this$props12.filterTreeNode, height = _this$props12.height, itemHeight = _this$props12.itemHeight, scrollWidth = _this$props12.scrollWidth, virtual = _this$props12.virtual, titleRender = _this$props12.titleRender, dropIndicatorRender = _this$props12.dropIndicatorRender, onContextMenu = _this$props12.onContextMenu, onScroll = _this$props12.onScroll, direction = _this$props12.direction, rootClassName = _this$props12.rootClassName, rootStyle = _this$props12.rootStyle;
                var domProps = (0, _pickAttrs.default)(this.props, {
                    aria: true,
                    data: true
                });
                // It's better move to hooks but we just simply keep here
                var draggableConfig;
                if (draggable) {
                    if ((0, _typeof.default)(draggable) === 'object') draggableConfig = draggable;
                    else if (typeof draggable === 'function') draggableConfig = {
                        nodeDraggable: draggable
                    };
                    else draggableConfig = {};
                }
                var contextValue = {
                    prefixCls: prefixCls,
                    selectable: selectable,
                    showIcon: showIcon,
                    icon: icon,
                    switcherIcon: switcherIcon,
                    draggable: draggableConfig,
                    draggingNodeKey: draggingNodeKey,
                    checkable: checkable,
                    checkStrictly: checkStrictly,
                    disabled: disabled,
                    keyEntities: keyEntities,
                    dropLevelOffset: dropLevelOffset,
                    dropContainerKey: dropContainerKey,
                    dropTargetKey: dropTargetKey,
                    dropPosition: dropPosition,
                    dragOverNodeKey: dragOverNodeKey,
                    indent: indent,
                    direction: direction,
                    dropIndicatorRender: dropIndicatorRender,
                    loadData: loadData,
                    filterTreeNode: filterTreeNode,
                    titleRender: titleRender,
                    onNodeClick: this.onNodeClick,
                    onNodeDoubleClick: this.onNodeDoubleClick,
                    onNodeExpand: this.onNodeExpand,
                    onNodeSelect: this.onNodeSelect,
                    onNodeCheck: this.onNodeCheck,
                    onNodeLoad: this.onNodeLoad,
                    onNodeMouseEnter: this.onNodeMouseEnter,
                    onNodeMouseLeave: this.onNodeMouseLeave,
                    onNodeContextMenu: this.onNodeContextMenu,
                    onNodeDragStart: this.onNodeDragStart,
                    onNodeDragEnter: this.onNodeDragEnter,
                    onNodeDragOver: this.onNodeDragOver,
                    onNodeDragLeave: this.onNodeDragLeave,
                    onNodeDragEnd: this.onNodeDragEnd,
                    onNodeDrop: this.onNodeDrop
                };
                return /*#__PURE__*/ _react.createElement(_contextTypes.TreeContext.Provider, {
                    value: contextValue
                }, /*#__PURE__*/ _react.createElement("div", {
                    className: (0, _classnames.default)(prefixCls, className, rootClassName, (0, _defineProperty.default)((0, _defineProperty.default)((0, _defineProperty.default)({}, "".concat(prefixCls, "-show-line"), showLine), "".concat(prefixCls, "-focused"), focused), "".concat(prefixCls, "-active-focused"), activeKey !== null)),
                    style: rootStyle
                }, /*#__PURE__*/ _react.createElement(_NodeList.default, (0, _extends.default)({
                    ref: this.listRef,
                    prefixCls: prefixCls,
                    style: style,
                    data: flattenNodes,
                    disabled: disabled,
                    selectable: selectable,
                    checkable: !!checkable,
                    motion: motion,
                    dragging: draggingNodeKey !== null,
                    height: height,
                    itemHeight: itemHeight,
                    virtual: virtual,
                    focusable: focusable,
                    focused: focused,
                    tabIndex: tabIndex,
                    activeItem: this.getActiveItem(),
                    onFocus: this.onFocus,
                    onBlur: this.onBlur,
                    onKeyDown: this.onKeyDown,
                    onActiveChange: this.onActiveChange,
                    onListChangeStart: this.onListChangeStart,
                    onListChangeEnd: this.onListChangeEnd,
                    onContextMenu: onContextMenu,
                    onScroll: onScroll,
                    scrollWidth: scrollWidth
                }, this.getTreeNodeRequiredProps(), domProps))));
            }
        }
    ], [
        {
            key: "getDerivedStateFromProps",
            value: function getDerivedStateFromProps(props, prevState) {
                var prevProps = prevState.prevProps;
                var newState = {
                    prevProps: props
                };
                function needSync(name) {
                    return !prevProps && props.hasOwnProperty(name) || prevProps && prevProps[name] !== props[name];
                }
                // ================== Tree Node ==================
                var treeData;
                // fieldNames
                var fieldNames = prevState.fieldNames;
                if (needSync('fieldNames')) {
                    fieldNames = (0, _treeUtil.fillFieldNames)(props.fieldNames);
                    newState.fieldNames = fieldNames;
                }
                // Check if `treeData` or `children` changed and save into the state.
                if (needSync('treeData')) treeData = props.treeData;
                else if (needSync('children')) {
                    (0, _warning.default)(false, '`children` of Tree is deprecated. Please use `treeData` instead.');
                    treeData = (0, _treeUtil.convertTreeToData)(props.children);
                }
                // Save flatten nodes info and convert `treeData` into keyEntities
                if (treeData) {
                    newState.treeData = treeData;
                    var entitiesMap = (0, _treeUtil.convertDataToEntities)(treeData, {
                        fieldNames: fieldNames
                    });
                    newState.keyEntities = (0, _objectSpread2.default)((0, _defineProperty.default)({}, _NodeList.MOTION_KEY, _NodeList.MotionEntity), entitiesMap.keyEntities);
                    (0, _treeUtil.warningWithoutKey)(treeData, fieldNames);
                }
                var keyEntities = newState.keyEntities || prevState.keyEntities;
                // ================ expandedKeys =================
                if (needSync('expandedKeys') || prevProps && needSync('autoExpandParent')) newState.expandedKeys = props.autoExpandParent || !prevProps && props.defaultExpandParent ? (0, _util.conductExpandParent)(props.expandedKeys, keyEntities) : props.expandedKeys;
                else if (!prevProps && props.defaultExpandAll) {
                    var cloneKeyEntities = (0, _objectSpread2.default)({}, keyEntities);
                    delete cloneKeyEntities[_NodeList.MOTION_KEY];
                    // Only take the key who has the children to enhance the performance
                    var nextExpandedKeys = [];
                    Object.keys(cloneKeyEntities).forEach(function(key) {
                        var entity = cloneKeyEntities[key];
                        if (entity.children && entity.children.length) nextExpandedKeys.push(entity.key);
                    });
                    newState.expandedKeys = nextExpandedKeys;
                } else if (!prevProps && props.defaultExpandedKeys) newState.expandedKeys = props.autoExpandParent || props.defaultExpandParent ? (0, _util.conductExpandParent)(props.defaultExpandedKeys, keyEntities) : props.defaultExpandedKeys;
                if (!newState.expandedKeys) delete newState.expandedKeys;
                // ================ flattenNodes =================
                if (treeData || newState.expandedKeys) {
                    var flattenNodes = (0, _treeUtil.flattenTreeData)(treeData || prevState.treeData, newState.expandedKeys || prevState.expandedKeys, fieldNames);
                    newState.flattenNodes = flattenNodes;
                }
                // ================ selectedKeys =================
                if (props.selectable) {
                    if (needSync('selectedKeys')) newState.selectedKeys = (0, _util.calcSelectedKeys)(props.selectedKeys, props);
                    else if (!prevProps && props.defaultSelectedKeys) newState.selectedKeys = (0, _util.calcSelectedKeys)(props.defaultSelectedKeys, props);
                }
                // ================= checkedKeys =================
                if (props.checkable) {
                    var checkedKeyEntity;
                    if (needSync('checkedKeys')) checkedKeyEntity = (0, _util.parseCheckedKeys)(props.checkedKeys) || {};
                    else if (!prevProps && props.defaultCheckedKeys) checkedKeyEntity = (0, _util.parseCheckedKeys)(props.defaultCheckedKeys) || {};
                    else if (treeData) // If `treeData` changed, we also need check it
                    checkedKeyEntity = (0, _util.parseCheckedKeys)(props.checkedKeys) || {
                        checkedKeys: prevState.checkedKeys,
                        halfCheckedKeys: prevState.halfCheckedKeys
                    };
                    if (checkedKeyEntity) {
                        var _checkedKeyEntity = checkedKeyEntity, _checkedKeyEntity$che = _checkedKeyEntity.checkedKeys, checkedKeys = _checkedKeyEntity$che === void 0 ? [] : _checkedKeyEntity$che, _checkedKeyEntity$hal = _checkedKeyEntity.halfCheckedKeys, halfCheckedKeys = _checkedKeyEntity$hal === void 0 ? [] : _checkedKeyEntity$hal;
                        if (!props.checkStrictly) {
                            var conductKeys = (0, _conductUtil.conductCheck)(checkedKeys, true, keyEntities);
                            checkedKeys = conductKeys.checkedKeys;
                            halfCheckedKeys = conductKeys.halfCheckedKeys;
                        }
                        newState.checkedKeys = checkedKeys;
                        newState.halfCheckedKeys = halfCheckedKeys;
                    }
                }
                // ================= loadedKeys ==================
                if (needSync('loadedKeys')) newState.loadedKeys = props.loadedKeys;
                return newState;
            }
        }
    ]);
    return Tree;
}(_react.Component);
(0, _defineProperty.default)(Tree, "defaultProps", {
    prefixCls: 'rc-tree',
    showLine: false,
    showIcon: true,
    selectable: true,
    multiple: false,
    checkable: false,
    disabled: false,
    checkStrictly: false,
    draggable: false,
    defaultExpandParent: true,
    autoExpandParent: false,
    defaultExpandAll: false,
    defaultExpandedKeys: [],
    defaultCheckedKeys: [],
    defaultSelectedKeys: [],
    dropIndicatorRender: _DropIndicator.default,
    allowDrop: function allowDrop() {
        return true;
    },
    expandAction: false
});
(0, _defineProperty.default)(Tree, "TreeNode", _TreeNode.default);
var _default = Tree;

},
"node_modules/rc-tree/es/TreeNode.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _extends = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@babel/runtime/helpers/esm/extends.js"));
var _defineProperty = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@babel/runtime/helpers/esm/defineProperty.js"));
var _objectSpread2 = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@babel/runtime/helpers/esm/objectSpread2.js"));
var _slicedToArray = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@babel/runtime/helpers/esm/slicedToArray.js"));
var _objectWithoutProperties = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js"));
var _react = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/react/index.js"));
var _classnames = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/classnames/index.js"));
var _pickAttrs = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/rc-util/es/pickAttrs.js"));
var _contextTypes = __mako_require__("node_modules/rc-tree/es/contextTypes.js");
var _Indent = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/rc-tree/es/Indent.js"));
var _keyUtil = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/rc-tree/es/utils/keyUtil.js"));
var _treeUtil = __mako_require__("node_modules/rc-tree/es/utils/treeUtil.js");
var _excluded = [
    "eventKey",
    "className",
    "style",
    "dragOver",
    "dragOverGapTop",
    "dragOverGapBottom",
    "isLeaf",
    "isStart",
    "isEnd",
    "expanded",
    "selected",
    "checked",
    "halfChecked",
    "loading",
    "domRef",
    "active",
    "data",
    "onMouseMove",
    "selectable"
];
var ICON_OPEN = 'open';
var ICON_CLOSE = 'close';
var defaultTitle = '---';
var TreeNode = function TreeNode(props) {
    var _unstableContext$node, _context$filterTreeNo, _classNames4;
    var eventKey = props.eventKey, className = props.className, style = props.style, dragOver = props.dragOver, dragOverGapTop = props.dragOverGapTop, dragOverGapBottom = props.dragOverGapBottom, isLeaf = props.isLeaf, isStart = props.isStart, isEnd = props.isEnd, expanded = props.expanded, selected = props.selected, checked = props.checked, halfChecked = props.halfChecked, loading = props.loading, domRef = props.domRef, active = props.active, data = props.data, onMouseMove = props.onMouseMove, selectable = props.selectable, otherProps = (0, _objectWithoutProperties.default)(props, _excluded);
    var context = _react.default.useContext(_contextTypes.TreeContext);
    var unstableContext = _react.default.useContext(_contextTypes.UnstableContext);
    var selectHandleRef = _react.default.useRef(null);
    var _React$useState = _react.default.useState(false), _React$useState2 = (0, _slicedToArray.default)(_React$useState, 2), dragNodeHighlight = _React$useState2[0], setDragNodeHighlight = _React$useState2[1];
    // ======= State: Disabled State =======
    var isDisabled = !!(context.disabled || props.disabled || (_unstableContext$node = unstableContext.nodeDisabled) !== null && _unstableContext$node !== void 0 && _unstableContext$node.call(unstableContext, data));
    var isCheckable = _react.default.useMemo(function() {
        // Return false if tree or treeNode is not checkable
        if (!context.checkable || props.checkable === false) return false;
        return context.checkable;
    }, [
        context.checkable,
        props.checkable
    ]);
    // ======= Event Handlers: Selection and Check =======
    var onSelect = function onSelect(e) {
        if (isDisabled) return;
        context.onNodeSelect(e, (0, _treeUtil.convertNodePropsToEventData)(props));
    };
    var onCheck = function onCheck(e) {
        if (isDisabled) return;
        if (!isCheckable || props.disableCheckbox) return;
        context.onNodeCheck(e, (0, _treeUtil.convertNodePropsToEventData)(props), !checked);
    };
    // ======= State: Selectable Check =======
    var isSelectable = _react.default.useMemo(function() {
        // Ignore when selectable is undefined or null
        if (typeof selectable === 'boolean') return selectable;
        return context.selectable;
    }, [
        selectable,
        context.selectable
    ]);
    var onSelectorClick = function onSelectorClick(e) {
        // Click trigger before select/check operation
        context.onNodeClick(e, (0, _treeUtil.convertNodePropsToEventData)(props));
        if (isSelectable) onSelect(e);
        else onCheck(e);
    };
    var onSelectorDoubleClick = function onSelectorDoubleClick(e) {
        context.onNodeDoubleClick(e, (0, _treeUtil.convertNodePropsToEventData)(props));
    };
    var onMouseEnter = function onMouseEnter(e) {
        context.onNodeMouseEnter(e, (0, _treeUtil.convertNodePropsToEventData)(props));
    };
    var onMouseLeave = function onMouseLeave(e) {
        context.onNodeMouseLeave(e, (0, _treeUtil.convertNodePropsToEventData)(props));
    };
    var onContextMenu = function onContextMenu(e) {
        context.onNodeContextMenu(e, (0, _treeUtil.convertNodePropsToEventData)(props));
    };
    // ======= Drag: Drag Enabled =======
    var isDraggable = _react.default.useMemo(function() {
        return !!(context.draggable && (!context.draggable.nodeDraggable || context.draggable.nodeDraggable(data)));
    }, [
        context.draggable,
        data
    ]);
    // ======= Drag: Drag Event Handlers =======
    var onDragStart = function onDragStart(e) {
        e.stopPropagation();
        setDragNodeHighlight(true);
        context.onNodeDragStart(e, props);
        try {
            // ie throw error
            // firefox-need-it
            e.dataTransfer.setData('text/plain', '');
        } catch (_unused) {
        // empty
        }
    };
    var onDragEnter = function onDragEnter(e) {
        e.preventDefault();
        e.stopPropagation();
        context.onNodeDragEnter(e, props);
    };
    var onDragOver = function onDragOver(e) {
        e.preventDefault();
        e.stopPropagation();
        context.onNodeDragOver(e, props);
    };
    var onDragLeave = function onDragLeave(e) {
        e.stopPropagation();
        context.onNodeDragLeave(e, props);
    };
    var onDragEnd = function onDragEnd(e) {
        e.stopPropagation();
        setDragNodeHighlight(false);
        context.onNodeDragEnd(e, props);
    };
    var onDrop = function onDrop(e) {
        e.preventDefault();
        e.stopPropagation();
        setDragNodeHighlight(false);
        context.onNodeDrop(e, props);
    };
    // ======= Expand: Node Expansion =======
    var onExpand = function onExpand(e) {
        if (loading) return;
        context.onNodeExpand(e, (0, _treeUtil.convertNodePropsToEventData)(props));
    };
    // ======= State: Has Children =======
    var hasChildren = _react.default.useMemo(function() {
        var _ref = (0, _keyUtil.default)(context.keyEntities, eventKey) || {}, children = _ref.children;
        return Boolean((children || []).length);
    }, [
        context.keyEntities,
        eventKey
    ]);
    // ======= State: Leaf Check =======
    var memoizedIsLeaf = _react.default.useMemo(function() {
        if (isLeaf === false) return false;
        return isLeaf || !context.loadData && !hasChildren || context.loadData && props.loaded && !hasChildren;
    }, [
        isLeaf,
        context.loadData,
        hasChildren,
        props.loaded
    ]);
    // ============== Effect ==============
    _react.default.useEffect(function() {
        // Load data to avoid default expanded tree without data
        if (loading) return;
        // read from state to avoid loadData at same time
        if (typeof context.loadData === 'function' && expanded && !memoizedIsLeaf && !props.loaded) // We needn't reload data when has children in sync logic
        // It's only needed in node expanded
        context.onNodeLoad((0, _treeUtil.convertNodePropsToEventData)(props));
    }, [
        loading,
        context.loadData,
        context.onNodeLoad,
        expanded,
        memoizedIsLeaf,
        props
    ]);
    // ==================== Render: Drag Handler ====================
    var dragHandlerNode = _react.default.useMemo(function() {
        var _context$draggable;
        if (!((_context$draggable = context.draggable) !== null && _context$draggable !== void 0 && _context$draggable.icon)) return null;
        return /*#__PURE__*/ _react.default.createElement("span", {
            className: "".concat(context.prefixCls, "-draggable-icon")
        }, context.draggable.icon);
    }, [
        context.draggable
    ]);
    // ====================== Render: Switcher ======================
    var renderSwitcherIconDom = function renderSwitcherIconDom(isInternalLeaf) {
        var switcherIcon = props.switcherIcon || context.switcherIcon;
        // if switcherIconDom is null, no render switcher span
        if (typeof switcherIcon === 'function') return switcherIcon((0, _objectSpread2.default)((0, _objectSpread2.default)({}, props), {}, {
            isLeaf: isInternalLeaf
        }));
        return switcherIcon;
    };
    // Switcher
    var renderSwitcher = function renderSwitcher() {
        if (memoizedIsLeaf) {
            // if switcherIconDom is null, no render switcher span
            var _switcherIconDom = renderSwitcherIconDom(true);
            return _switcherIconDom !== false ? /*#__PURE__*/ _react.default.createElement("span", {
                className: (0, _classnames.default)("".concat(context.prefixCls, "-switcher"), "".concat(context.prefixCls, "-switcher-noop"))
            }, _switcherIconDom) : null;
        }
        var switcherIconDom = renderSwitcherIconDom(false);
        return switcherIconDom !== false ? /*#__PURE__*/ _react.default.createElement("span", {
            onClick: onExpand,
            className: (0, _classnames.default)("".concat(context.prefixCls, "-switcher"), "".concat(context.prefixCls, "-switcher_").concat(expanded ? ICON_OPEN : ICON_CLOSE))
        }, switcherIconDom) : null;
    };
    // ====================== Checkbox ======================
    var checkboxNode = _react.default.useMemo(function() {
        if (!isCheckable) return null;
        // [Legacy] Custom element should be separate with `checkable` in future
        var $custom = typeof isCheckable !== 'boolean' ? isCheckable : null;
        return /*#__PURE__*/ _react.default.createElement("span", {
            className: (0, _classnames.default)("".concat(context.prefixCls, "-checkbox"), (0, _defineProperty.default)((0, _defineProperty.default)((0, _defineProperty.default)({}, "".concat(context.prefixCls, "-checkbox-checked"), checked), "".concat(context.prefixCls, "-checkbox-indeterminate"), !checked && halfChecked), "".concat(context.prefixCls, "-checkbox-disabled"), isDisabled || props.disableCheckbox)),
            onClick: onCheck,
            role: "checkbox",
            "aria-checked": halfChecked ? 'mixed' : checked,
            "aria-disabled": isDisabled || props.disableCheckbox,
            "aria-label": "Select ".concat(typeof props.title === 'string' ? props.title : 'tree node')
        }, $custom);
    }, [
        isCheckable,
        checked,
        halfChecked,
        isDisabled,
        props.disableCheckbox,
        props.title
    ]);
    // ============== State: Node State (Open/Close) ==============
    var nodeState = _react.default.useMemo(function() {
        if (memoizedIsLeaf) return null;
        return expanded ? ICON_OPEN : ICON_CLOSE;
    }, [
        memoizedIsLeaf,
        expanded
    ]);
    // ==================== Render: Title + Icon ====================
    var iconNode = _react.default.useMemo(function() {
        return /*#__PURE__*/ _react.default.createElement("span", {
            className: (0, _classnames.default)("".concat(context.prefixCls, "-iconEle"), "".concat(context.prefixCls, "-icon__").concat(nodeState || 'docu'), (0, _defineProperty.default)({}, "".concat(context.prefixCls, "-icon_loading"), loading))
        });
    }, [
        context.prefixCls,
        nodeState,
        loading
    ]);
    // =================== Drop Indicator ===================
    var dropIndicatorNode = _react.default.useMemo(function() {
        var rootDraggable = Boolean(context.draggable);
        // allowDrop is calculated in Tree.tsx, there is no need for calc it here
        var showIndicator = !props.disabled && rootDraggable && context.dragOverNodeKey === eventKey;
        if (!showIndicator) return null;
        return context.dropIndicatorRender({
            dropPosition: context.dropPosition,
            dropLevelOffset: context.dropLevelOffset,
            indent: context.indent,
            prefixCls: context.prefixCls,
            direction: context.direction
        });
    }, [
        context.dropPosition,
        context.dropLevelOffset,
        context.indent,
        context.prefixCls,
        context.direction,
        context.draggable,
        context.dragOverNodeKey,
        context.dropIndicatorRender
    ]);
    // Icon + Title
    var selectorNode = _react.default.useMemo(function() {
        var _props$title = props.title, title = _props$title === void 0 ? defaultTitle : _props$title;
        var wrapClass = "".concat(context.prefixCls, "-node-content-wrapper");
        // Icon - Still show loading icon when loading without showIcon
        var $icon;
        if (context.showIcon) {
            var currentIcon = props.icon || context.icon;
            $icon = currentIcon ? /*#__PURE__*/ _react.default.createElement("span", {
                className: (0, _classnames.default)("".concat(context.prefixCls, "-iconEle"), "".concat(context.prefixCls, "-icon__customize"))
            }, typeof currentIcon === 'function' ? currentIcon(props) : currentIcon) : iconNode;
        } else if (context.loadData && loading) $icon = iconNode;
        // Title
        var titleNode;
        if (typeof title === 'function') titleNode = title(data);
        else if (context.titleRender) titleNode = context.titleRender(data);
        else titleNode = title;
        return /*#__PURE__*/ _react.default.createElement("span", {
            ref: selectHandleRef,
            title: typeof title === 'string' ? title : '',
            className: (0, _classnames.default)(wrapClass, "".concat(wrapClass, "-").concat(nodeState || 'normal'), (0, _defineProperty.default)({}, "".concat(context.prefixCls, "-node-selected"), !isDisabled && (selected || dragNodeHighlight))),
            onMouseEnter: onMouseEnter,
            onMouseLeave: onMouseLeave,
            onContextMenu: onContextMenu,
            onClick: onSelectorClick,
            onDoubleClick: onSelectorDoubleClick
        }, $icon, /*#__PURE__*/ _react.default.createElement("span", {
            className: "".concat(context.prefixCls, "-title")
        }, titleNode), dropIndicatorNode);
    }, [
        context.prefixCls,
        context.showIcon,
        props,
        context.icon,
        iconNode,
        context.titleRender,
        data,
        nodeState,
        onMouseEnter,
        onMouseLeave,
        onContextMenu,
        onSelectorClick,
        onSelectorDoubleClick
    ]);
    var dataOrAriaAttributeProps = (0, _pickAttrs.default)(otherProps, {
        aria: true,
        data: true
    });
    var _ref2 = (0, _keyUtil.default)(context.keyEntities, eventKey) || {}, level = _ref2.level;
    var isEndNode = isEnd[isEnd.length - 1];
    var draggableWithoutDisabled = !isDisabled && isDraggable;
    var dragging = context.draggingNodeKey === eventKey;
    var ariaSelected = selectable !== undefined ? {
        'aria-selected': !!selectable
    } : undefined;
    return /*#__PURE__*/ _react.default.createElement("div", (0, _extends.default)({
        ref: domRef,
        role: "treeitem",
        "aria-expanded": isLeaf ? undefined : expanded,
        className: (0, _classnames.default)(className, "".concat(context.prefixCls, "-treenode"), (_classNames4 = {}, (0, _defineProperty.default)((0, _defineProperty.default)((0, _defineProperty.default)((0, _defineProperty.default)((0, _defineProperty.default)((0, _defineProperty.default)((0, _defineProperty.default)((0, _defineProperty.default)((0, _defineProperty.default)((0, _defineProperty.default)(_classNames4, "".concat(context.prefixCls, "-treenode-disabled"), isDisabled), "".concat(context.prefixCls, "-treenode-switcher-").concat(expanded ? 'open' : 'close'), !isLeaf), "".concat(context.prefixCls, "-treenode-checkbox-checked"), checked), "".concat(context.prefixCls, "-treenode-checkbox-indeterminate"), halfChecked), "".concat(context.prefixCls, "-treenode-selected"), selected), "".concat(context.prefixCls, "-treenode-loading"), loading), "".concat(context.prefixCls, "-treenode-active"), active), "".concat(context.prefixCls, "-treenode-leaf-last"), isEndNode), "".concat(context.prefixCls, "-treenode-draggable"), isDraggable), "dragging", dragging), (0, _defineProperty.default)((0, _defineProperty.default)((0, _defineProperty.default)((0, _defineProperty.default)((0, _defineProperty.default)((0, _defineProperty.default)((0, _defineProperty.default)(_classNames4, 'drop-target', context.dropTargetKey === eventKey), 'drop-container', context.dropContainerKey === eventKey), 'drag-over', !isDisabled && dragOver), 'drag-over-gap-top', !isDisabled && dragOverGapTop), 'drag-over-gap-bottom', !isDisabled && dragOverGapBottom), 'filter-node', (_context$filterTreeNo = context.filterTreeNode) === null || _context$filterTreeNo === void 0 ? void 0 : _context$filterTreeNo.call(context, (0, _treeUtil.convertNodePropsToEventData)(props))), "".concat(context.prefixCls, "-treenode-leaf"), memoizedIsLeaf))),
        style: style,
        draggable: draggableWithoutDisabled,
        onDragStart: draggableWithoutDisabled ? onDragStart : undefined,
        onDragEnter: isDraggable ? onDragEnter : undefined,
        onDragOver: isDraggable ? onDragOver : undefined,
        onDragLeave: isDraggable ? onDragLeave : undefined,
        onDrop: isDraggable ? onDrop : undefined,
        onDragEnd: isDraggable ? onDragEnd : undefined,
        onMouseMove: onMouseMove
    }, ariaSelected, dataOrAriaAttributeProps), /*#__PURE__*/ _react.default.createElement(_Indent.default, {
        prefixCls: context.prefixCls,
        level: level,
        isStart: isStart,
        isEnd: isEnd
    }), dragHandlerNode, renderSwitcher(), checkboxNode, selectorNode);
};
TreeNode.isTreeNode = 1;
TreeNode.displayName = 'TreeNode';
var _default = TreeNode;

},
"node_modules/rc-tree/es/contextTypes.js": function (module, exports, __mako_require__){
/**
 * Webpack has bug for import loop, which is not the same behavior as ES module.
 * When util.js imports the TreeNode for tree generate will cause treeContextTypes be empty.
 */ "use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    TreeContext: function() {
        return TreeContext;
    },
    UnstableContext: function() {
        return UnstableContext;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
var TreeContext = /*#__PURE__*/ _react.createContext(null);
var UnstableContext = /*#__PURE__*/ _react.createContext({});

},
"node_modules/rc-tree/es/index.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    TreeNode: function() {
        return _TreeNode.default;
    },
    UnstableContext: function() {
        return _contextTypes.UnstableContext;
    },
    default: function() {
        return _default;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _Tree = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/rc-tree/es/Tree.js"));
var _TreeNode = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/rc-tree/es/TreeNode.js"));
var _contextTypes = __mako_require__("node_modules/rc-tree/es/contextTypes.js");
var _default = _Tree.default;

},
"node_modules/rc-tree/es/useUnmount.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _slicedToArray = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@babel/runtime/helpers/esm/slicedToArray.js"));
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
var _useLayoutEffect = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/rc-util/es/hooks/useLayoutEffect.js"));
/**
 * Trigger only when component unmount
 */ function useUnmount(triggerStart, triggerEnd) {
    var _React$useState = _react.useState(false), _React$useState2 = (0, _slicedToArray.default)(_React$useState, 2), firstMount = _React$useState2[0], setFirstMount = _React$useState2[1];
    (0, _useLayoutEffect.default)(function() {
        if (firstMount) {
            triggerStart();
            return function() {
                triggerEnd();
            };
        }
    }, [
        firstMount
    ]);
    (0, _useLayoutEffect.default)(function() {
        setFirstMount(true);
        return function() {
            setFirstMount(false);
        };
    }, []);
}
var _default = useUnmount;

},
"node_modules/rc-tree/es/util.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    arrAdd: function() {
        return arrAdd;
    },
    arrDel: function() {
        return arrDel;
    },
    calcDropPosition: function() {
        return calcDropPosition;
    },
    calcSelectedKeys: function() {
        return calcSelectedKeys;
    },
    conductExpandParent: function() {
        return conductExpandParent;
    },
    convertDataToTree: function() {
        return convertDataToTree;
    },
    getDragChildrenKeys: function() {
        return getDragChildrenKeys;
    },
    getPosition: function() {
        return _treeUtil.getPosition;
    },
    isFirstChild: function() {
        return isFirstChild;
    },
    isLastChild: function() {
        return isLastChild;
    },
    isTreeNode: function() {
        return _treeUtil.isTreeNode;
    },
    parseCheckedKeys: function() {
        return parseCheckedKeys;
    },
    posToArr: function() {
        return posToArr;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _toConsumableArray = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@babel/runtime/helpers/esm/toConsumableArray.js"));
var _typeof = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@babel/runtime/helpers/esm/typeof.js"));
var _extends = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@babel/runtime/helpers/esm/extends.js"));
var _objectWithoutProperties = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js"));
var _warning = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/rc-util/es/warning.js"));
var _react = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/react/index.js"));
var _TreeNode = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/rc-tree/es/TreeNode.js"));
var _keyUtil = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/rc-tree/es/utils/keyUtil.js"));
var _treeUtil = __mako_require__("node_modules/rc-tree/es/utils/treeUtil.js");
var _excluded = [
    "children"
];
function arrDel(list, value) {
    if (!list) return [];
    var clone = list.slice();
    var index = clone.indexOf(value);
    if (index >= 0) clone.splice(index, 1);
    return clone;
}
function arrAdd(list, value) {
    var clone = (list || []).slice();
    if (clone.indexOf(value) === -1) clone.push(value);
    return clone;
}
function posToArr(pos) {
    return pos.split('-');
}
function getDragChildrenKeys(dragNodeKey, keyEntities) {
    // not contains self
    // self for left or right drag
    var dragChildrenKeys = [];
    var entity = (0, _keyUtil.default)(keyEntities, dragNodeKey);
    function dig() {
        var list = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        list.forEach(function(_ref) {
            var key = _ref.key, children = _ref.children;
            dragChildrenKeys.push(key);
            dig(children);
        });
    }
    dig(entity.children);
    return dragChildrenKeys;
}
function isLastChild(treeNodeEntity) {
    if (treeNodeEntity.parent) {
        var posArr = posToArr(treeNodeEntity.pos);
        return Number(posArr[posArr.length - 1]) === treeNodeEntity.parent.children.length - 1;
    }
    return false;
}
function isFirstChild(treeNodeEntity) {
    var posArr = posToArr(treeNodeEntity.pos);
    return Number(posArr[posArr.length - 1]) === 0;
}
function calcDropPosition(event, dragNodeProps, targetNodeProps, indent, startMousePosition, allowDrop, flattenedNodes, keyEntities, expandKeys, direction) {
    var _abstractDropNodeEnti;
    var clientX = event.clientX, clientY = event.clientY;
    var _getBoundingClientRec = event.target.getBoundingClientRect(), top = _getBoundingClientRec.top, height = _getBoundingClientRec.height;
    // optional chain for testing
    var horizontalMouseOffset = (direction === 'rtl' ? -1 : 1) * (((startMousePosition === null || startMousePosition === void 0 ? void 0 : startMousePosition.x) || 0) - clientX);
    var rawDropLevelOffset = (horizontalMouseOffset - 12) / indent;
    // Filter the expanded keys to exclude the node that not has children currently (like async nodes).
    var filteredExpandKeys = expandKeys.filter(function(key) {
        var _keyEntities$key;
        return (_keyEntities$key = keyEntities[key]) === null || _keyEntities$key === void 0 || (_keyEntities$key = _keyEntities$key.children) === null || _keyEntities$key === void 0 ? void 0 : _keyEntities$key.length;
    });
    // find abstract drop node by horizontal offset
    var abstractDropNodeEntity = (0, _keyUtil.default)(keyEntities, targetNodeProps.eventKey);
    if (clientY < top + height / 2) {
        // first half, set abstract drop node to previous node
        var nodeIndex = flattenedNodes.findIndex(function(flattenedNode) {
            return flattenedNode.key === abstractDropNodeEntity.key;
        });
        var prevNodeIndex = nodeIndex <= 0 ? 0 : nodeIndex - 1;
        var prevNodeKey = flattenedNodes[prevNodeIndex].key;
        abstractDropNodeEntity = (0, _keyUtil.default)(keyEntities, prevNodeKey);
    }
    var initialAbstractDropNodeKey = abstractDropNodeEntity.key;
    var abstractDragOverEntity = abstractDropNodeEntity;
    var dragOverNodeKey = abstractDropNodeEntity.key;
    var dropPosition = 0;
    var dropLevelOffset = 0;
    // Only allow cross level drop when dragging on a non-expanded node
    if (!filteredExpandKeys.includes(initialAbstractDropNodeKey)) for(var i = 0; i < rawDropLevelOffset; i += 1){
        if (isLastChild(abstractDropNodeEntity)) {
            abstractDropNodeEntity = abstractDropNodeEntity.parent;
            dropLevelOffset += 1;
        } else break;
    }
    var abstractDragDataNode = dragNodeProps.data;
    var abstractDropDataNode = abstractDropNodeEntity.node;
    var dropAllowed = true;
    if (isFirstChild(abstractDropNodeEntity) && abstractDropNodeEntity.level === 0 && clientY < top + height / 2 && allowDrop({
        dragNode: abstractDragDataNode,
        dropNode: abstractDropDataNode,
        dropPosition: -1
    }) && abstractDropNodeEntity.key === targetNodeProps.eventKey) // first half of first node in first level
    dropPosition = -1;
    else if ((abstractDragOverEntity.children || []).length && filteredExpandKeys.includes(dragOverNodeKey)) {
        // drop on expanded node
        // only allow drop inside
        if (allowDrop({
            dragNode: abstractDragDataNode,
            dropNode: abstractDropDataNode,
            dropPosition: 0
        })) dropPosition = 0;
        else dropAllowed = false;
    } else if (dropLevelOffset === 0) {
        if (rawDropLevelOffset > -1.5) {
            // | Node     | <- abstractDropNode
            // | -^-===== | <- mousePosition
            // 1. try drop after
            // 2. do not allow drop
            if (allowDrop({
                dragNode: abstractDragDataNode,
                dropNode: abstractDropDataNode,
                dropPosition: 1
            })) dropPosition = 1;
            else dropAllowed = false;
        } else {
            // | Node     | <- abstractDropNode
            // | ---==^== | <- mousePosition
            // whether it has children or doesn't has children
            // always
            // 1. try drop inside
            // 2. try drop after
            // 3. do not allow drop
            if (allowDrop({
                dragNode: abstractDragDataNode,
                dropNode: abstractDropDataNode,
                dropPosition: 0
            })) dropPosition = 0;
            else if (allowDrop({
                dragNode: abstractDragDataNode,
                dropNode: abstractDropDataNode,
                dropPosition: 1
            })) dropPosition = 1;
            else dropAllowed = false;
        }
    } else // | Node1 | <- abstractDropNode
    //      |  Node2  |
    // --^--|----=====| <- mousePosition
    // 1. try insert after Node1
    // 2. do not allow drop
    if (allowDrop({
        dragNode: abstractDragDataNode,
        dropNode: abstractDropDataNode,
        dropPosition: 1
    })) dropPosition = 1;
    else dropAllowed = false;
    return {
        dropPosition: dropPosition,
        dropLevelOffset: dropLevelOffset,
        dropTargetKey: abstractDropNodeEntity.key,
        dropTargetPos: abstractDropNodeEntity.pos,
        dragOverNodeKey: dragOverNodeKey,
        dropContainerKey: dropPosition === 0 ? null : ((_abstractDropNodeEnti = abstractDropNodeEntity.parent) === null || _abstractDropNodeEnti === void 0 ? void 0 : _abstractDropNodeEnti.key) || null,
        dropAllowed: dropAllowed
    };
}
function calcSelectedKeys(selectedKeys, props) {
    if (!selectedKeys) return undefined;
    var multiple = props.multiple;
    if (multiple) return selectedKeys.slice();
    if (selectedKeys.length) return [
        selectedKeys[0]
    ];
    return selectedKeys;
}
var internalProcessProps = function internalProcessProps(props) {
    return props;
};
function convertDataToTree(treeData, processor) {
    if (!treeData) return [];
    var _ref2 = processor || {}, _ref2$processProps = _ref2.processProps, processProps = _ref2$processProps === void 0 ? internalProcessProps : _ref2$processProps;
    var list = Array.isArray(treeData) ? treeData : [
        treeData
    ];
    return list.map(function(_ref3) {
        var children = _ref3.children, props = (0, _objectWithoutProperties.default)(_ref3, _excluded);
        var childrenNodes = convertDataToTree(children, processor);
        return /*#__PURE__*/ _react.default.createElement(_TreeNode.default, (0, _extends.default)({
            key: props.key
        }, processProps(props)), childrenNodes);
    });
}
function parseCheckedKeys(keys) {
    if (!keys) return null;
    // Convert keys to object format
    var keyProps;
    if (Array.isArray(keys)) // [Legacy] Follow the api doc
    keyProps = {
        checkedKeys: keys,
        halfCheckedKeys: undefined
    };
    else if ((0, _typeof.default)(keys) === 'object') keyProps = {
        checkedKeys: keys.checked || undefined,
        halfCheckedKeys: keys.halfChecked || undefined
    };
    else {
        (0, _warning.default)(false, '`checkedKeys` is not an array or an object');
        return null;
    }
    return keyProps;
}
function conductExpandParent(keyList, keyEntities) {
    var expandedKeys = new Set();
    function conductUp(key) {
        if (expandedKeys.has(key)) return;
        var entity = (0, _keyUtil.default)(keyEntities, key);
        if (!entity) return;
        expandedKeys.add(key);
        var parent = entity.parent, node = entity.node;
        if (node.disabled) return;
        if (parent) conductUp(parent.key);
    }
    (keyList || []).forEach(function(key) {
        conductUp(key);
    });
    return (0, _toConsumableArray.default)(expandedKeys);
}

},
"node_modules/rc-tree/es/utils/conductUtil.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    conductCheck: function() {
        return conductCheck;
    },
    isCheckDisabled: function() {
        return isCheckDisabled;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _warning = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/rc-util/es/warning.js"));
var _keyUtil = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/rc-tree/es/utils/keyUtil.js"));
function removeFromCheckedKeys(halfCheckedKeys, checkedKeys) {
    var filteredKeys = new Set();
    halfCheckedKeys.forEach(function(key) {
        if (!checkedKeys.has(key)) filteredKeys.add(key);
    });
    return filteredKeys;
}
function isCheckDisabled(node) {
    var _ref = node || {}, disabled = _ref.disabled, disableCheckbox = _ref.disableCheckbox, checkable = _ref.checkable;
    return !!(disabled || disableCheckbox) || checkable === false;
}
// Fill miss keys
function fillConductCheck(keys, levelEntities, maxLevel, syntheticGetCheckDisabled) {
    var checkedKeys = new Set(keys);
    var halfCheckedKeys = new Set();
    // Add checked keys top to bottom
    for(var level = 0; level <= maxLevel; level += 1){
        var entities = levelEntities.get(level) || new Set();
        entities.forEach(function(entity) {
            var key = entity.key, node = entity.node, _entity$children = entity.children, children = _entity$children === void 0 ? [] : _entity$children;
            if (checkedKeys.has(key) && !syntheticGetCheckDisabled(node)) children.filter(function(childEntity) {
                return !syntheticGetCheckDisabled(childEntity.node);
            }).forEach(function(childEntity) {
                checkedKeys.add(childEntity.key);
            });
        });
    }
    // Add checked keys from bottom to top
    var visitedKeys = new Set();
    for(var _level = maxLevel; _level >= 0; _level -= 1){
        var _entities = levelEntities.get(_level) || new Set();
        _entities.forEach(function(entity) {
            var parent = entity.parent, node = entity.node;
            // Skip if no need to check
            if (syntheticGetCheckDisabled(node) || !entity.parent || visitedKeys.has(entity.parent.key)) return;
            // Skip if parent is disabled
            if (syntheticGetCheckDisabled(entity.parent.node)) {
                visitedKeys.add(parent.key);
                return;
            }
            var allChecked = true;
            var partialChecked = false;
            (parent.children || []).filter(function(childEntity) {
                return !syntheticGetCheckDisabled(childEntity.node);
            }).forEach(function(_ref2) {
                var key = _ref2.key;
                var checked = checkedKeys.has(key);
                if (allChecked && !checked) allChecked = false;
                if (!partialChecked && (checked || halfCheckedKeys.has(key))) partialChecked = true;
            });
            if (allChecked) checkedKeys.add(parent.key);
            if (partialChecked) halfCheckedKeys.add(parent.key);
            visitedKeys.add(parent.key);
        });
    }
    return {
        checkedKeys: Array.from(checkedKeys),
        halfCheckedKeys: Array.from(removeFromCheckedKeys(halfCheckedKeys, checkedKeys))
    };
}
// Remove useless key
function cleanConductCheck(keys, halfKeys, levelEntities, maxLevel, syntheticGetCheckDisabled) {
    var checkedKeys = new Set(keys);
    var halfCheckedKeys = new Set(halfKeys);
    // Remove checked keys from top to bottom
    for(var level = 0; level <= maxLevel; level += 1){
        var entities = levelEntities.get(level) || new Set();
        entities.forEach(function(entity) {
            var key = entity.key, node = entity.node, _entity$children2 = entity.children, children = _entity$children2 === void 0 ? [] : _entity$children2;
            if (!checkedKeys.has(key) && !halfCheckedKeys.has(key) && !syntheticGetCheckDisabled(node)) children.filter(function(childEntity) {
                return !syntheticGetCheckDisabled(childEntity.node);
            }).forEach(function(childEntity) {
                checkedKeys.delete(childEntity.key);
            });
        });
    }
    // Remove checked keys form bottom to top
    halfCheckedKeys = new Set();
    var visitedKeys = new Set();
    for(var _level2 = maxLevel; _level2 >= 0; _level2 -= 1){
        var _entities2 = levelEntities.get(_level2) || new Set();
        _entities2.forEach(function(entity) {
            var parent = entity.parent, node = entity.node;
            // Skip if no need to check
            if (syntheticGetCheckDisabled(node) || !entity.parent || visitedKeys.has(entity.parent.key)) return;
            // Skip if parent is disabled
            if (syntheticGetCheckDisabled(entity.parent.node)) {
                visitedKeys.add(parent.key);
                return;
            }
            var allChecked = true;
            var partialChecked = false;
            (parent.children || []).filter(function(childEntity) {
                return !syntheticGetCheckDisabled(childEntity.node);
            }).forEach(function(_ref3) {
                var key = _ref3.key;
                var checked = checkedKeys.has(key);
                if (allChecked && !checked) allChecked = false;
                if (!partialChecked && (checked || halfCheckedKeys.has(key))) partialChecked = true;
            });
            if (!allChecked) checkedKeys.delete(parent.key);
            if (partialChecked) halfCheckedKeys.add(parent.key);
            visitedKeys.add(parent.key);
        });
    }
    return {
        checkedKeys: Array.from(checkedKeys),
        halfCheckedKeys: Array.from(removeFromCheckedKeys(halfCheckedKeys, checkedKeys))
    };
}
function conductCheck(keyList, checked, keyEntities, getCheckDisabled) {
    var warningMissKeys = [];
    var syntheticGetCheckDisabled;
    if (getCheckDisabled) syntheticGetCheckDisabled = getCheckDisabled;
    else syntheticGetCheckDisabled = isCheckDisabled;
    // We only handle exist keys
    var keys = new Set(keyList.filter(function(key) {
        var hasEntity = !!(0, _keyUtil.default)(keyEntities, key);
        if (!hasEntity) warningMissKeys.push(key);
        return hasEntity;
    }));
    var levelEntities = new Map();
    var maxLevel = 0;
    // Convert entities by level for calculation
    Object.keys(keyEntities).forEach(function(key) {
        var entity = keyEntities[key];
        var level = entity.level;
        var levelSet = levelEntities.get(level);
        if (!levelSet) {
            levelSet = new Set();
            levelEntities.set(level, levelSet);
        }
        levelSet.add(entity);
        maxLevel = Math.max(maxLevel, level);
    });
    (0, _warning.default)(!warningMissKeys.length, "Tree missing follow keys: ".concat(warningMissKeys.slice(0, 100).map(function(key) {
        return "'".concat(key, "'");
    }).join(', ')));
    var result;
    if (checked === true) result = fillConductCheck(keys, levelEntities, maxLevel, syntheticGetCheckDisabled);
    else result = cleanConductCheck(keys, checked.halfCheckedKeys, levelEntities, maxLevel, syntheticGetCheckDisabled);
    return result;
}

},
"node_modules/rc-tree/es/utils/diffUtil.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    findExpandedKeys: function() {
        return findExpandedKeys;
    },
    getExpandRange: function() {
        return getExpandRange;
    }
});
function findExpandedKeys() {
    var prev = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var next = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var prevLen = prev.length;
    var nextLen = next.length;
    if (Math.abs(prevLen - nextLen) !== 1) return {
        add: false,
        key: null
    };
    function find(shorter, longer) {
        var cache = new Map();
        shorter.forEach(function(key) {
            cache.set(key, true);
        });
        var keys = longer.filter(function(key) {
            return !cache.has(key);
        });
        return keys.length === 1 ? keys[0] : null;
    }
    if (prevLen < nextLen) return {
        add: true,
        key: find(prev, next)
    };
    return {
        add: false,
        key: find(next, prev)
    };
}
function getExpandRange(shorter, longer, key) {
    var shorterStartIndex = shorter.findIndex(function(data) {
        return data.key === key;
    });
    var shorterEndNode = shorter[shorterStartIndex + 1];
    var longerStartIndex = longer.findIndex(function(data) {
        return data.key === key;
    });
    if (shorterEndNode) {
        var longerEndIndex = longer.findIndex(function(data) {
            return data.key === shorterEndNode.key;
        });
        return longer.slice(longerStartIndex + 1, longerEndIndex);
    }
    return longer.slice(longerStartIndex + 1);
}

},
"node_modules/rc-tree/es/utils/keyUtil.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return getEntity;
    }
});
function getEntity(keyEntities, key) {
    return keyEntities[key];
}

},
"node_modules/rc-tree/es/utils/treeUtil.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    convertDataToEntities: function() {
        return convertDataToEntities;
    },
    convertNodePropsToEventData: function() {
        return convertNodePropsToEventData;
    },
    convertTreeToData: function() {
        return convertTreeToData;
    },
    fillFieldNames: function() {
        return fillFieldNames;
    },
    flattenTreeData: function() {
        return flattenTreeData;
    },
    getKey: function() {
        return getKey;
    },
    getPosition: function() {
        return getPosition;
    },
    getTreeNodeProps: function() {
        return getTreeNodeProps;
    },
    isTreeNode: function() {
        return isTreeNode;
    },
    traverseDataNodes: function() {
        return traverseDataNodes;
    },
    warningWithoutKey: function() {
        return warningWithoutKey;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _typeof = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@babel/runtime/helpers/esm/typeof.js"));
var _toConsumableArray = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@babel/runtime/helpers/esm/toConsumableArray.js"));
var _objectSpread2 = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@babel/runtime/helpers/esm/objectSpread2.js"));
var _objectWithoutProperties = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js"));
var _toArray = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/rc-util/es/Children/toArray.js"));
var _omit = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/rc-util/es/omit.js"));
var _warning = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/rc-util/es/warning.js"));
var _keyUtil = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/rc-tree/es/utils/keyUtil.js"));
var _excluded = [
    "children"
];
function getPosition(level, index) {
    return "".concat(level, "-").concat(index);
}
function isTreeNode(node) {
    return node && node.type && node.type.isTreeNode;
}
function getKey(key, pos) {
    if (key !== null && key !== undefined) return key;
    return pos;
}
function fillFieldNames(fieldNames) {
    var _ref = fieldNames || {}, title = _ref.title, _title = _ref._title, key = _ref.key, children = _ref.children;
    var mergedTitle = title || 'title';
    return {
        title: mergedTitle,
        _title: _title || [
            mergedTitle
        ],
        key: key || 'key',
        children: children || 'children'
    };
}
function warningWithoutKey(treeData, fieldNames) {
    var keys = new Map();
    function dig(list) {
        var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
        (list || []).forEach(function(treeNode) {
            var key = treeNode[fieldNames.key];
            var children = treeNode[fieldNames.children];
            (0, _warning.default)(key !== null && key !== undefined, "Tree node must have a certain key: [".concat(path).concat(key, "]"));
            var recordKey = String(key);
            (0, _warning.default)(!keys.has(recordKey) || key === null || key === undefined, "Same 'key' exist in the Tree: ".concat(recordKey));
            keys.set(recordKey, true);
            dig(children, "".concat(path).concat(recordKey, " > "));
        });
    }
    dig(treeData);
}
function convertTreeToData(rootNodes) {
    function dig(node) {
        var treeNodes = (0, _toArray.default)(node);
        return treeNodes.map(function(treeNode) {
            // Filter invalidate node
            if (!isTreeNode(treeNode)) {
                (0, _warning.default)(!treeNode, 'Tree/TreeNode can only accept TreeNode as children.');
                return null;
            }
            var key = treeNode.key;
            var _treeNode$props = treeNode.props, children = _treeNode$props.children, rest = (0, _objectWithoutProperties.default)(_treeNode$props, _excluded);
            var dataNode = (0, _objectSpread2.default)({
                key: key
            }, rest);
            var parsedChildren = dig(children);
            if (parsedChildren.length) dataNode.children = parsedChildren;
            return dataNode;
        }).filter(function(dataNode) {
            return dataNode;
        });
    }
    return dig(rootNodes);
}
function flattenTreeData(treeNodeList, expandedKeys, fieldNames) {
    var _fillFieldNames = fillFieldNames(fieldNames), fieldTitles = _fillFieldNames._title, fieldKey = _fillFieldNames.key, fieldChildren = _fillFieldNames.children;
    var expandedKeySet = new Set(expandedKeys === true ? [] : expandedKeys);
    var flattenList = [];
    function dig(list) {
        var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        return list.map(function(treeNode, index) {
            var pos = getPosition(parent ? parent.pos : '0', index);
            var mergedKey = getKey(treeNode[fieldKey], pos);
            // Pick matched title in field title list
            var mergedTitle;
            for(var i = 0; i < fieldTitles.length; i += 1){
                var fieldTitle = fieldTitles[i];
                if (treeNode[fieldTitle] !== undefined) {
                    mergedTitle = treeNode[fieldTitle];
                    break;
                }
            }
            // Add FlattenDataNode into list
            // We use `Object.assign` here to save perf since babel's `objectSpread` has perf issue
            var flattenNode = Object.assign((0, _omit.default)(treeNode, [].concat((0, _toConsumableArray.default)(fieldTitles), [
                fieldKey,
                fieldChildren
            ])), {
                title: mergedTitle,
                key: mergedKey,
                parent: parent,
                pos: pos,
                children: null,
                data: treeNode,
                isStart: [].concat((0, _toConsumableArray.default)(parent ? parent.isStart : []), [
                    index === 0
                ]),
                isEnd: [].concat((0, _toConsumableArray.default)(parent ? parent.isEnd : []), [
                    index === list.length - 1
                ])
            });
            flattenList.push(flattenNode);
            // Loop treeNode children
            if (expandedKeys === true || expandedKeySet.has(mergedKey)) flattenNode.children = dig(treeNode[fieldChildren] || [], flattenNode);
            else flattenNode.children = [];
            return flattenNode;
        });
    }
    dig(treeNodeList);
    return flattenList;
}
function traverseDataNodes(dataNodes, callback, // To avoid too many params, let use config instead of origin param
config) {
    var mergedConfig = {};
    if ((0, _typeof.default)(config) === 'object') mergedConfig = config;
    else mergedConfig = {
        externalGetKey: config
    };
    mergedConfig = mergedConfig || {};
    // Init config
    var _mergedConfig = mergedConfig, childrenPropName = _mergedConfig.childrenPropName, externalGetKey = _mergedConfig.externalGetKey, fieldNames = _mergedConfig.fieldNames;
    var _fillFieldNames2 = fillFieldNames(fieldNames), fieldKey = _fillFieldNames2.key, fieldChildren = _fillFieldNames2.children;
    var mergeChildrenPropName = childrenPropName || fieldChildren;
    // Get keys
    var syntheticGetKey;
    if (externalGetKey) {
        if (typeof externalGetKey === 'string') syntheticGetKey = function syntheticGetKey(node) {
            return node[externalGetKey];
        };
        else if (typeof externalGetKey === 'function') syntheticGetKey = function syntheticGetKey(node) {
            return externalGetKey(node);
        };
    } else syntheticGetKey = function syntheticGetKey(node, pos) {
        return getKey(node[fieldKey], pos);
    };
    // Process
    function processNode(node, index, parent, pathNodes) {
        var children = node ? node[mergeChildrenPropName] : dataNodes;
        var pos = node ? getPosition(parent.pos, index) : '0';
        var connectNodes = node ? [].concat((0, _toConsumableArray.default)(pathNodes), [
            node
        ]) : [];
        // Process node if is not root
        if (node) {
            var key = syntheticGetKey(node, pos);
            var _data = {
                node: node,
                index: index,
                pos: pos,
                key: key,
                parentPos: parent.node ? parent.pos : null,
                level: parent.level + 1,
                nodes: connectNodes
            };
            callback(_data);
        }
        // Process children node
        if (children) children.forEach(function(subNode, subIndex) {
            processNode(subNode, subIndex, {
                node: node,
                pos: pos,
                level: parent ? parent.level + 1 : -1
            }, connectNodes);
        });
    }
    processNode(null);
}
function convertDataToEntities(dataNodes) {
    var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, initWrapper = _ref2.initWrapper, processEntity = _ref2.processEntity, onProcessFinished = _ref2.onProcessFinished, externalGetKey = _ref2.externalGetKey, childrenPropName = _ref2.childrenPropName, fieldNames = _ref2.fieldNames;
    var /** @deprecated Use `config.externalGetKey` instead */ legacyExternalGetKey = arguments.length > 2 ? arguments[2] : undefined;
    // Init config
    var mergedExternalGetKey = externalGetKey || legacyExternalGetKey;
    var posEntities = {};
    var keyEntities = {};
    var wrapper = {
        posEntities: posEntities,
        keyEntities: keyEntities
    };
    if (initWrapper) wrapper = initWrapper(wrapper) || wrapper;
    traverseDataNodes(dataNodes, function(item) {
        var node = item.node, index = item.index, pos = item.pos, key = item.key, parentPos = item.parentPos, level = item.level, nodes = item.nodes;
        var entity = {
            node: node,
            nodes: nodes,
            index: index,
            key: key,
            pos: pos,
            level: level
        };
        var mergedKey = getKey(key, pos);
        posEntities[pos] = entity;
        keyEntities[mergedKey] = entity;
        // Fill children
        entity.parent = posEntities[parentPos];
        if (entity.parent) {
            entity.parent.children = entity.parent.children || [];
            entity.parent.children.push(entity);
        }
        if (processEntity) processEntity(entity, wrapper);
    }, {
        externalGetKey: mergedExternalGetKey,
        childrenPropName: childrenPropName,
        fieldNames: fieldNames
    });
    if (onProcessFinished) onProcessFinished(wrapper);
    return wrapper;
}
function getTreeNodeProps(key, _ref3) {
    var expandedKeys = _ref3.expandedKeys, selectedKeys = _ref3.selectedKeys, loadedKeys = _ref3.loadedKeys, loadingKeys = _ref3.loadingKeys, checkedKeys = _ref3.checkedKeys, halfCheckedKeys = _ref3.halfCheckedKeys, dragOverNodeKey = _ref3.dragOverNodeKey, dropPosition = _ref3.dropPosition, keyEntities = _ref3.keyEntities;
    var entity = (0, _keyUtil.default)(keyEntities, key);
    var treeNodeProps = {
        eventKey: key,
        expanded: expandedKeys.indexOf(key) !== -1,
        selected: selectedKeys.indexOf(key) !== -1,
        loaded: loadedKeys.indexOf(key) !== -1,
        loading: loadingKeys.indexOf(key) !== -1,
        checked: checkedKeys.indexOf(key) !== -1,
        halfChecked: halfCheckedKeys.indexOf(key) !== -1,
        pos: String(entity ? entity.pos : ''),
        // [Legacy] Drag props
        // Since the interaction of drag is changed, the semantic of the props are
        // not accuracy, I think it should be finally removed
        dragOver: dragOverNodeKey === key && dropPosition === 0,
        dragOverGapTop: dragOverNodeKey === key && dropPosition === -1,
        dragOverGapBottom: dragOverNodeKey === key && dropPosition === 1
    };
    return treeNodeProps;
}
function convertNodePropsToEventData(props) {
    var data = props.data, expanded = props.expanded, selected = props.selected, checked = props.checked, loaded = props.loaded, loading = props.loading, halfChecked = props.halfChecked, dragOver = props.dragOver, dragOverGapTop = props.dragOverGapTop, dragOverGapBottom = props.dragOverGapBottom, pos = props.pos, active = props.active, eventKey = props.eventKey;
    var eventData = (0, _objectSpread2.default)((0, _objectSpread2.default)({}, data), {}, {
        expanded: expanded,
        selected: selected,
        checked: checked,
        loaded: loaded,
        loading: loading,
        halfChecked: halfChecked,
        dragOver: dragOver,
        dragOverGapTop: dragOverGapTop,
        dragOverGapBottom: dragOverGapBottom,
        pos: pos,
        active: active,
        key: eventKey
    });
    if (!('props' in eventData)) Object.defineProperty(eventData, 'props', {
        get: function get() {
            (0, _warning.default)(false, 'Second param return from event is node data instead of TreeNode instance. Please read value directly instead of reading from `props`.');
            return props;
        }
    });
    return eventData;
}

},
"node_modules/rc-util/es/pickAttrs.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, /**
 * Picker props from exist props with filter
 * @param props Passed props
 * @param ariaOnly boolean | { aria?: boolean; data?: boolean; attr?: boolean; } filter config
 */ "default", {
    enumerable: true,
    get: function() {
        return pickAttrs;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _objectSpread2 = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@babel/runtime/helpers/esm/objectSpread2.js"));
var attributes = "accept acceptCharset accessKey action allowFullScreen allowTransparency\n    alt async autoComplete autoFocus autoPlay capture cellPadding cellSpacing challenge\n    charSet checked classID className colSpan cols content contentEditable contextMenu\n    controls coords crossOrigin data dateTime default defer dir disabled download draggable\n    encType form formAction formEncType formMethod formNoValidate formTarget frameBorder\n    headers height hidden high href hrefLang htmlFor httpEquiv icon id inputMode integrity\n    is keyParams keyType kind label lang list loop low manifest marginHeight marginWidth max maxLength media\n    mediaGroup method min minLength multiple muted name noValidate nonce open\n    optimum pattern placeholder poster preload radioGroup readOnly rel required\n    reversed role rowSpan rows sandbox scope scoped scrolling seamless selected\n    shape size sizes span spellCheck src srcDoc srcLang srcSet start step style\n    summary tabIndex target title type useMap value width wmode wrap";
var eventsName = "onCopy onCut onPaste onCompositionEnd onCompositionStart onCompositionUpdate onKeyDown\n    onKeyPress onKeyUp onFocus onBlur onChange onInput onSubmit onClick onContextMenu onDoubleClick\n    onDrag onDragEnd onDragEnter onDragExit onDragLeave onDragOver onDragStart onDrop onMouseDown\n    onMouseEnter onMouseLeave onMouseMove onMouseOut onMouseOver onMouseUp onSelect onTouchCancel\n    onTouchEnd onTouchMove onTouchStart onScroll onWheel onAbort onCanPlay onCanPlayThrough\n    onDurationChange onEmptied onEncrypted onEnded onError onLoadedData onLoadedMetadata\n    onLoadStart onPause onPlay onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend onTimeUpdate onVolumeChange onWaiting onLoad onError";
var propList = "".concat(attributes, " ").concat(eventsName).split(/[\s\n]+/);
/* eslint-enable max-len */ var ariaPrefix = 'aria-';
var dataPrefix = 'data-';
function match(key, prefix) {
    return key.indexOf(prefix) === 0;
}
function pickAttrs(props) {
    var ariaOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var mergedConfig;
    if (ariaOnly === false) mergedConfig = {
        aria: true,
        data: true,
        attr: true
    };
    else if (ariaOnly === true) mergedConfig = {
        aria: true
    };
    else mergedConfig = (0, _objectSpread2.default)({}, ariaOnly);
    var attrs = {};
    Object.keys(props).forEach(function(key) {
        if (// Aria
        mergedConfig.aria && (key === 'role' || match(key, ariaPrefix)) || // Data
        mergedConfig.data && match(key, dataPrefix) || // Attr
        mergedConfig.attr && propList.includes(key)) attrs[key] = props[key];
    });
    return attrs;
}

},
"node_modules/rc-util/lib/Children/toArray.js": function (module, exports, __mako_require__){
"use strict";
var _interopRequireDefault = __mako_require__("node_modules/@babel/runtime/helpers/interopRequireDefault.js").default;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = toArray;
var _isFragment = _interopRequireDefault(__mako_require__("node_modules/rc-util/lib/React/isFragment.js"));
var _react = _interopRequireDefault(__mako_require__("node_modules/react/index.js"));
function toArray(children) {
    var option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var ret = [];
    _react.default.Children.forEach(children, function(child) {
        if ((child === undefined || child === null) && !option.keepEmpty) return;
        if (Array.isArray(child)) ret = ret.concat(toArray(child));
        else if ((0, _isFragment.default)(child) && child.props) ret = ret.concat(toArray(child.props.children, option));
        else ret.push(child);
    });
    return ret;
}

},
"node_modules/rc-util/lib/React/isFragment.js": function (module, exports, __mako_require__){
"use strict";
var _interopRequireDefault = __mako_require__("node_modules/@babel/runtime/helpers/interopRequireDefault.js").default;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isFragment;
var _typeof2 = _interopRequireDefault(__mako_require__("node_modules/@babel/runtime/helpers/typeof.js"));
var REACT_ELEMENT_TYPE_18 = Symbol.for('react.element');
var REACT_ELEMENT_TYPE_19 = Symbol.for('react.transitional.element');
var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
/**
 * Compatible with React 18 or 19 to check if node is a Fragment.
 */ function isFragment(object) {
    return(// Base object type
    object && (0, _typeof2.default)(object) === 'object' && // React Element type
    (object.$$typeof === REACT_ELEMENT_TYPE_18 || object.$$typeof === REACT_ELEMENT_TYPE_19) && // React Fragment type
    object.type === REACT_FRAGMENT_TYPE);
}

},
"node_modules/rc-virtual-list/es/Filler.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _extends = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@babel/runtime/helpers/esm/extends.js"));
var _defineProperty = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@babel/runtime/helpers/esm/defineProperty.js"));
var _objectSpread2 = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@babel/runtime/helpers/esm/objectSpread2.js"));
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
var _rcresizeobserver = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/rc-resize-observer/es/index.js"));
var _classnames = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/classnames/index.js"));
/**
 * Fill component to provided the scroll content real height.
 */ var Filler = /*#__PURE__*/ _react.forwardRef(function(_ref, ref) {
    var height = _ref.height, offsetY = _ref.offsetY, offsetX = _ref.offsetX, children = _ref.children, prefixCls = _ref.prefixCls, onInnerResize = _ref.onInnerResize, innerProps = _ref.innerProps, rtl = _ref.rtl, extra = _ref.extra;
    var outerStyle = {};
    var innerStyle = {
        display: 'flex',
        flexDirection: 'column'
    };
    if (offsetY !== undefined) {
        // Not set `width` since this will break `sticky: right`
        outerStyle = {
            height: height,
            position: 'relative',
            overflow: 'hidden'
        };
        innerStyle = (0, _objectSpread2.default)((0, _objectSpread2.default)({}, innerStyle), {}, (0, _defineProperty.default)((0, _defineProperty.default)((0, _defineProperty.default)((0, _defineProperty.default)((0, _defineProperty.default)({
            transform: "translateY(".concat(offsetY, "px)")
        }, rtl ? 'marginRight' : 'marginLeft', -offsetX), "position", 'absolute'), "left", 0), "right", 0), "top", 0));
    }
    return /*#__PURE__*/ _react.createElement("div", {
        style: outerStyle
    }, /*#__PURE__*/ _react.createElement(_rcresizeobserver.default, {
        onResize: function onResize(_ref2) {
            var offsetHeight = _ref2.offsetHeight;
            if (offsetHeight && onInnerResize) onInnerResize();
        }
    }, /*#__PURE__*/ _react.createElement("div", (0, _extends.default)({
        style: innerStyle,
        className: (0, _classnames.default)((0, _defineProperty.default)({}, "".concat(prefixCls, "-holder-inner"), prefixCls)),
        ref: ref
    }, innerProps), children, extra)));
});
Filler.displayName = 'Filler';
var _default = Filler;

},
"node_modules/rc-virtual-list/es/Item.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "Item", {
    enumerable: true,
    get: function() {
        return Item;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
function Item(_ref) {
    var children = _ref.children, setRef = _ref.setRef;
    var refFunc = _react.useCallback(function(node) {
        setRef(node);
    }, []);
    return /*#__PURE__*/ _react.cloneElement(children, {
        ref: refFunc
    });
}

},
"node_modules/rc-virtual-list/es/List.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    RawList: function() {
        return RawList;
    },
    default: function() {
        return _default;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _extends = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@babel/runtime/helpers/esm/extends.js"));
var _typeof = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@babel/runtime/helpers/esm/typeof.js"));
var _objectSpread2 = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@babel/runtime/helpers/esm/objectSpread2.js"));
var _defineProperty = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@babel/runtime/helpers/esm/defineProperty.js"));
var _slicedToArray = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@babel/runtime/helpers/esm/slicedToArray.js"));
var _objectWithoutProperties = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js"));
var _classnames = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/classnames/index.js"));
var _rcresizeobserver = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/rc-resize-observer/es/index.js"));
var _rcutil = __mako_require__("node_modules/rc-util/es/index.js");
var _useLayoutEffect = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/rc-util/es/hooks/useLayoutEffect.js"));
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
var _reactdom = __mako_require__("node_modules/react-dom/index.js");
var _Filler = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/rc-virtual-list/es/Filler.js"));
var _useChildren = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/rc-virtual-list/es/hooks/useChildren.js"));
var _useDiffItem = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/rc-virtual-list/es/hooks/useDiffItem.js"));
var _useFrameWheel = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/rc-virtual-list/es/hooks/useFrameWheel.js"));
var _useGetSize = __mako_require__("node_modules/rc-virtual-list/es/hooks/useGetSize.js");
var _useHeights = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/rc-virtual-list/es/hooks/useHeights.js"));
var _useMobileTouchMove = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/rc-virtual-list/es/hooks/useMobileTouchMove.js"));
var _useOriginScroll = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/rc-virtual-list/es/hooks/useOriginScroll.js"));
var _useScrollDrag = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/rc-virtual-list/es/hooks/useScrollDrag.js"));
var _useScrollTo = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/rc-virtual-list/es/hooks/useScrollTo.js"));
var _ScrollBar = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/rc-virtual-list/es/ScrollBar.js"));
var _scrollbarUtil = __mako_require__("node_modules/rc-virtual-list/es/utils/scrollbarUtil.js");
var _excluded = [
    "prefixCls",
    "className",
    "height",
    "itemHeight",
    "fullHeight",
    "style",
    "data",
    "children",
    "itemKey",
    "virtual",
    "direction",
    "scrollWidth",
    "component",
    "onScroll",
    "onVirtualScroll",
    "onVisibleChange",
    "innerProps",
    "extraRender",
    "styles",
    "showScrollBar"
];
var EMPTY_DATA = [];
var ScrollStyle = {
    overflowY: 'auto',
    overflowAnchor: 'none'
};
function RawList(props, ref) {
    var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? 'rc-virtual-list' : _props$prefixCls, className = props.className, height = props.height, itemHeight = props.itemHeight, _props$fullHeight = props.fullHeight, fullHeight = _props$fullHeight === void 0 ? true : _props$fullHeight, style = props.style, data = props.data, children = props.children, itemKey = props.itemKey, virtual = props.virtual, direction = props.direction, scrollWidth = props.scrollWidth, _props$component = props.component, Component = _props$component === void 0 ? 'div' : _props$component, onScroll = props.onScroll, onVirtualScroll = props.onVirtualScroll, onVisibleChange = props.onVisibleChange, innerProps = props.innerProps, extraRender = props.extraRender, styles = props.styles, _props$showScrollBar = props.showScrollBar, showScrollBar = _props$showScrollBar === void 0 ? 'optional' : _props$showScrollBar, restProps = (0, _objectWithoutProperties.default)(props, _excluded);
    // =============================== Item Key ===============================
    var getKey = _react.useCallback(function(item) {
        if (typeof itemKey === 'function') return itemKey(item);
        return item === null || item === void 0 ? void 0 : item[itemKey];
    }, [
        itemKey
    ]);
    // ================================ Height ================================
    var _useHeights1 = (0, _useHeights.default)(getKey, null, null), _useHeights2 = (0, _slicedToArray.default)(_useHeights1, 4), setInstanceRef = _useHeights2[0], collectHeight = _useHeights2[1], heights = _useHeights2[2], heightUpdatedMark = _useHeights2[3];
    // ================================= MISC =================================
    var useVirtual = !!(virtual !== false && height && itemHeight);
    var containerHeight = _react.useMemo(function() {
        return Object.values(heights.maps).reduce(function(total, curr) {
            return total + curr;
        }, 0);
    }, [
        heights.id,
        heights.maps
    ]);
    var inVirtual = useVirtual && data && (Math.max(itemHeight * data.length, containerHeight) > height || !!scrollWidth);
    var isRTL = direction === 'rtl';
    var mergedClassName = (0, _classnames.default)(prefixCls, (0, _defineProperty.default)({}, "".concat(prefixCls, "-rtl"), isRTL), className);
    var mergedData = data || EMPTY_DATA;
    var componentRef = (0, _react.useRef)();
    var fillerInnerRef = (0, _react.useRef)();
    var containerRef = (0, _react.useRef)();
    // =============================== Item Key ===============================
    var _useState = (0, _react.useState)(0), _useState2 = (0, _slicedToArray.default)(_useState, 2), offsetTop = _useState2[0], setOffsetTop = _useState2[1];
    var _useState3 = (0, _react.useState)(0), _useState4 = (0, _slicedToArray.default)(_useState3, 2), offsetLeft = _useState4[0], setOffsetLeft = _useState4[1];
    var _useState5 = (0, _react.useState)(false), _useState6 = (0, _slicedToArray.default)(_useState5, 2), scrollMoving = _useState6[0], setScrollMoving = _useState6[1];
    var onScrollbarStartMove = function onScrollbarStartMove() {
        setScrollMoving(true);
    };
    var onScrollbarStopMove = function onScrollbarStopMove() {
        setScrollMoving(false);
    };
    var sharedConfig = {
        getKey: getKey
    };
    // ================================ Scroll ================================
    function syncScrollTop(newTop) {
        setOffsetTop(function(origin) {
            var value;
            if (typeof newTop === 'function') value = newTop(origin);
            else value = newTop;
            var alignedTop = keepInRange(value);
            componentRef.current.scrollTop = alignedTop;
            return alignedTop;
        });
    }
    // ================================ Legacy ================================
    // Put ref here since the range is generate by follow
    var rangeRef = (0, _react.useRef)({
        start: 0,
        end: mergedData.length
    });
    var diffItemRef = (0, _react.useRef)();
    var _useDiffItem1 = (0, _useDiffItem.default)(mergedData, getKey), _useDiffItem2 = (0, _slicedToArray.default)(_useDiffItem1, 1), diffItem = _useDiffItem2[0];
    diffItemRef.current = diffItem;
    // ========================== Visible Calculation =========================
    var _React$useMemo = _react.useMemo(function() {
        if (!useVirtual) return {
            scrollHeight: undefined,
            start: 0,
            end: mergedData.length - 1,
            offset: undefined
        };
        // Always use virtual scroll bar in avoid shaking
        if (!inVirtual) {
            var _fillerInnerRef$curre;
            return {
                scrollHeight: ((_fillerInnerRef$curre = fillerInnerRef.current) === null || _fillerInnerRef$curre === void 0 ? void 0 : _fillerInnerRef$curre.offsetHeight) || 0,
                start: 0,
                end: mergedData.length - 1,
                offset: undefined
            };
        }
        var itemTop = 0;
        var startIndex;
        var startOffset;
        var endIndex;
        var dataLen = mergedData.length;
        for(var i = 0; i < dataLen; i += 1){
            var _item = mergedData[i];
            var key = getKey(_item);
            var cacheHeight = heights.get(key);
            var currentItemBottom = itemTop + (cacheHeight === undefined ? itemHeight : cacheHeight);
            // Check item top in the range
            if (currentItemBottom >= offsetTop && startIndex === undefined) {
                startIndex = i;
                startOffset = itemTop;
            }
            // Check item bottom in the range. We will render additional one item for motion usage
            if (currentItemBottom > offsetTop + height && endIndex === undefined) endIndex = i;
            itemTop = currentItemBottom;
        }
        // When scrollTop at the end but data cut to small count will reach this
        if (startIndex === undefined) {
            startIndex = 0;
            startOffset = 0;
            endIndex = Math.ceil(height / itemHeight);
        }
        if (endIndex === undefined) endIndex = mergedData.length - 1;
        // Give cache to improve scroll experience
        endIndex = Math.min(endIndex + 1, mergedData.length - 1);
        return {
            scrollHeight: itemTop,
            start: startIndex,
            end: endIndex,
            offset: startOffset
        };
    }, [
        inVirtual,
        useVirtual,
        offsetTop,
        mergedData,
        heightUpdatedMark,
        height
    ]), scrollHeight = _React$useMemo.scrollHeight, start = _React$useMemo.start, end = _React$useMemo.end, fillerOffset = _React$useMemo.offset;
    rangeRef.current.start = start;
    rangeRef.current.end = end;
    // When scroll up, first visible item get real height may not same as `itemHeight`,
    // Which will make scroll jump.
    // Let's sync scroll top to avoid jump
    _react.useLayoutEffect(function() {
        var changedRecord = heights.getRecord();
        if (changedRecord.size === 1) {
            var recordKey = Array.from(changedRecord.keys())[0];
            var prevCacheHeight = changedRecord.get(recordKey);
            // Quick switch data may cause `start` not in `mergedData` anymore
            var startItem = mergedData[start];
            if (startItem && prevCacheHeight === undefined) {
                var startIndexKey = getKey(startItem);
                if (startIndexKey === recordKey) {
                    var realStartHeight = heights.get(recordKey);
                    var diffHeight = realStartHeight - itemHeight;
                    syncScrollTop(function(ori) {
                        return ori + diffHeight;
                    });
                }
            }
        }
        heights.resetRecord();
    }, [
        scrollHeight
    ]);
    // ================================= Size =================================
    var _React$useState = _react.useState({
        width: 0,
        height: height
    }), _React$useState2 = (0, _slicedToArray.default)(_React$useState, 2), size = _React$useState2[0], setSize = _React$useState2[1];
    var onHolderResize = function onHolderResize(sizeInfo) {
        setSize({
            width: sizeInfo.offsetWidth,
            height: sizeInfo.offsetHeight
        });
    };
    // Hack on scrollbar to enable flash call
    var verticalScrollBarRef = (0, _react.useRef)();
    var horizontalScrollBarRef = (0, _react.useRef)();
    var horizontalScrollBarSpinSize = _react.useMemo(function() {
        return (0, _scrollbarUtil.getSpinSize)(size.width, scrollWidth);
    }, [
        size.width,
        scrollWidth
    ]);
    var verticalScrollBarSpinSize = _react.useMemo(function() {
        return (0, _scrollbarUtil.getSpinSize)(size.height, scrollHeight);
    }, [
        size.height,
        scrollHeight
    ]);
    // =============================== In Range ===============================
    var maxScrollHeight = scrollHeight - height;
    var maxScrollHeightRef = (0, _react.useRef)(maxScrollHeight);
    maxScrollHeightRef.current = maxScrollHeight;
    function keepInRange(newScrollTop) {
        var newTop = newScrollTop;
        if (!Number.isNaN(maxScrollHeightRef.current)) newTop = Math.min(newTop, maxScrollHeightRef.current);
        newTop = Math.max(newTop, 0);
        return newTop;
    }
    var isScrollAtTop = offsetTop <= 0;
    var isScrollAtBottom = offsetTop >= maxScrollHeight;
    var isScrollAtLeft = offsetLeft <= 0;
    var isScrollAtRight = offsetLeft >= scrollWidth;
    var originScroll = (0, _useOriginScroll.default)(isScrollAtTop, isScrollAtBottom, isScrollAtLeft, isScrollAtRight);
    // ================================ Scroll ================================
    var getVirtualScrollInfo = function getVirtualScrollInfo() {
        return {
            x: isRTL ? -offsetLeft : offsetLeft,
            y: offsetTop
        };
    };
    var lastVirtualScrollInfoRef = (0, _react.useRef)(getVirtualScrollInfo());
    var triggerScroll = (0, _rcutil.useEvent)(function(params) {
        if (onVirtualScroll) {
            var nextInfo = (0, _objectSpread2.default)((0, _objectSpread2.default)({}, getVirtualScrollInfo()), params);
            // Trigger when offset changed
            if (lastVirtualScrollInfoRef.current.x !== nextInfo.x || lastVirtualScrollInfoRef.current.y !== nextInfo.y) {
                onVirtualScroll(nextInfo);
                lastVirtualScrollInfoRef.current = nextInfo;
            }
        }
    });
    function onScrollBar(newScrollOffset, horizontal) {
        var newOffset = newScrollOffset;
        if (horizontal) {
            (0, _reactdom.flushSync)(function() {
                setOffsetLeft(newOffset);
            });
            triggerScroll();
        } else syncScrollTop(newOffset);
    }
    // When data size reduce. It may trigger native scroll event back to fit scroll position
    function onFallbackScroll(e) {
        var newScrollTop = e.currentTarget.scrollTop;
        if (newScrollTop !== offsetTop) syncScrollTop(newScrollTop);
        // Trigger origin onScroll
        onScroll === null || onScroll === void 0 || onScroll(e);
        triggerScroll();
    }
    var keepInHorizontalRange = function keepInHorizontalRange(nextOffsetLeft) {
        var tmpOffsetLeft = nextOffsetLeft;
        var max = !!scrollWidth ? scrollWidth - size.width : 0;
        tmpOffsetLeft = Math.max(tmpOffsetLeft, 0);
        tmpOffsetLeft = Math.min(tmpOffsetLeft, max);
        return tmpOffsetLeft;
    };
    var onWheelDelta = (0, _rcutil.useEvent)(function(offsetXY, fromHorizontal) {
        if (fromHorizontal) {
            (0, _reactdom.flushSync)(function() {
                setOffsetLeft(function(left) {
                    var nextOffsetLeft = left + (isRTL ? -offsetXY : offsetXY);
                    return keepInHorizontalRange(nextOffsetLeft);
                });
            });
            triggerScroll();
        } else syncScrollTop(function(top) {
            var newTop = top + offsetXY;
            return newTop;
        });
    });
    // Since this added in global,should use ref to keep update
    var _useFrameWheel1 = (0, _useFrameWheel.default)(useVirtual, isScrollAtTop, isScrollAtBottom, isScrollAtLeft, isScrollAtRight, !!scrollWidth, onWheelDelta), _useFrameWheel2 = (0, _slicedToArray.default)(_useFrameWheel1, 2), onRawWheel = _useFrameWheel2[0], onFireFoxScroll = _useFrameWheel2[1];
    // Mobile touch move
    (0, _useMobileTouchMove.default)(useVirtual, componentRef, function(isHorizontal, delta, smoothOffset, e) {
        var event = e;
        if (originScroll(isHorizontal, delta, smoothOffset)) return false;
        // Fix nest List trigger TouchMove event
        if (!event || !event._virtualHandled) {
            if (event) event._virtualHandled = true;
            onRawWheel({
                preventDefault: function preventDefault() {},
                deltaX: isHorizontal ? delta : 0,
                deltaY: isHorizontal ? 0 : delta
            });
            return true;
        }
        return false;
    });
    // MouseDown drag for scroll
    (0, _useScrollDrag.default)(inVirtual, componentRef, function(offset) {
        syncScrollTop(function(top) {
            return top + offset;
        });
    });
    (0, _useLayoutEffect.default)(function() {
        // Firefox only
        function onMozMousePixelScroll(e) {
            // scrolling at top/bottom limit
            var scrollingUpAtTop = isScrollAtTop && e.detail < 0;
            var scrollingDownAtBottom = isScrollAtBottom && e.detail > 0;
            if (useVirtual && !scrollingUpAtTop && !scrollingDownAtBottom) e.preventDefault();
        }
        var componentEle = componentRef.current;
        componentEle.addEventListener('wheel', onRawWheel, {
            passive: false
        });
        componentEle.addEventListener('DOMMouseScroll', onFireFoxScroll, {
            passive: true
        });
        componentEle.addEventListener('MozMousePixelScroll', onMozMousePixelScroll, {
            passive: false
        });
        return function() {
            componentEle.removeEventListener('wheel', onRawWheel);
            componentEle.removeEventListener('DOMMouseScroll', onFireFoxScroll);
            componentEle.removeEventListener('MozMousePixelScroll', onMozMousePixelScroll);
        };
    }, [
        useVirtual,
        isScrollAtTop,
        isScrollAtBottom
    ]);
    // Sync scroll left
    (0, _useLayoutEffect.default)(function() {
        if (scrollWidth) {
            var newOffsetLeft = keepInHorizontalRange(offsetLeft);
            setOffsetLeft(newOffsetLeft);
            triggerScroll({
                x: newOffsetLeft
            });
        }
    }, [
        size.width,
        scrollWidth
    ]);
    // ================================= Ref ==================================
    var delayHideScrollBar = function delayHideScrollBar() {
        var _verticalScrollBarRef, _horizontalScrollBarR;
        (_verticalScrollBarRef = verticalScrollBarRef.current) === null || _verticalScrollBarRef === void 0 || _verticalScrollBarRef.delayHidden();
        (_horizontalScrollBarR = horizontalScrollBarRef.current) === null || _horizontalScrollBarR === void 0 || _horizontalScrollBarR.delayHidden();
    };
    var _scrollTo = (0, _useScrollTo.default)(componentRef, mergedData, heights, itemHeight, getKey, function() {
        return collectHeight(true);
    }, syncScrollTop, delayHideScrollBar);
    _react.useImperativeHandle(ref, function() {
        return {
            nativeElement: containerRef.current,
            getScrollInfo: getVirtualScrollInfo,
            scrollTo: function scrollTo(config) {
                function isPosScroll(arg) {
                    return arg && (0, _typeof.default)(arg) === 'object' && ('left' in arg || 'top' in arg);
                }
                if (isPosScroll(config)) {
                    // Scroll X
                    if (config.left !== undefined) setOffsetLeft(keepInHorizontalRange(config.left));
                    // Scroll Y
                    _scrollTo(config.top);
                } else _scrollTo(config);
            }
        };
    });
    // ================================ Effect ================================
    /** We need told outside that some list not rendered */ (0, _useLayoutEffect.default)(function() {
        if (onVisibleChange) {
            var renderList = mergedData.slice(start, end + 1);
            onVisibleChange(renderList, mergedData);
        }
    }, [
        start,
        end,
        mergedData
    ]);
    // ================================ Extra =================================
    var getSize = (0, _useGetSize.useGetSize)(mergedData, getKey, heights, itemHeight);
    var extraContent = extraRender === null || extraRender === void 0 ? void 0 : extraRender({
        start: start,
        end: end,
        virtual: inVirtual,
        offsetX: offsetLeft,
        offsetY: fillerOffset,
        rtl: isRTL,
        getSize: getSize
    });
    // ================================ Render ================================
    var listChildren = (0, _useChildren.default)(mergedData, start, end, scrollWidth, offsetLeft, setInstanceRef, children, sharedConfig);
    var componentStyle = null;
    if (height) {
        componentStyle = (0, _objectSpread2.default)((0, _defineProperty.default)({}, fullHeight ? 'height' : 'maxHeight', height), ScrollStyle);
        if (useVirtual) {
            componentStyle.overflowY = 'hidden';
            if (scrollWidth) componentStyle.overflowX = 'hidden';
            if (scrollMoving) componentStyle.pointerEvents = 'none';
        }
    }
    var containerProps = {};
    if (isRTL) containerProps.dir = 'rtl';
    return /*#__PURE__*/ _react.createElement("div", (0, _extends.default)({
        ref: containerRef,
        style: (0, _objectSpread2.default)((0, _objectSpread2.default)({}, style), {}, {
            position: 'relative'
        }),
        className: mergedClassName
    }, containerProps, restProps), /*#__PURE__*/ _react.createElement(_rcresizeobserver.default, {
        onResize: onHolderResize
    }, /*#__PURE__*/ _react.createElement(Component, {
        className: "".concat(prefixCls, "-holder"),
        style: componentStyle,
        ref: componentRef,
        onScroll: onFallbackScroll,
        onMouseEnter: delayHideScrollBar
    }, /*#__PURE__*/ _react.createElement(_Filler.default, {
        prefixCls: prefixCls,
        height: scrollHeight,
        offsetX: offsetLeft,
        offsetY: fillerOffset,
        scrollWidth: scrollWidth,
        onInnerResize: collectHeight,
        ref: fillerInnerRef,
        innerProps: innerProps,
        rtl: isRTL,
        extra: extraContent
    }, listChildren))), inVirtual && scrollHeight > height && /*#__PURE__*/ _react.createElement(_ScrollBar.default, {
        ref: verticalScrollBarRef,
        prefixCls: prefixCls,
        scrollOffset: offsetTop,
        scrollRange: scrollHeight,
        rtl: isRTL,
        onScroll: onScrollBar,
        onStartMove: onScrollbarStartMove,
        onStopMove: onScrollbarStopMove,
        spinSize: verticalScrollBarSpinSize,
        containerSize: size.height,
        style: styles === null || styles === void 0 ? void 0 : styles.verticalScrollBar,
        thumbStyle: styles === null || styles === void 0 ? void 0 : styles.verticalScrollBarThumb,
        showScrollBar: showScrollBar
    }), inVirtual && scrollWidth > size.width && /*#__PURE__*/ _react.createElement(_ScrollBar.default, {
        ref: horizontalScrollBarRef,
        prefixCls: prefixCls,
        scrollOffset: offsetLeft,
        scrollRange: scrollWidth,
        rtl: isRTL,
        onScroll: onScrollBar,
        onStartMove: onScrollbarStartMove,
        onStopMove: onScrollbarStopMove,
        spinSize: horizontalScrollBarSpinSize,
        containerSize: size.width,
        horizontal: true,
        style: styles === null || styles === void 0 ? void 0 : styles.horizontalScrollBar,
        thumbStyle: styles === null || styles === void 0 ? void 0 : styles.horizontalScrollBarThumb,
        showScrollBar: showScrollBar
    }));
}
var List = /*#__PURE__*/ _react.forwardRef(RawList);
List.displayName = 'List';
var _default = List;

},
"node_modules/rc-virtual-list/es/ScrollBar.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _objectSpread2 = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@babel/runtime/helpers/esm/objectSpread2.js"));
var _defineProperty = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@babel/runtime/helpers/esm/defineProperty.js"));
var _slicedToArray = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@babel/runtime/helpers/esm/slicedToArray.js"));
var _classnames = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/classnames/index.js"));
var _raf = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/rc-util/es/raf.js"));
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
var _useScrollDrag = __mako_require__("node_modules/rc-virtual-list/es/hooks/useScrollDrag.js");
var ScrollBar = /*#__PURE__*/ _react.forwardRef(function(props, ref) {
    var prefixCls = props.prefixCls, rtl = props.rtl, scrollOffset = props.scrollOffset, scrollRange = props.scrollRange, onStartMove = props.onStartMove, onStopMove = props.onStopMove, onScroll = props.onScroll, horizontal = props.horizontal, spinSize = props.spinSize, containerSize = props.containerSize, style = props.style, propsThumbStyle = props.thumbStyle, showScrollBar = props.showScrollBar;
    var _React$useState = _react.useState(false), _React$useState2 = (0, _slicedToArray.default)(_React$useState, 2), dragging = _React$useState2[0], setDragging = _React$useState2[1];
    var _React$useState3 = _react.useState(null), _React$useState4 = (0, _slicedToArray.default)(_React$useState3, 2), pageXY = _React$useState4[0], setPageXY = _React$useState4[1];
    var _React$useState5 = _react.useState(null), _React$useState6 = (0, _slicedToArray.default)(_React$useState5, 2), startTop = _React$useState6[0], setStartTop = _React$useState6[1];
    var isLTR = !rtl;
    // ========================= Refs =========================
    var scrollbarRef = _react.useRef();
    var thumbRef = _react.useRef();
    // ======================= Visible ========================
    var _React$useState7 = _react.useState(showScrollBar), _React$useState8 = (0, _slicedToArray.default)(_React$useState7, 2), visible = _React$useState8[0], setVisible = _React$useState8[1];
    var visibleTimeoutRef = _react.useRef();
    var delayHidden = function delayHidden() {
        if (showScrollBar === true || showScrollBar === false) return;
        clearTimeout(visibleTimeoutRef.current);
        setVisible(true);
        visibleTimeoutRef.current = setTimeout(function() {
            setVisible(false);
        }, 3000);
    };
    // ======================== Range =========================
    var enableScrollRange = scrollRange - containerSize || 0;
    var enableOffsetRange = containerSize - spinSize || 0;
    // ========================= Top ==========================
    var top = _react.useMemo(function() {
        if (scrollOffset === 0 || enableScrollRange === 0) return 0;
        var ptg = scrollOffset / enableScrollRange;
        return ptg * enableOffsetRange;
    }, [
        scrollOffset,
        enableScrollRange,
        enableOffsetRange
    ]);
    // ====================== Container =======================
    var onContainerMouseDown = function onContainerMouseDown(e) {
        e.stopPropagation();
        e.preventDefault();
    };
    // ======================== Thumb =========================
    var stateRef = _react.useRef({
        top: top,
        dragging: dragging,
        pageY: pageXY,
        startTop: startTop
    });
    stateRef.current = {
        top: top,
        dragging: dragging,
        pageY: pageXY,
        startTop: startTop
    };
    var onThumbMouseDown = function onThumbMouseDown(e) {
        setDragging(true);
        setPageXY((0, _useScrollDrag.getPageXY)(e, horizontal));
        setStartTop(stateRef.current.top);
        onStartMove();
        e.stopPropagation();
        e.preventDefault();
    };
    // ======================== Effect ========================
    // React make event as passive, but we need to preventDefault
    // Add event on dom directly instead.
    // ref: https://github.com/facebook/react/issues/9809
    _react.useEffect(function() {
        var onScrollbarTouchStart = function onScrollbarTouchStart(e) {
            e.preventDefault();
        };
        var scrollbarEle = scrollbarRef.current;
        var thumbEle = thumbRef.current;
        scrollbarEle.addEventListener('touchstart', onScrollbarTouchStart, {
            passive: false
        });
        thumbEle.addEventListener('touchstart', onThumbMouseDown, {
            passive: false
        });
        return function() {
            scrollbarEle.removeEventListener('touchstart', onScrollbarTouchStart);
            thumbEle.removeEventListener('touchstart', onThumbMouseDown);
        };
    }, []);
    // Pass to effect
    var enableScrollRangeRef = _react.useRef();
    enableScrollRangeRef.current = enableScrollRange;
    var enableOffsetRangeRef = _react.useRef();
    enableOffsetRangeRef.current = enableOffsetRange;
    _react.useEffect(function() {
        if (dragging) {
            var moveRafId;
            var onMouseMove = function onMouseMove(e) {
                var _stateRef$current = stateRef.current, stateDragging = _stateRef$current.dragging, statePageY = _stateRef$current.pageY, stateStartTop = _stateRef$current.startTop;
                _raf.default.cancel(moveRafId);
                var rect = scrollbarRef.current.getBoundingClientRect();
                var scale = containerSize / (horizontal ? rect.width : rect.height);
                if (stateDragging) {
                    var offset = ((0, _useScrollDrag.getPageXY)(e, horizontal) - statePageY) * scale;
                    var newTop = stateStartTop;
                    if (!isLTR && horizontal) newTop -= offset;
                    else newTop += offset;
                    var tmpEnableScrollRange = enableScrollRangeRef.current;
                    var tmpEnableOffsetRange = enableOffsetRangeRef.current;
                    var ptg = tmpEnableOffsetRange ? newTop / tmpEnableOffsetRange : 0;
                    var newScrollTop = Math.ceil(ptg * tmpEnableScrollRange);
                    newScrollTop = Math.max(newScrollTop, 0);
                    newScrollTop = Math.min(newScrollTop, tmpEnableScrollRange);
                    moveRafId = (0, _raf.default)(function() {
                        onScroll(newScrollTop, horizontal);
                    });
                }
            };
            var onMouseUp = function onMouseUp() {
                setDragging(false);
                onStopMove();
            };
            window.addEventListener('mousemove', onMouseMove, {
                passive: true
            });
            window.addEventListener('touchmove', onMouseMove, {
                passive: true
            });
            window.addEventListener('mouseup', onMouseUp, {
                passive: true
            });
            window.addEventListener('touchend', onMouseUp, {
                passive: true
            });
            return function() {
                window.removeEventListener('mousemove', onMouseMove);
                window.removeEventListener('touchmove', onMouseMove);
                window.removeEventListener('mouseup', onMouseUp);
                window.removeEventListener('touchend', onMouseUp);
                _raf.default.cancel(moveRafId);
            };
        }
    }, [
        dragging
    ]);
    _react.useEffect(function() {
        delayHidden();
        return function() {
            clearTimeout(visibleTimeoutRef.current);
        };
    }, [
        scrollOffset
    ]);
    // ====================== Imperative ======================
    _react.useImperativeHandle(ref, function() {
        return {
            delayHidden: delayHidden
        };
    });
    // ======================== Render ========================
    var scrollbarPrefixCls = "".concat(prefixCls, "-scrollbar");
    var containerStyle = {
        position: 'absolute',
        visibility: visible ? null : 'hidden'
    };
    var thumbStyle = {
        position: 'absolute',
        borderRadius: 99,
        background: 'var(--rc-virtual-list-scrollbar-bg, rgba(0, 0, 0, 0.5))',
        cursor: 'pointer',
        userSelect: 'none'
    };
    if (horizontal) {
        Object.assign(containerStyle, {
            height: 8,
            left: 0,
            right: 0,
            bottom: 0
        });
        Object.assign(thumbStyle, (0, _defineProperty.default)({
            height: '100%',
            width: spinSize
        }, isLTR ? 'left' : 'right', top));
    } else {
        Object.assign(containerStyle, (0, _defineProperty.default)({
            width: 8,
            top: 0,
            bottom: 0
        }, isLTR ? 'right' : 'left', 0));
        Object.assign(thumbStyle, {
            width: '100%',
            height: spinSize,
            top: top
        });
    }
    return /*#__PURE__*/ _react.createElement("div", {
        ref: scrollbarRef,
        className: (0, _classnames.default)(scrollbarPrefixCls, (0, _defineProperty.default)((0, _defineProperty.default)((0, _defineProperty.default)({}, "".concat(scrollbarPrefixCls, "-horizontal"), horizontal), "".concat(scrollbarPrefixCls, "-vertical"), !horizontal), "".concat(scrollbarPrefixCls, "-visible"), visible)),
        style: (0, _objectSpread2.default)((0, _objectSpread2.default)({}, containerStyle), style),
        onMouseDown: onContainerMouseDown,
        onMouseMove: delayHidden
    }, /*#__PURE__*/ _react.createElement("div", {
        ref: thumbRef,
        className: (0, _classnames.default)("".concat(scrollbarPrefixCls, "-thumb"), (0, _defineProperty.default)({}, "".concat(scrollbarPrefixCls, "-thumb-moving"), dragging)),
        style: (0, _objectSpread2.default)((0, _objectSpread2.default)({}, thumbStyle), propsThumbStyle),
        onMouseDown: onThumbMouseDown
    }));
});
ScrollBar.displayName = 'ScrollBar';
var _default = ScrollBar;

},
"node_modules/rc-virtual-list/es/hooks/useChildren.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return useChildren;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
var _Item = __mako_require__("node_modules/rc-virtual-list/es/Item.js");
function useChildren(list, startIndex, endIndex, scrollWidth, offsetX, setNodeRef, renderFunc, _ref) {
    var getKey = _ref.getKey;
    return list.slice(startIndex, endIndex + 1).map(function(item, index) {
        var eleIndex = startIndex + index;
        var node = renderFunc(item, eleIndex, {
            style: {
                width: scrollWidth
            },
            offsetX: offsetX
        });
        var key = getKey(item);
        return /*#__PURE__*/ _react.createElement(_Item.Item, {
            key: key,
            setRef: function setRef(ele) {
                return setNodeRef(item, ele);
            }
        }, node);
    });
}

},
"node_modules/rc-virtual-list/es/hooks/useDiffItem.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return useDiffItem;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _slicedToArray = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@babel/runtime/helpers/esm/slicedToArray.js"));
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
var _algorithmUtil = __mako_require__("node_modules/rc-virtual-list/es/utils/algorithmUtil.js");
function useDiffItem(data, getKey, onDiff) {
    var _React$useState = _react.useState(data), _React$useState2 = (0, _slicedToArray.default)(_React$useState, 2), prevData = _React$useState2[0], setPrevData = _React$useState2[1];
    var _React$useState3 = _react.useState(null), _React$useState4 = (0, _slicedToArray.default)(_React$useState3, 2), diffItem = _React$useState4[0], setDiffItem = _React$useState4[1];
    _react.useEffect(function() {
        var diff = (0, _algorithmUtil.findListDiffIndex)(prevData || [], data || [], getKey);
        if ((diff === null || diff === void 0 ? void 0 : diff.index) !== undefined) {
            onDiff === null || onDiff === void 0 || onDiff(diff.index);
            setDiffItem(data[diff.index]);
        }
        setPrevData(data);
    }, [
        data
    ]);
    return [
        diffItem
    ];
}

},
"node_modules/rc-virtual-list/es/hooks/useFrameWheel.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return useFrameWheel;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _raf = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/rc-util/es/raf.js"));
var _react = __mako_require__("node_modules/react/index.js");
var _isFirefox = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/rc-virtual-list/es/utils/isFirefox.js"));
var _useOriginScroll = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/rc-virtual-list/es/hooks/useOriginScroll.js"));
function useFrameWheel(inVirtual, isScrollAtTop, isScrollAtBottom, isScrollAtLeft, isScrollAtRight, horizontalScroll, /***
 * Return `true` when you need to prevent default event
 */ onWheelDelta) {
    var offsetRef = (0, _react.useRef)(0);
    var nextFrameRef = (0, _react.useRef)(null);
    // Firefox patch
    var wheelValueRef = (0, _react.useRef)(null);
    var isMouseScrollRef = (0, _react.useRef)(false);
    // Scroll status sync
    var originScroll = (0, _useOriginScroll.default)(isScrollAtTop, isScrollAtBottom, isScrollAtLeft, isScrollAtRight);
    function onWheelY(e, deltaY) {
        _raf.default.cancel(nextFrameRef.current);
        // Do nothing when scroll at the edge, Skip check when is in scroll
        if (originScroll(false, deltaY)) return;
        // Skip if nest List has handled this event
        var event = e;
        if (!event._virtualHandled) event._virtualHandled = true;
        else return;
        offsetRef.current += deltaY;
        wheelValueRef.current = deltaY;
        // Proxy of scroll events
        if (!_isFirefox.default) event.preventDefault();
        nextFrameRef.current = (0, _raf.default)(function() {
            // Patch a multiple for Firefox to fix wheel number too small
            // ref: https://github.com/ant-design/ant-design/issues/26372#issuecomment-679460266
            var patchMultiple = isMouseScrollRef.current ? 10 : 1;
            onWheelDelta(offsetRef.current * patchMultiple, false);
            offsetRef.current = 0;
        });
    }
    function onWheelX(event, deltaX) {
        onWheelDelta(deltaX, true);
        if (!_isFirefox.default) event.preventDefault();
    }
    // Check for which direction does wheel do. `sx` means `shift + wheel`
    var wheelDirectionRef = (0, _react.useRef)(null);
    var wheelDirectionCleanRef = (0, _react.useRef)(null);
    function onWheel(event) {
        if (!inVirtual) return;
        // Wait for 2 frame to clean direction
        _raf.default.cancel(wheelDirectionCleanRef.current);
        wheelDirectionCleanRef.current = (0, _raf.default)(function() {
            wheelDirectionRef.current = null;
        }, 2);
        var deltaX = event.deltaX, deltaY = event.deltaY, shiftKey = event.shiftKey;
        var mergedDeltaX = deltaX;
        var mergedDeltaY = deltaY;
        if (wheelDirectionRef.current === 'sx' || !wheelDirectionRef.current && (shiftKey || false) && deltaY && !deltaX) {
            mergedDeltaX = deltaY;
            mergedDeltaY = 0;
            wheelDirectionRef.current = 'sx';
        }
        var absX = Math.abs(mergedDeltaX);
        var absY = Math.abs(mergedDeltaY);
        if (wheelDirectionRef.current === null) wheelDirectionRef.current = horizontalScroll && absX > absY ? 'x' : 'y';
        if (wheelDirectionRef.current === 'y') onWheelY(event, mergedDeltaY);
        else onWheelX(event, mergedDeltaX);
    }
    // A patch for firefox
    function onFireFoxScroll(event) {
        if (!inVirtual) return;
        isMouseScrollRef.current = event.detail === wheelValueRef.current;
    }
    return [
        onWheel,
        onFireFoxScroll
    ];
}

},
"node_modules/rc-virtual-list/es/hooks/useGetSize.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "useGetSize", {
    enumerable: true,
    get: function() {
        return useGetSize;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _slicedToArray = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@babel/runtime/helpers/esm/slicedToArray.js"));
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
function useGetSize(mergedData, getKey, heights, itemHeight) {
    var _React$useMemo = _react.useMemo(function() {
        return [
            new Map(),
            []
        ];
    }, [
        mergedData,
        heights.id,
        itemHeight
    ]), _React$useMemo2 = (0, _slicedToArray.default)(_React$useMemo, 2), key2Index = _React$useMemo2[0], bottomList = _React$useMemo2[1];
    var getSize = function getSize(startKey) {
        var endKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startKey;
        // Get from cache first
        var startIndex = key2Index.get(startKey);
        var endIndex = key2Index.get(endKey);
        // Loop to fill the cache
        if (startIndex === undefined || endIndex === undefined) {
            var dataLen = mergedData.length;
            for(var i = bottomList.length; i < dataLen; i += 1){
                var _heights$get;
                var item = mergedData[i];
                var key = getKey(item);
                key2Index.set(key, i);
                var cacheHeight = (_heights$get = heights.get(key)) !== null && _heights$get !== void 0 ? _heights$get : itemHeight;
                bottomList[i] = (bottomList[i - 1] || 0) + cacheHeight;
                if (key === startKey) startIndex = i;
                if (key === endKey) endIndex = i;
                if (startIndex !== undefined && endIndex !== undefined) break;
            }
        }
        return {
            top: bottomList[startIndex - 1] || 0,
            bottom: bottomList[endIndex]
        };
    };
    return getSize;
}

},
"node_modules/rc-virtual-list/es/hooks/useHeights.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return useHeights;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _slicedToArray = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@babel/runtime/helpers/esm/slicedToArray.js"));
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
var _CacheMap = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/rc-virtual-list/es/utils/CacheMap.js"));
function parseNumber(value) {
    var num = parseFloat(value);
    return isNaN(num) ? 0 : num;
}
function useHeights(getKey, onItemAdd, onItemRemove) {
    var _React$useState = _react.useState(0), _React$useState2 = (0, _slicedToArray.default)(_React$useState, 2), updatedMark = _React$useState2[0], setUpdatedMark = _React$useState2[1];
    var instanceRef = (0, _react.useRef)(new Map());
    var heightsRef = (0, _react.useRef)(new _CacheMap.default());
    var promiseIdRef = (0, _react.useRef)(0);
    function cancelRaf() {
        promiseIdRef.current += 1;
    }
    function collectHeight() {
        var sync = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        cancelRaf();
        var doCollect = function doCollect() {
            var changed = false;
            instanceRef.current.forEach(function(element, key) {
                if (element && element.offsetParent) {
                    var offsetHeight = element.offsetHeight;
                    var _getComputedStyle = getComputedStyle(element), marginTop = _getComputedStyle.marginTop, marginBottom = _getComputedStyle.marginBottom;
                    var marginTopNum = parseNumber(marginTop);
                    var marginBottomNum = parseNumber(marginBottom);
                    var totalHeight = offsetHeight + marginTopNum + marginBottomNum;
                    if (heightsRef.current.get(key) !== totalHeight) {
                        heightsRef.current.set(key, totalHeight);
                        changed = true;
                    }
                }
            });
            // Always trigger update mark to tell parent that should re-calculate heights when resized
            if (changed) setUpdatedMark(function(c) {
                return c + 1;
            });
        };
        if (sync) doCollect();
        else {
            promiseIdRef.current += 1;
            var id = promiseIdRef.current;
            Promise.resolve().then(function() {
                if (id === promiseIdRef.current) doCollect();
            });
        }
    }
    function setInstanceRef(item, instance) {
        var key = getKey(item);
        var origin = instanceRef.current.get(key);
        if (instance) {
            instanceRef.current.set(key, instance);
            collectHeight();
        } else instanceRef.current.delete(key);
        // Instance changed
        if (!origin !== !instance) {
            if (instance) onItemAdd === null || onItemAdd === void 0 || onItemAdd(item);
            else onItemRemove === null || onItemRemove === void 0 || onItemRemove(item);
        }
    }
    (0, _react.useEffect)(function() {
        return cancelRaf;
    }, []);
    return [
        setInstanceRef,
        collectHeight,
        heightsRef.current,
        updatedMark
    ];
}

},
"node_modules/rc-virtual-list/es/hooks/useMobileTouchMove.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return useMobileTouchMove;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _useLayoutEffect = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/rc-util/es/hooks/useLayoutEffect.js"));
var _react = __mako_require__("node_modules/react/index.js");
var SMOOTH_PTG = 14 / 15;
function useMobileTouchMove(inVirtual, listRef, callback) {
    var touchedRef = (0, _react.useRef)(false);
    var touchXRef = (0, _react.useRef)(0);
    var touchYRef = (0, _react.useRef)(0);
    var elementRef = (0, _react.useRef)(null);
    // Smooth scroll
    var intervalRef = (0, _react.useRef)(null);
    /* eslint-disable prefer-const */ var cleanUpEvents;
    var onTouchMove = function onTouchMove(e) {
        if (touchedRef.current) {
            var currentX = Math.ceil(e.touches[0].pageX);
            var currentY = Math.ceil(e.touches[0].pageY);
            var offsetX = touchXRef.current - currentX;
            var offsetY = touchYRef.current - currentY;
            var _isHorizontal = Math.abs(offsetX) > Math.abs(offsetY);
            if (_isHorizontal) touchXRef.current = currentX;
            else touchYRef.current = currentY;
            var scrollHandled = callback(_isHorizontal, _isHorizontal ? offsetX : offsetY, false, e);
            if (scrollHandled) e.preventDefault();
            // Smooth interval
            clearInterval(intervalRef.current);
            if (scrollHandled) intervalRef.current = setInterval(function() {
                if (_isHorizontal) offsetX *= SMOOTH_PTG;
                else offsetY *= SMOOTH_PTG;
                var offset = Math.floor(_isHorizontal ? offsetX : offsetY);
                if (!callback(_isHorizontal, offset, true) || Math.abs(offset) <= 0.1) clearInterval(intervalRef.current);
            }, 16);
        }
    };
    var onTouchEnd = function onTouchEnd() {
        touchedRef.current = false;
        cleanUpEvents();
    };
    var onTouchStart = function onTouchStart(e) {
        cleanUpEvents();
        if (e.touches.length === 1 && !touchedRef.current) {
            touchedRef.current = true;
            touchXRef.current = Math.ceil(e.touches[0].pageX);
            touchYRef.current = Math.ceil(e.touches[0].pageY);
            elementRef.current = e.target;
            elementRef.current.addEventListener('touchmove', onTouchMove, {
                passive: false
            });
            elementRef.current.addEventListener('touchend', onTouchEnd, {
                passive: true
            });
        }
    };
    cleanUpEvents = function cleanUpEvents() {
        if (elementRef.current) {
            elementRef.current.removeEventListener('touchmove', onTouchMove);
            elementRef.current.removeEventListener('touchend', onTouchEnd);
        }
    };
    (0, _useLayoutEffect.default)(function() {
        if (inVirtual) listRef.current.addEventListener('touchstart', onTouchStart, {
            passive: true
        });
        return function() {
            var _listRef$current;
            (_listRef$current = listRef.current) === null || _listRef$current === void 0 || _listRef$current.removeEventListener('touchstart', onTouchStart);
            cleanUpEvents();
            clearInterval(intervalRef.current);
        };
    }, [
        inVirtual
    ]);
}

},
"node_modules/rc-virtual-list/es/hooks/useOriginScroll.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _react = __mako_require__("node_modules/react/index.js");
var _default = function(isScrollAtTop, isScrollAtBottom, isScrollAtLeft, isScrollAtRight) {
    // Do lock for a wheel when scrolling
    var lockRef = (0, _react.useRef)(false);
    var lockTimeoutRef = (0, _react.useRef)(null);
    function lockScroll() {
        clearTimeout(lockTimeoutRef.current);
        lockRef.current = true;
        lockTimeoutRef.current = setTimeout(function() {
            lockRef.current = false;
        }, 50);
    }
    // Pass to ref since global add is in closure
    var scrollPingRef = (0, _react.useRef)({
        top: isScrollAtTop,
        bottom: isScrollAtBottom,
        left: isScrollAtLeft,
        right: isScrollAtRight
    });
    scrollPingRef.current.top = isScrollAtTop;
    scrollPingRef.current.bottom = isScrollAtBottom;
    scrollPingRef.current.left = isScrollAtLeft;
    scrollPingRef.current.right = isScrollAtRight;
    return function(isHorizontal, delta) {
        var smoothOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var originScroll = isHorizontal ? // Pass origin wheel when on the left
        delta < 0 && scrollPingRef.current.left || // Pass origin wheel when on the right
        delta > 0 && scrollPingRef.current.right // Pass origin wheel when on the top
         : delta < 0 && scrollPingRef.current.top || // Pass origin wheel when on the bottom
        delta > 0 && scrollPingRef.current.bottom;
        if (smoothOffset && originScroll) {
            // No need lock anymore when it's smooth offset from touchMove interval
            clearTimeout(lockTimeoutRef.current);
            lockRef.current = false;
        } else if (!originScroll || lockRef.current) lockScroll();
        return !lockRef.current && originScroll;
    };
};

},
"node_modules/rc-virtual-list/es/hooks/useScrollDrag.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    default: function() {
        return useScrollDrag;
    },
    getPageXY: function() {
        return getPageXY;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _raf = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/rc-util/es/raf.js"));
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
function smoothScrollOffset(offset) {
    return Math.floor(Math.pow(offset, 0.5));
}
function getPageXY(e, horizontal) {
    var obj = 'touches' in e ? e.touches[0] : e;
    return obj[horizontal ? 'pageX' : 'pageY'] - window[horizontal ? 'scrollX' : 'scrollY'];
}
function useScrollDrag(inVirtual, componentRef, onScrollOffset) {
    _react.useEffect(function() {
        var ele = componentRef.current;
        if (inVirtual && ele) {
            var mouseDownLock = false;
            var rafId;
            var _offset;
            var stopScroll = function stopScroll() {
                _raf.default.cancel(rafId);
            };
            var continueScroll = function continueScroll() {
                stopScroll();
                rafId = (0, _raf.default)(function() {
                    onScrollOffset(_offset);
                    continueScroll();
                });
            };
            var onMouseDown = function onMouseDown(e) {
                // Skip if element set draggable
                if (e.target.draggable || e.button !== 0) return;
                // Skip if nest List has handled this event
                var event = e;
                if (!event._virtualHandled) {
                    event._virtualHandled = true;
                    mouseDownLock = true;
                }
            };
            var onMouseUp = function onMouseUp() {
                mouseDownLock = false;
                stopScroll();
            };
            var onMouseMove = function onMouseMove(e) {
                if (mouseDownLock) {
                    var mouseY = getPageXY(e, false);
                    var _ele$getBoundingClien = ele.getBoundingClientRect(), top = _ele$getBoundingClien.top, bottom = _ele$getBoundingClien.bottom;
                    if (mouseY <= top) {
                        var diff = top - mouseY;
                        _offset = -smoothScrollOffset(diff);
                        continueScroll();
                    } else if (mouseY >= bottom) {
                        var _diff = mouseY - bottom;
                        _offset = smoothScrollOffset(_diff);
                        continueScroll();
                    } else stopScroll();
                }
            };
            ele.addEventListener('mousedown', onMouseDown);
            ele.ownerDocument.addEventListener('mouseup', onMouseUp);
            ele.ownerDocument.addEventListener('mousemove', onMouseMove);
            return function() {
                ele.removeEventListener('mousedown', onMouseDown);
                ele.ownerDocument.removeEventListener('mouseup', onMouseUp);
                ele.ownerDocument.removeEventListener('mousemove', onMouseMove);
                stopScroll();
            };
        }
    }, [
        inVirtual
    ]);
}

},
"node_modules/rc-virtual-list/es/hooks/useScrollTo.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return useScrollTo;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _typeof = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@babel/runtime/helpers/esm/typeof.js"));
var _objectSpread2 = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@babel/runtime/helpers/esm/objectSpread2.js"));
var _slicedToArray = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@babel/runtime/helpers/esm/slicedToArray.js"));
var _react = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/react/index.js"));
var _raf = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/rc-util/es/raf.js"));
var _useLayoutEffect = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/rc-util/es/hooks/useLayoutEffect.js"));
var _rcutil = __mako_require__("node_modules/rc-util/es/index.js");
var MAX_TIMES = 10;
function useScrollTo(containerRef, data, heights, itemHeight, getKey, collectHeight, syncScrollTop, triggerFlash) {
    var scrollRef = _react.useRef();
    var _React$useState = _react.useState(null), _React$useState2 = (0, _slicedToArray.default)(_React$useState, 2), syncState = _React$useState2[0], setSyncState = _React$useState2[1];
    // ========================== Sync Scroll ==========================
    (0, _useLayoutEffect.default)(function() {
        if (syncState && syncState.times < MAX_TIMES) {
            // Never reach
            if (!containerRef.current) {
                setSyncState(function(ori) {
                    return (0, _objectSpread2.default)({}, ori);
                });
                return;
            }
            collectHeight();
            var targetAlign = syncState.targetAlign, originAlign = syncState.originAlign, index = syncState.index, offset = syncState.offset;
            var height = containerRef.current.clientHeight;
            var needCollectHeight = false;
            var newTargetAlign = targetAlign;
            var targetTop = null;
            // Go to next frame if height not exist
            if (height) {
                var mergedAlign = targetAlign || originAlign;
                // Get top & bottom
                var stackTop = 0;
                var itemTop = 0;
                var itemBottom = 0;
                var maxLen = Math.min(data.length - 1, index);
                for(var i = 0; i <= maxLen; i += 1){
                    var key = getKey(data[i]);
                    itemTop = stackTop;
                    var cacheHeight = heights.get(key);
                    itemBottom = itemTop + (cacheHeight === undefined ? itemHeight : cacheHeight);
                    stackTop = itemBottom;
                }
                // Check if need sync height (visible range has item not record height)
                var leftHeight = mergedAlign === 'top' ? offset : height - offset;
                for(var _i = maxLen; _i >= 0; _i -= 1){
                    var _key = getKey(data[_i]);
                    var _cacheHeight = heights.get(_key);
                    if (_cacheHeight === undefined) {
                        needCollectHeight = true;
                        break;
                    }
                    leftHeight -= _cacheHeight;
                    if (leftHeight <= 0) break;
                }
                // Scroll to
                switch(mergedAlign){
                    case 'top':
                        targetTop = itemTop - offset;
                        break;
                    case 'bottom':
                        targetTop = itemBottom - height + offset;
                        break;
                    default:
                        var scrollTop = containerRef.current.scrollTop;
                        var scrollBottom = scrollTop + height;
                        if (itemTop < scrollTop) newTargetAlign = 'top';
                        else if (itemBottom > scrollBottom) newTargetAlign = 'bottom';
                }
                if (targetTop !== null) syncScrollTop(targetTop);
                // One more time for sync
                if (targetTop !== syncState.lastTop) needCollectHeight = true;
            }
            // Trigger next effect
            if (needCollectHeight) setSyncState((0, _objectSpread2.default)((0, _objectSpread2.default)({}, syncState), {}, {
                times: syncState.times + 1,
                targetAlign: newTargetAlign,
                lastTop: targetTop
            }));
        } else if ((syncState === null || syncState === void 0 ? void 0 : syncState.times) === MAX_TIMES) (0, _rcutil.warning)(false, 'Seems `scrollTo` with `rc-virtual-list` reach the max limitation. Please fire issue for us. Thanks.');
    }, [
        syncState,
        containerRef.current
    ]);
    // =========================== Scroll To ===========================
    return function(arg) {
        // When not argument provided, we think dev may want to show the scrollbar
        if (arg === null || arg === undefined) {
            triggerFlash();
            return;
        }
        // Normal scroll logic
        _raf.default.cancel(scrollRef.current);
        if (typeof arg === 'number') syncScrollTop(arg);
        else if (arg && (0, _typeof.default)(arg) === 'object') {
            var index;
            var align = arg.align;
            if ('index' in arg) index = arg.index;
            else index = data.findIndex(function(item) {
                return getKey(item) === arg.key;
            });
            var _arg$offset = arg.offset, offset = _arg$offset === void 0 ? 0 : _arg$offset;
            setSyncState({
                times: 0,
                index: index,
                offset: offset,
                originAlign: align
            });
        }
    };
}

},
"node_modules/rc-virtual-list/es/index.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _List = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/rc-virtual-list/es/List.js"));
var _default = _List.default;

},
"node_modules/rc-virtual-list/es/utils/CacheMap.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _classCallCheck = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@babel/runtime/helpers/esm/classCallCheck.js"));
var _createClass = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@babel/runtime/helpers/esm/createClass.js"));
var _defineProperty = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@babel/runtime/helpers/esm/defineProperty.js"));
// Firefox has low performance of map.
var CacheMap = /*#__PURE__*/ function() {
    function CacheMap() {
        (0, _classCallCheck.default)(this, CacheMap);
        (0, _defineProperty.default)(this, "maps", void 0);
        // Used for cache key
        // `useMemo` no need to update if `id` not change
        (0, _defineProperty.default)(this, "id", 0);
        (0, _defineProperty.default)(this, "diffRecords", new Map());
        this.maps = Object.create(null);
    }
    (0, _createClass.default)(CacheMap, [
        {
            key: "set",
            value: function set(key, value) {
                // Record prev value
                this.diffRecords.set(key, this.maps[key]);
                this.maps[key] = value;
                this.id += 1;
            }
        },
        {
            key: "get",
            value: function get(key) {
                return this.maps[key];
            }
        },
        {
            key: "resetRecord",
            value: function resetRecord() {
                this.diffRecords.clear();
            }
        },
        {
            key: "getRecord",
            value: function getRecord() {
                return this.diffRecords;
            }
        }
    ]);
    return CacheMap;
}();
var _default = CacheMap;

},
"node_modules/rc-virtual-list/es/utils/algorithmUtil.js": function (module, exports, __mako_require__){
/**
 * Get index with specific start index one by one. e.g.
 * min: 3, max: 9, start: 6
 *
 * Return index is:
 * [0]: 6
 * [1]: 7
 * [2]: 5
 * [3]: 8
 * [4]: 4
 * [5]: 9
 * [6]: 3
 */ "use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    findListDiffIndex: function() {
        return findListDiffIndex;
    },
    getIndexByStartLoc: function() {
        return getIndexByStartLoc;
    }
});
function getIndexByStartLoc(min, max, start, index) {
    var beforeCount = start - min;
    var afterCount = max - start;
    var balanceCount = Math.min(beforeCount, afterCount) * 2;
    // Balance
    if (index <= balanceCount) {
        var stepIndex = Math.floor(index / 2);
        if (index % 2) return start + stepIndex + 1;
        return start - stepIndex;
    }
    // One is out of range
    if (beforeCount > afterCount) return start - (index - afterCount);
    return start + (index - beforeCount);
}
function findListDiffIndex(originList, targetList, getKey) {
    var originLen = originList.length;
    var targetLen = targetList.length;
    var shortList;
    var longList;
    if (originLen === 0 && targetLen === 0) return null;
    if (originLen < targetLen) {
        shortList = originList;
        longList = targetList;
    } else {
        shortList = targetList;
        longList = originList;
    }
    var notExistKey = {
        __EMPTY_ITEM__: true
    };
    function getItemKey(item) {
        if (item !== undefined) return getKey(item);
        return notExistKey;
    }
    // Loop to find diff one
    var diffIndex = null;
    var multiple = Math.abs(originLen - targetLen) !== 1;
    for(var i = 0; i < longList.length; i += 1){
        var shortKey = getItemKey(shortList[i]);
        var longKey = getItemKey(longList[i]);
        if (shortKey !== longKey) {
            diffIndex = i;
            multiple = multiple || shortKey !== getItemKey(longList[i + 1]);
            break;
        }
    }
    return diffIndex === null ? null : {
        index: diffIndex,
        multiple: multiple
    };
}

},
"node_modules/rc-virtual-list/es/utils/isFirefox.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _typeof = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/@babel/runtime/helpers/esm/typeof.js"));
var isFF = (typeof navigator === "undefined" ? "undefined" : (0, _typeof.default)(navigator)) === 'object' && /Firefox/i.test(navigator.userAgent);
var _default = isFF;

},
"node_modules/rc-virtual-list/es/utils/scrollbarUtil.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "getSpinSize", {
    enumerable: true,
    get: function() {
        return getSpinSize;
    }
});
var MIN_SIZE = 20;
function getSpinSize() {
    var containerSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var scrollRange = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var baseSize = containerSize / scrollRange * containerSize;
    if (isNaN(baseSize)) baseSize = 0;
    baseSize = Math.max(baseSize, MIN_SIZE);
    return Math.floor(baseSize);
}

},
"node_modules/react-dom/cjs/react-dom-server-legacy.browser.development.js": function (module, exports, __mako_require__){
/**
 * @license React
 * react-dom-server-legacy.browser.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 'use strict';
(function() {
    'use strict';
    var React = __mako_require__("node_modules/react/index.js");
    var ReactVersion = '18.3.1';
    var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    // by calls to these methods by a Babel plugin.
    //
    // In PROD (or in packages without access to React internals),
    // they are left as they are instead.
    function warn(format) {
        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)args[_key - 1] = arguments[_key];
        printWarning('warn', format, args);
    }
    function error(format) {
        for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++)args[_key2 - 1] = arguments[_key2];
        printWarning('error', format, args);
    }
    function printWarning(level, format, args) {
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        var stack = ReactDebugCurrentFrame.getStackAddendum();
        if (stack !== '') {
            format += '%s';
            args = args.concat([
                stack
            ]);
        } // eslint-disable-next-line react-internal/safe-string-coercion
        var argsWithFormat = args.map(function(item) {
            return String(item);
        }); // Careful: RN currently depends on this prefix
        argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
        // breaks IE9: https://github.com/facebook/react/issues/13610
        // eslint-disable-next-line react-internal/no-production-logging
        Function.prototype.apply.call(console[level], console, argsWithFormat);
    }
    function scheduleWork(callback) {
        callback();
    }
    function beginWriting(destination) {}
    function writeChunk(destination, chunk) {
        writeChunkAndReturn(destination, chunk);
    }
    function writeChunkAndReturn(destination, chunk) {
        return destination.push(chunk);
    }
    function completeWriting(destination) {}
    function close(destination) {
        destination.push(null);
    }
    function stringToChunk(content) {
        return content;
    }
    function stringToPrecomputedChunk(content) {
        return content;
    }
    function closeWithError(destination, error) {
        // $FlowFixMe: This is an Error object or the destination accepts other types.
        destination.destroy(error);
    }
    /*
 * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol
 * and Temporal.* types. See https://github.com/facebook/react/pull/22064.
 *
 * The functions in this module will throw an easier-to-understand,
 * easier-to-debug exception with a clear errors message message explaining the
 * problem. (Instead of a confusing exception thrown inside the implementation
 * of the `value` object).
 */ // $FlowFixMe only called in DEV, so void return is not possible.
    function typeName(value) {
        // toStringTag is needed for namespaced types like Temporal.Instant
        var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;
        var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';
        return type;
    } // $FlowFixMe only called in DEV, so void return is not possible.
    function willCoercionThrow(value) {
        try {
            testStringCoercion(value);
            return false;
        } catch (e) {
            return true;
        }
    }
    function testStringCoercion(value) {
        // If you ended up here by following an exception call stack, here's what's
        // happened: you supplied an object or symbol value to React (as a prop, key,
        // DOM attribute, CSS property, string ref, etc.) and when React tried to
        // coerce it to a string using `'' + value`, an exception was thrown.
        //
        // The most common types that will cause this exception are `Symbol` instances
        // and Temporal objects like `Temporal.Instant`. But any object that has a
        // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this
        // exception. (Library authors do this to prevent users from using built-in
        // numeric operators like `+` or comparison operators like `>=` because custom
        // methods are needed to perform accurate arithmetic or comparison.)
        //
        // To fix the problem, coerce this object or symbol value to a string before
        // passing it to React. The most reliable way is usually `String(value)`.
        //
        // To find which value is throwing, check the browser or debugger console.
        // Before this exception was thrown, there should be `console.error` output
        // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the
        // problem and how that type was used: key, atrribute, input value prop, etc.
        // In most cases, this console output also shows the component and its
        // ancestor components where the exception happened.
        //
        // eslint-disable-next-line react-internal/safe-string-coercion
        return '' + value;
    }
    function checkAttributeStringCoercion(value, attributeName) {
        if (willCoercionThrow(value)) {
            error("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", attributeName, typeName(value));
            return testStringCoercion(value); // throw (to help callers find troubleshooting comments)
        }
    }
    function checkCSSPropertyStringCoercion(value, propName) {
        if (willCoercionThrow(value)) {
            error("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value));
            return testStringCoercion(value); // throw (to help callers find troubleshooting comments)
        }
    }
    function checkHtmlStringCoercion(value) {
        if (willCoercionThrow(value)) {
            error("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
            return testStringCoercion(value); // throw (to help callers find troubleshooting comments)
        }
    }
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    // A reserved attribute.
    // It is handled by React separately and shouldn't be written to the DOM.
    var RESERVED = 0; // A simple string attribute.
    // Attributes that aren't in the filter are presumed to have this type.
    var STRING = 1; // A string attribute that accepts booleans in React. In HTML, these are called
    // "enumerated" attributes with "true" and "false" as possible values.
    // When true, it should be set to a "true" string.
    // When false, it should be set to a "false" string.
    var BOOLEANISH_STRING = 2; // A real boolean attribute.
    // When true, it should be present (set either to an empty string or its name).
    // When false, it should be omitted.
    var BOOLEAN = 3; // An attribute that can be used as a flag as well as with a value.
    // When true, it should be present (set either to an empty string or its name).
    // When false, it should be omitted.
    // For any other value, should be present with that value.
    var OVERLOADED_BOOLEAN = 4; // An attribute that must be numeric or parse as a numeric.
    // When falsy, it should be removed.
    var NUMERIC = 5; // An attribute that must be positive numeric or parse as a positive numeric.
    // When falsy, it should be removed.
    var POSITIVE_NUMERIC = 6;
    /* eslint-disable max-len */ var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
    /* eslint-enable max-len */ var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
    var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + ATTRIBUTE_NAME_START_CHAR + '][' + ATTRIBUTE_NAME_CHAR + ']*$');
    var illegalAttributeNameCache = {};
    var validatedAttributeNameCache = {};
    function isAttributeNameSafe(attributeName) {
        if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) return true;
        if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) return false;
        if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
            validatedAttributeNameCache[attributeName] = true;
            return true;
        }
        illegalAttributeNameCache[attributeName] = true;
        error('Invalid attribute name: `%s`', attributeName);
        return false;
    }
    function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {
        if (propertyInfo !== null && propertyInfo.type === RESERVED) return false;
        switch(typeof value){
            case 'function':
            case 'symbol':
                // eslint-disable-line
                return true;
            case 'boolean':
                if (isCustomComponentTag) return false;
                if (propertyInfo !== null) return !propertyInfo.acceptsBooleans;
                else {
                    var prefix = name.toLowerCase().slice(0, 5);
                    return prefix !== 'data-' && prefix !== 'aria-';
                }
            default:
                return false;
        }
    }
    function getPropertyInfo(name) {
        return properties.hasOwnProperty(name) ? properties[name] : null;
    }
    function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL, removeEmptyString) {
        this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
        this.attributeName = attributeName;
        this.attributeNamespace = attributeNamespace;
        this.mustUseProperty = mustUseProperty;
        this.propertyName = name;
        this.type = type;
        this.sanitizeURL = sanitizeURL;
        this.removeEmptyString = removeEmptyString;
    } // When adding attributes to this list, be sure to also add them to
    // the `possibleStandardNames` module to ensure casing and incorrect
    // name warnings.
    var properties = {}; // These props are reserved by React. They shouldn't be written to the DOM.
    var reservedProps = [
        'children',
        'dangerouslySetInnerHTML',
        // elements (not just inputs). Now that ReactDOMInput assigns to the
        // defaultValue property -- do we need this?
        'defaultValue',
        'defaultChecked',
        'innerHTML',
        'suppressContentEditableWarning',
        'suppressHydrationWarning',
        'style'
    ];
    reservedProps.forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, RESERVED, false, name, null, false, false);
    }); // A few React string attributes have a different name.
    // This is a mapping from React prop names to the attribute names.
    [
        [
            'acceptCharset',
            'accept-charset'
        ],
        [
            'className',
            'class'
        ],
        [
            'htmlFor',
            'for'
        ],
        [
            'httpEquiv',
            'http-equiv'
        ]
    ].forEach(function(_ref) {
        var name = _ref[0], attributeName = _ref[1];
        properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, null, false, false);
    }); // These are "enumerated" HTML attributes that accept "true" and "false".
    // In React, we let users pass `true` and `false` even though technically
    // these aren't boolean attributes (they are coerced to strings).
    [
        'contentEditable',
        'draggable',
        'spellCheck',
        'value'
    ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, name.toLowerCase(), null, false, false);
    }); // These are "enumerated" SVG attributes that accept "true" and "false".
    // In React, we let users pass `true` and `false` even though technically
    // these aren't boolean attributes (they are coerced to strings).
    // Since these are SVG attributes, their attribute names are case-sensitive.
    [
        'autoReverse',
        'externalResourcesRequired',
        'focusable',
        'preserveAlpha'
    ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, name, null, false, false);
    }); // These are HTML boolean attributes.
    [
        'allowFullScreen',
        'async',
        // on the client side because the browsers are inconsistent. Instead we call focus().
        'autoFocus',
        'autoPlay',
        'controls',
        'default',
        'defer',
        'disabled',
        'disablePictureInPicture',
        'disableRemotePlayback',
        'formNoValidate',
        'hidden',
        'loop',
        'noModule',
        'noValidate',
        'open',
        'playsInline',
        'readOnly',
        'required',
        'reversed',
        'scoped',
        'seamless',
        'itemScope'
    ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, BOOLEAN, false, name.toLowerCase(), null, false, false);
    }); // These are the few React props that we set as DOM properties
    // rather than attributes. These are all booleans.
    [
        'checked',
        // disabled with `removeAttribute`. We have special logic for handling this.
        'multiple',
        'muted',
        'selected' // NOTE: if you add a camelCased prop to this list,
    ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, BOOLEAN, true, name, null, false, false);
    }); // These are HTML attributes that are "overloaded booleans": they behave like
    // booleans, but can also accept a string value.
    [
        'capture',
        'download' // NOTE: if you add a camelCased prop to this list,
    ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, OVERLOADED_BOOLEAN, false, name, null, false, false);
    }); // These are HTML attributes that must be positive numbers.
    [
        'cols',
        'rows',
        'size',
        'span' // NOTE: if you add a camelCased prop to this list,
    ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, POSITIVE_NUMERIC, false, name, null, false, false);
    }); // These are HTML attributes that must be numbers.
    [
        'rowSpan',
        'start'
    ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, NUMERIC, false, name.toLowerCase(), null, false, false);
    });
    var CAMELIZE = /[\-\:]([a-z])/g;
    var capitalize = function(token) {
        return token[1].toUpperCase();
    }; // This is a list of all SVG attributes that need special casing, namespacing,
    // or boolean value assignment. Regular attributes that just accept strings
    // and have the same names are omitted, just like in the HTML attribute filter.
    // Some of these attributes can be hard to find. This list was created by
    // scraping the MDN documentation.
    [
        'accent-height',
        'alignment-baseline',
        'arabic-form',
        'baseline-shift',
        'cap-height',
        'clip-path',
        'clip-rule',
        'color-interpolation',
        'color-interpolation-filters',
        'color-profile',
        'color-rendering',
        'dominant-baseline',
        'enable-background',
        'fill-opacity',
        'fill-rule',
        'flood-color',
        'flood-opacity',
        'font-family',
        'font-size',
        'font-size-adjust',
        'font-stretch',
        'font-style',
        'font-variant',
        'font-weight',
        'glyph-name',
        'glyph-orientation-horizontal',
        'glyph-orientation-vertical',
        'horiz-adv-x',
        'horiz-origin-x',
        'image-rendering',
        'letter-spacing',
        'lighting-color',
        'marker-end',
        'marker-mid',
        'marker-start',
        'overline-position',
        'overline-thickness',
        'paint-order',
        'panose-1',
        'pointer-events',
        'rendering-intent',
        'shape-rendering',
        'stop-color',
        'stop-opacity',
        'strikethrough-position',
        'strikethrough-thickness',
        'stroke-dasharray',
        'stroke-dashoffset',
        'stroke-linecap',
        'stroke-linejoin',
        'stroke-miterlimit',
        'stroke-opacity',
        'stroke-width',
        'text-anchor',
        'text-decoration',
        'text-rendering',
        'underline-position',
        'underline-thickness',
        'unicode-bidi',
        'unicode-range',
        'units-per-em',
        'v-alphabetic',
        'v-hanging',
        'v-ideographic',
        'v-mathematical',
        'vector-effect',
        'vert-adv-y',
        'vert-origin-x',
        'vert-origin-y',
        'word-spacing',
        'writing-mode',
        'xmlns:xlink',
        'x-height' // NOTE: if you add a camelCased prop to this list,
    ].forEach(function(attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize);
        properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, null, false, false);
    }); // String SVG attributes with the xlink namespace.
    [
        'xlink:actuate',
        'xlink:arcrole',
        'xlink:role',
        'xlink:show',
        'xlink:title',
        'xlink:type' // NOTE: if you add a camelCased prop to this list,
    ].forEach(function(attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize);
        properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, 'http://www.w3.org/1999/xlink', false, false);
    }); // String SVG attributes with the xml namespace.
    [
        'xml:base',
        'xml:lang',
        'xml:space' // NOTE: if you add a camelCased prop to this list,
    ].forEach(function(attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize);
        properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, 'http://www.w3.org/XML/1998/namespace', false, false);
    }); // These attribute exists both in HTML and SVG.
    // The attribute name is case-sensitive in SVG so we can't just use
    // the React name like we do for attributes that exist only in HTML.
    [
        'tabIndex',
        'crossOrigin'
    ].forEach(function(attributeName) {
        properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, false, false);
    }); // These attributes accept URLs. These must not allow javascript: URLS.
    // These will also need to accept Trusted Types object in the future.
    var xlinkHref = 'xlinkHref';
    properties[xlinkHref] = new PropertyInfoRecord('xlinkHref', STRING, false, 'xlink:href', 'http://www.w3.org/1999/xlink', true, false);
    [
        'src',
        'href',
        'action',
        'formAction'
    ].forEach(function(attributeName) {
        properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, true, true);
    });
    /**
 * CSS properties which accept numbers but are not in units of "px".
 */ var isUnitlessNumber = {
        animationIterationCount: true,
        aspectRatio: true,
        borderImageOutset: true,
        borderImageSlice: true,
        borderImageWidth: true,
        boxFlex: true,
        boxFlexGroup: true,
        boxOrdinalGroup: true,
        columnCount: true,
        columns: true,
        flex: true,
        flexGrow: true,
        flexPositive: true,
        flexShrink: true,
        flexNegative: true,
        flexOrder: true,
        gridArea: true,
        gridRow: true,
        gridRowEnd: true,
        gridRowSpan: true,
        gridRowStart: true,
        gridColumn: true,
        gridColumnEnd: true,
        gridColumnSpan: true,
        gridColumnStart: true,
        fontWeight: true,
        lineClamp: true,
        lineHeight: true,
        opacity: true,
        order: true,
        orphans: true,
        tabSize: true,
        widows: true,
        zIndex: true,
        zoom: true,
        // SVG-related properties
        fillOpacity: true,
        floodOpacity: true,
        stopOpacity: true,
        strokeDasharray: true,
        strokeDashoffset: true,
        strokeMiterlimit: true,
        strokeOpacity: true,
        strokeWidth: true
    };
    /**
 * @param {string} prefix vendor-specific prefix, eg: Webkit
 * @param {string} key style name, eg: transitionDuration
 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
 * WebkitTransitionDuration
 */ function prefixKey(prefix, key) {
        return prefix + key.charAt(0).toUpperCase() + key.substring(1);
    }
    /**
 * Support style names that may come passed in prefixed by adding permutations
 * of vendor prefixes.
 */ var prefixes = [
        'Webkit',
        'ms',
        'Moz',
        'O'
    ]; // Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
    // infinite loop, because it iterates over the newly added props too.
    Object.keys(isUnitlessNumber).forEach(function(prop) {
        prefixes.forEach(function(prefix) {
            isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
        });
    });
    var hasReadOnlyValue = {
        button: true,
        checkbox: true,
        image: true,
        hidden: true,
        radio: true,
        reset: true,
        submit: true
    };
    function checkControlledValueProps(tagName, props) {
        if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.");
        if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function isCustomComponent(tagName, props) {
        if (tagName.indexOf('-') === -1) return typeof props.is === 'string';
        switch(tagName){
            // These are reserved SVG and MathML elements.
            // We don't mind this list too much because we expect it to never grow.
            // The alternative is to track the namespace in a few places which is convoluted.
            // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts
            case 'annotation-xml':
            case 'color-profile':
            case 'font-face':
            case 'font-face-src':
            case 'font-face-uri':
            case 'font-face-format':
            case 'font-face-name':
            case 'missing-glyph':
                return false;
            default:
                return true;
        }
    }
    var ariaProperties = {
        'aria-current': 0,
        // state
        'aria-description': 0,
        'aria-details': 0,
        'aria-disabled': 0,
        // state
        'aria-hidden': 0,
        // state
        'aria-invalid': 0,
        // state
        'aria-keyshortcuts': 0,
        'aria-label': 0,
        'aria-roledescription': 0,
        // Widget Attributes
        'aria-autocomplete': 0,
        'aria-checked': 0,
        'aria-expanded': 0,
        'aria-haspopup': 0,
        'aria-level': 0,
        'aria-modal': 0,
        'aria-multiline': 0,
        'aria-multiselectable': 0,
        'aria-orientation': 0,
        'aria-placeholder': 0,
        'aria-pressed': 0,
        'aria-readonly': 0,
        'aria-required': 0,
        'aria-selected': 0,
        'aria-sort': 0,
        'aria-valuemax': 0,
        'aria-valuemin': 0,
        'aria-valuenow': 0,
        'aria-valuetext': 0,
        // Live Region Attributes
        'aria-atomic': 0,
        'aria-busy': 0,
        'aria-live': 0,
        'aria-relevant': 0,
        // Drag-and-Drop Attributes
        'aria-dropeffect': 0,
        'aria-grabbed': 0,
        // Relationship Attributes
        'aria-activedescendant': 0,
        'aria-colcount': 0,
        'aria-colindex': 0,
        'aria-colspan': 0,
        'aria-controls': 0,
        'aria-describedby': 0,
        'aria-errormessage': 0,
        'aria-flowto': 0,
        'aria-labelledby': 0,
        'aria-owns': 0,
        'aria-posinset': 0,
        'aria-rowcount': 0,
        'aria-rowindex': 0,
        'aria-rowspan': 0,
        'aria-setsize': 0
    };
    var warnedProperties = {};
    var rARIA = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');
    var rARIACamel = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');
    function validateProperty(tagName, name) {
        if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) return true;
        if (rARIACamel.test(name)) {
            var ariaName = 'aria-' + name.slice(4).toLowerCase();
            var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null; // If this is an aria-* attribute, but is not listed in the known DOM
            // DOM properties, then it is an invalid aria-* attribute.
            if (correctName == null) {
                error('Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.', name);
                warnedProperties[name] = true;
                return true;
            } // aria-* attributes should be lowercase; suggest the lowercase version.
            if (name !== correctName) {
                error('Invalid ARIA attribute `%s`. Did you mean `%s`?', name, correctName);
                warnedProperties[name] = true;
                return true;
            }
        }
        if (rARIA.test(name)) {
            var lowerCasedName = name.toLowerCase();
            var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null; // If this is an aria-* attribute, but is not listed in the known DOM
            // DOM properties, then it is an invalid aria-* attribute.
            if (standardName == null) {
                warnedProperties[name] = true;
                return false;
            } // aria-* attributes should be lowercase; suggest the lowercase version.
            if (name !== standardName) {
                error('Unknown ARIA attribute `%s`. Did you mean `%s`?', name, standardName);
                warnedProperties[name] = true;
                return true;
            }
        }
        return true;
    }
    function warnInvalidARIAProps(type, props) {
        var invalidProps = [];
        for(var key in props){
            var isValid = validateProperty(type, key);
            if (!isValid) invalidProps.push(key);
        }
        var unknownPropString = invalidProps.map(function(prop) {
            return '`' + prop + '`';
        }).join(', ');
        if (invalidProps.length === 1) error("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
        else if (invalidProps.length > 1) error("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
    }
    function validateProperties(type, props) {
        if (isCustomComponent(type, props)) return;
        warnInvalidARIAProps(type, props);
    }
    var didWarnValueNull = false;
    function validateProperties$1(type, props) {
        if (type !== 'input' && type !== 'textarea' && type !== 'select') return;
        if (props != null && props.value === null && !didWarnValueNull) {
            didWarnValueNull = true;
            if (type === 'select' && props.multiple) error("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type);
            else error("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type);
        }
    }
    // When adding attributes to the HTML or SVG allowed attribute list, be sure to
    // also add them to this module to ensure casing and incorrect name
    // warnings.
    var possibleStandardNames = {
        // HTML
        accept: 'accept',
        acceptcharset: 'acceptCharset',
        'accept-charset': 'acceptCharset',
        accesskey: 'accessKey',
        action: 'action',
        allowfullscreen: 'allowFullScreen',
        alt: 'alt',
        as: 'as',
        async: 'async',
        autocapitalize: 'autoCapitalize',
        autocomplete: 'autoComplete',
        autocorrect: 'autoCorrect',
        autofocus: 'autoFocus',
        autoplay: 'autoPlay',
        autosave: 'autoSave',
        capture: 'capture',
        cellpadding: 'cellPadding',
        cellspacing: 'cellSpacing',
        challenge: 'challenge',
        charset: 'charSet',
        checked: 'checked',
        children: 'children',
        cite: 'cite',
        class: 'className',
        classid: 'classID',
        classname: 'className',
        cols: 'cols',
        colspan: 'colSpan',
        content: 'content',
        contenteditable: 'contentEditable',
        contextmenu: 'contextMenu',
        controls: 'controls',
        controlslist: 'controlsList',
        coords: 'coords',
        crossorigin: 'crossOrigin',
        dangerouslysetinnerhtml: 'dangerouslySetInnerHTML',
        data: 'data',
        datetime: 'dateTime',
        default: 'default',
        defaultchecked: 'defaultChecked',
        defaultvalue: 'defaultValue',
        defer: 'defer',
        dir: 'dir',
        disabled: 'disabled',
        disablepictureinpicture: 'disablePictureInPicture',
        disableremoteplayback: 'disableRemotePlayback',
        download: 'download',
        draggable: 'draggable',
        enctype: 'encType',
        enterkeyhint: 'enterKeyHint',
        for: 'htmlFor',
        form: 'form',
        formmethod: 'formMethod',
        formaction: 'formAction',
        formenctype: 'formEncType',
        formnovalidate: 'formNoValidate',
        formtarget: 'formTarget',
        frameborder: 'frameBorder',
        headers: 'headers',
        height: 'height',
        hidden: 'hidden',
        high: 'high',
        href: 'href',
        hreflang: 'hrefLang',
        htmlfor: 'htmlFor',
        httpequiv: 'httpEquiv',
        'http-equiv': 'httpEquiv',
        icon: 'icon',
        id: 'id',
        imagesizes: 'imageSizes',
        imagesrcset: 'imageSrcSet',
        innerhtml: 'innerHTML',
        inputmode: 'inputMode',
        integrity: 'integrity',
        is: 'is',
        itemid: 'itemID',
        itemprop: 'itemProp',
        itemref: 'itemRef',
        itemscope: 'itemScope',
        itemtype: 'itemType',
        keyparams: 'keyParams',
        keytype: 'keyType',
        kind: 'kind',
        label: 'label',
        lang: 'lang',
        list: 'list',
        loop: 'loop',
        low: 'low',
        manifest: 'manifest',
        marginwidth: 'marginWidth',
        marginheight: 'marginHeight',
        max: 'max',
        maxlength: 'maxLength',
        media: 'media',
        mediagroup: 'mediaGroup',
        method: 'method',
        min: 'min',
        minlength: 'minLength',
        multiple: 'multiple',
        muted: 'muted',
        name: 'name',
        nomodule: 'noModule',
        nonce: 'nonce',
        novalidate: 'noValidate',
        open: 'open',
        optimum: 'optimum',
        pattern: 'pattern',
        placeholder: 'placeholder',
        playsinline: 'playsInline',
        poster: 'poster',
        preload: 'preload',
        profile: 'profile',
        radiogroup: 'radioGroup',
        readonly: 'readOnly',
        referrerpolicy: 'referrerPolicy',
        rel: 'rel',
        required: 'required',
        reversed: 'reversed',
        role: 'role',
        rows: 'rows',
        rowspan: 'rowSpan',
        sandbox: 'sandbox',
        scope: 'scope',
        scoped: 'scoped',
        scrolling: 'scrolling',
        seamless: 'seamless',
        selected: 'selected',
        shape: 'shape',
        size: 'size',
        sizes: 'sizes',
        span: 'span',
        spellcheck: 'spellCheck',
        src: 'src',
        srcdoc: 'srcDoc',
        srclang: 'srcLang',
        srcset: 'srcSet',
        start: 'start',
        step: 'step',
        style: 'style',
        summary: 'summary',
        tabindex: 'tabIndex',
        target: 'target',
        title: 'title',
        type: 'type',
        usemap: 'useMap',
        value: 'value',
        width: 'width',
        wmode: 'wmode',
        wrap: 'wrap',
        // SVG
        about: 'about',
        accentheight: 'accentHeight',
        'accent-height': 'accentHeight',
        accumulate: 'accumulate',
        additive: 'additive',
        alignmentbaseline: 'alignmentBaseline',
        'alignment-baseline': 'alignmentBaseline',
        allowreorder: 'allowReorder',
        alphabetic: 'alphabetic',
        amplitude: 'amplitude',
        arabicform: 'arabicForm',
        'arabic-form': 'arabicForm',
        ascent: 'ascent',
        attributename: 'attributeName',
        attributetype: 'attributeType',
        autoreverse: 'autoReverse',
        azimuth: 'azimuth',
        basefrequency: 'baseFrequency',
        baselineshift: 'baselineShift',
        'baseline-shift': 'baselineShift',
        baseprofile: 'baseProfile',
        bbox: 'bbox',
        begin: 'begin',
        bias: 'bias',
        by: 'by',
        calcmode: 'calcMode',
        capheight: 'capHeight',
        'cap-height': 'capHeight',
        clip: 'clip',
        clippath: 'clipPath',
        'clip-path': 'clipPath',
        clippathunits: 'clipPathUnits',
        cliprule: 'clipRule',
        'clip-rule': 'clipRule',
        color: 'color',
        colorinterpolation: 'colorInterpolation',
        'color-interpolation': 'colorInterpolation',
        colorinterpolationfilters: 'colorInterpolationFilters',
        'color-interpolation-filters': 'colorInterpolationFilters',
        colorprofile: 'colorProfile',
        'color-profile': 'colorProfile',
        colorrendering: 'colorRendering',
        'color-rendering': 'colorRendering',
        contentscripttype: 'contentScriptType',
        contentstyletype: 'contentStyleType',
        cursor: 'cursor',
        cx: 'cx',
        cy: 'cy',
        d: 'd',
        datatype: 'datatype',
        decelerate: 'decelerate',
        descent: 'descent',
        diffuseconstant: 'diffuseConstant',
        direction: 'direction',
        display: 'display',
        divisor: 'divisor',
        dominantbaseline: 'dominantBaseline',
        'dominant-baseline': 'dominantBaseline',
        dur: 'dur',
        dx: 'dx',
        dy: 'dy',
        edgemode: 'edgeMode',
        elevation: 'elevation',
        enablebackground: 'enableBackground',
        'enable-background': 'enableBackground',
        end: 'end',
        exponent: 'exponent',
        externalresourcesrequired: 'externalResourcesRequired',
        fill: 'fill',
        fillopacity: 'fillOpacity',
        'fill-opacity': 'fillOpacity',
        fillrule: 'fillRule',
        'fill-rule': 'fillRule',
        filter: 'filter',
        filterres: 'filterRes',
        filterunits: 'filterUnits',
        floodopacity: 'floodOpacity',
        'flood-opacity': 'floodOpacity',
        floodcolor: 'floodColor',
        'flood-color': 'floodColor',
        focusable: 'focusable',
        fontfamily: 'fontFamily',
        'font-family': 'fontFamily',
        fontsize: 'fontSize',
        'font-size': 'fontSize',
        fontsizeadjust: 'fontSizeAdjust',
        'font-size-adjust': 'fontSizeAdjust',
        fontstretch: 'fontStretch',
        'font-stretch': 'fontStretch',
        fontstyle: 'fontStyle',
        'font-style': 'fontStyle',
        fontvariant: 'fontVariant',
        'font-variant': 'fontVariant',
        fontweight: 'fontWeight',
        'font-weight': 'fontWeight',
        format: 'format',
        from: 'from',
        fx: 'fx',
        fy: 'fy',
        g1: 'g1',
        g2: 'g2',
        glyphname: 'glyphName',
        'glyph-name': 'glyphName',
        glyphorientationhorizontal: 'glyphOrientationHorizontal',
        'glyph-orientation-horizontal': 'glyphOrientationHorizontal',
        glyphorientationvertical: 'glyphOrientationVertical',
        'glyph-orientation-vertical': 'glyphOrientationVertical',
        glyphref: 'glyphRef',
        gradienttransform: 'gradientTransform',
        gradientunits: 'gradientUnits',
        hanging: 'hanging',
        horizadvx: 'horizAdvX',
        'horiz-adv-x': 'horizAdvX',
        horizoriginx: 'horizOriginX',
        'horiz-origin-x': 'horizOriginX',
        ideographic: 'ideographic',
        imagerendering: 'imageRendering',
        'image-rendering': 'imageRendering',
        in2: 'in2',
        in: 'in',
        inlist: 'inlist',
        intercept: 'intercept',
        k1: 'k1',
        k2: 'k2',
        k3: 'k3',
        k4: 'k4',
        k: 'k',
        kernelmatrix: 'kernelMatrix',
        kernelunitlength: 'kernelUnitLength',
        kerning: 'kerning',
        keypoints: 'keyPoints',
        keysplines: 'keySplines',
        keytimes: 'keyTimes',
        lengthadjust: 'lengthAdjust',
        letterspacing: 'letterSpacing',
        'letter-spacing': 'letterSpacing',
        lightingcolor: 'lightingColor',
        'lighting-color': 'lightingColor',
        limitingconeangle: 'limitingConeAngle',
        local: 'local',
        markerend: 'markerEnd',
        'marker-end': 'markerEnd',
        markerheight: 'markerHeight',
        markermid: 'markerMid',
        'marker-mid': 'markerMid',
        markerstart: 'markerStart',
        'marker-start': 'markerStart',
        markerunits: 'markerUnits',
        markerwidth: 'markerWidth',
        mask: 'mask',
        maskcontentunits: 'maskContentUnits',
        maskunits: 'maskUnits',
        mathematical: 'mathematical',
        mode: 'mode',
        numoctaves: 'numOctaves',
        offset: 'offset',
        opacity: 'opacity',
        operator: 'operator',
        order: 'order',
        orient: 'orient',
        orientation: 'orientation',
        origin: 'origin',
        overflow: 'overflow',
        overlineposition: 'overlinePosition',
        'overline-position': 'overlinePosition',
        overlinethickness: 'overlineThickness',
        'overline-thickness': 'overlineThickness',
        paintorder: 'paintOrder',
        'paint-order': 'paintOrder',
        panose1: 'panose1',
        'panose-1': 'panose1',
        pathlength: 'pathLength',
        patterncontentunits: 'patternContentUnits',
        patterntransform: 'patternTransform',
        patternunits: 'patternUnits',
        pointerevents: 'pointerEvents',
        'pointer-events': 'pointerEvents',
        points: 'points',
        pointsatx: 'pointsAtX',
        pointsaty: 'pointsAtY',
        pointsatz: 'pointsAtZ',
        prefix: 'prefix',
        preservealpha: 'preserveAlpha',
        preserveaspectratio: 'preserveAspectRatio',
        primitiveunits: 'primitiveUnits',
        property: 'property',
        r: 'r',
        radius: 'radius',
        refx: 'refX',
        refy: 'refY',
        renderingintent: 'renderingIntent',
        'rendering-intent': 'renderingIntent',
        repeatcount: 'repeatCount',
        repeatdur: 'repeatDur',
        requiredextensions: 'requiredExtensions',
        requiredfeatures: 'requiredFeatures',
        resource: 'resource',
        restart: 'restart',
        result: 'result',
        results: 'results',
        rotate: 'rotate',
        rx: 'rx',
        ry: 'ry',
        scale: 'scale',
        security: 'security',
        seed: 'seed',
        shaperendering: 'shapeRendering',
        'shape-rendering': 'shapeRendering',
        slope: 'slope',
        spacing: 'spacing',
        specularconstant: 'specularConstant',
        specularexponent: 'specularExponent',
        speed: 'speed',
        spreadmethod: 'spreadMethod',
        startoffset: 'startOffset',
        stddeviation: 'stdDeviation',
        stemh: 'stemh',
        stemv: 'stemv',
        stitchtiles: 'stitchTiles',
        stopcolor: 'stopColor',
        'stop-color': 'stopColor',
        stopopacity: 'stopOpacity',
        'stop-opacity': 'stopOpacity',
        strikethroughposition: 'strikethroughPosition',
        'strikethrough-position': 'strikethroughPosition',
        strikethroughthickness: 'strikethroughThickness',
        'strikethrough-thickness': 'strikethroughThickness',
        string: 'string',
        stroke: 'stroke',
        strokedasharray: 'strokeDasharray',
        'stroke-dasharray': 'strokeDasharray',
        strokedashoffset: 'strokeDashoffset',
        'stroke-dashoffset': 'strokeDashoffset',
        strokelinecap: 'strokeLinecap',
        'stroke-linecap': 'strokeLinecap',
        strokelinejoin: 'strokeLinejoin',
        'stroke-linejoin': 'strokeLinejoin',
        strokemiterlimit: 'strokeMiterlimit',
        'stroke-miterlimit': 'strokeMiterlimit',
        strokewidth: 'strokeWidth',
        'stroke-width': 'strokeWidth',
        strokeopacity: 'strokeOpacity',
        'stroke-opacity': 'strokeOpacity',
        suppresscontenteditablewarning: 'suppressContentEditableWarning',
        suppresshydrationwarning: 'suppressHydrationWarning',
        surfacescale: 'surfaceScale',
        systemlanguage: 'systemLanguage',
        tablevalues: 'tableValues',
        targetx: 'targetX',
        targety: 'targetY',
        textanchor: 'textAnchor',
        'text-anchor': 'textAnchor',
        textdecoration: 'textDecoration',
        'text-decoration': 'textDecoration',
        textlength: 'textLength',
        textrendering: 'textRendering',
        'text-rendering': 'textRendering',
        to: 'to',
        transform: 'transform',
        typeof: 'typeof',
        u1: 'u1',
        u2: 'u2',
        underlineposition: 'underlinePosition',
        'underline-position': 'underlinePosition',
        underlinethickness: 'underlineThickness',
        'underline-thickness': 'underlineThickness',
        unicode: 'unicode',
        unicodebidi: 'unicodeBidi',
        'unicode-bidi': 'unicodeBidi',
        unicoderange: 'unicodeRange',
        'unicode-range': 'unicodeRange',
        unitsperem: 'unitsPerEm',
        'units-per-em': 'unitsPerEm',
        unselectable: 'unselectable',
        valphabetic: 'vAlphabetic',
        'v-alphabetic': 'vAlphabetic',
        values: 'values',
        vectoreffect: 'vectorEffect',
        'vector-effect': 'vectorEffect',
        version: 'version',
        vertadvy: 'vertAdvY',
        'vert-adv-y': 'vertAdvY',
        vertoriginx: 'vertOriginX',
        'vert-origin-x': 'vertOriginX',
        vertoriginy: 'vertOriginY',
        'vert-origin-y': 'vertOriginY',
        vhanging: 'vHanging',
        'v-hanging': 'vHanging',
        videographic: 'vIdeographic',
        'v-ideographic': 'vIdeographic',
        viewbox: 'viewBox',
        viewtarget: 'viewTarget',
        visibility: 'visibility',
        vmathematical: 'vMathematical',
        'v-mathematical': 'vMathematical',
        vocab: 'vocab',
        widths: 'widths',
        wordspacing: 'wordSpacing',
        'word-spacing': 'wordSpacing',
        writingmode: 'writingMode',
        'writing-mode': 'writingMode',
        x1: 'x1',
        x2: 'x2',
        x: 'x',
        xchannelselector: 'xChannelSelector',
        xheight: 'xHeight',
        'x-height': 'xHeight',
        xlinkactuate: 'xlinkActuate',
        'xlink:actuate': 'xlinkActuate',
        xlinkarcrole: 'xlinkArcrole',
        'xlink:arcrole': 'xlinkArcrole',
        xlinkhref: 'xlinkHref',
        'xlink:href': 'xlinkHref',
        xlinkrole: 'xlinkRole',
        'xlink:role': 'xlinkRole',
        xlinkshow: 'xlinkShow',
        'xlink:show': 'xlinkShow',
        xlinktitle: 'xlinkTitle',
        'xlink:title': 'xlinkTitle',
        xlinktype: 'xlinkType',
        'xlink:type': 'xlinkType',
        xmlbase: 'xmlBase',
        'xml:base': 'xmlBase',
        xmllang: 'xmlLang',
        'xml:lang': 'xmlLang',
        xmlns: 'xmlns',
        'xml:space': 'xmlSpace',
        xmlnsxlink: 'xmlnsXlink',
        'xmlns:xlink': 'xmlnsXlink',
        xmlspace: 'xmlSpace',
        y1: 'y1',
        y2: 'y2',
        y: 'y',
        ychannelselector: 'yChannelSelector',
        z: 'z',
        zoomandpan: 'zoomAndPan'
    };
    var validateProperty$1 = function() {};
    var warnedProperties$1 = {};
    var EVENT_NAME_REGEX = /^on./;
    var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
    var rARIA$1 = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');
    var rARIACamel$1 = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');
    validateProperty$1 = function(tagName, name, value, eventRegistry) {
        if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) return true;
        var lowerCasedName = name.toLowerCase();
        if (lowerCasedName === 'onfocusin' || lowerCasedName === 'onfocusout') {
            error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.");
            warnedProperties$1[name] = true;
            return true;
        } // We can't rely on the event system being injected on the server.
        if (eventRegistry != null) {
            var registrationNameDependencies = eventRegistry.registrationNameDependencies, possibleRegistrationNames = eventRegistry.possibleRegistrationNames;
            if (registrationNameDependencies.hasOwnProperty(name)) return true;
            var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;
            if (registrationName != null) {
                error('Invalid event handler property `%s`. Did you mean `%s`?', name, registrationName);
                warnedProperties$1[name] = true;
                return true;
            }
            if (EVENT_NAME_REGEX.test(name)) {
                error('Unknown event handler property `%s`. It will be ignored.', name);
                warnedProperties$1[name] = true;
                return true;
            }
        } else if (EVENT_NAME_REGEX.test(name)) {
            // If no event plugins have been injected, we are in a server environment.
            // So we can't tell if the event name is correct for sure, but we can filter
            // out known bad ones like `onclick`. We can't suggest a specific replacement though.
            if (INVALID_EVENT_NAME_REGEX.test(name)) error("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name);
            warnedProperties$1[name] = true;
            return true;
        } // Let the ARIA attribute hook validate ARIA attributes
        if (rARIA$1.test(name) || rARIACamel$1.test(name)) return true;
        if (lowerCasedName === 'innerhtml') {
            error("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.");
            warnedProperties$1[name] = true;
            return true;
        }
        if (lowerCasedName === 'aria') {
            error("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.");
            warnedProperties$1[name] = true;
            return true;
        }
        if (lowerCasedName === 'is' && value !== null && value !== undefined && typeof value !== 'string') {
            error("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value);
            warnedProperties$1[name] = true;
            return true;
        }
        if (typeof value === 'number' && isNaN(value)) {
            error("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name);
            warnedProperties$1[name] = true;
            return true;
        }
        var propertyInfo = getPropertyInfo(name);
        var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED; // Known attributes should match the casing specified in the property config.
        if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
            var standardName = possibleStandardNames[lowerCasedName];
            if (standardName !== name) {
                error('Invalid DOM property `%s`. Did you mean `%s`?', name, standardName);
                warnedProperties$1[name] = true;
                return true;
            }
        } else if (!isReserved && name !== lowerCasedName) {
            // Unknown attributes should have lowercase casing since that's how they
            // will be cased anyway with server rendering.
            error("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name, lowerCasedName);
            warnedProperties$1[name] = true;
            return true;
        }
        if (typeof value === 'boolean' && shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
            if (value) error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value, name, name, value, name);
            else error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);
            warnedProperties$1[name] = true;
            return true;
        } // Now that we've validated casing, do not validate
        // data types for reserved props
        if (isReserved) return true;
         // Warn when a known attribute is a bad type
        if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
            warnedProperties$1[name] = true;
            return false;
        } // Warn when passing the strings 'false' or 'true' into a boolean prop
        if ((value === 'false' || value === 'true') && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
            error("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name, value === 'false' ? 'The browser will interpret it as a truthy value.' : 'Although this works, it will not work as expected if you pass the string "false".', name, value);
            warnedProperties$1[name] = true;
            return true;
        }
        return true;
    };
    var warnUnknownProperties = function(type, props, eventRegistry) {
        var unknownProps = [];
        for(var key in props){
            var isValid = validateProperty$1(type, key, props[key], eventRegistry);
            if (!isValid) unknownProps.push(key);
        }
        var unknownPropString = unknownProps.map(function(prop) {
            return '`' + prop + '`';
        }).join(', ');
        if (unknownProps.length === 1) error("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
        else if (unknownProps.length > 1) error("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
    };
    function validateProperties$2(type, props, eventRegistry) {
        if (isCustomComponent(type, props)) return;
        warnUnknownProperties(type, props, eventRegistry);
    }
    var warnValidStyle = function() {};
    // 'msTransform' is correct, but the other prefixes should be capitalized
    var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
    var msPattern = /^-ms-/;
    var hyphenPattern = /-(.)/g; // style values shouldn't contain a semicolon
    var badStyleValueWithSemicolonPattern = /;\s*$/;
    var warnedStyleNames = {};
    var warnedStyleValues = {};
    var warnedForNaNValue = false;
    var warnedForInfinityValue = false;
    var camelize = function(string) {
        return string.replace(hyphenPattern, function(_, character) {
            return character.toUpperCase();
        });
    };
    var warnHyphenatedStyleName = function(name) {
        if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) return;
        warnedStyleNames[name] = true;
        error('Unsupported style property %s. Did you mean %s?', name, // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
        // is converted to lowercase `ms`.
        camelize(name.replace(msPattern, 'ms-')));
    };
    var warnBadVendoredStyleName = function(name) {
        if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) return;
        warnedStyleNames[name] = true;
        error('Unsupported vendor-prefixed style property %s. Did you mean %s?', name, name.charAt(0).toUpperCase() + name.slice(1));
    };
    var warnStyleValueWithSemicolon = function(name, value) {
        if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) return;
        warnedStyleValues[value] = true;
        error('Style property values shouldn\'t contain a semicolon. Try "%s: %s" instead.', name, value.replace(badStyleValueWithSemicolonPattern, ''));
    };
    var warnStyleValueIsNaN = function(name, value) {
        if (warnedForNaNValue) return;
        warnedForNaNValue = true;
        error('`NaN` is an invalid value for the `%s` css style property.', name);
    };
    var warnStyleValueIsInfinity = function(name, value) {
        if (warnedForInfinityValue) return;
        warnedForInfinityValue = true;
        error('`Infinity` is an invalid value for the `%s` css style property.', name);
    };
    warnValidStyle = function(name, value) {
        if (name.indexOf('-') > -1) warnHyphenatedStyleName(name);
        else if (badVendoredStyleNamePattern.test(name)) warnBadVendoredStyleName(name);
        else if (badStyleValueWithSemicolonPattern.test(value)) warnStyleValueWithSemicolon(name, value);
        if (typeof value === 'number') {
            if (isNaN(value)) warnStyleValueIsNaN(name, value);
            else if (!isFinite(value)) warnStyleValueIsInfinity(name, value);
        }
    };
    var warnValidStyle$1 = warnValidStyle;
    // code copied and modified from escape-html
    var matchHtmlRegExp = /["'&<>]/;
    /**
 * Escapes special characters and HTML entities in a given html string.
 *
 * @param  {string} string HTML string to escape for later insertion
 * @return {string}
 * @public
 */ function escapeHtml(string) {
        checkHtmlStringCoercion(string);
        var str = '' + string;
        var match = matchHtmlRegExp.exec(str);
        if (!match) return str;
        var escape;
        var html = '';
        var index;
        var lastIndex = 0;
        for(index = match.index; index < str.length; index++){
            switch(str.charCodeAt(index)){
                case 34:
                    // "
                    escape = '&quot;';
                    break;
                case 38:
                    // &
                    escape = '&amp;';
                    break;
                case 39:
                    // '
                    escape = '&#x27;'; // modified from escape-html; used to be '&#39'
                    break;
                case 60:
                    // <
                    escape = '&lt;';
                    break;
                case 62:
                    // >
                    escape = '&gt;';
                    break;
                default:
                    continue;
            }
            if (lastIndex !== index) html += str.substring(lastIndex, index);
            lastIndex = index + 1;
            html += escape;
        }
        return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
    } // end code copied and modified from escape-html
    /**
 * Escapes text to prevent scripting attacks.
 *
 * @param {*} text Text value to escape.
 * @return {string} An escaped string.
 */ function escapeTextForBrowser(text) {
        if (typeof text === 'boolean' || typeof text === 'number') // this shortcircuit helps perf for types that we know will never have
        // special characters, especially given that this function is used often
        // for numeric dom ids.
        return '' + text;
        return escapeHtml(text);
    }
    var uppercasePattern = /([A-Z])/g;
    var msPattern$1 = /^ms-/;
    /**
 * Hyphenates a camelcased CSS property name, for example:
 *
 *   > hyphenateStyleName('backgroundColor')
 *   < "background-color"
 *   > hyphenateStyleName('MozTransition')
 *   < "-moz-transition"
 *   > hyphenateStyleName('msTransition')
 *   < "-ms-transition"
 *
 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
 * is converted to `-ms-`.
 */ function hyphenateStyleName(name) {
        return name.replace(uppercasePattern, '-$1').toLowerCase().replace(msPattern$1, '-ms-');
    }
    // and any newline or tab are filtered out as if they're not part of the URL.
    // https://url.spec.whatwg.org/#url-parsing
    // Tab or newline are defined as \r\n\t:
    // https://infra.spec.whatwg.org/#ascii-tab-or-newline
    // A C0 control is a code point in the range \u0000 NULL to \u001F
    // INFORMATION SEPARATOR ONE, inclusive:
    // https://infra.spec.whatwg.org/#c0-control-or-space
    /* eslint-disable max-len */ var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
    var didWarn = false;
    function sanitizeURL(url) {
        if (!didWarn && isJavaScriptProtocol.test(url)) {
            didWarn = true;
            error("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url));
        }
    }
    var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare
    function isArray(a) {
        return isArrayImpl(a);
    }
    var startInlineScript = stringToPrecomputedChunk('<script>');
    var endInlineScript = stringToPrecomputedChunk('</script>');
    var startScriptSrc = stringToPrecomputedChunk('<script src="');
    var startModuleSrc = stringToPrecomputedChunk('<script type="module" src="');
    var endAsyncScript = stringToPrecomputedChunk('" async=""></script>');
    /**
 * This escaping function is designed to work with bootstrapScriptContent only.
 * because we know we are escaping the entire script. We can avoid for instance
 * escaping html comment string sequences that are valid javascript as well because
 * if there are no sebsequent <script sequences the html parser will never enter
 * script data double escaped state (see: https://www.w3.org/TR/html53/syntax.html#script-data-double-escaped-state)
 *
 * While untrusted script content should be made safe before using this api it will
 * ensure that the script cannot be early terminated or never terminated state
 */ function escapeBootstrapScriptContent(scriptText) {
        checkHtmlStringCoercion(scriptText);
        return ('' + scriptText).replace(scriptRegex, scriptReplacer);
    }
    var scriptRegex = /(<\/|<)(s)(cript)/gi;
    var scriptReplacer = function(match, prefix, s, suffix) {
        return "" + prefix + (s === 's' ? "\\u0073" : "\\u0053") + suffix;
    }; // Allows us to keep track of what we've already written so we can refer back to it.
    function createResponseState(identifierPrefix, nonce, bootstrapScriptContent, bootstrapScripts, bootstrapModules) {
        var idPrefix = identifierPrefix === undefined ? '' : identifierPrefix;
        var inlineScriptWithNonce = nonce === undefined ? startInlineScript : stringToPrecomputedChunk('<script nonce="' + escapeTextForBrowser(nonce) + '">');
        var bootstrapChunks = [];
        if (bootstrapScriptContent !== undefined) bootstrapChunks.push(inlineScriptWithNonce, stringToChunk(escapeBootstrapScriptContent(bootstrapScriptContent)), endInlineScript);
        if (bootstrapScripts !== undefined) for(var i = 0; i < bootstrapScripts.length; i++)bootstrapChunks.push(startScriptSrc, stringToChunk(escapeTextForBrowser(bootstrapScripts[i])), endAsyncScript);
        if (bootstrapModules !== undefined) for(var _i = 0; _i < bootstrapModules.length; _i++)bootstrapChunks.push(startModuleSrc, stringToChunk(escapeTextForBrowser(bootstrapModules[_i])), endAsyncScript);
        return {
            bootstrapChunks: bootstrapChunks,
            startInlineScript: inlineScriptWithNonce,
            placeholderPrefix: stringToPrecomputedChunk(idPrefix + 'P:'),
            segmentPrefix: stringToPrecomputedChunk(idPrefix + 'S:'),
            boundaryPrefix: idPrefix + 'B:',
            idPrefix: idPrefix,
            nextSuspenseID: 0,
            sentCompleteSegmentFunction: false,
            sentCompleteBoundaryFunction: false,
            sentClientRenderFunction: false
        };
    } // Constants for the insertion mode we're currently writing in. We don't encode all HTML5 insertion
    // modes. We only include the variants as they matter for the sake of our purposes.
    // We don't actually provide the namespace therefore we use constants instead of the string.
    var ROOT_HTML_MODE = 0; // Used for the root most element tag.
    var HTML_MODE = 1;
    var SVG_MODE = 2;
    var MATHML_MODE = 3;
    var HTML_TABLE_MODE = 4;
    var HTML_TABLE_BODY_MODE = 5;
    var HTML_TABLE_ROW_MODE = 6;
    var HTML_COLGROUP_MODE = 7; // We have a greater than HTML_TABLE_MODE check elsewhere. If you add more cases here, make sure it
    // still makes sense
    function createFormatContext(insertionMode, selectedValue) {
        return {
            insertionMode: insertionMode,
            selectedValue: selectedValue
        };
    }
    function getChildFormatContext(parentContext, type, props) {
        switch(type){
            case 'select':
                return createFormatContext(HTML_MODE, props.value != null ? props.value : props.defaultValue);
            case 'svg':
                return createFormatContext(SVG_MODE, null);
            case 'math':
                return createFormatContext(MATHML_MODE, null);
            case 'foreignObject':
                return createFormatContext(HTML_MODE, null);
            // Table parents are special in that their children can only be created at all if they're
            // wrapped in a table parent. So we need to encode that we're entering this mode.
            case 'table':
                return createFormatContext(HTML_TABLE_MODE, null);
            case 'thead':
            case 'tbody':
            case 'tfoot':
                return createFormatContext(HTML_TABLE_BODY_MODE, null);
            case 'colgroup':
                return createFormatContext(HTML_COLGROUP_MODE, null);
            case 'tr':
                return createFormatContext(HTML_TABLE_ROW_MODE, null);
        }
        if (parentContext.insertionMode >= HTML_TABLE_MODE) // Whatever tag this was, it wasn't a table parent or other special parent, so we must have
        // entered plain HTML again.
        return createFormatContext(HTML_MODE, null);
        if (parentContext.insertionMode === ROOT_HTML_MODE) // We've emitted the root and is now in plain HTML mode.
        return createFormatContext(HTML_MODE, null);
        return parentContext;
    }
    var UNINITIALIZED_SUSPENSE_BOUNDARY_ID = null;
    function assignSuspenseBoundaryID(responseState) {
        var generatedID = responseState.nextSuspenseID++;
        return stringToPrecomputedChunk(responseState.boundaryPrefix + generatedID.toString(16));
    }
    function makeId(responseState, treeId, localId) {
        var idPrefix = responseState.idPrefix;
        var id = ':' + idPrefix + 'R' + treeId; // Unless this is the first id at this level, append a number at the end
        // that represents the position of this useId hook among all the useId
        // hooks for this fiber.
        if (localId > 0) id += 'H' + localId.toString(32);
        return id + ':';
    }
    function encodeHTMLTextNode(text) {
        return escapeTextForBrowser(text);
    }
    var textSeparator = stringToPrecomputedChunk('<!-- -->');
    function pushTextInstance(target, text, responseState, textEmbedded) {
        if (text === '') // Empty text doesn't have a DOM node representation and the hydration is aware of this.
        return textEmbedded;
        if (textEmbedded) target.push(textSeparator);
        target.push(stringToChunk(encodeHTMLTextNode(text)));
        return true;
    } // Called when Fizz is done with a Segment. Currently the only purpose is to conditionally
    // emit a text separator when we don't know for sure it is safe to omit
    function pushSegmentFinale(target, responseState, lastPushedText, textEmbedded) {
        if (lastPushedText && textEmbedded) target.push(textSeparator);
    }
    var styleNameCache = new Map();
    function processStyleName(styleName) {
        var chunk = styleNameCache.get(styleName);
        if (chunk !== undefined) return chunk;
        var result = stringToPrecomputedChunk(escapeTextForBrowser(hyphenateStyleName(styleName)));
        styleNameCache.set(styleName, result);
        return result;
    }
    var styleAttributeStart = stringToPrecomputedChunk(' style="');
    var styleAssign = stringToPrecomputedChunk(':');
    var styleSeparator = stringToPrecomputedChunk(';');
    function pushStyle(target, responseState, style) {
        if (typeof style !== 'object') throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
        var isFirst = true;
        for(var styleName in style){
            if (!hasOwnProperty.call(style, styleName)) continue;
             // If you provide unsafe user data here they can inject arbitrary CSS
            // which may be problematic (I couldn't repro this):
            // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
            // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
            // This is not an XSS hole but instead a potential CSS injection issue
            // which has lead to a greater discussion about how we're going to
            // trust URLs moving forward. See #2115901
            var styleValue = style[styleName];
            if (styleValue == null || typeof styleValue === 'boolean' || styleValue === '') continue;
            var nameChunk = void 0;
            var valueChunk = void 0;
            var isCustomProperty = styleName.indexOf('--') === 0;
            if (isCustomProperty) {
                nameChunk = stringToChunk(escapeTextForBrowser(styleName));
                checkCSSPropertyStringCoercion(styleValue, styleName);
                valueChunk = stringToChunk(escapeTextForBrowser(('' + styleValue).trim()));
            } else {
                warnValidStyle$1(styleName, styleValue);
                nameChunk = processStyleName(styleName);
                if (typeof styleValue === 'number') {
                    if (styleValue !== 0 && !hasOwnProperty.call(isUnitlessNumber, styleName)) valueChunk = stringToChunk(styleValue + 'px'); // Presumes implicit 'px' suffix for unitless numbers
                    else valueChunk = stringToChunk('' + styleValue);
                } else {
                    checkCSSPropertyStringCoercion(styleValue, styleName);
                    valueChunk = stringToChunk(escapeTextForBrowser(('' + styleValue).trim()));
                }
            }
            if (isFirst) {
                isFirst = false; // If it's first, we don't need any separators prefixed.
                target.push(styleAttributeStart, nameChunk, styleAssign, valueChunk);
            } else target.push(styleSeparator, nameChunk, styleAssign, valueChunk);
        }
        if (!isFirst) target.push(attributeEnd);
    }
    var attributeSeparator = stringToPrecomputedChunk(' ');
    var attributeAssign = stringToPrecomputedChunk('="');
    var attributeEnd = stringToPrecomputedChunk('"');
    var attributeEmptyString = stringToPrecomputedChunk('=""');
    function pushAttribute(target, responseState, name, value) {
        switch(name){
            case 'style':
                pushStyle(target, responseState, value);
                return;
            case 'defaultValue':
            case 'defaultChecked':
            case 'innerHTML':
            case 'suppressContentEditableWarning':
            case 'suppressHydrationWarning':
                // Ignored. These are built-in to React on the client.
                return;
        }
        if (// We have already filtered out null/undefined and reserved words.
        name.length > 2 && (name[0] === 'o' || name[0] === 'O') && (name[1] === 'n' || name[1] === 'N')) return;
        var propertyInfo = getPropertyInfo(name);
        if (propertyInfo !== null) {
            // shouldRemoveAttribute
            switch(typeof value){
                case 'function':
                case 'symbol':
                    // eslint-disable-line
                    return;
                case 'boolean':
                    if (!propertyInfo.acceptsBooleans) return;
            }
            var attributeName = propertyInfo.attributeName;
            var attributeNameChunk = stringToChunk(attributeName); // TODO: If it's known we can cache the chunk.
            switch(propertyInfo.type){
                case BOOLEAN:
                    if (value) target.push(attributeSeparator, attributeNameChunk, attributeEmptyString);
                    return;
                case OVERLOADED_BOOLEAN:
                    if (value === true) target.push(attributeSeparator, attributeNameChunk, attributeEmptyString);
                    else if (value === false) ;
                    else target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
                    return;
                case NUMERIC:
                    if (!isNaN(value)) target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
                    break;
                case POSITIVE_NUMERIC:
                    if (!isNaN(value) && value >= 1) target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
                    break;
                default:
                    if (propertyInfo.sanitizeURL) {
                        checkAttributeStringCoercion(value, attributeName);
                        value = '' + value;
                        sanitizeURL(value);
                    }
                    target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
            }
        } else if (isAttributeNameSafe(name)) {
            // shouldRemoveAttribute
            switch(typeof value){
                case 'function':
                case 'symbol':
                    // eslint-disable-line
                    return;
                case 'boolean':
                    var prefix = name.toLowerCase().slice(0, 5);
                    if (prefix !== 'data-' && prefix !== 'aria-') return;
            }
            target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
        }
    }
    var endOfStartTag = stringToPrecomputedChunk('>');
    var endOfStartTagSelfClosing = stringToPrecomputedChunk('/>');
    function pushInnerHTML(target, innerHTML, children) {
        if (innerHTML != null) {
            if (children != null) throw new Error('Can only set one of `children` or `props.dangerouslySetInnerHTML`.');
            if (typeof innerHTML !== 'object' || !('__html' in innerHTML)) throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
            var html = innerHTML.__html;
            if (html !== null && html !== undefined) {
                checkHtmlStringCoercion(html);
                target.push(stringToChunk('' + html));
            }
        }
    } // TODO: Move these to ResponseState so that we warn for every request.
    // It would help debugging in stateful servers (e.g. service worker).
    var didWarnDefaultInputValue = false;
    var didWarnDefaultChecked = false;
    var didWarnDefaultSelectValue = false;
    var didWarnDefaultTextareaValue = false;
    var didWarnInvalidOptionChildren = false;
    var didWarnInvalidOptionInnerHTML = false;
    var didWarnSelectedSetOnOption = false;
    function checkSelectProp(props, propName) {
        var value = props[propName];
        if (value != null) {
            var array = isArray(value);
            if (props.multiple && !array) error("The `%s` prop supplied to <select> must be an array if `multiple` is true.", propName);
            else if (!props.multiple && array) error("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", propName);
        }
    }
    function pushStartSelect(target, props, responseState) {
        checkControlledValueProps('select', props);
        checkSelectProp(props, 'value');
        checkSelectProp(props, 'defaultValue');
        if (props.value !== undefined && props.defaultValue !== undefined && !didWarnDefaultSelectValue) {
            error("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components");
            didWarnDefaultSelectValue = true;
        }
        target.push(startChunkForTag('select'));
        var children = null;
        var innerHTML = null;
        for(var propKey in props)if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) continue;
            switch(propKey){
                case 'children':
                    children = propValue;
                    break;
                case 'dangerouslySetInnerHTML':
                    // TODO: This doesn't really make sense for select since it can't use the controlled
                    // value in the innerHTML.
                    innerHTML = propValue;
                    break;
                case 'defaultValue':
                case 'value':
                    break;
                default:
                    pushAttribute(target, responseState, propKey, propValue);
                    break;
            }
        }
        target.push(endOfStartTag);
        pushInnerHTML(target, innerHTML, children);
        return children;
    }
    function flattenOptionChildren(children) {
        var content = ''; // Flatten children and warn if they aren't strings or numbers;
        // invalid types are ignored.
        React.Children.forEach(children, function(child) {
            if (child == null) return;
            content += child;
            if (!didWarnInvalidOptionChildren && typeof child !== 'string' && typeof child !== 'number') {
                didWarnInvalidOptionChildren = true;
                error("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.");
            }
        });
        return content;
    }
    var selectedMarkerAttribute = stringToPrecomputedChunk(' selected=""');
    function pushStartOption(target, props, responseState, formatContext) {
        var selectedValue = formatContext.selectedValue;
        target.push(startChunkForTag('option'));
        var children = null;
        var value = null;
        var selected = null;
        var innerHTML = null;
        for(var propKey in props)if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) continue;
            switch(propKey){
                case 'children':
                    children = propValue;
                    break;
                case 'selected':
                    // ignore
                    selected = propValue;
                    // TODO: Remove support for `selected` in <option>.
                    if (!didWarnSelectedSetOnOption) {
                        error("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.");
                        didWarnSelectedSetOnOption = true;
                    }
                    break;
                case 'dangerouslySetInnerHTML':
                    innerHTML = propValue;
                    break;
                // eslint-disable-next-line-no-fallthrough
                case 'value':
                    value = propValue;
                // We intentionally fallthrough to also set the attribute on the node.
                // eslint-disable-next-line-no-fallthrough
                default:
                    pushAttribute(target, responseState, propKey, propValue);
                    break;
            }
        }
        if (selectedValue != null) {
            var stringValue;
            if (value !== null) {
                checkAttributeStringCoercion(value, 'value');
                stringValue = '' + value;
            } else {
                if (innerHTML !== null) {
                    if (!didWarnInvalidOptionInnerHTML) {
                        didWarnInvalidOptionInnerHTML = true;
                        error("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.");
                    }
                }
                stringValue = flattenOptionChildren(children);
            }
            if (isArray(selectedValue)) // multiple
            for(var i = 0; i < selectedValue.length; i++){
                checkAttributeStringCoercion(selectedValue[i], 'value');
                var v = '' + selectedValue[i];
                if (v === stringValue) {
                    target.push(selectedMarkerAttribute);
                    break;
                }
            }
            else {
                checkAttributeStringCoercion(selectedValue, 'select.value');
                if ('' + selectedValue === stringValue) target.push(selectedMarkerAttribute);
            }
        } else if (selected) target.push(selectedMarkerAttribute);
        target.push(endOfStartTag);
        pushInnerHTML(target, innerHTML, children);
        return children;
    }
    function pushInput(target, props, responseState) {
        checkControlledValueProps('input', props);
        if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnDefaultChecked) {
            error("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", 'A component', props.type);
            didWarnDefaultChecked = true;
        }
        if (props.value !== undefined && props.defaultValue !== undefined && !didWarnDefaultInputValue) {
            error("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", 'A component', props.type);
            didWarnDefaultInputValue = true;
        }
        target.push(startChunkForTag('input'));
        var value = null;
        var defaultValue = null;
        var checked = null;
        var defaultChecked = null;
        for(var propKey in props)if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) continue;
            switch(propKey){
                case 'children':
                case 'dangerouslySetInnerHTML':
                    throw new Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                // eslint-disable-next-line-no-fallthrough
                case 'defaultChecked':
                    defaultChecked = propValue;
                    break;
                case 'defaultValue':
                    defaultValue = propValue;
                    break;
                case 'checked':
                    checked = propValue;
                    break;
                case 'value':
                    value = propValue;
                    break;
                default:
                    pushAttribute(target, responseState, propKey, propValue);
                    break;
            }
        }
        if (checked !== null) pushAttribute(target, responseState, 'checked', checked);
        else if (defaultChecked !== null) pushAttribute(target, responseState, 'checked', defaultChecked);
        if (value !== null) pushAttribute(target, responseState, 'value', value);
        else if (defaultValue !== null) pushAttribute(target, responseState, 'value', defaultValue);
        target.push(endOfStartTagSelfClosing);
        return null;
    }
    function pushStartTextArea(target, props, responseState) {
        checkControlledValueProps('textarea', props);
        if (props.value !== undefined && props.defaultValue !== undefined && !didWarnDefaultTextareaValue) {
            error("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components");
            didWarnDefaultTextareaValue = true;
        }
        target.push(startChunkForTag('textarea'));
        var value = null;
        var defaultValue = null;
        var children = null;
        for(var propKey in props)if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) continue;
            switch(propKey){
                case 'children':
                    children = propValue;
                    break;
                case 'value':
                    value = propValue;
                    break;
                case 'defaultValue':
                    defaultValue = propValue;
                    break;
                case 'dangerouslySetInnerHTML':
                    throw new Error('`dangerouslySetInnerHTML` does not make sense on <textarea>.');
                // eslint-disable-next-line-no-fallthrough
                default:
                    pushAttribute(target, responseState, propKey, propValue);
                    break;
            }
        }
        if (value === null && defaultValue !== null) value = defaultValue;
        target.push(endOfStartTag); // TODO (yungsters): Remove support for children content in <textarea>.
        if (children != null) {
            error("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
            if (value != null) throw new Error('If you supply `defaultValue` on a <textarea>, do not pass children.');
            if (isArray(children)) {
                if (children.length > 1) throw new Error('<textarea> can only have at most one child.');
                 // TODO: remove the coercion and the DEV check below because it will
                checkHtmlStringCoercion(children[0]);
                value = '' + children[0];
            }
            checkHtmlStringCoercion(children);
            value = '' + children;
        }
        if (typeof value === 'string' && value[0] === '\n') // text/html ignores the first character in these tags if it's a newline
        // Prefer to break application/xml over text/html (for now) by adding
        // a newline specifically to get eaten by the parser. (Alternately for
        // textareas, replacing "^\n" with "\r\n" doesn't get eaten, and the first
        // \r is normalized out by HTMLTextAreaElement#value.)
        // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>
        // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>
        // See: <http://www.w3.org/TR/html5/syntax.html#newlines>
        // See: Parsing of "textarea" "listing" and "pre" elements
        //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>
        target.push(leadingNewline);
         // ToString and push directly instead of recurse over children.
        // We don't really support complex children in the value anyway.
        // This also currently avoids a trailing comment node which breaks textarea.
        if (value !== null) {
            checkAttributeStringCoercion(value, 'value');
            target.push(stringToChunk(encodeHTMLTextNode('' + value)));
        }
        return null;
    }
    function pushSelfClosing(target, props, tag, responseState) {
        target.push(startChunkForTag(tag));
        for(var propKey in props)if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) continue;
            switch(propKey){
                case 'children':
                case 'dangerouslySetInnerHTML':
                    throw new Error(tag + " is a self-closing tag and must neither have `children` nor " + 'use `dangerouslySetInnerHTML`.');
                // eslint-disable-next-line-no-fallthrough
                default:
                    pushAttribute(target, responseState, propKey, propValue);
                    break;
            }
        }
        target.push(endOfStartTagSelfClosing);
        return null;
    }
    function pushStartMenuItem(target, props, responseState) {
        target.push(startChunkForTag('menuitem'));
        for(var propKey in props)if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) continue;
            switch(propKey){
                case 'children':
                case 'dangerouslySetInnerHTML':
                    throw new Error('menuitems cannot have `children` nor `dangerouslySetInnerHTML`.');
                // eslint-disable-next-line-no-fallthrough
                default:
                    pushAttribute(target, responseState, propKey, propValue);
                    break;
            }
        }
        target.push(endOfStartTag);
        return null;
    }
    function pushStartTitle(target, props, responseState) {
        target.push(startChunkForTag('title'));
        var children = null;
        for(var propKey in props)if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) continue;
            switch(propKey){
                case 'children':
                    children = propValue;
                    break;
                case 'dangerouslySetInnerHTML':
                    throw new Error('`dangerouslySetInnerHTML` does not make sense on <title>.');
                // eslint-disable-next-line-no-fallthrough
                default:
                    pushAttribute(target, responseState, propKey, propValue);
                    break;
            }
        }
        target.push(endOfStartTag);
        var child = Array.isArray(children) && children.length < 2 ? children[0] || null : children;
        if (Array.isArray(children) && children.length > 1) error("A title element received an array with more than 1 element as children. In browsers title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
        else if (child != null && child.$$typeof != null) error("A title element received a React element for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
        else if (child != null && typeof child !== 'string' && typeof child !== 'number') error("A title element received a value that was not a string or number for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
        return children;
    }
    function pushStartGenericElement(target, props, tag, responseState) {
        target.push(startChunkForTag(tag));
        var children = null;
        var innerHTML = null;
        for(var propKey in props)if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) continue;
            switch(propKey){
                case 'children':
                    children = propValue;
                    break;
                case 'dangerouslySetInnerHTML':
                    innerHTML = propValue;
                    break;
                default:
                    pushAttribute(target, responseState, propKey, propValue);
                    break;
            }
        }
        target.push(endOfStartTag);
        pushInnerHTML(target, innerHTML, children);
        if (typeof children === 'string') {
            // Special case children as a string to avoid the unnecessary comment.
            // TODO: Remove this special case after the general optimization is in place.
            target.push(stringToChunk(encodeHTMLTextNode(children)));
            return null;
        }
        return children;
    }
    function pushStartCustomElement(target, props, tag, responseState) {
        target.push(startChunkForTag(tag));
        var children = null;
        var innerHTML = null;
        for(var propKey in props)if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) continue;
            switch(propKey){
                case 'children':
                    children = propValue;
                    break;
                case 'dangerouslySetInnerHTML':
                    innerHTML = propValue;
                    break;
                case 'style':
                    pushStyle(target, responseState, propValue);
                    break;
                case 'suppressContentEditableWarning':
                case 'suppressHydrationWarning':
                    break;
                default:
                    if (isAttributeNameSafe(propKey) && typeof propValue !== 'function' && typeof propValue !== 'symbol') target.push(attributeSeparator, stringToChunk(propKey), attributeAssign, stringToChunk(escapeTextForBrowser(propValue)), attributeEnd);
                    break;
            }
        }
        target.push(endOfStartTag);
        pushInnerHTML(target, innerHTML, children);
        return children;
    }
    var leadingNewline = stringToPrecomputedChunk('\n');
    function pushStartPreformattedElement(target, props, tag, responseState) {
        target.push(startChunkForTag(tag));
        var children = null;
        var innerHTML = null;
        for(var propKey in props)if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) continue;
            switch(propKey){
                case 'children':
                    children = propValue;
                    break;
                case 'dangerouslySetInnerHTML':
                    innerHTML = propValue;
                    break;
                default:
                    pushAttribute(target, responseState, propKey, propValue);
                    break;
            }
        }
        target.push(endOfStartTag); // text/html ignores the first character in these tags if it's a newline
        // Prefer to break application/xml over text/html (for now) by adding
        // a newline specifically to get eaten by the parser. (Alternately for
        // textareas, replacing "^\n" with "\r\n" doesn't get eaten, and the first
        // \r is normalized out by HTMLTextAreaElement#value.)
        // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>
        // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>
        // See: <http://www.w3.org/TR/html5/syntax.html#newlines>
        // See: Parsing of "textarea" "listing" and "pre" elements
        //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>
        // TODO: This doesn't deal with the case where the child is an array
        // or component that returns a string.
        if (innerHTML != null) {
            if (children != null) throw new Error('Can only set one of `children` or `props.dangerouslySetInnerHTML`.');
            if (typeof innerHTML !== 'object' || !('__html' in innerHTML)) throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
            var html = innerHTML.__html;
            if (html !== null && html !== undefined) {
                if (typeof html === 'string' && html.length > 0 && html[0] === '\n') target.push(leadingNewline, stringToChunk(html));
                else {
                    checkHtmlStringCoercion(html);
                    target.push(stringToChunk('' + html));
                }
            }
        }
        if (typeof children === 'string' && children[0] === '\n') target.push(leadingNewline);
        return children;
    } // We accept any tag to be rendered but since this gets injected into arbitrary
    // HTML, we want to make sure that it's a safe tag.
    // http://www.w3.org/TR/REC-xml/#NT-Name
    var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/; // Simplified subset
    var validatedTagCache = new Map();
    function startChunkForTag(tag) {
        var tagStartChunk = validatedTagCache.get(tag);
        if (tagStartChunk === undefined) {
            if (!VALID_TAG_REGEX.test(tag)) throw new Error("Invalid tag: " + tag);
            tagStartChunk = stringToPrecomputedChunk('<' + tag);
            validatedTagCache.set(tag, tagStartChunk);
        }
        return tagStartChunk;
    }
    var DOCTYPE = stringToPrecomputedChunk('<!DOCTYPE html>');
    function pushStartInstance(target, type, props, responseState, formatContext) {
        validateProperties(type, props);
        validateProperties$1(type, props);
        validateProperties$2(type, props, null);
        if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) error("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
        if (formatContext.insertionMode !== SVG_MODE && formatContext.insertionMode !== MATHML_MODE) {
            if (type.indexOf('-') === -1 && typeof props.is !== 'string' && type.toLowerCase() !== type) error("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type);
        }
        switch(type){
            // Special tags
            case 'select':
                return pushStartSelect(target, props, responseState);
            case 'option':
                return pushStartOption(target, props, responseState, formatContext);
            case 'textarea':
                return pushStartTextArea(target, props, responseState);
            case 'input':
                return pushInput(target, props, responseState);
            case 'menuitem':
                return pushStartMenuItem(target, props, responseState);
            case 'title':
                return pushStartTitle(target, props, responseState);
            // Newline eating tags
            case 'listing':
            case 'pre':
                return pushStartPreformattedElement(target, props, type, responseState);
            // Omitted close tags
            case 'area':
            case 'base':
            case 'br':
            case 'col':
            case 'embed':
            case 'hr':
            case 'img':
            case 'keygen':
            case 'link':
            case 'meta':
            case 'param':
            case 'source':
            case 'track':
            case 'wbr':
                return pushSelfClosing(target, props, type, responseState);
            // These are reserved SVG and MathML elements, that are never custom elements.
            // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts
            case 'annotation-xml':
            case 'color-profile':
            case 'font-face':
            case 'font-face-src':
            case 'font-face-uri':
            case 'font-face-format':
            case 'font-face-name':
            case 'missing-glyph':
                return pushStartGenericElement(target, props, type, responseState);
            case 'html':
                if (formatContext.insertionMode === ROOT_HTML_MODE) // If we're rendering the html tag and we're at the root (i.e. not in foreignObject)
                // then we also emit the DOCTYPE as part of the root content as a convenience for
                // rendering the whole document.
                target.push(DOCTYPE);
                return pushStartGenericElement(target, props, type, responseState);
            default:
                if (type.indexOf('-') === -1 && typeof props.is !== 'string') // Generic element
                return pushStartGenericElement(target, props, type, responseState);
                else // Custom element
                return pushStartCustomElement(target, props, type, responseState);
        }
    }
    var endTag1 = stringToPrecomputedChunk('</');
    var endTag2 = stringToPrecomputedChunk('>');
    function pushEndInstance(target, type, props) {
        switch(type){
            // Omitted close tags
            // TODO: Instead of repeating this switch we could try to pass a flag from above.
            // That would require returning a tuple. Which might be ok if it gets inlined.
            case 'area':
            case 'base':
            case 'br':
            case 'col':
            case 'embed':
            case 'hr':
            case 'img':
            case 'input':
            case 'keygen':
            case 'link':
            case 'meta':
            case 'param':
            case 'source':
            case 'track':
            case 'wbr':
                break;
            default:
                target.push(endTag1, stringToChunk(type), endTag2);
        }
    }
    function writeCompletedRoot(destination, responseState) {
        var bootstrapChunks = responseState.bootstrapChunks;
        var i = 0;
        for(; i < bootstrapChunks.length - 1; i++)writeChunk(destination, bootstrapChunks[i]);
        if (i < bootstrapChunks.length) return writeChunkAndReturn(destination, bootstrapChunks[i]);
        return true;
    } // Structural Nodes
    // A placeholder is a node inside a hidden partial tree that can be filled in later, but before
    // display. It's never visible to users. We use the template tag because it can be used in every
    // type of parent. <script> tags also work in every other tag except <colgroup>.
    var placeholder1 = stringToPrecomputedChunk('<template id="');
    var placeholder2 = stringToPrecomputedChunk('"></template>');
    function writePlaceholder(destination, responseState, id) {
        writeChunk(destination, placeholder1);
        writeChunk(destination, responseState.placeholderPrefix);
        var formattedID = stringToChunk(id.toString(16));
        writeChunk(destination, formattedID);
        return writeChunkAndReturn(destination, placeholder2);
    } // Suspense boundaries are encoded as comments.
    var startCompletedSuspenseBoundary = stringToPrecomputedChunk('<!--$-->');
    var startPendingSuspenseBoundary1 = stringToPrecomputedChunk('<!--$?--><template id="');
    var startPendingSuspenseBoundary2 = stringToPrecomputedChunk('"></template>');
    var startClientRenderedSuspenseBoundary = stringToPrecomputedChunk('<!--$!-->');
    var endSuspenseBoundary = stringToPrecomputedChunk('<!--/$-->');
    var clientRenderedSuspenseBoundaryError1 = stringToPrecomputedChunk('<template');
    var clientRenderedSuspenseBoundaryErrorAttrInterstitial = stringToPrecomputedChunk('"');
    var clientRenderedSuspenseBoundaryError1A = stringToPrecomputedChunk(' data-dgst="');
    var clientRenderedSuspenseBoundaryError1B = stringToPrecomputedChunk(' data-msg="');
    var clientRenderedSuspenseBoundaryError1C = stringToPrecomputedChunk(' data-stck="');
    var clientRenderedSuspenseBoundaryError2 = stringToPrecomputedChunk('></template>');
    function writeStartCompletedSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, startCompletedSuspenseBoundary);
    }
    function writeStartPendingSuspenseBoundary(destination, responseState, id) {
        writeChunk(destination, startPendingSuspenseBoundary1);
        if (id === null) throw new Error('An ID must have been assigned before we can complete the boundary.');
        writeChunk(destination, id);
        return writeChunkAndReturn(destination, startPendingSuspenseBoundary2);
    }
    function writeStartClientRenderedSuspenseBoundary(destination, responseState, errorDigest, errorMesssage, errorComponentStack) {
        var result;
        result = writeChunkAndReturn(destination, startClientRenderedSuspenseBoundary);
        writeChunk(destination, clientRenderedSuspenseBoundaryError1);
        if (errorDigest) {
            writeChunk(destination, clientRenderedSuspenseBoundaryError1A);
            writeChunk(destination, stringToChunk(escapeTextForBrowser(errorDigest)));
            writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
        }
        if (errorMesssage) {
            writeChunk(destination, clientRenderedSuspenseBoundaryError1B);
            writeChunk(destination, stringToChunk(escapeTextForBrowser(errorMesssage)));
            writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
        }
        if (errorComponentStack) {
            writeChunk(destination, clientRenderedSuspenseBoundaryError1C);
            writeChunk(destination, stringToChunk(escapeTextForBrowser(errorComponentStack)));
            writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
        }
        result = writeChunkAndReturn(destination, clientRenderedSuspenseBoundaryError2);
        return result;
    }
    function writeEndCompletedSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, endSuspenseBoundary);
    }
    function writeEndPendingSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, endSuspenseBoundary);
    }
    function writeEndClientRenderedSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, endSuspenseBoundary);
    }
    var startSegmentHTML = stringToPrecomputedChunk('<div hidden id="');
    var startSegmentHTML2 = stringToPrecomputedChunk('">');
    var endSegmentHTML = stringToPrecomputedChunk('</div>');
    var startSegmentSVG = stringToPrecomputedChunk('<svg aria-hidden="true" style="display:none" id="');
    var startSegmentSVG2 = stringToPrecomputedChunk('">');
    var endSegmentSVG = stringToPrecomputedChunk('</svg>');
    var startSegmentMathML = stringToPrecomputedChunk('<math aria-hidden="true" style="display:none" id="');
    var startSegmentMathML2 = stringToPrecomputedChunk('">');
    var endSegmentMathML = stringToPrecomputedChunk('</math>');
    var startSegmentTable = stringToPrecomputedChunk('<table hidden id="');
    var startSegmentTable2 = stringToPrecomputedChunk('">');
    var endSegmentTable = stringToPrecomputedChunk('</table>');
    var startSegmentTableBody = stringToPrecomputedChunk('<table hidden><tbody id="');
    var startSegmentTableBody2 = stringToPrecomputedChunk('">');
    var endSegmentTableBody = stringToPrecomputedChunk('</tbody></table>');
    var startSegmentTableRow = stringToPrecomputedChunk('<table hidden><tr id="');
    var startSegmentTableRow2 = stringToPrecomputedChunk('">');
    var endSegmentTableRow = stringToPrecomputedChunk('</tr></table>');
    var startSegmentColGroup = stringToPrecomputedChunk('<table hidden><colgroup id="');
    var startSegmentColGroup2 = stringToPrecomputedChunk('">');
    var endSegmentColGroup = stringToPrecomputedChunk('</colgroup></table>');
    function writeStartSegment(destination, responseState, formatContext, id) {
        switch(formatContext.insertionMode){
            case ROOT_HTML_MODE:
            case HTML_MODE:
                writeChunk(destination, startSegmentHTML);
                writeChunk(destination, responseState.segmentPrefix);
                writeChunk(destination, stringToChunk(id.toString(16)));
                return writeChunkAndReturn(destination, startSegmentHTML2);
            case SVG_MODE:
                writeChunk(destination, startSegmentSVG);
                writeChunk(destination, responseState.segmentPrefix);
                writeChunk(destination, stringToChunk(id.toString(16)));
                return writeChunkAndReturn(destination, startSegmentSVG2);
            case MATHML_MODE:
                writeChunk(destination, startSegmentMathML);
                writeChunk(destination, responseState.segmentPrefix);
                writeChunk(destination, stringToChunk(id.toString(16)));
                return writeChunkAndReturn(destination, startSegmentMathML2);
            case HTML_TABLE_MODE:
                writeChunk(destination, startSegmentTable);
                writeChunk(destination, responseState.segmentPrefix);
                writeChunk(destination, stringToChunk(id.toString(16)));
                return writeChunkAndReturn(destination, startSegmentTable2);
            // TODO: For the rest of these, there will be extra wrapper nodes that never
            // get deleted from the document. We need to delete the table too as part
            // of the injected scripts. They are invisible though so it's not too terrible
            // and it's kind of an edge case to suspend in a table. Totally supported though.
            case HTML_TABLE_BODY_MODE:
                writeChunk(destination, startSegmentTableBody);
                writeChunk(destination, responseState.segmentPrefix);
                writeChunk(destination, stringToChunk(id.toString(16)));
                return writeChunkAndReturn(destination, startSegmentTableBody2);
            case HTML_TABLE_ROW_MODE:
                writeChunk(destination, startSegmentTableRow);
                writeChunk(destination, responseState.segmentPrefix);
                writeChunk(destination, stringToChunk(id.toString(16)));
                return writeChunkAndReturn(destination, startSegmentTableRow2);
            case HTML_COLGROUP_MODE:
                writeChunk(destination, startSegmentColGroup);
                writeChunk(destination, responseState.segmentPrefix);
                writeChunk(destination, stringToChunk(id.toString(16)));
                return writeChunkAndReturn(destination, startSegmentColGroup2);
            default:
                throw new Error('Unknown insertion mode. This is a bug in React.');
        }
    }
    function writeEndSegment(destination, formatContext) {
        switch(formatContext.insertionMode){
            case ROOT_HTML_MODE:
            case HTML_MODE:
                return writeChunkAndReturn(destination, endSegmentHTML);
            case SVG_MODE:
                return writeChunkAndReturn(destination, endSegmentSVG);
            case MATHML_MODE:
                return writeChunkAndReturn(destination, endSegmentMathML);
            case HTML_TABLE_MODE:
                return writeChunkAndReturn(destination, endSegmentTable);
            case HTML_TABLE_BODY_MODE:
                return writeChunkAndReturn(destination, endSegmentTableBody);
            case HTML_TABLE_ROW_MODE:
                return writeChunkAndReturn(destination, endSegmentTableRow);
            case HTML_COLGROUP_MODE:
                return writeChunkAndReturn(destination, endSegmentColGroup);
            default:
                throw new Error('Unknown insertion mode. This is a bug in React.');
        }
    } // Instruction Set
    // The following code is the source scripts that we then minify and inline below,
    // with renamed function names that we hope don't collide:
    // const COMMENT_NODE = 8;
    // const SUSPENSE_START_DATA = '$';
    // const SUSPENSE_END_DATA = '/$';
    // const SUSPENSE_PENDING_START_DATA = '$?';
    // const SUSPENSE_FALLBACK_START_DATA = '$!';
    //
    // function clientRenderBoundary(suspenseBoundaryID, errorDigest, errorMsg, errorComponentStack) {
    //   // Find the fallback's first element.
    //   const suspenseIdNode = document.getElementById(suspenseBoundaryID);
    //   if (!suspenseIdNode) {
    //     // The user must have already navigated away from this tree.
    //     // E.g. because the parent was hydrated.
    //     return;
    //   }
    //   // Find the boundary around the fallback. This is always the previous node.
    //   const suspenseNode = suspenseIdNode.previousSibling;
    //   // Tag it to be client rendered.
    //   suspenseNode.data = SUSPENSE_FALLBACK_START_DATA;
    //   // assign error metadata to first sibling
    //   let dataset = suspenseIdNode.dataset;
    //   if (errorDigest) dataset.dgst = errorDigest;
    //   if (errorMsg) dataset.msg = errorMsg;
    //   if (errorComponentStack) dataset.stck = errorComponentStack;
    //   // Tell React to retry it if the parent already hydrated.
    //   if (suspenseNode._reactRetry) {
    //     suspenseNode._reactRetry();
    //   }
    // }
    //
    // function completeBoundary(suspenseBoundaryID, contentID) {
    //   // Find the fallback's first element.
    //   const suspenseIdNode = document.getElementById(suspenseBoundaryID);
    //   const contentNode = document.getElementById(contentID);
    //   // We'll detach the content node so that regardless of what happens next we don't leave in the tree.
    //   // This might also help by not causing recalcing each time we move a child from here to the target.
    //   contentNode.parentNode.removeChild(contentNode);
    //   if (!suspenseIdNode) {
    //     // The user must have already navigated away from this tree.
    //     // E.g. because the parent was hydrated. That's fine there's nothing to do
    //     // but we have to make sure that we already deleted the container node.
    //     return;
    //   }
    //   // Find the boundary around the fallback. This is always the previous node.
    //   const suspenseNode = suspenseIdNode.previousSibling;
    //
    //   // Clear all the existing children. This is complicated because
    //   // there can be embedded Suspense boundaries in the fallback.
    //   // This is similar to clearSuspenseBoundary in ReactDOMHostConfig.
    //   // TODO: We could avoid this if we never emitted suspense boundaries in fallback trees.
    //   // They never hydrate anyway. However, currently we support incrementally loading the fallback.
    //   const parentInstance = suspenseNode.parentNode;
    //   let node = suspenseNode.nextSibling;
    //   let depth = 0;
    //   do {
    //     if (node && node.nodeType === COMMENT_NODE) {
    //       const data = node.data;
    //       if (data === SUSPENSE_END_DATA) {
    //         if (depth === 0) {
    //           break;
    //         } else {
    //           depth--;
    //         }
    //       } else if (
    //         data === SUSPENSE_START_DATA ||
    //         data === SUSPENSE_PENDING_START_DATA ||
    //         data === SUSPENSE_FALLBACK_START_DATA
    //       ) {
    //         depth++;
    //       }
    //     }
    //
    //     const nextNode = node.nextSibling;
    //     parentInstance.removeChild(node);
    //     node = nextNode;
    //   } while (node);
    //
    //   const endOfBoundary = node;
    //
    //   // Insert all the children from the contentNode between the start and end of suspense boundary.
    //   while (contentNode.firstChild) {
    //     parentInstance.insertBefore(contentNode.firstChild, endOfBoundary);
    //   }
    //   suspenseNode.data = SUSPENSE_START_DATA;
    //   if (suspenseNode._reactRetry) {
    //     suspenseNode._reactRetry();
    //   }
    // }
    //
    // function completeSegment(containerID, placeholderID) {
    //   const segmentContainer = document.getElementById(containerID);
    //   const placeholderNode = document.getElementById(placeholderID);
    //   // We always expect both nodes to exist here because, while we might
    //   // have navigated away from the main tree, we still expect the detached
    //   // tree to exist.
    //   segmentContainer.parentNode.removeChild(segmentContainer);
    //   while (segmentContainer.firstChild) {
    //     placeholderNode.parentNode.insertBefore(
    //       segmentContainer.firstChild,
    //       placeholderNode,
    //     );
    //   }
    //   placeholderNode.parentNode.removeChild(placeholderNode);
    // }
    var completeSegmentFunction = 'function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}';
    var completeBoundaryFunction = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}';
    var clientRenderFunction = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}';
    var completeSegmentScript1Full = stringToPrecomputedChunk(completeSegmentFunction + ';$RS("');
    var completeSegmentScript1Partial = stringToPrecomputedChunk('$RS("');
    var completeSegmentScript2 = stringToPrecomputedChunk('","');
    var completeSegmentScript3 = stringToPrecomputedChunk('")</script>');
    function writeCompletedSegmentInstruction(destination, responseState, contentSegmentID) {
        writeChunk(destination, responseState.startInlineScript);
        if (!responseState.sentCompleteSegmentFunction) {
            // The first time we write this, we'll need to include the full implementation.
            responseState.sentCompleteSegmentFunction = true;
            writeChunk(destination, completeSegmentScript1Full);
        } else // Future calls can just reuse the same function.
        writeChunk(destination, completeSegmentScript1Partial);
        writeChunk(destination, responseState.segmentPrefix);
        var formattedID = stringToChunk(contentSegmentID.toString(16));
        writeChunk(destination, formattedID);
        writeChunk(destination, completeSegmentScript2);
        writeChunk(destination, responseState.placeholderPrefix);
        writeChunk(destination, formattedID);
        return writeChunkAndReturn(destination, completeSegmentScript3);
    }
    var completeBoundaryScript1Full = stringToPrecomputedChunk(completeBoundaryFunction + ';$RC("');
    var completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC("');
    var completeBoundaryScript2 = stringToPrecomputedChunk('","');
    var completeBoundaryScript3 = stringToPrecomputedChunk('")</script>');
    function writeCompletedBoundaryInstruction(destination, responseState, boundaryID, contentSegmentID) {
        writeChunk(destination, responseState.startInlineScript);
        if (!responseState.sentCompleteBoundaryFunction) {
            // The first time we write this, we'll need to include the full implementation.
            responseState.sentCompleteBoundaryFunction = true;
            writeChunk(destination, completeBoundaryScript1Full);
        } else // Future calls can just reuse the same function.
        writeChunk(destination, completeBoundaryScript1Partial);
        if (boundaryID === null) throw new Error('An ID must have been assigned before we can complete the boundary.');
        var formattedContentID = stringToChunk(contentSegmentID.toString(16));
        writeChunk(destination, boundaryID);
        writeChunk(destination, completeBoundaryScript2);
        writeChunk(destination, responseState.segmentPrefix);
        writeChunk(destination, formattedContentID);
        return writeChunkAndReturn(destination, completeBoundaryScript3);
    }
    var clientRenderScript1Full = stringToPrecomputedChunk(clientRenderFunction + ';$RX("');
    var clientRenderScript1Partial = stringToPrecomputedChunk('$RX("');
    var clientRenderScript1A = stringToPrecomputedChunk('"');
    var clientRenderScript2 = stringToPrecomputedChunk(')</script>');
    var clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(',');
    function writeClientRenderBoundaryInstruction(destination, responseState, boundaryID, errorDigest, errorMessage, errorComponentStack) {
        writeChunk(destination, responseState.startInlineScript);
        if (!responseState.sentClientRenderFunction) {
            // The first time we write this, we'll need to include the full implementation.
            responseState.sentClientRenderFunction = true;
            writeChunk(destination, clientRenderScript1Full);
        } else // Future calls can just reuse the same function.
        writeChunk(destination, clientRenderScript1Partial);
        if (boundaryID === null) throw new Error('An ID must have been assigned before we can complete the boundary.');
        writeChunk(destination, boundaryID);
        writeChunk(destination, clientRenderScript1A);
        if (errorDigest || errorMessage || errorComponentStack) {
            writeChunk(destination, clientRenderErrorScriptArgInterstitial);
            writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorDigest || '')));
        }
        if (errorMessage || errorComponentStack) {
            writeChunk(destination, clientRenderErrorScriptArgInterstitial);
            writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorMessage || '')));
        }
        if (errorComponentStack) {
            writeChunk(destination, clientRenderErrorScriptArgInterstitial);
            writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorComponentStack)));
        }
        return writeChunkAndReturn(destination, clientRenderScript2);
    }
    var regexForJSStringsInScripts = /[<\u2028\u2029]/g;
    function escapeJSStringsForInstructionScripts(input) {
        var escaped = JSON.stringify(input);
        return escaped.replace(regexForJSStringsInScripts, function(match) {
            switch(match){
                // santizing breaking out of strings and script tags
                case '<':
                    return "\\u003c";
                case "\u2028":
                    return "\\u2028";
                case "\u2029":
                    return "\\u2029";
                default:
                    // eslint-disable-next-line react-internal/prod-error-codes
                    throw new Error('escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React');
            }
        });
    }
    function createResponseState$1(generateStaticMarkup, identifierPrefix) {
        var responseState = createResponseState(identifierPrefix, undefined);
        return {
            // Keep this in sync with ReactDOMServerFormatConfig
            bootstrapChunks: responseState.bootstrapChunks,
            startInlineScript: responseState.startInlineScript,
            placeholderPrefix: responseState.placeholderPrefix,
            segmentPrefix: responseState.segmentPrefix,
            boundaryPrefix: responseState.boundaryPrefix,
            idPrefix: responseState.idPrefix,
            nextSuspenseID: responseState.nextSuspenseID,
            sentCompleteSegmentFunction: responseState.sentCompleteSegmentFunction,
            sentCompleteBoundaryFunction: responseState.sentCompleteBoundaryFunction,
            sentClientRenderFunction: responseState.sentClientRenderFunction,
            // This is an extra field for the legacy renderer
            generateStaticMarkup: generateStaticMarkup
        };
    }
    function createRootFormatContext() {
        return {
            insertionMode: HTML_MODE,
            // We skip the root mode because we don't want to emit the DOCTYPE in legacy mode.
            selectedValue: null
        };
    }
    function pushTextInstance$1(target, text, responseState, textEmbedded) {
        if (responseState.generateStaticMarkup) {
            target.push(stringToChunk(escapeTextForBrowser(text)));
            return false;
        } else return pushTextInstance(target, text, responseState, textEmbedded);
    }
    function pushSegmentFinale$1(target, responseState, lastPushedText, textEmbedded) {
        if (responseState.generateStaticMarkup) return;
        else return pushSegmentFinale(target, responseState, lastPushedText, textEmbedded);
    }
    function writeStartCompletedSuspenseBoundary$1(destination, responseState) {
        if (responseState.generateStaticMarkup) // A completed boundary is done and doesn't need a representation in the HTML
        // if we're not going to be hydrating it.
        return true;
        return writeStartCompletedSuspenseBoundary(destination);
    }
    function writeStartClientRenderedSuspenseBoundary$1(destination, responseState, errorDigest, errorMessage, errorComponentStack) {
        if (responseState.generateStaticMarkup) // A client rendered boundary is done and doesn't need a representation in the HTML
        // since we'll never hydrate it. This is arguably an error in static generation.
        return true;
        return writeStartClientRenderedSuspenseBoundary(destination, responseState, errorDigest, errorMessage, errorComponentStack);
    }
    function writeEndCompletedSuspenseBoundary$1(destination, responseState) {
        if (responseState.generateStaticMarkup) return true;
        return writeEndCompletedSuspenseBoundary(destination);
    }
    function writeEndClientRenderedSuspenseBoundary$1(destination, responseState) {
        if (responseState.generateStaticMarkup) return true;
        return writeEndClientRenderedSuspenseBoundary(destination);
    }
    var assign = Object.assign;
    // ATTENTION
    // When adding new symbols to this file,
    // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
    // The Symbol used to tag the ReactElement-like types.
    var REACT_ELEMENT_TYPE = Symbol.for('react.element');
    var REACT_PORTAL_TYPE = Symbol.for('react.portal');
    var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
    var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');
    var REACT_PROFILER_TYPE = Symbol.for('react.profiler');
    var REACT_PROVIDER_TYPE = Symbol.for('react.provider');
    var REACT_CONTEXT_TYPE = Symbol.for('react.context');
    var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
    var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');
    var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');
    var REACT_MEMO_TYPE = Symbol.for('react.memo');
    var REACT_LAZY_TYPE = Symbol.for('react.lazy');
    var REACT_SCOPE_TYPE = Symbol.for('react.scope');
    var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for('react.debug_trace_mode');
    var REACT_LEGACY_HIDDEN_TYPE = Symbol.for('react.legacy_hidden');
    var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for('react.default_value');
    var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = '@@iterator';
    function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable !== 'object') return null;
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        if (typeof maybeIterator === 'function') return maybeIterator;
        return null;
    }
    function getWrappedName(outerType, innerType, wrapperName) {
        var displayName = outerType.displayName;
        if (displayName) return displayName;
        var functionName = innerType.displayName || innerType.name || '';
        return functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName;
    } // Keep in sync with react-reconciler/getComponentNameFromFiber
    function getContextName(type) {
        return type.displayName || 'Context';
    } // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.
    function getComponentNameFromType(type) {
        if (type == null) // Host root, text node or just invalid type.
        return null;
        if (typeof type.tag === 'number') error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
        if (typeof type === 'function') return type.displayName || type.name || null;
        if (typeof type === 'string') return type;
        switch(type){
            case REACT_FRAGMENT_TYPE:
                return 'Fragment';
            case REACT_PORTAL_TYPE:
                return 'Portal';
            case REACT_PROFILER_TYPE:
                return 'Profiler';
            case REACT_STRICT_MODE_TYPE:
                return 'StrictMode';
            case REACT_SUSPENSE_TYPE:
                return 'Suspense';
            case REACT_SUSPENSE_LIST_TYPE:
                return 'SuspenseList';
        }
        if (typeof type === 'object') switch(type.$$typeof){
            case REACT_CONTEXT_TYPE:
                var context = type;
                return getContextName(context) + '.Consumer';
            case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + '.Provider';
            case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, 'ForwardRef');
            case REACT_MEMO_TYPE:
                var outerName = type.displayName || null;
                if (outerName !== null) return outerName;
                return getComponentNameFromType(type.type) || 'Memo';
            case REACT_LAZY_TYPE:
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                    return getComponentNameFromType(init(payload));
                } catch (x) {
                    return null;
                }
        }
        return null;
    }
    // Helpers to patch console.logs to avoid logging during side-effect free
    // replaying on render function. This currently only patches the object
    // lazily which won't cover if the log function was extracted eagerly.
    // We could also eagerly patch the method.
    var disabledDepth = 0;
    var prevLog;
    var prevInfo;
    var prevWarn;
    var prevError;
    var prevGroup;
    var prevGroupCollapsed;
    var prevGroupEnd;
    function disabledLog() {}
    disabledLog.__reactDisabledLog = true;
    function disableLogs() {
        if (disabledDepth === 0) {
            /* eslint-disable react-internal/no-production-logging */ prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099
            var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
            }; // $FlowFixMe Flow thinks console is immutable.
            Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
            });
        /* eslint-enable react-internal/no-production-logging */ }
        disabledDepth++;
    }
    function reenableLogs() {
        disabledDepth--;
        if (disabledDepth === 0) {
            /* eslint-disable react-internal/no-production-logging */ var props = {
                configurable: true,
                enumerable: true,
                writable: true
            }; // $FlowFixMe Flow thinks console is immutable.
            Object.defineProperties(console, {
                log: assign({}, props, {
                    value: prevLog
                }),
                info: assign({}, props, {
                    value: prevInfo
                }),
                warn: assign({}, props, {
                    value: prevWarn
                }),
                error: assign({}, props, {
                    value: prevError
                }),
                group: assign({}, props, {
                    value: prevGroup
                }),
                groupCollapsed: assign({}, props, {
                    value: prevGroupCollapsed
                }),
                groupEnd: assign({}, props, {
                    value: prevGroupEnd
                })
            });
        /* eslint-enable react-internal/no-production-logging */ }
        if (disabledDepth < 0) error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
    }
    var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
    var prefix;
    function describeBuiltInComponentFrame(name, source, ownerFn) {
        if (prefix === undefined) // Extract the VM specific prefix used by each line.
        try {
            throw Error();
        } catch (x) {
            var match = x.stack.trim().match(/\n( *(at )?)/);
            prefix = match && match[1] || '';
        }
         // We use the prefix to ensure our stacks line up with native stack frames.
        return '\n' + prefix + name;
    }
    var reentry = false;
    var componentFrameCache;
    var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
    componentFrameCache = new PossiblyWeakMap();
    function describeNativeComponentFrame(fn, construct) {
        // If something asked for a stack inside a fake render, it should get ignored.
        if (!fn || reentry) return '';
        var frame = componentFrameCache.get(fn);
        if (frame !== undefined) return frame;
        var control;
        reentry = true;
        var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.
        Error.prepareStackTrace = undefined;
        var previousDispatcher;
        previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function
        // for warnings.
        ReactCurrentDispatcher.current = null;
        disableLogs();
        try {
            // This should throw.
            if (construct) {
                // Something should be setting the props in the constructor.
                var Fake = function() {
                    throw Error();
                }; // $FlowFixMe
                Object.defineProperty(Fake.prototype, 'props', {
                    set: function() {
                        // We use a throwing setter instead of frozen or non-writable props
                        // because that won't throw in a non-strict mode function.
                        throw Error();
                    }
                });
                if (typeof Reflect === 'object' && Reflect.construct) {
                    // We construct a different control for this case to include any extra
                    // frames added by the construct call.
                    try {
                        Reflect.construct(Fake, []);
                    } catch (x) {
                        control = x;
                    }
                    Reflect.construct(fn, [], Fake);
                } else {
                    try {
                        Fake.call();
                    } catch (x) {
                        control = x;
                    }
                    fn.call(Fake.prototype);
                }
            } else {
                try {
                    throw Error();
                } catch (x) {
                    control = x;
                }
                fn();
            }
        } catch (sample) {
            // This is inlined manually because closure doesn't do it for us.
            if (sample && control && typeof sample.stack === 'string') {
                // This extracts the first frame from the sample that isn't also in the control.
                // Skipping one frame that we assume is the frame that calls the two.
                var sampleLines = sample.stack.split('\n');
                var controlLines = control.stack.split('\n');
                var s = sampleLines.length - 1;
                var c = controlLines.length - 1;
                while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c])// We expect at least one stack frame to be shared.
                // Typically this will be the root most one. However, stack frames may be
                // cut off due to maximum stack limits. In this case, one maybe cut off
                // earlier than the other. We assume that the sample is longer or the same
                // and there for cut off earlier. So we should find the root most frame in
                // the sample somewhere in the control.
                c--;
                for(; s >= 1 && c >= 0; s--, c--)// Next we find the first one that isn't the same which should be the
                // frame that called our sample function and the control.
                if (sampleLines[s] !== controlLines[c]) {
                    // In V8, the first line is describing the message but other VMs don't.
                    // If we're about to return the first line, and the control is also on the same
                    // line, that's a pretty good indicator that our sample threw at same line as
                    // the control. I.e. before we entered the sample frame. So we ignore this result.
                    // This can happen if you passed a class to function component, or non-function.
                    if (s !== 1 || c !== 1) do {
                        s--;
                        c--; // We may still have similar intermediate frames from the construct call.
                        // The next one that isn't the same should be our match though.
                        if (c < 0 || sampleLines[s] !== controlLines[c]) {
                            // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                            var _frame = '\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled "<anonymous>"
                            // but we have a user-provided "displayName"
                            // splice it in to make the stack more readable.
                            if (fn.displayName && _frame.includes('<anonymous>')) _frame = _frame.replace('<anonymous>', fn.displayName);
                            if (typeof fn === 'function') componentFrameCache.set(fn, _frame);
                            return _frame;
                        }
                    }while (s >= 1 && c >= 0)
                    break;
                }
            }
        } finally{
            reentry = false;
            ReactCurrentDispatcher.current = previousDispatcher;
            reenableLogs();
            Error.prepareStackTrace = previousPrepareStackTrace;
        } // Fallback to just using the name if we couldn't make it throw.
        var name = fn ? fn.displayName || fn.name : '';
        var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';
        if (typeof fn === 'function') componentFrameCache.set(fn, syntheticFrame);
        return syntheticFrame;
    }
    function describeClassComponentFrame(ctor, source, ownerFn) {
        return describeNativeComponentFrame(ctor, true);
    }
    function describeFunctionComponentFrame(fn, source, ownerFn) {
        return describeNativeComponentFrame(fn, false);
    }
    function shouldConstruct(Component) {
        var prototype = Component.prototype;
        return !!(prototype && prototype.isReactComponent);
    }
    function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
        if (type == null) return '';
        if (typeof type === 'function') return describeNativeComponentFrame(type, shouldConstruct(type));
        if (typeof type === 'string') return describeBuiltInComponentFrame(type);
        switch(type){
            case REACT_SUSPENSE_TYPE:
                return describeBuiltInComponentFrame('Suspense');
            case REACT_SUSPENSE_LIST_TYPE:
                return describeBuiltInComponentFrame('SuspenseList');
        }
        if (typeof type === 'object') switch(type.$$typeof){
            case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
            case REACT_MEMO_TYPE:
                // Memo may contain any component type so we recursively resolve it.
                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
            case REACT_LAZY_TYPE:
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                    // Lazy may contain any component type so we recursively resolve it.
                    return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                } catch (x) {}
        }
        return '';
    }
    var loggedTypeFailures = {};
    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    function setCurrentlyValidatingElement(element) {
        if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame.setExtraStackFrame(stack);
        } else ReactDebugCurrentFrame.setExtraStackFrame(null);
    }
    function checkPropTypes(typeSpecs, values, location, componentName, element) {
        // $FlowFixMe This is okay but Flow doesn't know it.
        var has = Function.call.bind(hasOwnProperty);
        for(var typeSpecName in typeSpecs)if (has(typeSpecs, typeSpecName)) {
            var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
            // fail the render phase where it didn't fail before. So we log it.
            // After these have been cleaned up, we'll let them throw.
            try {
                // This is intentionally an invariant that gets caught. It's the same
                // behavior as without this statement except with a better message.
                if (typeof typeSpecs[typeSpecName] !== 'function') {
                    // eslint-disable-next-line react-internal/prod-error-codes
                    var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
                    err.name = 'Invariant Violation';
                    throw err;
                }
                error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
            } catch (ex) {
                error$1 = ex;
            }
            if (error$1 && !(error$1 instanceof Error)) {
                setCurrentlyValidatingElement(element);
                error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || 'React class', location, typeSpecName, typeof error$1);
                setCurrentlyValidatingElement(null);
            }
            if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                // Only monitor this failure once because there tends to be a lot of the
                // same error.
                loggedTypeFailures[error$1.message] = true;
                setCurrentlyValidatingElement(element);
                error('Failed %s type: %s', location, error$1.message);
                setCurrentlyValidatingElement(null);
            }
        }
    }
    var warnedAboutMissingGetChildContext;
    warnedAboutMissingGetChildContext = {};
    var emptyContextObject = {};
    Object.freeze(emptyContextObject);
    function getMaskedContext(type, unmaskedContext) {
        var contextTypes = type.contextTypes;
        if (!contextTypes) return emptyContextObject;
        var context = {};
        for(var key in contextTypes)context[key] = unmaskedContext[key];
        var name = getComponentNameFromType(type) || 'Unknown';
        checkPropTypes(contextTypes, context, 'context', name);
        return context;
    }
    function processChildContext(instance, type, parentContext, childContextTypes) {
        // TODO (bvaughn) Replace this behavior with an invariant() in the future.
        // It has only been added in Fiber to match the (unintentional) behavior in Stack.
        if (typeof instance.getChildContext !== 'function') {
            var componentName = getComponentNameFromType(type) || 'Unknown';
            if (!warnedAboutMissingGetChildContext[componentName]) {
                warnedAboutMissingGetChildContext[componentName] = true;
                error("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", componentName, componentName);
            }
            return parentContext;
        }
        var childContext = instance.getChildContext();
        for(var contextKey in childContext){
            if (!(contextKey in childContextTypes)) throw new Error((getComponentNameFromType(type) || 'Unknown') + ".getChildContext(): key \"" + contextKey + "\" is not defined in childContextTypes.");
        }
        var name = getComponentNameFromType(type) || 'Unknown';
        checkPropTypes(childContextTypes, childContext, 'child context', name);
        return assign({}, parentContext, childContext);
    }
    var rendererSigil;
    // Use this to detect multiple renderers using the same context
    rendererSigil = {};
    // Forming a reverse tree.
    var rootContextSnapshot = null; // We assume that this runtime owns the "current" field on all ReactContext instances.
    // This global (actually thread local) state represents what state all those "current",
    // fields are currently in.
    var currentActiveSnapshot = null;
    function popNode(prev) {
        prev.context._currentValue2 = prev.parentValue;
    }
    function pushNode(next) {
        next.context._currentValue2 = next.value;
    }
    function popToNearestCommonAncestor(prev, next) {
        if (prev === next) ;
        else {
            popNode(prev);
            var parentPrev = prev.parent;
            var parentNext = next.parent;
            if (parentPrev === null) {
                if (parentNext !== null) throw new Error('The stacks must reach the root at the same time. This is a bug in React.');
            } else {
                if (parentNext === null) throw new Error('The stacks must reach the root at the same time. This is a bug in React.');
                popToNearestCommonAncestor(parentPrev, parentNext);
            } // On the way back, we push the new ones that weren't common.
            pushNode(next);
        }
    }
    function popAllPrevious(prev) {
        popNode(prev);
        var parentPrev = prev.parent;
        if (parentPrev !== null) popAllPrevious(parentPrev);
    }
    function pushAllNext(next) {
        var parentNext = next.parent;
        if (parentNext !== null) pushAllNext(parentNext);
        pushNode(next);
    }
    function popPreviousToCommonLevel(prev, next) {
        popNode(prev);
        var parentPrev = prev.parent;
        if (parentPrev === null) throw new Error('The depth must equal at least at zero before reaching the root. This is a bug in React.');
        if (parentPrev.depth === next.depth) // We found the same level. Now we just need to find a shared ancestor.
        popToNearestCommonAncestor(parentPrev, next);
        else // We must still be deeper.
        popPreviousToCommonLevel(parentPrev, next);
    }
    function popNextToCommonLevel(prev, next) {
        var parentNext = next.parent;
        if (parentNext === null) throw new Error('The depth must equal at least at zero before reaching the root. This is a bug in React.');
        if (prev.depth === parentNext.depth) // We found the same level. Now we just need to find a shared ancestor.
        popToNearestCommonAncestor(prev, parentNext);
        else // We must still be deeper.
        popNextToCommonLevel(prev, parentNext);
        pushNode(next);
    } // Perform context switching to the new snapshot.
    // To make it cheap to read many contexts, while not suspending, we make the switch eagerly by
    // updating all the context's current values. That way reads, always just read the current value.
    // At the cost of updating contexts even if they're never read by this subtree.
    function switchContext(newSnapshot) {
        // The basic algorithm we need to do is to pop back any contexts that are no longer on the stack.
        // We also need to update any new contexts that are now on the stack with the deepest value.
        // The easiest way to update new contexts is to just reapply them in reverse order from the
        // perspective of the backpointers. To avoid allocating a lot when switching, we use the stack
        // for that. Therefore this algorithm is recursive.
        // 1) First we pop which ever snapshot tree was deepest. Popping old contexts as we go.
        // 2) Then we find the nearest common ancestor from there. Popping old contexts as we go.
        // 3) Then we reapply new contexts on the way back up the stack.
        var prev = currentActiveSnapshot;
        var next = newSnapshot;
        if (prev !== next) {
            if (prev === null) // $FlowFixMe: This has to be non-null since it's not equal to prev.
            pushAllNext(next);
            else if (next === null) popAllPrevious(prev);
            else if (prev.depth === next.depth) popToNearestCommonAncestor(prev, next);
            else if (prev.depth > next.depth) popPreviousToCommonLevel(prev, next);
            else popNextToCommonLevel(prev, next);
            currentActiveSnapshot = next;
        }
    }
    function pushProvider(context, nextValue) {
        var prevValue;
        prevValue = context._currentValue2;
        context._currentValue2 = nextValue;
        if (context._currentRenderer2 !== undefined && context._currentRenderer2 !== null && context._currentRenderer2 !== rendererSigil) error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
        context._currentRenderer2 = rendererSigil;
        var prevNode = currentActiveSnapshot;
        var newNode = {
            parent: prevNode,
            depth: prevNode === null ? 0 : prevNode.depth + 1,
            context: context,
            parentValue: prevValue,
            value: nextValue
        };
        currentActiveSnapshot = newNode;
        return newNode;
    }
    function popProvider(context) {
        var prevSnapshot = currentActiveSnapshot;
        if (prevSnapshot === null) throw new Error('Tried to pop a Context at the root of the app. This is a bug in React.');
        if (prevSnapshot.context !== context) error('The parent context is not the expected context. This is probably a bug in React.');
        var _value = prevSnapshot.parentValue;
        if (_value === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) prevSnapshot.context._currentValue2 = prevSnapshot.context._defaultValue;
        else prevSnapshot.context._currentValue2 = _value;
        if (context._currentRenderer2 !== undefined && context._currentRenderer2 !== null && context._currentRenderer2 !== rendererSigil) error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
        context._currentRenderer2 = rendererSigil;
        return currentActiveSnapshot = prevSnapshot.parent;
    }
    function getActiveContext() {
        return currentActiveSnapshot;
    }
    function readContext(context) {
        var value = context._currentValue2;
        return value;
    }
    /**
 * `ReactInstanceMap` maintains a mapping from a public facing stateful
 * instance (key) and the internal representation (value). This allows public
 * methods to accept the user facing instance as an argument and map them back
 * to internal methods.
 *
 * Note that this module is currently shared and assumed to be stateless.
 * If this becomes an actual Map, that will break.
 */ function get(key) {
        return key._reactInternals;
    }
    function set(key, value) {
        key._reactInternals = value;
    }
    var didWarnAboutNoopUpdateForComponent = {};
    var didWarnAboutDeprecatedWillMount = {};
    var didWarnAboutUninitializedState;
    var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
    var didWarnAboutLegacyLifecyclesAndDerivedState;
    var didWarnAboutUndefinedDerivedState;
    var warnOnUndefinedDerivedState;
    var warnOnInvalidCallback;
    var didWarnAboutDirectlyAssigningPropsToState;
    var didWarnAboutContextTypeAndContextTypes;
    var didWarnAboutInvalidateContextType;
    didWarnAboutUninitializedState = new Set();
    didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();
    didWarnAboutLegacyLifecyclesAndDerivedState = new Set();
    didWarnAboutDirectlyAssigningPropsToState = new Set();
    didWarnAboutUndefinedDerivedState = new Set();
    didWarnAboutContextTypeAndContextTypes = new Set();
    didWarnAboutInvalidateContextType = new Set();
    var didWarnOnInvalidCallback = new Set();
    warnOnInvalidCallback = function(callback, callerName) {
        if (callback === null || typeof callback === 'function') return;
        var key = callerName + '_' + callback;
        if (!didWarnOnInvalidCallback.has(key)) {
            didWarnOnInvalidCallback.add(key);
            error("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
        }
    };
    warnOnUndefinedDerivedState = function(type, partialState) {
        if (partialState === undefined) {
            var componentName = getComponentNameFromType(type) || 'Component';
            if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
                didWarnAboutUndefinedDerivedState.add(componentName);
                error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName);
            }
        }
    };
    function warnNoop(publicInstance, callerName) {
        var _constructor = publicInstance.constructor;
        var componentName = _constructor && getComponentNameFromType(_constructor) || 'ReactClass';
        var warningKey = componentName + '.' + callerName;
        if (didWarnAboutNoopUpdateForComponent[warningKey]) return;
        error("%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.\n\nPlease check the code for the %s component.", callerName, callerName, componentName);
        didWarnAboutNoopUpdateForComponent[warningKey] = true;
    }
    var classComponentUpdater = {
        isMounted: function(inst) {
            return false;
        },
        enqueueSetState: function(inst, payload, callback) {
            var internals = get(inst);
            if (internals.queue === null) warnNoop(inst, 'setState');
            else {
                internals.queue.push(payload);
                if (callback !== undefined && callback !== null) warnOnInvalidCallback(callback, 'setState');
            }
        },
        enqueueReplaceState: function(inst, payload, callback) {
            var internals = get(inst);
            internals.replace = true;
            internals.queue = [
                payload
            ];
            if (callback !== undefined && callback !== null) warnOnInvalidCallback(callback, 'setState');
        },
        enqueueForceUpdate: function(inst, callback) {
            var internals = get(inst);
            if (internals.queue === null) warnNoop(inst, 'forceUpdate');
            else if (callback !== undefined && callback !== null) warnOnInvalidCallback(callback, 'setState');
        }
    };
    function applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, prevState, nextProps) {
        var partialState = getDerivedStateFromProps(nextProps, prevState);
        warnOnUndefinedDerivedState(ctor, partialState);
        var newState = partialState === null || partialState === undefined ? prevState : assign({}, prevState, partialState);
        return newState;
    }
    function constructClassInstance(ctor, props, maskedLegacyContext) {
        var context = emptyContextObject;
        var contextType = ctor.contextType;
        if ('contextType' in ctor) {
            var isValid = contextType === null || contextType !== undefined && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === undefined; // Not a <Context.Consumer>
            if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {
                didWarnAboutInvalidateContextType.add(ctor);
                var addendum = '';
                if (contextType === undefined) addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.";
                else if (typeof contextType !== 'object') addendum = ' However, it is set to a ' + typeof contextType + '.';
                else if (contextType.$$typeof === REACT_PROVIDER_TYPE) addendum = ' Did you accidentally pass the Context.Provider instead?';
                else if (contextType._context !== undefined) // <Context.Consumer>
                addendum = ' Did you accidentally pass the Context.Consumer instead?';
                else addendum = ' However, it is set to an object with keys {' + Object.keys(contextType).join(', ') + '}.';
                error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(ctor) || 'Component', addendum);
            }
        }
        if (typeof contextType === 'object' && contextType !== null) context = readContext(contextType);
        else context = maskedLegacyContext;
        var instance = new ctor(props, context);
        if (typeof ctor.getDerivedStateFromProps === 'function' && (instance.state === null || instance.state === undefined)) {
            var componentName = getComponentNameFromType(ctor) || 'Component';
            if (!didWarnAboutUninitializedState.has(componentName)) {
                didWarnAboutUninitializedState.add(componentName);
                error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? 'null' : 'undefined', componentName);
            }
        } // If new component APIs are defined, "unsafe" lifecycles won't be called.
        // Warn about these lifecycles if they are present.
        // Don't warn about react-lifecycles-compat polyfilled methods though.
        if (typeof ctor.getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function') {
            var foundWillMountName = null;
            var foundWillReceivePropsName = null;
            var foundWillUpdateName = null;
            if (typeof instance.componentWillMount === 'function' && instance.componentWillMount.__suppressDeprecationWarning !== true) foundWillMountName = 'componentWillMount';
            else if (typeof instance.UNSAFE_componentWillMount === 'function') foundWillMountName = 'UNSAFE_componentWillMount';
            if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) foundWillReceivePropsName = 'componentWillReceiveProps';
            else if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';
            if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true) foundWillUpdateName = 'componentWillUpdate';
            else if (typeof instance.UNSAFE_componentWillUpdate === 'function') foundWillUpdateName = 'UNSAFE_componentWillUpdate';
            if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
                var _componentName = getComponentNameFromType(ctor) || 'Component';
                var newApiName = typeof ctor.getDerivedStateFromProps === 'function' ? 'getDerivedStateFromProps()' : 'getSnapshotBeforeUpdate()';
                if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
                    didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
                    error("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://reactjs.org/link/unsafe-component-lifecycles", _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : '', foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : '', foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : '');
                }
            }
        }
        return instance;
    }
    function checkClassInstance(instance, ctor, newProps) {
        var name = getComponentNameFromType(ctor) || 'Component';
        var renderPresent = instance.render;
        if (!renderPresent) {
            if (ctor.prototype && typeof ctor.prototype.render === 'function') error("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", name);
            else error("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", name);
        }
        if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) error("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name);
        if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) error("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name);
        if (instance.propTypes) error("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", name);
        if (instance.contextType) error("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name);
        if (instance.contextTypes) error("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", name);
        if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
            didWarnAboutContextTypeAndContextTypes.add(ctor);
            error("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", name);
        }
        if (typeof instance.componentShouldUpdate === 'function') error("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name);
        if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== 'undefined') error("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(ctor) || 'A pure component');
        if (typeof instance.componentDidUnmount === 'function') error("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name);
        if (typeof instance.componentDidReceiveProps === 'function') error("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name);
        if (typeof instance.componentWillRecieveProps === 'function') error("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name);
        if (typeof instance.UNSAFE_componentWillRecieveProps === 'function') error("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name);
        var hasMutatedProps = instance.props !== newProps;
        if (instance.props !== undefined && hasMutatedProps) error("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name, name);
        if (instance.defaultProps) error("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name, name);
        if (typeof instance.getSnapshotBeforeUpdate === 'function' && typeof instance.componentDidUpdate !== 'function' && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
            error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(ctor));
        }
        if (typeof instance.getDerivedStateFromProps === 'function') error("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
        if (typeof instance.getDerivedStateFromError === 'function') error("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
        if (typeof ctor.getSnapshotBeforeUpdate === 'function') error("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name);
        var _state = instance.state;
        if (_state && (typeof _state !== 'object' || isArray(_state))) error('%s.state: must be set to an object or null', name);
        if (typeof instance.getChildContext === 'function' && typeof ctor.childContextTypes !== 'object') error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name);
    }
    function callComponentWillMount(type, instance) {
        var oldState = instance.state;
        if (typeof instance.componentWillMount === 'function') {
            if (instance.componentWillMount.__suppressDeprecationWarning !== true) {
                var componentName = getComponentNameFromType(type) || 'Unknown';
                if (!didWarnAboutDeprecatedWillMount[componentName]) {
                    warn("componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.\n\nPlease update the following components: %s", componentName);
                    didWarnAboutDeprecatedWillMount[componentName] = true;
                }
            }
            instance.componentWillMount();
        }
        if (typeof instance.UNSAFE_componentWillMount === 'function') instance.UNSAFE_componentWillMount();
        if (oldState !== instance.state) {
            error("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromType(type) || 'Component');
            classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
        }
    }
    function processUpdateQueue(internalInstance, inst, props, maskedLegacyContext) {
        if (internalInstance.queue !== null && internalInstance.queue.length > 0) {
            var oldQueue = internalInstance.queue;
            var oldReplace = internalInstance.replace;
            internalInstance.queue = null;
            internalInstance.replace = false;
            if (oldReplace && oldQueue.length === 1) inst.state = oldQueue[0];
            else {
                var nextState = oldReplace ? oldQueue[0] : inst.state;
                var dontMutate = true;
                for(var i = oldReplace ? 1 : 0; i < oldQueue.length; i++){
                    var partial = oldQueue[i];
                    var partialState = typeof partial === 'function' ? partial.call(inst, nextState, props, maskedLegacyContext) : partial;
                    if (partialState != null) {
                        if (dontMutate) {
                            dontMutate = false;
                            nextState = assign({}, nextState, partialState);
                        } else assign(nextState, partialState);
                    }
                }
                inst.state = nextState;
            }
        } else internalInstance.queue = null;
    } // Invokes the mount life-cycles on a previously never rendered instance.
    function mountClassInstance(instance, ctor, newProps, maskedLegacyContext) {
        checkClassInstance(instance, ctor, newProps);
        var initialState = instance.state !== undefined ? instance.state : null;
        instance.updater = classComponentUpdater;
        instance.props = newProps;
        instance.state = initialState; // We don't bother initializing the refs object on the server, since we're not going to resolve them anyway.
        // The internal instance will be used to manage updates that happen during this mount.
        var internalInstance = {
            queue: [],
            replace: false
        };
        set(instance, internalInstance);
        var contextType = ctor.contextType;
        if (typeof contextType === 'object' && contextType !== null) instance.context = readContext(contextType);
        else instance.context = maskedLegacyContext;
        if (instance.state === newProps) {
            var componentName = getComponentNameFromType(ctor) || 'Component';
            if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
                didWarnAboutDirectlyAssigningPropsToState.add(componentName);
                error("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName);
            }
        }
        var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
        if (typeof getDerivedStateFromProps === 'function') instance.state = applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, initialState, newProps);
         // In order to support react-lifecycles-compat polyfilled components,
        // Unsafe lifecycles should not be invoked for components using the new APIs.
        if (typeof ctor.getDerivedStateFromProps !== 'function' && typeof instance.getSnapshotBeforeUpdate !== 'function' && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {
            callComponentWillMount(ctor, instance); // If we had additional state updates during this life-cycle, let's
            // process them now.
            processUpdateQueue(internalInstance, instance, newProps, maskedLegacyContext);
        }
    }
    // Ids are base 32 strings whose binary representation corresponds to the
    // position of a node in a tree.
    // Every time the tree forks into multiple children, we add additional bits to
    // the left of the sequence that represent the position of the child within the
    // current level of children.
    //
    //      00101       00010001011010101
    //             
    //   Fork 5 of 20       Parent id
    //
    // The leading 0s are important. In the above example, you only need 3 bits to
    // represent slot 5. However, you need 5 bits to represent all the forks at
    // the current level, so we must account for the empty bits at the end.
    //
    // For this same reason, slots are 1-indexed instead of 0-indexed. Otherwise,
    // the zeroth id at a level would be indistinguishable from its parent.
    //
    // If a node has only one child, and does not materialize an id (i.e. does not
    // contain a useId hook), then we don't need to allocate any space in the
    // sequence. It's treated as a transparent indirection. For example, these two
    // trees produce the same ids:
    //
    // <>                          <>
    //   <Indirection>               <A />
    //     <A />                     <B />
    //   </Indirection>            </>
    //   <B />
    // </>
    //
    // However, we cannot skip any node that materializes an id. Otherwise, a parent
    // id that does not fork would be indistinguishable from its child id. For
    // example, this tree does not fork, but the parent and child must have
    // different ids.
    //
    // <Parent>
    //   <Child />
    // </Parent>
    //
    // To handle this scenario, every time we materialize an id, we allocate a
    // new level with a single slot. You can think of this as a fork with only one
    // prong, or an array of children with length 1.
    //
    // It's possible for the size of the sequence to exceed 32 bits, the max
    // size for bitwise operations. When this happens, we make more room by
    // converting the right part of the id to a string and storing it in an overflow
    // variable. We use a base 32 string representation, because 32 is the largest
    // power of 2 that is supported by toString(). We want the base to be large so
    // that the resulting ids are compact, and we want the base to be a power of 2
    // because every log2(base) bits corresponds to a single character, i.e. every
    // log2(32) = 5 bits. That means we can lop bits off the end 5 at a time without
    // affecting the final result.
    var emptyTreeContext = {
        id: 1,
        overflow: ''
    };
    function getTreeId(context) {
        var overflow = context.overflow;
        var idWithLeadingBit = context.id;
        var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);
        return id.toString(32) + overflow;
    }
    function pushTreeContext(baseContext, totalChildren, index) {
        var baseIdWithLeadingBit = baseContext.id;
        var baseOverflow = baseContext.overflow; // The leftmost 1 marks the end of the sequence, non-inclusive. It's not part
        // of the id; we use it to account for leading 0s.
        var baseLength = getBitLength(baseIdWithLeadingBit) - 1;
        var baseId = baseIdWithLeadingBit & ~(1 << baseLength);
        var slot = index + 1;
        var length = getBitLength(totalChildren) + baseLength; // 30 is the max length we can store without overflowing, taking into
        // consideration the leading 1 we use to mark the end of the sequence.
        if (length > 30) {
            // We overflowed the bitwise-safe range. Fall back to slower algorithm.
            // This branch assumes the length of the base id is greater than 5; it won't
            // work for smaller ids, because you need 5 bits per character.
            //
            // We encode the id in multiple steps: first the base id, then the
            // remaining digits.
            //
            // Each 5 bit sequence corresponds to a single base 32 character. So for
            // example, if the current id is 23 bits long, we can convert 20 of those
            // bits into a string of 4 characters, with 3 bits left over.
            //
            // First calculate how many bits in the base id represent a complete
            // sequence of characters.
            var numberOfOverflowBits = baseLength - baseLength % 5; // Then create a bitmask that selects only those bits.
            var newOverflowBits = (1 << numberOfOverflowBits) - 1; // Select the bits, and convert them to a base 32 string.
            var newOverflow = (baseId & newOverflowBits).toString(32); // Now we can remove those bits from the base id.
            var restOfBaseId = baseId >> numberOfOverflowBits;
            var restOfBaseLength = baseLength - numberOfOverflowBits; // Finally, encode the rest of the bits using the normal algorithm. Because
            // we made more room, this time it won't overflow.
            var restOfLength = getBitLength(totalChildren) + restOfBaseLength;
            var restOfNewBits = slot << restOfBaseLength;
            var id = restOfNewBits | restOfBaseId;
            var overflow = newOverflow + baseOverflow;
            return {
                id: 1 << restOfLength | id,
                overflow: overflow
            };
        } else {
            // Normal path
            var newBits = slot << baseLength;
            var _id = newBits | baseId;
            var _overflow = baseOverflow;
            return {
                id: 1 << length | _id,
                overflow: _overflow
            };
        }
    }
    function getBitLength(number) {
        return 32 - clz32(number);
    }
    function getLeadingBit(id) {
        return 1 << getBitLength(id) - 1;
    } // TODO: Math.clz32 is supported in Node 12+. Maybe we can drop the fallback.
    var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback; // Count leading zeros.
    // Based on:
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32
    var log = Math.log;
    var LN2 = Math.LN2;
    function clz32Fallback(x) {
        var asUint = x >>> 0;
        if (asUint === 0) return 32;
        return 31 - (log(asUint) / LN2 | 0) | 0;
    }
    /**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */ function is(x, y) {
        return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare
        ;
    }
    var objectIs = typeof Object.is === 'function' ? Object.is : is;
    var currentlyRenderingComponent = null;
    var currentlyRenderingTask = null;
    var firstWorkInProgressHook = null;
    var workInProgressHook = null; // Whether the work-in-progress hook is a re-rendered hook
    var isReRender = false; // Whether an update was scheduled during the currently executing render pass.
    var didScheduleRenderPhaseUpdate = false; // Counts the number of useId hooks in this component
    var localIdCounter = 0; // Lazily created map of render-phase updates
    var renderPhaseUpdates = null; // Counter to prevent infinite loops.
    var numberOfReRenders = 0;
    var RE_RENDER_LIMIT = 25;
    var isInHookUserCodeInDev = false; // In DEV, this is the name of the currently executing primitive hook
    var currentHookNameInDev;
    function resolveCurrentlyRenderingComponent() {
        if (currentlyRenderingComponent === null) throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
        if (isInHookUserCodeInDev) error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
        return currentlyRenderingComponent;
    }
    function areHookInputsEqual(nextDeps, prevDeps) {
        if (prevDeps === null) {
            error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev);
            return false;
        }
        // Don't bother comparing lengths in prod because these arrays should be
        // passed inline.
        if (nextDeps.length !== prevDeps.length) error("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + nextDeps.join(', ') + "]", "[" + prevDeps.join(', ') + "]");
        for(var i = 0; i < prevDeps.length && i < nextDeps.length; i++){
            if (objectIs(nextDeps[i], prevDeps[i])) continue;
            return false;
        }
        return true;
    }
    function createHook() {
        if (numberOfReRenders > 0) throw new Error('Rendered more hooks than during the previous render');
        return {
            memoizedState: null,
            queue: null,
            next: null
        };
    }
    function createWorkInProgressHook() {
        if (workInProgressHook === null) {
            // This is the first hook in the list
            if (firstWorkInProgressHook === null) {
                isReRender = false;
                firstWorkInProgressHook = workInProgressHook = createHook();
            } else {
                // There's already a work-in-progress. Reuse it.
                isReRender = true;
                workInProgressHook = firstWorkInProgressHook;
            }
        } else if (workInProgressHook.next === null) {
            isReRender = false; // Append to the end of the list
            workInProgressHook = workInProgressHook.next = createHook();
        } else {
            // There's already a work-in-progress. Reuse it.
            isReRender = true;
            workInProgressHook = workInProgressHook.next;
        }
        return workInProgressHook;
    }
    function prepareToUseHooks(task, componentIdentity) {
        currentlyRenderingComponent = componentIdentity;
        currentlyRenderingTask = task;
        isInHookUserCodeInDev = false;
        // didScheduleRenderPhaseUpdate = false;
        // localIdCounter = 0;
        // firstWorkInProgressHook = null;
        // numberOfReRenders = 0;
        // renderPhaseUpdates = null;
        // workInProgressHook = null;
        localIdCounter = 0;
    }
    function finishHooks(Component, props, children, refOrContext) {
        // This must be called after every function component to prevent hooks from
        // being used in classes.
        while(didScheduleRenderPhaseUpdate){
            // Updates were scheduled during the render phase. They are stored in
            // the `renderPhaseUpdates` map. Call the component again, reusing the
            // work-in-progress hooks and applying the additional updates on top. Keep
            // restarting until no more updates are scheduled.
            didScheduleRenderPhaseUpdate = false;
            localIdCounter = 0;
            numberOfReRenders += 1; // Start over from the beginning of the list
            workInProgressHook = null;
            children = Component(props, refOrContext);
        }
        resetHooksState();
        return children;
    }
    function checkDidRenderIdHook() {
        // This should be called immediately after every finishHooks call.
        // Conceptually, it's part of the return value of finishHooks; it's only a
        // separate function to avoid using an array tuple.
        var didRenderIdHook = localIdCounter !== 0;
        return didRenderIdHook;
    } // Reset the internal hooks state if an error occurs while rendering a component
    function resetHooksState() {
        isInHookUserCodeInDev = false;
        currentlyRenderingComponent = null;
        currentlyRenderingTask = null;
        didScheduleRenderPhaseUpdate = false;
        firstWorkInProgressHook = null;
        numberOfReRenders = 0;
        renderPhaseUpdates = null;
        workInProgressHook = null;
    }
    function readContext$1(context) {
        if (isInHookUserCodeInDev) error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
        return readContext(context);
    }
    function useContext(context) {
        currentHookNameInDev = 'useContext';
        resolveCurrentlyRenderingComponent();
        return readContext(context);
    }
    function basicStateReducer(state, action) {
        // $FlowFixMe: Flow doesn't like mixed types
        return typeof action === 'function' ? action(state) : action;
    }
    function useState(initialState) {
        currentHookNameInDev = 'useState';
        return useReducer(basicStateReducer, initialState);
    }
    function useReducer(reducer, initialArg, init) {
        if (reducer !== basicStateReducer) currentHookNameInDev = 'useReducer';
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
        workInProgressHook = createWorkInProgressHook();
        if (isReRender) {
            // This is a re-render. Apply the new render phase updates to the previous
            // current hook.
            var queue = workInProgressHook.queue;
            var dispatch = queue.dispatch;
            if (renderPhaseUpdates !== null) {
                // Render phase updates are stored in a map of queue -> linked list
                var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
                if (firstRenderPhaseUpdate !== undefined) {
                    renderPhaseUpdates.delete(queue);
                    var newState = workInProgressHook.memoizedState;
                    var update = firstRenderPhaseUpdate;
                    do {
                        // Process this render phase update. We don't have to check the
                        // priority because it will always be the same as the current
                        // render's.
                        var action = update.action;
                        isInHookUserCodeInDev = true;
                        newState = reducer(newState, action);
                        isInHookUserCodeInDev = false;
                        update = update.next;
                    }while (update !== null)
                    workInProgressHook.memoizedState = newState;
                    return [
                        newState,
                        dispatch
                    ];
                }
            }
            return [
                workInProgressHook.memoizedState,
                dispatch
            ];
        } else {
            isInHookUserCodeInDev = true;
            var initialState;
            if (reducer === basicStateReducer) // Special case for `useState`.
            initialState = typeof initialArg === 'function' ? initialArg() : initialArg;
            else initialState = init !== undefined ? init(initialArg) : initialArg;
            isInHookUserCodeInDev = false;
            workInProgressHook.memoizedState = initialState;
            var _queue = workInProgressHook.queue = {
                last: null,
                dispatch: null
            };
            var _dispatch = _queue.dispatch = dispatchAction.bind(null, currentlyRenderingComponent, _queue);
            return [
                workInProgressHook.memoizedState,
                _dispatch
            ];
        }
    }
    function useMemo(nextCreate, deps) {
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
        workInProgressHook = createWorkInProgressHook();
        var nextDeps = deps === undefined ? null : deps;
        if (workInProgressHook !== null) {
            var prevState = workInProgressHook.memoizedState;
            if (prevState !== null) {
                if (nextDeps !== null) {
                    var prevDeps = prevState[1];
                    if (areHookInputsEqual(nextDeps, prevDeps)) return prevState[0];
                }
            }
        }
        isInHookUserCodeInDev = true;
        var nextValue = nextCreate();
        isInHookUserCodeInDev = false;
        workInProgressHook.memoizedState = [
            nextValue,
            nextDeps
        ];
        return nextValue;
    }
    function useRef(initialValue) {
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
        workInProgressHook = createWorkInProgressHook();
        var previousRef = workInProgressHook.memoizedState;
        if (previousRef === null) {
            var ref = {
                current: initialValue
            };
            Object.seal(ref);
            workInProgressHook.memoizedState = ref;
            return ref;
        } else return previousRef;
    }
    function useLayoutEffect(create, inputs) {
        currentHookNameInDev = 'useLayoutEffect';
        error("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
    }
    function dispatchAction(componentIdentity, queue, action) {
        if (numberOfReRenders >= RE_RENDER_LIMIT) throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
        if (componentIdentity === currentlyRenderingComponent) {
            // This is a render phase update. Stash it in a lazily-created map of
            // queue -> linked list of updates. After this render pass, we'll restart
            // and apply the stashed updates on top of the work-in-progress hook.
            didScheduleRenderPhaseUpdate = true;
            var update = {
                action: action,
                next: null
            };
            if (renderPhaseUpdates === null) renderPhaseUpdates = new Map();
            var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
            if (firstRenderPhaseUpdate === undefined) renderPhaseUpdates.set(queue, update);
            else {
                // Append the update to the end of the list.
                var lastRenderPhaseUpdate = firstRenderPhaseUpdate;
                while(lastRenderPhaseUpdate.next !== null)lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
                lastRenderPhaseUpdate.next = update;
            }
        }
    }
    function useCallback(callback, deps) {
        return useMemo(function() {
            return callback;
        }, deps);
    } // TODO Decide on how to implement this hook for server rendering.
    // If a mutation occurs during render, consider triggering a Suspense boundary
    // and falling back to client rendering.
    function useMutableSource(source, getSnapshot, subscribe) {
        resolveCurrentlyRenderingComponent();
        return getSnapshot(source._source);
    }
    function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
        if (getServerSnapshot === undefined) throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        return getServerSnapshot();
    }
    function useDeferredValue(value) {
        resolveCurrentlyRenderingComponent();
        return value;
    }
    function unsupportedStartTransition() {
        throw new Error('startTransition cannot be called during server rendering.');
    }
    function useTransition() {
        resolveCurrentlyRenderingComponent();
        return [
            false,
            unsupportedStartTransition
        ];
    }
    function useId() {
        var task = currentlyRenderingTask;
        var treeId = getTreeId(task.treeContext);
        var responseState = currentResponseState;
        if (responseState === null) throw new Error('Invalid hook call. Hooks can only be called inside of the body of a function component.');
        var localId = localIdCounter++;
        return makeId(responseState, treeId, localId);
    }
    function noop() {}
    var Dispatcher = {
        readContext: readContext$1,
        useContext: useContext,
        useMemo: useMemo,
        useReducer: useReducer,
        useRef: useRef,
        useState: useState,
        useInsertionEffect: noop,
        useLayoutEffect: useLayoutEffect,
        useCallback: useCallback,
        // useImperativeHandle is not run in the server environment
        useImperativeHandle: noop,
        // Effects are not run in the server environment.
        useEffect: noop,
        // Debugging effect
        useDebugValue: noop,
        useDeferredValue: useDeferredValue,
        useTransition: useTransition,
        useId: useId,
        // Subscriptions are not setup in a server environment.
        useMutableSource: useMutableSource,
        useSyncExternalStore: useSyncExternalStore
    };
    var currentResponseState = null;
    function setCurrentResponseState(responseState) {
        currentResponseState = responseState;
    }
    function getStackByComponentStackNode(componentStack) {
        try {
            var info = '';
            var node = componentStack;
            do {
                switch(node.tag){
                    case 0:
                        info += describeBuiltInComponentFrame(node.type, null, null);
                        break;
                    case 1:
                        info += describeFunctionComponentFrame(node.type, null, null);
                        break;
                    case 2:
                        info += describeClassComponentFrame(node.type, null, null);
                        break;
                }
                node = node.parent;
            }while (node)
            return info;
        } catch (x) {
            return '\nError generating stack: ' + x.message + '\n' + x.stack;
        }
    }
    var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
    var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
    var PENDING = 0;
    var COMPLETED = 1;
    var FLUSHED = 2;
    var ABORTED = 3;
    var ERRORED = 4;
    var OPEN = 0;
    var CLOSING = 1;
    var CLOSED = 2;
    // This is a default heuristic for how to split up the HTML content into progressive
    // loading. Our goal is to be able to display additional new content about every 500ms.
    // Faster than that is unnecessary and should be throttled on the client. It also
    // adds unnecessary overhead to do more splits. We don't know if it's a higher or lower
    // end device but higher end suffer less from the overhead than lower end does from
    // not getting small enough pieces. We error on the side of low end.
    // We base this on low end 3G speeds which is about 500kbits per second. We assume
    // that there can be a reasonable drop off from max bandwidth which leaves you with
    // as little as 80%. We can receive half of that each 500ms - at best. In practice,
    // a little bandwidth is lost to processing and contention - e.g. CSS and images that
    // are downloaded along with the main content. So we estimate about half of that to be
    // the lower end throughput. In other words, we expect that you can at least show
    // about 12.5kb of content per 500ms. Not counting starting latency for the first
    // paint.
    // 500 * 1024 / 8 * .8 * 0.5 / 2
    var DEFAULT_PROGRESSIVE_CHUNK_SIZE = 12800;
    function defaultErrorHandler(error) {
        console['error'](error); // Don't transform to our wrapper
        return null;
    }
    function noop$1() {}
    function createRequest(children, responseState, rootFormatContext, progressiveChunkSize, onError, onAllReady, onShellReady, onShellError, onFatalError) {
        var pingedTasks = [];
        var abortSet = new Set();
        var request = {
            destination: null,
            responseState: responseState,
            progressiveChunkSize: progressiveChunkSize === undefined ? DEFAULT_PROGRESSIVE_CHUNK_SIZE : progressiveChunkSize,
            status: OPEN,
            fatalError: null,
            nextSegmentId: 0,
            allPendingTasks: 0,
            pendingRootTasks: 0,
            completedRootSegment: null,
            abortableTasks: abortSet,
            pingedTasks: pingedTasks,
            clientRenderedBoundaries: [],
            completedBoundaries: [],
            partialBoundaries: [],
            onError: onError === undefined ? defaultErrorHandler : onError,
            onAllReady: onAllReady === undefined ? noop$1 : onAllReady,
            onShellReady: onShellReady === undefined ? noop$1 : onShellReady,
            onShellError: onShellError === undefined ? noop$1 : onShellError,
            onFatalError: onFatalError === undefined ? noop$1 : onFatalError
        }; // This segment represents the root fallback.
        var rootSegment = createPendingSegment(request, 0, null, rootFormatContext, false, false); // There is no parent so conceptually, we're unblocked to flush this segment.
        rootSegment.parentFlushed = true;
        var rootTask = createTask(request, children, null, rootSegment, abortSet, emptyContextObject, rootContextSnapshot, emptyTreeContext);
        pingedTasks.push(rootTask);
        return request;
    }
    function pingTask(request, task) {
        var pingedTasks = request.pingedTasks;
        pingedTasks.push(task);
        if (pingedTasks.length === 1) scheduleWork(function() {
            return performWork(request);
        });
    }
    function createSuspenseBoundary(request, fallbackAbortableTasks) {
        return {
            id: UNINITIALIZED_SUSPENSE_BOUNDARY_ID,
            rootSegmentID: -1,
            parentFlushed: false,
            pendingTasks: 0,
            forceClientRender: false,
            completedSegments: [],
            byteSize: 0,
            fallbackAbortableTasks: fallbackAbortableTasks,
            errorDigest: null
        };
    }
    function createTask(request, node, blockedBoundary, blockedSegment, abortSet, legacyContext, context, treeContext) {
        request.allPendingTasks++;
        if (blockedBoundary === null) request.pendingRootTasks++;
        else blockedBoundary.pendingTasks++;
        var task = {
            node: node,
            ping: function() {
                return pingTask(request, task);
            },
            blockedBoundary: blockedBoundary,
            blockedSegment: blockedSegment,
            abortSet: abortSet,
            legacyContext: legacyContext,
            context: context,
            treeContext: treeContext
        };
        task.componentStack = null;
        abortSet.add(task);
        return task;
    }
    function createPendingSegment(request, index, boundary, formatContext, lastPushedText, textEmbedded) {
        return {
            status: PENDING,
            id: -1,
            // lazily assigned later
            index: index,
            parentFlushed: false,
            chunks: [],
            children: [],
            formatContext: formatContext,
            boundary: boundary,
            lastPushedText: lastPushedText,
            textEmbedded: textEmbedded
        };
    } // DEV-only global reference to the currently executing task
    var currentTaskInDEV = null;
    function getCurrentStackInDEV() {
        if (currentTaskInDEV === null || currentTaskInDEV.componentStack === null) return '';
        return getStackByComponentStackNode(currentTaskInDEV.componentStack);
    }
    function pushBuiltInComponentStackInDEV(task, type) {
        task.componentStack = {
            tag: 0,
            parent: task.componentStack,
            type: type
        };
    }
    function pushFunctionComponentStackInDEV(task, type) {
        task.componentStack = {
            tag: 1,
            parent: task.componentStack,
            type: type
        };
    }
    function pushClassComponentStackInDEV(task, type) {
        task.componentStack = {
            tag: 2,
            parent: task.componentStack,
            type: type
        };
    }
    function popComponentStackInDEV(task) {
        if (task.componentStack === null) error('Unexpectedly popped too many stack frames. This is a bug in React.');
        else task.componentStack = task.componentStack.parent;
    } // stash the component stack of an unwinding error until it is processed
    var lastBoundaryErrorComponentStackDev = null;
    function captureBoundaryErrorDetailsDev(boundary, error) {
        var errorMessage;
        if (typeof error === 'string') errorMessage = error;
        else if (error && typeof error.message === 'string') errorMessage = error.message;
        else // eslint-disable-next-line react-internal/safe-string-coercion
        errorMessage = String(error);
        var errorComponentStack = lastBoundaryErrorComponentStackDev || getCurrentStackInDEV();
        lastBoundaryErrorComponentStackDev = null;
        boundary.errorMessage = errorMessage;
        boundary.errorComponentStack = errorComponentStack;
    }
    function logRecoverableError(request, error) {
        // If this callback errors, we intentionally let that error bubble up to become a fatal error
        // so that someone fixes the error reporting instead of hiding it.
        var errorDigest = request.onError(error);
        if (errorDigest != null && typeof errorDigest !== 'string') // eslint-disable-next-line react-internal/prod-error-codes
        throw new Error("onError returned something with a type other than \"string\". onError should return a string and may return null or undefined but must not return anything else. It received something of type \"" + typeof errorDigest + "\" instead");
        return errorDigest;
    }
    function fatalError(request, error) {
        // This is called outside error handling code such as if the root errors outside
        // a suspense boundary or if the root suspense boundary's fallback errors.
        // It's also called if React itself or its host configs errors.
        var onShellError = request.onShellError;
        onShellError(error);
        var onFatalError = request.onFatalError;
        onFatalError(error);
        if (request.destination !== null) {
            request.status = CLOSED;
            closeWithError(request.destination, error);
        } else {
            request.status = CLOSING;
            request.fatalError = error;
        }
    }
    function renderSuspenseBoundary(request, task, props) {
        pushBuiltInComponentStackInDEV(task, 'Suspense');
        var parentBoundary = task.blockedBoundary;
        var parentSegment = task.blockedSegment; // Each time we enter a suspense boundary, we split out into a new segment for
        // the fallback so that we can later replace that segment with the content.
        // This also lets us split out the main content even if it doesn't suspend,
        // in case it ends up generating a large subtree of content.
        var fallback = props.fallback;
        var content = props.children;
        var fallbackAbortSet = new Set();
        var newBoundary = createSuspenseBoundary(request, fallbackAbortSet);
        var insertionIndex = parentSegment.chunks.length; // The children of the boundary segment is actually the fallback.
        var boundarySegment = createPendingSegment(request, insertionIndex, newBoundary, parentSegment.formatContext, false, false);
        parentSegment.children.push(boundarySegment); // The parentSegment has a child Segment at this index so we reset the lastPushedText marker on the parent
        parentSegment.lastPushedText = false; // This segment is the actual child content. We can start rendering that immediately.
        var contentRootSegment = createPendingSegment(request, 0, null, parentSegment.formatContext, false, false); // We mark the root segment as having its parent flushed. It's not really flushed but there is
        // no parent segment so there's nothing to wait on.
        contentRootSegment.parentFlushed = true; // Currently this is running synchronously. We could instead schedule this to pingedTasks.
        // I suspect that there might be some efficiency benefits from not creating the suspended task
        // and instead just using the stack if possible.
        // TODO: Call this directly instead of messing with saving and restoring contexts.
        // We can reuse the current context and task to render the content immediately without
        // context switching. We just need to temporarily switch which boundary and which segment
        // we're writing to. If something suspends, it'll spawn new suspended task with that context.
        task.blockedBoundary = newBoundary;
        task.blockedSegment = contentRootSegment;
        try {
            // We use the safe form because we don't handle suspending here. Only error handling.
            renderNode(request, task, content);
            pushSegmentFinale$1(contentRootSegment.chunks, request.responseState, contentRootSegment.lastPushedText, contentRootSegment.textEmbedded);
            contentRootSegment.status = COMPLETED;
            queueCompletedSegment(newBoundary, contentRootSegment);
            if (newBoundary.pendingTasks === 0) {
                // This must have been the last segment we were waiting on. This boundary is now complete.
                // Therefore we won't need the fallback. We early return so that we don't have to create
                // the fallback.
                popComponentStackInDEV(task);
                return;
            }
        } catch (error) {
            contentRootSegment.status = ERRORED;
            newBoundary.forceClientRender = true;
            newBoundary.errorDigest = logRecoverableError(request, error);
            captureBoundaryErrorDetailsDev(newBoundary, error);
        // We don't need to schedule any task because we know the parent has written yet.
        // We do need to fallthrough to create the fallback though.
        } finally{
            task.blockedBoundary = parentBoundary;
            task.blockedSegment = parentSegment;
        } // We create suspended task for the fallback because we don't want to actually work
        // on it yet in case we finish the main content, so we queue for later.
        var suspendedFallbackTask = createTask(request, fallback, parentBoundary, boundarySegment, fallbackAbortSet, task.legacyContext, task.context, task.treeContext);
        suspendedFallbackTask.componentStack = task.componentStack;
        // on preparing fallbacks if we don't have any more main content to task on.
        request.pingedTasks.push(suspendedFallbackTask);
        popComponentStackInDEV(task);
    }
    function renderHostElement(request, task, type, props) {
        pushBuiltInComponentStackInDEV(task, type);
        var segment = task.blockedSegment;
        var children = pushStartInstance(segment.chunks, type, props, request.responseState, segment.formatContext);
        segment.lastPushedText = false;
        var prevContext = segment.formatContext;
        segment.formatContext = getChildFormatContext(prevContext, type, props); // We use the non-destructive form because if something suspends, we still
        // need to pop back up and finish this subtree of HTML.
        renderNode(request, task, children); // We expect that errors will fatal the whole task and that we don't need
        // the correct context. Therefore this is not in a finally.
        segment.formatContext = prevContext;
        pushEndInstance(segment.chunks, type);
        segment.lastPushedText = false;
        popComponentStackInDEV(task);
    }
    function shouldConstruct$1(Component) {
        return Component.prototype && Component.prototype.isReactComponent;
    }
    function renderWithHooks(request, task, Component, props, secondArg) {
        var componentIdentity = {};
        prepareToUseHooks(task, componentIdentity);
        var result = Component(props, secondArg);
        return finishHooks(Component, props, result, secondArg);
    }
    function finishClassComponent(request, task, instance, Component, props) {
        var nextChildren = instance.render();
        if (instance.props !== props) {
            if (!didWarnAboutReassigningProps) error("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromType(Component) || 'a component');
            didWarnAboutReassigningProps = true;
        }
        var childContextTypes = Component.childContextTypes;
        if (childContextTypes !== null && childContextTypes !== undefined) {
            var previousContext = task.legacyContext;
            var mergedContext = processChildContext(instance, Component, previousContext, childContextTypes);
            task.legacyContext = mergedContext;
            renderNodeDestructive(request, task, nextChildren);
            task.legacyContext = previousContext;
            return;
        }
        renderNodeDestructive(request, task, nextChildren);
    }
    function renderClassComponent(request, task, Component, props) {
        pushClassComponentStackInDEV(task, Component);
        var maskedContext = getMaskedContext(Component, task.legacyContext);
        var instance = constructClassInstance(Component, props, maskedContext);
        mountClassInstance(instance, Component, props, maskedContext);
        finishClassComponent(request, task, instance, Component, props);
        popComponentStackInDEV(task);
    }
    var didWarnAboutBadClass = {};
    var didWarnAboutModulePatternComponent = {};
    var didWarnAboutContextTypeOnFunctionComponent = {};
    var didWarnAboutGetDerivedStateOnFunctionComponent = {};
    var didWarnAboutReassigningProps = false;
    var didWarnAboutDefaultPropsOnFunctionComponent = {};
    var didWarnAboutGenerators = false;
    var didWarnAboutMaps = false;
    var hasWarnedAboutUsingContextAsConsumer = false; // This would typically be a function component but we still support module pattern
    // components for some reason.
    function renderIndeterminateComponent(request, task, Component, props) {
        var legacyContext;
        legacyContext = getMaskedContext(Component, task.legacyContext);
        pushFunctionComponentStackInDEV(task, Component);
        if (Component.prototype && typeof Component.prototype.render === 'function') {
            var componentName = getComponentNameFromType(Component) || 'Unknown';
            if (!didWarnAboutBadClass[componentName]) {
                error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName);
                didWarnAboutBadClass[componentName] = true;
            }
        }
        var value = renderWithHooks(request, task, Component, props, legacyContext);
        var hasId = checkDidRenderIdHook();
        // Support for module components is deprecated and is removed behind a flag.
        // Whether or not it would crash later, we want to show a good message in DEV first.
        if (typeof value === 'object' && value !== null && typeof value.render === 'function' && value.$$typeof === undefined) {
            var _componentName = getComponentNameFromType(Component) || 'Unknown';
            if (!didWarnAboutModulePatternComponent[_componentName]) {
                error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName, _componentName, _componentName);
                didWarnAboutModulePatternComponent[_componentName] = true;
            }
        }
        if (// Eventually we'll delete this branch altogether.
        typeof value === 'object' && value !== null && typeof value.render === 'function' && value.$$typeof === undefined) {
            var _componentName2 = getComponentNameFromType(Component) || 'Unknown';
            if (!didWarnAboutModulePatternComponent[_componentName2]) {
                error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName2, _componentName2, _componentName2);
                didWarnAboutModulePatternComponent[_componentName2] = true;
            }
            mountClassInstance(value, Component, props, legacyContext);
            finishClassComponent(request, task, value, Component, props);
        } else {
            validateFunctionComponentInDev(Component);
            // the previous task every again, so we can use the destructive recursive form.
            if (hasId) {
                // This component materialized an id. We treat this as its own level, with
                // a single "child" slot.
                var prevTreeContext = task.treeContext;
                var totalChildren = 1;
                var index = 0;
                task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index);
                try {
                    renderNodeDestructive(request, task, value);
                } finally{
                    task.treeContext = prevTreeContext;
                }
            } else renderNodeDestructive(request, task, value);
        }
        popComponentStackInDEV(task);
    }
    function validateFunctionComponentInDev(Component) {
        if (Component) {
            if (Component.childContextTypes) error('%s(...): childContextTypes cannot be defined on a function component.', Component.displayName || Component.name || 'Component');
        }
        if (Component.defaultProps !== undefined) {
            var componentName = getComponentNameFromType(Component) || 'Unknown';
            if (!didWarnAboutDefaultPropsOnFunctionComponent[componentName]) {
                error("%s: Support for defaultProps will be removed from function components in a future major release. Use JavaScript default parameters instead.", componentName);
                didWarnAboutDefaultPropsOnFunctionComponent[componentName] = true;
            }
        }
        if (typeof Component.getDerivedStateFromProps === 'function') {
            var _componentName3 = getComponentNameFromType(Component) || 'Unknown';
            if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
                error('%s: Function components do not support getDerivedStateFromProps.', _componentName3);
                didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;
            }
        }
        if (typeof Component.contextType === 'object' && Component.contextType !== null) {
            var _componentName4 = getComponentNameFromType(Component) || 'Unknown';
            if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
                error('%s: Function components do not support contextType.', _componentName4);
                didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;
            }
        }
    }
    function resolveDefaultProps(Component, baseProps) {
        if (Component && Component.defaultProps) {
            // Resolve default props. Taken from ReactElement
            var props = assign({}, baseProps);
            var defaultProps = Component.defaultProps;
            for(var propName in defaultProps)if (props[propName] === undefined) props[propName] = defaultProps[propName];
            return props;
        }
        return baseProps;
    }
    function renderForwardRef(request, task, type, props, ref) {
        pushFunctionComponentStackInDEV(task, type.render);
        var children = renderWithHooks(request, task, type.render, props, ref);
        var hasId = checkDidRenderIdHook();
        if (hasId) {
            // This component materialized an id. We treat this as its own level, with
            // a single "child" slot.
            var prevTreeContext = task.treeContext;
            var totalChildren = 1;
            var index = 0;
            task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index);
            try {
                renderNodeDestructive(request, task, children);
            } finally{
                task.treeContext = prevTreeContext;
            }
        } else renderNodeDestructive(request, task, children);
        popComponentStackInDEV(task);
    }
    function renderMemo(request, task, type, props, ref) {
        var innerType = type.type;
        var resolvedProps = resolveDefaultProps(innerType, props);
        renderElement(request, task, innerType, resolvedProps, ref);
    }
    function renderContextConsumer(request, task, context, props) {
        if (context._context === undefined) {
            // This may be because it's a Context (rather than a Consumer).
            // Or it may be because it's older React where they're the same thing.
            // We only want to warn if we're sure it's a new React.
            if (context !== context.Consumer) {
                if (!hasWarnedAboutUsingContextAsConsumer) {
                    hasWarnedAboutUsingContextAsConsumer = true;
                    error("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                }
            }
        } else context = context._context;
        var render = props.children;
        if (typeof render !== 'function') error("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
        var newValue = readContext(context);
        var newChildren = render(newValue);
        renderNodeDestructive(request, task, newChildren);
    }
    function renderContextProvider(request, task, type, props) {
        var context = type._context;
        var value = props.value;
        var children = props.children;
        var prevSnapshot;
        prevSnapshot = task.context;
        task.context = pushProvider(context, value);
        renderNodeDestructive(request, task, children);
        task.context = popProvider(context);
        if (prevSnapshot !== task.context) error('Popping the context provider did not return back to the original snapshot. This is a bug in React.');
    }
    function renderLazyComponent(request, task, lazyComponent, props, ref) {
        pushBuiltInComponentStackInDEV(task, 'Lazy');
        var payload = lazyComponent._payload;
        var init = lazyComponent._init;
        var Component = init(payload);
        var resolvedProps = resolveDefaultProps(Component, props);
        renderElement(request, task, Component, resolvedProps, ref);
        popComponentStackInDEV(task);
    }
    function renderElement(request, task, type, props, ref) {
        if (typeof type === 'function') {
            if (shouldConstruct$1(type)) {
                renderClassComponent(request, task, type, props);
                return;
            } else {
                renderIndeterminateComponent(request, task, type, props);
                return;
            }
        }
        if (typeof type === 'string') {
            renderHostElement(request, task, type, props);
            return;
        }
        switch(type){
            // TODO: LegacyHidden acts the same as a fragment. This only works
            // because we currently assume that every instance of LegacyHidden is
            // accompanied by a host component wrapper. In the hidden mode, the host
            // component is given a `hidden` attribute, which ensures that the
            // initial HTML is not visible. To support the use of LegacyHidden as a
            // true fragment, without an extra DOM node, we would have to hide the
            // initial HTML in some other way.
            // TODO: Add REACT_OFFSCREEN_TYPE here too with the same capability.
            case REACT_LEGACY_HIDDEN_TYPE:
            case REACT_DEBUG_TRACING_MODE_TYPE:
            case REACT_STRICT_MODE_TYPE:
            case REACT_PROFILER_TYPE:
            case REACT_FRAGMENT_TYPE:
                renderNodeDestructive(request, task, props.children);
                return;
            case REACT_SUSPENSE_LIST_TYPE:
                pushBuiltInComponentStackInDEV(task, 'SuspenseList'); // TODO: SuspenseList should control the boundaries.
                renderNodeDestructive(request, task, props.children);
                popComponentStackInDEV(task);
                return;
            case REACT_SCOPE_TYPE:
                throw new Error('ReactDOMServer does not yet support scope components.');
            // eslint-disable-next-line-no-fallthrough
            case REACT_SUSPENSE_TYPE:
                renderSuspenseBoundary(request, task, props);
                return;
        }
        if (typeof type === 'object' && type !== null) switch(type.$$typeof){
            case REACT_FORWARD_REF_TYPE:
                renderForwardRef(request, task, type, props, ref);
                return;
            case REACT_MEMO_TYPE:
                renderMemo(request, task, type, props, ref);
                return;
            case REACT_PROVIDER_TYPE:
                renderContextProvider(request, task, type, props);
                return;
            case REACT_CONTEXT_TYPE:
                renderContextConsumer(request, task, type, props);
                return;
            case REACT_LAZY_TYPE:
                renderLazyComponent(request, task, type, props);
                return;
        }
        var info = '';
        if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
        throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (type == null ? type : typeof type) + "." + info));
    }
    function validateIterable(iterable, iteratorFn) {
        // We don't support rendering Generators because it's a mutation.
        // See https://github.com/facebook/react/issues/12995
        if (typeof Symbol === 'function' && // $FlowFixMe Flow doesn't know about toStringTag
        iterable[Symbol.toStringTag] === 'Generator') {
            if (!didWarnAboutGenerators) error("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers.");
            didWarnAboutGenerators = true;
        } // Warn about using Maps as children
        if (iterable.entries === iteratorFn) {
            if (!didWarnAboutMaps) error("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
            didWarnAboutMaps = true;
        }
    }
    function renderNodeDestructive(request, task, node) {
        // In Dev we wrap renderNodeDestructiveImpl in a try / catch so we can capture
        // a component stack at the right place in the tree. We don't do this in renderNode
        // becuase it is not called at every layer of the tree and we may lose frames
        try {
            return renderNodeDestructiveImpl(request, task, node);
        } catch (x) {
            if (typeof x === 'object' && x !== null && typeof x.then === 'function') ;
            else // This is an error, stash the component stack if it is null.
            lastBoundaryErrorComponentStackDev = lastBoundaryErrorComponentStackDev !== null ? lastBoundaryErrorComponentStackDev : getCurrentStackInDEV();
             // rethrow so normal suspense logic can handle thrown value accordingly
            throw x;
        }
    } // This function by it self renders a node and consumes the task by mutating it
    // to update the current execution state.
    function renderNodeDestructiveImpl(request, task, node) {
        // Stash the node we're working on. We'll pick up from this task in case
        // something suspends.
        task.node = node; // Handle object types
        if (typeof node === 'object' && node !== null) {
            switch(node.$$typeof){
                case REACT_ELEMENT_TYPE:
                    var element = node;
                    var type = element.type;
                    var props = element.props;
                    var ref = element.ref;
                    renderElement(request, task, type, props, ref);
                    return;
                case REACT_PORTAL_TYPE:
                    throw new Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
                // eslint-disable-next-line-no-fallthrough
                case REACT_LAZY_TYPE:
                    var lazyNode = node;
                    var payload = lazyNode._payload;
                    var init = lazyNode._init;
                    var resolvedNode;
                    try {
                        resolvedNode = init(payload);
                    } catch (x) {
                        if (typeof x === 'object' && x !== null && typeof x.then === 'function') // this Lazy initializer is suspending. push a temporary frame onto the stack so it can be
                        // popped off in spawnNewSuspendedTask. This aligns stack behavior between Lazy in element position
                        // vs Component position. We do not want the frame for Errors so we exclusively do this in
                        // the wakeable branch
                        pushBuiltInComponentStackInDEV(task, 'Lazy');
                        throw x;
                    }
                    renderNodeDestructive(request, task, resolvedNode);
                    return;
            }
            if (isArray(node)) {
                renderChildrenArray(request, task, node);
                return;
            }
            var iteratorFn = getIteratorFn(node);
            if (iteratorFn) {
                validateIterable(node, iteratorFn);
                var iterator = iteratorFn.call(node);
                if (iterator) {
                    // We need to know how many total children are in this set, so that we
                    // can allocate enough id slots to acommodate them. So we must exhaust
                    // the iterator before we start recursively rendering the children.
                    // TODO: This is not great but I think it's inherent to the id
                    // generation algorithm.
                    var step = iterator.next(); // If there are not entries, we need to push an empty so we start by checking that.
                    if (!step.done) {
                        var children = [];
                        do {
                            children.push(step.value);
                            step = iterator.next();
                        }while (!step.done)
                        renderChildrenArray(request, task, children);
                        return;
                    }
                    return;
                }
            }
            var childString = Object.prototype.toString.call(node);
            throw new Error("Objects are not valid as a React child (found: " + (childString === '[object Object]' ? 'object with keys {' + Object.keys(node).join(', ') + '}' : childString) + "). " + 'If you meant to render a collection of children, use an array ' + 'instead.');
        }
        if (typeof node === 'string') {
            var segment = task.blockedSegment;
            segment.lastPushedText = pushTextInstance$1(task.blockedSegment.chunks, node, request.responseState, segment.lastPushedText);
            return;
        }
        if (typeof node === 'number') {
            var _segment = task.blockedSegment;
            _segment.lastPushedText = pushTextInstance$1(task.blockedSegment.chunks, '' + node, request.responseState, _segment.lastPushedText);
            return;
        }
        if (typeof node === 'function') error("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
    }
    function renderChildrenArray(request, task, children) {
        var totalChildren = children.length;
        for(var i = 0; i < totalChildren; i++){
            var prevTreeContext = task.treeContext;
            task.treeContext = pushTreeContext(prevTreeContext, totalChildren, i);
            try {
                // We need to use the non-destructive form so that we can safely pop back
                // up and render the sibling if something suspends.
                renderNode(request, task, children[i]);
            } finally{
                task.treeContext = prevTreeContext;
            }
        }
    }
    function spawnNewSuspendedTask(request, task, x) {
        // Something suspended, we'll need to create a new segment and resolve it later.
        var segment = task.blockedSegment;
        var insertionIndex = segment.chunks.length;
        var newSegment = createPendingSegment(request, insertionIndex, null, segment.formatContext, segment.lastPushedText, true);
        segment.children.push(newSegment); // Reset lastPushedText for current Segment since the new Segment "consumed" it
        segment.lastPushedText = false;
        var newTask = createTask(request, task.node, task.blockedBoundary, newSegment, task.abortSet, task.legacyContext, task.context, task.treeContext);
        if (task.componentStack !== null) // We pop one task off the stack because the node that suspended will be tried again,
        // which will add it back onto the stack.
        newTask.componentStack = task.componentStack.parent;
        var ping = newTask.ping;
        x.then(ping, ping);
    } // This is a non-destructive form of rendering a node. If it suspends it spawns
    // a new task and restores the context of this task to what it was before.
    function renderNode(request, task, node) {
        // TODO: Store segment.children.length here and reset it in case something
        // suspended partially through writing something.
        // Snapshot the current context in case something throws to interrupt the
        // process.
        var previousFormatContext = task.blockedSegment.formatContext;
        var previousLegacyContext = task.legacyContext;
        var previousContext = task.context;
        var previousComponentStack = null;
        previousComponentStack = task.componentStack;
        try {
            return renderNodeDestructive(request, task, node);
        } catch (x) {
            resetHooksState();
            if (typeof x === 'object' && x !== null && typeof x.then === 'function') {
                spawnNewSuspendedTask(request, task, x); // Restore the context. We assume that this will be restored by the inner
                // functions in case nothing throws so we don't use "finally" here.
                task.blockedSegment.formatContext = previousFormatContext;
                task.legacyContext = previousLegacyContext;
                task.context = previousContext; // Restore all active ReactContexts to what they were before.
                switchContext(previousContext);
                task.componentStack = previousComponentStack;
                return;
            } else {
                // Restore the context. We assume that this will be restored by the inner
                // functions in case nothing throws so we don't use "finally" here.
                task.blockedSegment.formatContext = previousFormatContext;
                task.legacyContext = previousLegacyContext;
                task.context = previousContext; // Restore all active ReactContexts to what they were before.
                switchContext(previousContext);
                task.componentStack = previousComponentStack;
                // Let's terminate the rest of the tree and don't render any siblings.
                throw x;
            }
        }
    }
    function erroredTask(request, boundary, segment, error) {
        // Report the error to a global handler.
        var errorDigest = logRecoverableError(request, error);
        if (boundary === null) fatalError(request, error);
        else {
            boundary.pendingTasks--;
            if (!boundary.forceClientRender) {
                boundary.forceClientRender = true;
                boundary.errorDigest = errorDigest;
                captureBoundaryErrorDetailsDev(boundary, error);
                // so we can flush it, if the parent already flushed.
                if (boundary.parentFlushed) // We don't have a preference where in the queue this goes since it's likely
                // to error on the client anyway. However, intentionally client-rendered
                // boundaries should be flushed earlier so that they can start on the client.
                // We reuse the same queue for errors.
                request.clientRenderedBoundaries.push(boundary);
            }
        }
        request.allPendingTasks--;
        if (request.allPendingTasks === 0) {
            var onAllReady = request.onAllReady;
            onAllReady();
        }
    }
    function abortTaskSoft(task) {
        // This aborts task without aborting the parent boundary that it blocks.
        // It's used for when we didn't need this task to complete the tree.
        // If task was needed, then it should use abortTask instead.
        var request = this;
        var boundary = task.blockedBoundary;
        var segment = task.blockedSegment;
        segment.status = ABORTED;
        finishedTask(request, boundary, segment);
    }
    function abortTask(task, request, reason) {
        // This aborts the task and aborts the parent that it blocks, putting it into
        // client rendered mode.
        var boundary = task.blockedBoundary;
        var segment = task.blockedSegment;
        segment.status = ABORTED;
        if (boundary === null) {
            request.allPendingTasks--; // We didn't complete the root so we have nothing to show. We can close
            // the request;
            if (request.status !== CLOSED) {
                request.status = CLOSED;
                if (request.destination !== null) close(request.destination);
            }
        } else {
            boundary.pendingTasks--;
            if (!boundary.forceClientRender) {
                boundary.forceClientRender = true;
                var _error = reason === undefined ? new Error('The render was aborted by the server without a reason.') : reason;
                boundary.errorDigest = request.onError(_error);
                var errorPrefix = 'The server did not finish this Suspense boundary: ';
                if (_error && typeof _error.message === 'string') _error = errorPrefix + _error.message;
                else // eslint-disable-next-line react-internal/safe-string-coercion
                _error = errorPrefix + String(_error);
                var previousTaskInDev = currentTaskInDEV;
                currentTaskInDEV = task;
                try {
                    captureBoundaryErrorDetailsDev(boundary, _error);
                } finally{
                    currentTaskInDEV = previousTaskInDev;
                }
                if (boundary.parentFlushed) request.clientRenderedBoundaries.push(boundary);
            } // If this boundary was still pending then we haven't already cancelled its fallbacks.
            // We'll need to abort the fallbacks, which will also error that parent boundary.
            boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {
                return abortTask(fallbackTask, request, reason);
            });
            boundary.fallbackAbortableTasks.clear();
            request.allPendingTasks--;
            if (request.allPendingTasks === 0) {
                var onAllReady = request.onAllReady;
                onAllReady();
            }
        }
    }
    function queueCompletedSegment(boundary, segment) {
        if (segment.chunks.length === 0 && segment.children.length === 1 && segment.children[0].boundary === null) {
            // This is an empty segment. There's nothing to write, so we can instead transfer the ID
            // to the child. That way any existing references point to the child.
            var childSegment = segment.children[0];
            childSegment.id = segment.id;
            childSegment.parentFlushed = true;
            if (childSegment.status === COMPLETED) queueCompletedSegment(boundary, childSegment);
        } else {
            var completedSegments = boundary.completedSegments;
            completedSegments.push(segment);
        }
    }
    function finishedTask(request, boundary, segment) {
        if (boundary === null) {
            if (segment.parentFlushed) {
                if (request.completedRootSegment !== null) throw new Error('There can only be one root segment. This is a bug in React.');
                request.completedRootSegment = segment;
            }
            request.pendingRootTasks--;
            if (request.pendingRootTasks === 0) {
                // We have completed the shell so the shell can't error anymore.
                request.onShellError = noop$1;
                var onShellReady = request.onShellReady;
                onShellReady();
            }
        } else {
            boundary.pendingTasks--;
            if (boundary.forceClientRender) ;
            else if (boundary.pendingTasks === 0) {
                // This must have been the last segment we were waiting on. This boundary is now complete.
                if (segment.parentFlushed) // Our parent segment already flushed, so we need to schedule this segment to be emitted.
                // If it is a segment that was aborted, we'll write other content instead so we don't need
                // to emit it.
                {
                    if (segment.status === COMPLETED) queueCompletedSegment(boundary, segment);
                }
                if (boundary.parentFlushed) // The segment might be part of a segment that didn't flush yet, but if the boundary's
                // parent flushed, we need to schedule the boundary to be emitted.
                request.completedBoundaries.push(boundary);
                 // We can now cancel any pending task on the fallback since we won't need to show it anymore.
                // This needs to happen after we read the parentFlushed flags because aborting can finish
                // work which can trigger user code, which can start flushing, which can change those flags.
                boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request);
                boundary.fallbackAbortableTasks.clear();
            } else {
                if (segment.parentFlushed) // Our parent already flushed, so we need to schedule this segment to be emitted.
                // If it is a segment that was aborted, we'll write other content instead so we don't need
                // to emit it.
                {
                    if (segment.status === COMPLETED) {
                        queueCompletedSegment(boundary, segment);
                        var completedSegments = boundary.completedSegments;
                        if (completedSegments.length === 1) // This is the first time since we last flushed that we completed anything.
                        // We can schedule this boundary to emit its partially completed segments early
                        // in case the parent has already been flushed.
                        {
                            if (boundary.parentFlushed) request.partialBoundaries.push(boundary);
                        }
                    }
                }
            }
        }
        request.allPendingTasks--;
        if (request.allPendingTasks === 0) {
            // This needs to be called at the very end so that we can synchronously write the result
            // in the callback if needed.
            var onAllReady = request.onAllReady;
            onAllReady();
        }
    }
    function retryTask(request, task) {
        var segment = task.blockedSegment;
        if (segment.status !== PENDING) // We completed this by other means before we had a chance to retry it.
        return;
         // We restore the context to what it was when we suspended.
        // We don't restore it after we leave because it's likely that we'll end up
        // needing a very similar context soon again.
        switchContext(task.context);
        var prevTaskInDEV = null;
        prevTaskInDEV = currentTaskInDEV;
        currentTaskInDEV = task;
        try {
            // We call the destructive form that mutates this task. That way if something
            // suspends again, we can reuse the same task instead of spawning a new one.
            renderNodeDestructive(request, task, task.node);
            pushSegmentFinale$1(segment.chunks, request.responseState, segment.lastPushedText, segment.textEmbedded);
            task.abortSet.delete(task);
            segment.status = COMPLETED;
            finishedTask(request, task.blockedBoundary, segment);
        } catch (x) {
            resetHooksState();
            if (typeof x === 'object' && x !== null && typeof x.then === 'function') {
                // Something suspended again, let's pick it back up later.
                var ping = task.ping;
                x.then(ping, ping);
            } else {
                task.abortSet.delete(task);
                segment.status = ERRORED;
                erroredTask(request, task.blockedBoundary, segment, x);
            }
        } finally{
            currentTaskInDEV = prevTaskInDEV;
        }
    }
    function performWork(request) {
        if (request.status === CLOSED) return;
        var prevContext = getActiveContext();
        var prevDispatcher = ReactCurrentDispatcher$1.current;
        ReactCurrentDispatcher$1.current = Dispatcher;
        var prevGetCurrentStackImpl;
        prevGetCurrentStackImpl = ReactDebugCurrentFrame$1.getCurrentStack;
        ReactDebugCurrentFrame$1.getCurrentStack = getCurrentStackInDEV;
        var prevResponseState = currentResponseState;
        setCurrentResponseState(request.responseState);
        try {
            var pingedTasks = request.pingedTasks;
            var i;
            for(i = 0; i < pingedTasks.length; i++){
                var task = pingedTasks[i];
                retryTask(request, task);
            }
            pingedTasks.splice(0, i);
            if (request.destination !== null) flushCompletedQueues(request, request.destination);
        } catch (error) {
            logRecoverableError(request, error);
            fatalError(request, error);
        } finally{
            setCurrentResponseState(prevResponseState);
            ReactCurrentDispatcher$1.current = prevDispatcher;
            ReactDebugCurrentFrame$1.getCurrentStack = prevGetCurrentStackImpl;
            if (prevDispatcher === Dispatcher) // This means that we were in a reentrant work loop. This could happen
            // in a renderer that supports synchronous work like renderToString,
            // when it's called from within another renderer.
            // Normally we don't bother switching the contexts to their root/default
            // values when leaving because we'll likely need the same or similar
            // context again. However, when we're inside a synchronous loop like this
            // we'll to restore the context to what it was before returning.
            switchContext(prevContext);
        }
    }
    function flushSubtree(request, destination, segment) {
        segment.parentFlushed = true;
        switch(segment.status){
            case PENDING:
                // We're emitting a placeholder for this segment to be filled in later.
                // Therefore we'll need to assign it an ID - to refer to it by.
                var segmentID = segment.id = request.nextSegmentId++; // When this segment finally completes it won't be embedded in text since it will flush separately
                segment.lastPushedText = false;
                segment.textEmbedded = false;
                return writePlaceholder(destination, request.responseState, segmentID);
            case COMPLETED:
                segment.status = FLUSHED;
                var r = true;
                var chunks = segment.chunks;
                var chunkIdx = 0;
                var children = segment.children;
                for(var childIdx = 0; childIdx < children.length; childIdx++){
                    var nextChild = children[childIdx]; // Write all the chunks up until the next child.
                    for(; chunkIdx < nextChild.index; chunkIdx++)writeChunk(destination, chunks[chunkIdx]);
                    r = flushSegment(request, destination, nextChild);
                } // Finally just write all the remaining chunks
                for(; chunkIdx < chunks.length - 1; chunkIdx++)writeChunk(destination, chunks[chunkIdx]);
                if (chunkIdx < chunks.length) r = writeChunkAndReturn(destination, chunks[chunkIdx]);
                return r;
            default:
                throw new Error('Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.');
        }
    }
    function flushSegment(request, destination, segment) {
        var boundary = segment.boundary;
        if (boundary === null) // Not a suspense boundary.
        return flushSubtree(request, destination, segment);
        boundary.parentFlushed = true; // This segment is a Suspense boundary. We need to decide whether to
        // emit the content or the fallback now.
        if (boundary.forceClientRender) {
            // Emit a client rendered suspense boundary wrapper.
            // We never queue the inner boundary so we'll never emit its content or partial segments.
            writeStartClientRenderedSuspenseBoundary$1(destination, request.responseState, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack); // Flush the fallback.
            flushSubtree(request, destination, segment);
            return writeEndClientRenderedSuspenseBoundary$1(destination, request.responseState);
        } else if (boundary.pendingTasks > 0) {
            // This boundary is still loading. Emit a pending suspense boundary wrapper.
            // Assign an ID to refer to the future content by.
            boundary.rootSegmentID = request.nextSegmentId++;
            if (boundary.completedSegments.length > 0) // If this is at least partially complete, we can queue it to be partially emitted early.
            request.partialBoundaries.push(boundary);
             /// This is the first time we should have referenced this ID.
            var id = boundary.id = assignSuspenseBoundaryID(request.responseState);
            writeStartPendingSuspenseBoundary(destination, request.responseState, id); // Flush the fallback.
            flushSubtree(request, destination, segment);
            return writeEndPendingSuspenseBoundary(destination, request.responseState);
        } else if (boundary.byteSize > request.progressiveChunkSize) {
            // This boundary is large and will be emitted separately so that we can progressively show
            // other content. We add it to the queue during the flush because we have to ensure that
            // the parent flushes first so that there's something to inject it into.
            // We also have to make sure that it's emitted into the queue in a deterministic slot.
            // I.e. we can't insert it here when it completes.
            // Assign an ID to refer to the future content by.
            boundary.rootSegmentID = request.nextSegmentId++;
            request.completedBoundaries.push(boundary); // Emit a pending rendered suspense boundary wrapper.
            writeStartPendingSuspenseBoundary(destination, request.responseState, boundary.id); // Flush the fallback.
            flushSubtree(request, destination, segment);
            return writeEndPendingSuspenseBoundary(destination, request.responseState);
        } else {
            // We can inline this boundary's content as a complete boundary.
            writeStartCompletedSuspenseBoundary$1(destination, request.responseState);
            var completedSegments = boundary.completedSegments;
            if (completedSegments.length !== 1) throw new Error('A previously unvisited boundary must have exactly one root segment. This is a bug in React.');
            var contentSegment = completedSegments[0];
            flushSegment(request, destination, contentSegment);
            return writeEndCompletedSuspenseBoundary$1(destination, request.responseState);
        }
    }
    function flushClientRenderedBoundary(request, destination, boundary) {
        return writeClientRenderBoundaryInstruction(destination, request.responseState, boundary.id, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack);
    }
    function flushSegmentContainer(request, destination, segment) {
        writeStartSegment(destination, request.responseState, segment.formatContext, segment.id);
        flushSegment(request, destination, segment);
        return writeEndSegment(destination, segment.formatContext);
    }
    function flushCompletedBoundary(request, destination, boundary) {
        var completedSegments = boundary.completedSegments;
        var i = 0;
        for(; i < completedSegments.length; i++){
            var segment = completedSegments[i];
            flushPartiallyCompletedSegment(request, destination, boundary, segment);
        }
        completedSegments.length = 0;
        return writeCompletedBoundaryInstruction(destination, request.responseState, boundary.id, boundary.rootSegmentID);
    }
    function flushPartialBoundary(request, destination, boundary) {
        var completedSegments = boundary.completedSegments;
        var i = 0;
        for(; i < completedSegments.length; i++){
            var segment = completedSegments[i];
            if (!flushPartiallyCompletedSegment(request, destination, boundary, segment)) {
                i++;
                completedSegments.splice(0, i); // Only write as much as the buffer wants. Something higher priority
                // might want to write later.
                return false;
            }
        }
        completedSegments.splice(0, i);
        return true;
    }
    function flushPartiallyCompletedSegment(request, destination, boundary, segment) {
        if (segment.status === FLUSHED) // We've already flushed this inline.
        return true;
        var segmentID = segment.id;
        if (segmentID === -1) {
            // This segment wasn't previously referred to. This happens at the root of
            // a boundary. We make kind of a leap here and assume this is the root.
            var rootSegmentID = segment.id = boundary.rootSegmentID;
            if (rootSegmentID === -1) throw new Error('A root segment ID must have been assigned by now. This is a bug in React.');
            return flushSegmentContainer(request, destination, segment);
        } else {
            flushSegmentContainer(request, destination, segment);
            return writeCompletedSegmentInstruction(destination, request.responseState, segmentID);
        }
    }
    function flushCompletedQueues(request, destination) {
        try {
            // The structure of this is to go through each queue one by one and write
            // until the sink tells us to stop. When we should stop, we still finish writing
            // that item fully and then yield. At that point we remove the already completed
            // items up until the point we completed them.
            // TODO: Emit preloading.
            // TODO: It's kind of unfortunate to keep checking this array after we've already
            // emitted the root.
            var completedRootSegment = request.completedRootSegment;
            if (completedRootSegment !== null && request.pendingRootTasks === 0) {
                flushSegment(request, destination, completedRootSegment);
                request.completedRootSegment = null;
                writeCompletedRoot(destination, request.responseState);
            } // We emit client rendering instructions for already emitted boundaries first.
            // This is so that we can signal to the client to start client rendering them as
            // soon as possible.
            var clientRenderedBoundaries = request.clientRenderedBoundaries;
            var i;
            for(i = 0; i < clientRenderedBoundaries.length; i++){
                var boundary = clientRenderedBoundaries[i];
                if (!flushClientRenderedBoundary(request, destination, boundary)) {
                    request.destination = null;
                    i++;
                    clientRenderedBoundaries.splice(0, i);
                    return;
                }
            }
            clientRenderedBoundaries.splice(0, i); // Next we emit any complete boundaries. It's better to favor boundaries
            // that are completely done since we can actually show them, than it is to emit
            // any individual segments from a partially complete boundary.
            var completedBoundaries = request.completedBoundaries;
            for(i = 0; i < completedBoundaries.length; i++){
                var _boundary = completedBoundaries[i];
                if (!flushCompletedBoundary(request, destination, _boundary)) {
                    request.destination = null;
                    i++;
                    completedBoundaries.splice(0, i);
                    return;
                }
            }
            completedBoundaries.splice(0, i); // Allow anything written so far to flush to the underlying sink before
            // we continue with lower priorities.
            completeWriting(destination);
            beginWriting(destination); // TODO: Here we'll emit data used by hydration.
            // Next we emit any segments of any boundaries that are partially complete
            // but not deeply complete.
            var partialBoundaries = request.partialBoundaries;
            for(i = 0; i < partialBoundaries.length; i++){
                var _boundary2 = partialBoundaries[i];
                if (!flushPartialBoundary(request, destination, _boundary2)) {
                    request.destination = null;
                    i++;
                    partialBoundaries.splice(0, i);
                    return;
                }
            }
            partialBoundaries.splice(0, i); // Next we check the completed boundaries again. This may have had
            // boundaries added to it in case they were too larged to be inlined.
            // New ones might be added in this loop.
            var largeBoundaries = request.completedBoundaries;
            for(i = 0; i < largeBoundaries.length; i++){
                var _boundary3 = largeBoundaries[i];
                if (!flushCompletedBoundary(request, destination, _boundary3)) {
                    request.destination = null;
                    i++;
                    largeBoundaries.splice(0, i);
                    return;
                }
            }
            largeBoundaries.splice(0, i);
        } finally{
            if (request.allPendingTasks === 0 && request.pingedTasks.length === 0 && request.clientRenderedBoundaries.length === 0 && request.completedBoundaries.length === 0 // We don't need to check any partially completed segments because
            ) {
                if (request.abortableTasks.size !== 0) error('There was still abortable task at the root when we closed. This is a bug in React.');
                close(destination);
            }
        }
    }
    function startWork(request) {
        scheduleWork(function() {
            return performWork(request);
        });
    }
    function startFlowing(request, destination) {
        if (request.status === CLOSING) {
            request.status = CLOSED;
            closeWithError(destination, request.fatalError);
            return;
        }
        if (request.status === CLOSED) return;
        if (request.destination !== null) // We're already flowing.
        return;
        request.destination = destination;
        try {
            flushCompletedQueues(request, destination);
        } catch (error) {
            logRecoverableError(request, error);
            fatalError(request, error);
        }
    } // This is called to early terminate a request. It puts all pending boundaries in client rendered state.
    function abort(request, reason) {
        try {
            var abortableTasks = request.abortableTasks;
            abortableTasks.forEach(function(task) {
                return abortTask(task, request, reason);
            });
            abortableTasks.clear();
            if (request.destination !== null) flushCompletedQueues(request, request.destination);
        } catch (error) {
            logRecoverableError(request, error);
            fatalError(request, error);
        }
    }
    function onError() {}
    function renderToStringImpl(children, options, generateStaticMarkup, abortReason) {
        var didFatal = false;
        var fatalError = null;
        var result = '';
        var destination = {
            push: function(chunk) {
                if (chunk !== null) result += chunk;
                return true;
            },
            destroy: function(error) {
                didFatal = true;
                fatalError = error;
            }
        };
        var readyToStream = false;
        function onShellReady() {
            readyToStream = true;
        }
        var request = createRequest(children, createResponseState$1(generateStaticMarkup, options ? options.identifierPrefix : undefined), createRootFormatContext(), Infinity, onError, undefined, onShellReady, undefined, undefined);
        startWork(request); // If anything suspended and is still pending, we'll abort it before writing.
        // That way we write only client-rendered boundaries from the start.
        abort(request, abortReason);
        startFlowing(request, destination);
        if (didFatal) throw fatalError;
        if (!readyToStream) // Note: This error message is the one we use on the client. It doesn't
        // really make sense here. But this is the legacy server renderer, anyway.
        // We're going to delete it soon.
        throw new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
        return result;
    }
    function renderToString(children, options) {
        return renderToStringImpl(children, options, false, 'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
    }
    function renderToStaticMarkup(children, options) {
        return renderToStringImpl(children, options, true, 'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
    }
    function renderToNodeStream() {
        throw new Error("ReactDOMServer.renderToNodeStream(): The streaming API is not available in the browser. Use ReactDOMServer.renderToString() instead.");
    }
    function renderToStaticNodeStream() {
        throw new Error("ReactDOMServer.renderToStaticNodeStream(): The streaming API is not available in the browser. Use ReactDOMServer.renderToStaticMarkup() instead.");
    }
    exports.renderToNodeStream = renderToNodeStream;
    exports.renderToStaticMarkup = renderToStaticMarkup;
    exports.renderToStaticNodeStream = renderToStaticNodeStream;
    exports.renderToString = renderToString;
    exports.version = ReactVersion;
})();

},
"node_modules/react-dom/cjs/react-dom-server.browser.development.js": function (module, exports, __mako_require__){
/**
 * @license React
 * react-dom-server.browser.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 'use strict';
(function() {
    'use strict';
    var React = __mako_require__("node_modules/react/index.js");
    var ReactVersion = '18.3.1';
    var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    // by calls to these methods by a Babel plugin.
    //
    // In PROD (or in packages without access to React internals),
    // they are left as they are instead.
    function warn(format) {
        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)args[_key - 1] = arguments[_key];
        printWarning('warn', format, args);
    }
    function error(format) {
        for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++)args[_key2 - 1] = arguments[_key2];
        printWarning('error', format, args);
    }
    function printWarning(level, format, args) {
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        var stack = ReactDebugCurrentFrame.getStackAddendum();
        if (stack !== '') {
            format += '%s';
            args = args.concat([
                stack
            ]);
        } // eslint-disable-next-line react-internal/safe-string-coercion
        var argsWithFormat = args.map(function(item) {
            return String(item);
        }); // Careful: RN currently depends on this prefix
        argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
        // breaks IE9: https://github.com/facebook/react/issues/13610
        // eslint-disable-next-line react-internal/no-production-logging
        Function.prototype.apply.call(console[level], console, argsWithFormat);
    }
    function scheduleWork(callback) {
        callback();
    }
    var VIEW_SIZE = 512;
    var currentView = null;
    var writtenBytes = 0;
    function beginWriting(destination) {
        currentView = new Uint8Array(VIEW_SIZE);
        writtenBytes = 0;
    }
    function writeChunk(destination, chunk) {
        if (chunk.length === 0) return;
        if (chunk.length > VIEW_SIZE) {
            // this chunk may overflow a single view which implies it was not
            // one that is cached by the streaming renderer. We will enqueu
            // it directly and expect it is not re-used
            if (writtenBytes > 0) {
                destination.enqueue(new Uint8Array(currentView.buffer, 0, writtenBytes));
                currentView = new Uint8Array(VIEW_SIZE);
                writtenBytes = 0;
            }
            destination.enqueue(chunk);
            return;
        }
        var bytesToWrite = chunk;
        var allowableBytes = currentView.length - writtenBytes;
        if (allowableBytes < bytesToWrite.length) {
            // this chunk would overflow the current view. We enqueue a full view
            // and start a new view with the remaining chunk
            if (allowableBytes === 0) // the current view is already full, send it
            destination.enqueue(currentView);
            else {
                // fill up the current view and apply the remaining chunk bytes
                // to a new view.
                currentView.set(bytesToWrite.subarray(0, allowableBytes), writtenBytes); // writtenBytes += allowableBytes; // this can be skipped because we are going to immediately reset the view
                destination.enqueue(currentView);
                bytesToWrite = bytesToWrite.subarray(allowableBytes);
            }
            currentView = new Uint8Array(VIEW_SIZE);
            writtenBytes = 0;
        }
        currentView.set(bytesToWrite, writtenBytes);
        writtenBytes += bytesToWrite.length;
    }
    function writeChunkAndReturn(destination, chunk) {
        writeChunk(destination, chunk); // in web streams there is no backpressure so we can alwas write more
        return true;
    }
    function completeWriting(destination) {
        if (currentView && writtenBytes > 0) {
            destination.enqueue(new Uint8Array(currentView.buffer, 0, writtenBytes));
            currentView = null;
            writtenBytes = 0;
        }
    }
    function close(destination) {
        destination.close();
    }
    var textEncoder = new TextEncoder();
    function stringToChunk(content) {
        return textEncoder.encode(content);
    }
    function stringToPrecomputedChunk(content) {
        return textEncoder.encode(content);
    }
    function closeWithError(destination, error) {
        if (typeof destination.error === 'function') // $FlowFixMe: This is an Error object or the destination accepts other types.
        destination.error(error);
        else // Earlier implementations doesn't support this method. In that environment you're
        // supposed to throw from a promise returned but we don't return a promise in our
        // approach. We could fork this implementation but this is environment is an edge
        // case to begin with. It's even less common to run this in an older environment.
        // Even then, this is not where errors are supposed to happen and they get reported
        // to a global callback in addition to this anyway. So it's fine just to close this.
        destination.close();
    }
    /*
 * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol
 * and Temporal.* types. See https://github.com/facebook/react/pull/22064.
 *
 * The functions in this module will throw an easier-to-understand,
 * easier-to-debug exception with a clear errors message message explaining the
 * problem. (Instead of a confusing exception thrown inside the implementation
 * of the `value` object).
 */ // $FlowFixMe only called in DEV, so void return is not possible.
    function typeName(value) {
        // toStringTag is needed for namespaced types like Temporal.Instant
        var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;
        var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';
        return type;
    } // $FlowFixMe only called in DEV, so void return is not possible.
    function willCoercionThrow(value) {
        try {
            testStringCoercion(value);
            return false;
        } catch (e) {
            return true;
        }
    }
    function testStringCoercion(value) {
        // If you ended up here by following an exception call stack, here's what's
        // happened: you supplied an object or symbol value to React (as a prop, key,
        // DOM attribute, CSS property, string ref, etc.) and when React tried to
        // coerce it to a string using `'' + value`, an exception was thrown.
        //
        // The most common types that will cause this exception are `Symbol` instances
        // and Temporal objects like `Temporal.Instant`. But any object that has a
        // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this
        // exception. (Library authors do this to prevent users from using built-in
        // numeric operators like `+` or comparison operators like `>=` because custom
        // methods are needed to perform accurate arithmetic or comparison.)
        //
        // To fix the problem, coerce this object or symbol value to a string before
        // passing it to React. The most reliable way is usually `String(value)`.
        //
        // To find which value is throwing, check the browser or debugger console.
        // Before this exception was thrown, there should be `console.error` output
        // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the
        // problem and how that type was used: key, atrribute, input value prop, etc.
        // In most cases, this console output also shows the component and its
        // ancestor components where the exception happened.
        //
        // eslint-disable-next-line react-internal/safe-string-coercion
        return '' + value;
    }
    function checkAttributeStringCoercion(value, attributeName) {
        if (willCoercionThrow(value)) {
            error("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", attributeName, typeName(value));
            return testStringCoercion(value); // throw (to help callers find troubleshooting comments)
        }
    }
    function checkCSSPropertyStringCoercion(value, propName) {
        if (willCoercionThrow(value)) {
            error("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value));
            return testStringCoercion(value); // throw (to help callers find troubleshooting comments)
        }
    }
    function checkHtmlStringCoercion(value) {
        if (willCoercionThrow(value)) {
            error("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
            return testStringCoercion(value); // throw (to help callers find troubleshooting comments)
        }
    }
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    // A reserved attribute.
    // It is handled by React separately and shouldn't be written to the DOM.
    var RESERVED = 0; // A simple string attribute.
    // Attributes that aren't in the filter are presumed to have this type.
    var STRING = 1; // A string attribute that accepts booleans in React. In HTML, these are called
    // "enumerated" attributes with "true" and "false" as possible values.
    // When true, it should be set to a "true" string.
    // When false, it should be set to a "false" string.
    var BOOLEANISH_STRING = 2; // A real boolean attribute.
    // When true, it should be present (set either to an empty string or its name).
    // When false, it should be omitted.
    var BOOLEAN = 3; // An attribute that can be used as a flag as well as with a value.
    // When true, it should be present (set either to an empty string or its name).
    // When false, it should be omitted.
    // For any other value, should be present with that value.
    var OVERLOADED_BOOLEAN = 4; // An attribute that must be numeric or parse as a numeric.
    // When falsy, it should be removed.
    var NUMERIC = 5; // An attribute that must be positive numeric or parse as a positive numeric.
    // When falsy, it should be removed.
    var POSITIVE_NUMERIC = 6;
    /* eslint-disable max-len */ var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
    /* eslint-enable max-len */ var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
    var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + ATTRIBUTE_NAME_START_CHAR + '][' + ATTRIBUTE_NAME_CHAR + ']*$');
    var illegalAttributeNameCache = {};
    var validatedAttributeNameCache = {};
    function isAttributeNameSafe(attributeName) {
        if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) return true;
        if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) return false;
        if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
            validatedAttributeNameCache[attributeName] = true;
            return true;
        }
        illegalAttributeNameCache[attributeName] = true;
        error('Invalid attribute name: `%s`', attributeName);
        return false;
    }
    function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {
        if (propertyInfo !== null && propertyInfo.type === RESERVED) return false;
        switch(typeof value){
            case 'function':
            case 'symbol':
                // eslint-disable-line
                return true;
            case 'boolean':
                if (isCustomComponentTag) return false;
                if (propertyInfo !== null) return !propertyInfo.acceptsBooleans;
                else {
                    var prefix = name.toLowerCase().slice(0, 5);
                    return prefix !== 'data-' && prefix !== 'aria-';
                }
            default:
                return false;
        }
    }
    function getPropertyInfo(name) {
        return properties.hasOwnProperty(name) ? properties[name] : null;
    }
    function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL, removeEmptyString) {
        this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
        this.attributeName = attributeName;
        this.attributeNamespace = attributeNamespace;
        this.mustUseProperty = mustUseProperty;
        this.propertyName = name;
        this.type = type;
        this.sanitizeURL = sanitizeURL;
        this.removeEmptyString = removeEmptyString;
    } // When adding attributes to this list, be sure to also add them to
    // the `possibleStandardNames` module to ensure casing and incorrect
    // name warnings.
    var properties = {}; // These props are reserved by React. They shouldn't be written to the DOM.
    var reservedProps = [
        'children',
        'dangerouslySetInnerHTML',
        // elements (not just inputs). Now that ReactDOMInput assigns to the
        // defaultValue property -- do we need this?
        'defaultValue',
        'defaultChecked',
        'innerHTML',
        'suppressContentEditableWarning',
        'suppressHydrationWarning',
        'style'
    ];
    reservedProps.forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, RESERVED, false, name, null, false, false);
    }); // A few React string attributes have a different name.
    // This is a mapping from React prop names to the attribute names.
    [
        [
            'acceptCharset',
            'accept-charset'
        ],
        [
            'className',
            'class'
        ],
        [
            'htmlFor',
            'for'
        ],
        [
            'httpEquiv',
            'http-equiv'
        ]
    ].forEach(function(_ref) {
        var name = _ref[0], attributeName = _ref[1];
        properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, null, false, false);
    }); // These are "enumerated" HTML attributes that accept "true" and "false".
    // In React, we let users pass `true` and `false` even though technically
    // these aren't boolean attributes (they are coerced to strings).
    [
        'contentEditable',
        'draggable',
        'spellCheck',
        'value'
    ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, name.toLowerCase(), null, false, false);
    }); // These are "enumerated" SVG attributes that accept "true" and "false".
    // In React, we let users pass `true` and `false` even though technically
    // these aren't boolean attributes (they are coerced to strings).
    // Since these are SVG attributes, their attribute names are case-sensitive.
    [
        'autoReverse',
        'externalResourcesRequired',
        'focusable',
        'preserveAlpha'
    ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, name, null, false, false);
    }); // These are HTML boolean attributes.
    [
        'allowFullScreen',
        'async',
        // on the client side because the browsers are inconsistent. Instead we call focus().
        'autoFocus',
        'autoPlay',
        'controls',
        'default',
        'defer',
        'disabled',
        'disablePictureInPicture',
        'disableRemotePlayback',
        'formNoValidate',
        'hidden',
        'loop',
        'noModule',
        'noValidate',
        'open',
        'playsInline',
        'readOnly',
        'required',
        'reversed',
        'scoped',
        'seamless',
        'itemScope'
    ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, BOOLEAN, false, name.toLowerCase(), null, false, false);
    }); // These are the few React props that we set as DOM properties
    // rather than attributes. These are all booleans.
    [
        'checked',
        // disabled with `removeAttribute`. We have special logic for handling this.
        'multiple',
        'muted',
        'selected' // NOTE: if you add a camelCased prop to this list,
    ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, BOOLEAN, true, name, null, false, false);
    }); // These are HTML attributes that are "overloaded booleans": they behave like
    // booleans, but can also accept a string value.
    [
        'capture',
        'download' // NOTE: if you add a camelCased prop to this list,
    ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, OVERLOADED_BOOLEAN, false, name, null, false, false);
    }); // These are HTML attributes that must be positive numbers.
    [
        'cols',
        'rows',
        'size',
        'span' // NOTE: if you add a camelCased prop to this list,
    ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, POSITIVE_NUMERIC, false, name, null, false, false);
    }); // These are HTML attributes that must be numbers.
    [
        'rowSpan',
        'start'
    ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, NUMERIC, false, name.toLowerCase(), null, false, false);
    });
    var CAMELIZE = /[\-\:]([a-z])/g;
    var capitalize = function(token) {
        return token[1].toUpperCase();
    }; // This is a list of all SVG attributes that need special casing, namespacing,
    // or boolean value assignment. Regular attributes that just accept strings
    // and have the same names are omitted, just like in the HTML attribute filter.
    // Some of these attributes can be hard to find. This list was created by
    // scraping the MDN documentation.
    [
        'accent-height',
        'alignment-baseline',
        'arabic-form',
        'baseline-shift',
        'cap-height',
        'clip-path',
        'clip-rule',
        'color-interpolation',
        'color-interpolation-filters',
        'color-profile',
        'color-rendering',
        'dominant-baseline',
        'enable-background',
        'fill-opacity',
        'fill-rule',
        'flood-color',
        'flood-opacity',
        'font-family',
        'font-size',
        'font-size-adjust',
        'font-stretch',
        'font-style',
        'font-variant',
        'font-weight',
        'glyph-name',
        'glyph-orientation-horizontal',
        'glyph-orientation-vertical',
        'horiz-adv-x',
        'horiz-origin-x',
        'image-rendering',
        'letter-spacing',
        'lighting-color',
        'marker-end',
        'marker-mid',
        'marker-start',
        'overline-position',
        'overline-thickness',
        'paint-order',
        'panose-1',
        'pointer-events',
        'rendering-intent',
        'shape-rendering',
        'stop-color',
        'stop-opacity',
        'strikethrough-position',
        'strikethrough-thickness',
        'stroke-dasharray',
        'stroke-dashoffset',
        'stroke-linecap',
        'stroke-linejoin',
        'stroke-miterlimit',
        'stroke-opacity',
        'stroke-width',
        'text-anchor',
        'text-decoration',
        'text-rendering',
        'underline-position',
        'underline-thickness',
        'unicode-bidi',
        'unicode-range',
        'units-per-em',
        'v-alphabetic',
        'v-hanging',
        'v-ideographic',
        'v-mathematical',
        'vector-effect',
        'vert-adv-y',
        'vert-origin-x',
        'vert-origin-y',
        'word-spacing',
        'writing-mode',
        'xmlns:xlink',
        'x-height' // NOTE: if you add a camelCased prop to this list,
    ].forEach(function(attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize);
        properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, null, false, false);
    }); // String SVG attributes with the xlink namespace.
    [
        'xlink:actuate',
        'xlink:arcrole',
        'xlink:role',
        'xlink:show',
        'xlink:title',
        'xlink:type' // NOTE: if you add a camelCased prop to this list,
    ].forEach(function(attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize);
        properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, 'http://www.w3.org/1999/xlink', false, false);
    }); // String SVG attributes with the xml namespace.
    [
        'xml:base',
        'xml:lang',
        'xml:space' // NOTE: if you add a camelCased prop to this list,
    ].forEach(function(attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize);
        properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, 'http://www.w3.org/XML/1998/namespace', false, false);
    }); // These attribute exists both in HTML and SVG.
    // The attribute name is case-sensitive in SVG so we can't just use
    // the React name like we do for attributes that exist only in HTML.
    [
        'tabIndex',
        'crossOrigin'
    ].forEach(function(attributeName) {
        properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, false, false);
    }); // These attributes accept URLs. These must not allow javascript: URLS.
    // These will also need to accept Trusted Types object in the future.
    var xlinkHref = 'xlinkHref';
    properties[xlinkHref] = new PropertyInfoRecord('xlinkHref', STRING, false, 'xlink:href', 'http://www.w3.org/1999/xlink', true, false);
    [
        'src',
        'href',
        'action',
        'formAction'
    ].forEach(function(attributeName) {
        properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, true, true);
    });
    /**
 * CSS properties which accept numbers but are not in units of "px".
 */ var isUnitlessNumber = {
        animationIterationCount: true,
        aspectRatio: true,
        borderImageOutset: true,
        borderImageSlice: true,
        borderImageWidth: true,
        boxFlex: true,
        boxFlexGroup: true,
        boxOrdinalGroup: true,
        columnCount: true,
        columns: true,
        flex: true,
        flexGrow: true,
        flexPositive: true,
        flexShrink: true,
        flexNegative: true,
        flexOrder: true,
        gridArea: true,
        gridRow: true,
        gridRowEnd: true,
        gridRowSpan: true,
        gridRowStart: true,
        gridColumn: true,
        gridColumnEnd: true,
        gridColumnSpan: true,
        gridColumnStart: true,
        fontWeight: true,
        lineClamp: true,
        lineHeight: true,
        opacity: true,
        order: true,
        orphans: true,
        tabSize: true,
        widows: true,
        zIndex: true,
        zoom: true,
        // SVG-related properties
        fillOpacity: true,
        floodOpacity: true,
        stopOpacity: true,
        strokeDasharray: true,
        strokeDashoffset: true,
        strokeMiterlimit: true,
        strokeOpacity: true,
        strokeWidth: true
    };
    /**
 * @param {string} prefix vendor-specific prefix, eg: Webkit
 * @param {string} key style name, eg: transitionDuration
 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
 * WebkitTransitionDuration
 */ function prefixKey(prefix, key) {
        return prefix + key.charAt(0).toUpperCase() + key.substring(1);
    }
    /**
 * Support style names that may come passed in prefixed by adding permutations
 * of vendor prefixes.
 */ var prefixes = [
        'Webkit',
        'ms',
        'Moz',
        'O'
    ]; // Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
    // infinite loop, because it iterates over the newly added props too.
    Object.keys(isUnitlessNumber).forEach(function(prop) {
        prefixes.forEach(function(prefix) {
            isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
        });
    });
    var hasReadOnlyValue = {
        button: true,
        checkbox: true,
        image: true,
        hidden: true,
        radio: true,
        reset: true,
        submit: true
    };
    function checkControlledValueProps(tagName, props) {
        if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.");
        if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function isCustomComponent(tagName, props) {
        if (tagName.indexOf('-') === -1) return typeof props.is === 'string';
        switch(tagName){
            // These are reserved SVG and MathML elements.
            // We don't mind this list too much because we expect it to never grow.
            // The alternative is to track the namespace in a few places which is convoluted.
            // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts
            case 'annotation-xml':
            case 'color-profile':
            case 'font-face':
            case 'font-face-src':
            case 'font-face-uri':
            case 'font-face-format':
            case 'font-face-name':
            case 'missing-glyph':
                return false;
            default:
                return true;
        }
    }
    var ariaProperties = {
        'aria-current': 0,
        // state
        'aria-description': 0,
        'aria-details': 0,
        'aria-disabled': 0,
        // state
        'aria-hidden': 0,
        // state
        'aria-invalid': 0,
        // state
        'aria-keyshortcuts': 0,
        'aria-label': 0,
        'aria-roledescription': 0,
        // Widget Attributes
        'aria-autocomplete': 0,
        'aria-checked': 0,
        'aria-expanded': 0,
        'aria-haspopup': 0,
        'aria-level': 0,
        'aria-modal': 0,
        'aria-multiline': 0,
        'aria-multiselectable': 0,
        'aria-orientation': 0,
        'aria-placeholder': 0,
        'aria-pressed': 0,
        'aria-readonly': 0,
        'aria-required': 0,
        'aria-selected': 0,
        'aria-sort': 0,
        'aria-valuemax': 0,
        'aria-valuemin': 0,
        'aria-valuenow': 0,
        'aria-valuetext': 0,
        // Live Region Attributes
        'aria-atomic': 0,
        'aria-busy': 0,
        'aria-live': 0,
        'aria-relevant': 0,
        // Drag-and-Drop Attributes
        'aria-dropeffect': 0,
        'aria-grabbed': 0,
        // Relationship Attributes
        'aria-activedescendant': 0,
        'aria-colcount': 0,
        'aria-colindex': 0,
        'aria-colspan': 0,
        'aria-controls': 0,
        'aria-describedby': 0,
        'aria-errormessage': 0,
        'aria-flowto': 0,
        'aria-labelledby': 0,
        'aria-owns': 0,
        'aria-posinset': 0,
        'aria-rowcount': 0,
        'aria-rowindex': 0,
        'aria-rowspan': 0,
        'aria-setsize': 0
    };
    var warnedProperties = {};
    var rARIA = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');
    var rARIACamel = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');
    function validateProperty(tagName, name) {
        if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) return true;
        if (rARIACamel.test(name)) {
            var ariaName = 'aria-' + name.slice(4).toLowerCase();
            var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null; // If this is an aria-* attribute, but is not listed in the known DOM
            // DOM properties, then it is an invalid aria-* attribute.
            if (correctName == null) {
                error('Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.', name);
                warnedProperties[name] = true;
                return true;
            } // aria-* attributes should be lowercase; suggest the lowercase version.
            if (name !== correctName) {
                error('Invalid ARIA attribute `%s`. Did you mean `%s`?', name, correctName);
                warnedProperties[name] = true;
                return true;
            }
        }
        if (rARIA.test(name)) {
            var lowerCasedName = name.toLowerCase();
            var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null; // If this is an aria-* attribute, but is not listed in the known DOM
            // DOM properties, then it is an invalid aria-* attribute.
            if (standardName == null) {
                warnedProperties[name] = true;
                return false;
            } // aria-* attributes should be lowercase; suggest the lowercase version.
            if (name !== standardName) {
                error('Unknown ARIA attribute `%s`. Did you mean `%s`?', name, standardName);
                warnedProperties[name] = true;
                return true;
            }
        }
        return true;
    }
    function warnInvalidARIAProps(type, props) {
        var invalidProps = [];
        for(var key in props){
            var isValid = validateProperty(type, key);
            if (!isValid) invalidProps.push(key);
        }
        var unknownPropString = invalidProps.map(function(prop) {
            return '`' + prop + '`';
        }).join(', ');
        if (invalidProps.length === 1) error("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
        else if (invalidProps.length > 1) error("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
    }
    function validateProperties(type, props) {
        if (isCustomComponent(type, props)) return;
        warnInvalidARIAProps(type, props);
    }
    var didWarnValueNull = false;
    function validateProperties$1(type, props) {
        if (type !== 'input' && type !== 'textarea' && type !== 'select') return;
        if (props != null && props.value === null && !didWarnValueNull) {
            didWarnValueNull = true;
            if (type === 'select' && props.multiple) error("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type);
            else error("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type);
        }
    }
    // When adding attributes to the HTML or SVG allowed attribute list, be sure to
    // also add them to this module to ensure casing and incorrect name
    // warnings.
    var possibleStandardNames = {
        // HTML
        accept: 'accept',
        acceptcharset: 'acceptCharset',
        'accept-charset': 'acceptCharset',
        accesskey: 'accessKey',
        action: 'action',
        allowfullscreen: 'allowFullScreen',
        alt: 'alt',
        as: 'as',
        async: 'async',
        autocapitalize: 'autoCapitalize',
        autocomplete: 'autoComplete',
        autocorrect: 'autoCorrect',
        autofocus: 'autoFocus',
        autoplay: 'autoPlay',
        autosave: 'autoSave',
        capture: 'capture',
        cellpadding: 'cellPadding',
        cellspacing: 'cellSpacing',
        challenge: 'challenge',
        charset: 'charSet',
        checked: 'checked',
        children: 'children',
        cite: 'cite',
        class: 'className',
        classid: 'classID',
        classname: 'className',
        cols: 'cols',
        colspan: 'colSpan',
        content: 'content',
        contenteditable: 'contentEditable',
        contextmenu: 'contextMenu',
        controls: 'controls',
        controlslist: 'controlsList',
        coords: 'coords',
        crossorigin: 'crossOrigin',
        dangerouslysetinnerhtml: 'dangerouslySetInnerHTML',
        data: 'data',
        datetime: 'dateTime',
        default: 'default',
        defaultchecked: 'defaultChecked',
        defaultvalue: 'defaultValue',
        defer: 'defer',
        dir: 'dir',
        disabled: 'disabled',
        disablepictureinpicture: 'disablePictureInPicture',
        disableremoteplayback: 'disableRemotePlayback',
        download: 'download',
        draggable: 'draggable',
        enctype: 'encType',
        enterkeyhint: 'enterKeyHint',
        for: 'htmlFor',
        form: 'form',
        formmethod: 'formMethod',
        formaction: 'formAction',
        formenctype: 'formEncType',
        formnovalidate: 'formNoValidate',
        formtarget: 'formTarget',
        frameborder: 'frameBorder',
        headers: 'headers',
        height: 'height',
        hidden: 'hidden',
        high: 'high',
        href: 'href',
        hreflang: 'hrefLang',
        htmlfor: 'htmlFor',
        httpequiv: 'httpEquiv',
        'http-equiv': 'httpEquiv',
        icon: 'icon',
        id: 'id',
        imagesizes: 'imageSizes',
        imagesrcset: 'imageSrcSet',
        innerhtml: 'innerHTML',
        inputmode: 'inputMode',
        integrity: 'integrity',
        is: 'is',
        itemid: 'itemID',
        itemprop: 'itemProp',
        itemref: 'itemRef',
        itemscope: 'itemScope',
        itemtype: 'itemType',
        keyparams: 'keyParams',
        keytype: 'keyType',
        kind: 'kind',
        label: 'label',
        lang: 'lang',
        list: 'list',
        loop: 'loop',
        low: 'low',
        manifest: 'manifest',
        marginwidth: 'marginWidth',
        marginheight: 'marginHeight',
        max: 'max',
        maxlength: 'maxLength',
        media: 'media',
        mediagroup: 'mediaGroup',
        method: 'method',
        min: 'min',
        minlength: 'minLength',
        multiple: 'multiple',
        muted: 'muted',
        name: 'name',
        nomodule: 'noModule',
        nonce: 'nonce',
        novalidate: 'noValidate',
        open: 'open',
        optimum: 'optimum',
        pattern: 'pattern',
        placeholder: 'placeholder',
        playsinline: 'playsInline',
        poster: 'poster',
        preload: 'preload',
        profile: 'profile',
        radiogroup: 'radioGroup',
        readonly: 'readOnly',
        referrerpolicy: 'referrerPolicy',
        rel: 'rel',
        required: 'required',
        reversed: 'reversed',
        role: 'role',
        rows: 'rows',
        rowspan: 'rowSpan',
        sandbox: 'sandbox',
        scope: 'scope',
        scoped: 'scoped',
        scrolling: 'scrolling',
        seamless: 'seamless',
        selected: 'selected',
        shape: 'shape',
        size: 'size',
        sizes: 'sizes',
        span: 'span',
        spellcheck: 'spellCheck',
        src: 'src',
        srcdoc: 'srcDoc',
        srclang: 'srcLang',
        srcset: 'srcSet',
        start: 'start',
        step: 'step',
        style: 'style',
        summary: 'summary',
        tabindex: 'tabIndex',
        target: 'target',
        title: 'title',
        type: 'type',
        usemap: 'useMap',
        value: 'value',
        width: 'width',
        wmode: 'wmode',
        wrap: 'wrap',
        // SVG
        about: 'about',
        accentheight: 'accentHeight',
        'accent-height': 'accentHeight',
        accumulate: 'accumulate',
        additive: 'additive',
        alignmentbaseline: 'alignmentBaseline',
        'alignment-baseline': 'alignmentBaseline',
        allowreorder: 'allowReorder',
        alphabetic: 'alphabetic',
        amplitude: 'amplitude',
        arabicform: 'arabicForm',
        'arabic-form': 'arabicForm',
        ascent: 'ascent',
        attributename: 'attributeName',
        attributetype: 'attributeType',
        autoreverse: 'autoReverse',
        azimuth: 'azimuth',
        basefrequency: 'baseFrequency',
        baselineshift: 'baselineShift',
        'baseline-shift': 'baselineShift',
        baseprofile: 'baseProfile',
        bbox: 'bbox',
        begin: 'begin',
        bias: 'bias',
        by: 'by',
        calcmode: 'calcMode',
        capheight: 'capHeight',
        'cap-height': 'capHeight',
        clip: 'clip',
        clippath: 'clipPath',
        'clip-path': 'clipPath',
        clippathunits: 'clipPathUnits',
        cliprule: 'clipRule',
        'clip-rule': 'clipRule',
        color: 'color',
        colorinterpolation: 'colorInterpolation',
        'color-interpolation': 'colorInterpolation',
        colorinterpolationfilters: 'colorInterpolationFilters',
        'color-interpolation-filters': 'colorInterpolationFilters',
        colorprofile: 'colorProfile',
        'color-profile': 'colorProfile',
        colorrendering: 'colorRendering',
        'color-rendering': 'colorRendering',
        contentscripttype: 'contentScriptType',
        contentstyletype: 'contentStyleType',
        cursor: 'cursor',
        cx: 'cx',
        cy: 'cy',
        d: 'd',
        datatype: 'datatype',
        decelerate: 'decelerate',
        descent: 'descent',
        diffuseconstant: 'diffuseConstant',
        direction: 'direction',
        display: 'display',
        divisor: 'divisor',
        dominantbaseline: 'dominantBaseline',
        'dominant-baseline': 'dominantBaseline',
        dur: 'dur',
        dx: 'dx',
        dy: 'dy',
        edgemode: 'edgeMode',
        elevation: 'elevation',
        enablebackground: 'enableBackground',
        'enable-background': 'enableBackground',
        end: 'end',
        exponent: 'exponent',
        externalresourcesrequired: 'externalResourcesRequired',
        fill: 'fill',
        fillopacity: 'fillOpacity',
        'fill-opacity': 'fillOpacity',
        fillrule: 'fillRule',
        'fill-rule': 'fillRule',
        filter: 'filter',
        filterres: 'filterRes',
        filterunits: 'filterUnits',
        floodopacity: 'floodOpacity',
        'flood-opacity': 'floodOpacity',
        floodcolor: 'floodColor',
        'flood-color': 'floodColor',
        focusable: 'focusable',
        fontfamily: 'fontFamily',
        'font-family': 'fontFamily',
        fontsize: 'fontSize',
        'font-size': 'fontSize',
        fontsizeadjust: 'fontSizeAdjust',
        'font-size-adjust': 'fontSizeAdjust',
        fontstretch: 'fontStretch',
        'font-stretch': 'fontStretch',
        fontstyle: 'fontStyle',
        'font-style': 'fontStyle',
        fontvariant: 'fontVariant',
        'font-variant': 'fontVariant',
        fontweight: 'fontWeight',
        'font-weight': 'fontWeight',
        format: 'format',
        from: 'from',
        fx: 'fx',
        fy: 'fy',
        g1: 'g1',
        g2: 'g2',
        glyphname: 'glyphName',
        'glyph-name': 'glyphName',
        glyphorientationhorizontal: 'glyphOrientationHorizontal',
        'glyph-orientation-horizontal': 'glyphOrientationHorizontal',
        glyphorientationvertical: 'glyphOrientationVertical',
        'glyph-orientation-vertical': 'glyphOrientationVertical',
        glyphref: 'glyphRef',
        gradienttransform: 'gradientTransform',
        gradientunits: 'gradientUnits',
        hanging: 'hanging',
        horizadvx: 'horizAdvX',
        'horiz-adv-x': 'horizAdvX',
        horizoriginx: 'horizOriginX',
        'horiz-origin-x': 'horizOriginX',
        ideographic: 'ideographic',
        imagerendering: 'imageRendering',
        'image-rendering': 'imageRendering',
        in2: 'in2',
        in: 'in',
        inlist: 'inlist',
        intercept: 'intercept',
        k1: 'k1',
        k2: 'k2',
        k3: 'k3',
        k4: 'k4',
        k: 'k',
        kernelmatrix: 'kernelMatrix',
        kernelunitlength: 'kernelUnitLength',
        kerning: 'kerning',
        keypoints: 'keyPoints',
        keysplines: 'keySplines',
        keytimes: 'keyTimes',
        lengthadjust: 'lengthAdjust',
        letterspacing: 'letterSpacing',
        'letter-spacing': 'letterSpacing',
        lightingcolor: 'lightingColor',
        'lighting-color': 'lightingColor',
        limitingconeangle: 'limitingConeAngle',
        local: 'local',
        markerend: 'markerEnd',
        'marker-end': 'markerEnd',
        markerheight: 'markerHeight',
        markermid: 'markerMid',
        'marker-mid': 'markerMid',
        markerstart: 'markerStart',
        'marker-start': 'markerStart',
        markerunits: 'markerUnits',
        markerwidth: 'markerWidth',
        mask: 'mask',
        maskcontentunits: 'maskContentUnits',
        maskunits: 'maskUnits',
        mathematical: 'mathematical',
        mode: 'mode',
        numoctaves: 'numOctaves',
        offset: 'offset',
        opacity: 'opacity',
        operator: 'operator',
        order: 'order',
        orient: 'orient',
        orientation: 'orientation',
        origin: 'origin',
        overflow: 'overflow',
        overlineposition: 'overlinePosition',
        'overline-position': 'overlinePosition',
        overlinethickness: 'overlineThickness',
        'overline-thickness': 'overlineThickness',
        paintorder: 'paintOrder',
        'paint-order': 'paintOrder',
        panose1: 'panose1',
        'panose-1': 'panose1',
        pathlength: 'pathLength',
        patterncontentunits: 'patternContentUnits',
        patterntransform: 'patternTransform',
        patternunits: 'patternUnits',
        pointerevents: 'pointerEvents',
        'pointer-events': 'pointerEvents',
        points: 'points',
        pointsatx: 'pointsAtX',
        pointsaty: 'pointsAtY',
        pointsatz: 'pointsAtZ',
        prefix: 'prefix',
        preservealpha: 'preserveAlpha',
        preserveaspectratio: 'preserveAspectRatio',
        primitiveunits: 'primitiveUnits',
        property: 'property',
        r: 'r',
        radius: 'radius',
        refx: 'refX',
        refy: 'refY',
        renderingintent: 'renderingIntent',
        'rendering-intent': 'renderingIntent',
        repeatcount: 'repeatCount',
        repeatdur: 'repeatDur',
        requiredextensions: 'requiredExtensions',
        requiredfeatures: 'requiredFeatures',
        resource: 'resource',
        restart: 'restart',
        result: 'result',
        results: 'results',
        rotate: 'rotate',
        rx: 'rx',
        ry: 'ry',
        scale: 'scale',
        security: 'security',
        seed: 'seed',
        shaperendering: 'shapeRendering',
        'shape-rendering': 'shapeRendering',
        slope: 'slope',
        spacing: 'spacing',
        specularconstant: 'specularConstant',
        specularexponent: 'specularExponent',
        speed: 'speed',
        spreadmethod: 'spreadMethod',
        startoffset: 'startOffset',
        stddeviation: 'stdDeviation',
        stemh: 'stemh',
        stemv: 'stemv',
        stitchtiles: 'stitchTiles',
        stopcolor: 'stopColor',
        'stop-color': 'stopColor',
        stopopacity: 'stopOpacity',
        'stop-opacity': 'stopOpacity',
        strikethroughposition: 'strikethroughPosition',
        'strikethrough-position': 'strikethroughPosition',
        strikethroughthickness: 'strikethroughThickness',
        'strikethrough-thickness': 'strikethroughThickness',
        string: 'string',
        stroke: 'stroke',
        strokedasharray: 'strokeDasharray',
        'stroke-dasharray': 'strokeDasharray',
        strokedashoffset: 'strokeDashoffset',
        'stroke-dashoffset': 'strokeDashoffset',
        strokelinecap: 'strokeLinecap',
        'stroke-linecap': 'strokeLinecap',
        strokelinejoin: 'strokeLinejoin',
        'stroke-linejoin': 'strokeLinejoin',
        strokemiterlimit: 'strokeMiterlimit',
        'stroke-miterlimit': 'strokeMiterlimit',
        strokewidth: 'strokeWidth',
        'stroke-width': 'strokeWidth',
        strokeopacity: 'strokeOpacity',
        'stroke-opacity': 'strokeOpacity',
        suppresscontenteditablewarning: 'suppressContentEditableWarning',
        suppresshydrationwarning: 'suppressHydrationWarning',
        surfacescale: 'surfaceScale',
        systemlanguage: 'systemLanguage',
        tablevalues: 'tableValues',
        targetx: 'targetX',
        targety: 'targetY',
        textanchor: 'textAnchor',
        'text-anchor': 'textAnchor',
        textdecoration: 'textDecoration',
        'text-decoration': 'textDecoration',
        textlength: 'textLength',
        textrendering: 'textRendering',
        'text-rendering': 'textRendering',
        to: 'to',
        transform: 'transform',
        typeof: 'typeof',
        u1: 'u1',
        u2: 'u2',
        underlineposition: 'underlinePosition',
        'underline-position': 'underlinePosition',
        underlinethickness: 'underlineThickness',
        'underline-thickness': 'underlineThickness',
        unicode: 'unicode',
        unicodebidi: 'unicodeBidi',
        'unicode-bidi': 'unicodeBidi',
        unicoderange: 'unicodeRange',
        'unicode-range': 'unicodeRange',
        unitsperem: 'unitsPerEm',
        'units-per-em': 'unitsPerEm',
        unselectable: 'unselectable',
        valphabetic: 'vAlphabetic',
        'v-alphabetic': 'vAlphabetic',
        values: 'values',
        vectoreffect: 'vectorEffect',
        'vector-effect': 'vectorEffect',
        version: 'version',
        vertadvy: 'vertAdvY',
        'vert-adv-y': 'vertAdvY',
        vertoriginx: 'vertOriginX',
        'vert-origin-x': 'vertOriginX',
        vertoriginy: 'vertOriginY',
        'vert-origin-y': 'vertOriginY',
        vhanging: 'vHanging',
        'v-hanging': 'vHanging',
        videographic: 'vIdeographic',
        'v-ideographic': 'vIdeographic',
        viewbox: 'viewBox',
        viewtarget: 'viewTarget',
        visibility: 'visibility',
        vmathematical: 'vMathematical',
        'v-mathematical': 'vMathematical',
        vocab: 'vocab',
        widths: 'widths',
        wordspacing: 'wordSpacing',
        'word-spacing': 'wordSpacing',
        writingmode: 'writingMode',
        'writing-mode': 'writingMode',
        x1: 'x1',
        x2: 'x2',
        x: 'x',
        xchannelselector: 'xChannelSelector',
        xheight: 'xHeight',
        'x-height': 'xHeight',
        xlinkactuate: 'xlinkActuate',
        'xlink:actuate': 'xlinkActuate',
        xlinkarcrole: 'xlinkArcrole',
        'xlink:arcrole': 'xlinkArcrole',
        xlinkhref: 'xlinkHref',
        'xlink:href': 'xlinkHref',
        xlinkrole: 'xlinkRole',
        'xlink:role': 'xlinkRole',
        xlinkshow: 'xlinkShow',
        'xlink:show': 'xlinkShow',
        xlinktitle: 'xlinkTitle',
        'xlink:title': 'xlinkTitle',
        xlinktype: 'xlinkType',
        'xlink:type': 'xlinkType',
        xmlbase: 'xmlBase',
        'xml:base': 'xmlBase',
        xmllang: 'xmlLang',
        'xml:lang': 'xmlLang',
        xmlns: 'xmlns',
        'xml:space': 'xmlSpace',
        xmlnsxlink: 'xmlnsXlink',
        'xmlns:xlink': 'xmlnsXlink',
        xmlspace: 'xmlSpace',
        y1: 'y1',
        y2: 'y2',
        y: 'y',
        ychannelselector: 'yChannelSelector',
        z: 'z',
        zoomandpan: 'zoomAndPan'
    };
    var validateProperty$1 = function() {};
    var warnedProperties$1 = {};
    var EVENT_NAME_REGEX = /^on./;
    var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
    var rARIA$1 = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');
    var rARIACamel$1 = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');
    validateProperty$1 = function(tagName, name, value, eventRegistry) {
        if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) return true;
        var lowerCasedName = name.toLowerCase();
        if (lowerCasedName === 'onfocusin' || lowerCasedName === 'onfocusout') {
            error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.");
            warnedProperties$1[name] = true;
            return true;
        } // We can't rely on the event system being injected on the server.
        if (eventRegistry != null) {
            var registrationNameDependencies = eventRegistry.registrationNameDependencies, possibleRegistrationNames = eventRegistry.possibleRegistrationNames;
            if (registrationNameDependencies.hasOwnProperty(name)) return true;
            var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;
            if (registrationName != null) {
                error('Invalid event handler property `%s`. Did you mean `%s`?', name, registrationName);
                warnedProperties$1[name] = true;
                return true;
            }
            if (EVENT_NAME_REGEX.test(name)) {
                error('Unknown event handler property `%s`. It will be ignored.', name);
                warnedProperties$1[name] = true;
                return true;
            }
        } else if (EVENT_NAME_REGEX.test(name)) {
            // If no event plugins have been injected, we are in a server environment.
            // So we can't tell if the event name is correct for sure, but we can filter
            // out known bad ones like `onclick`. We can't suggest a specific replacement though.
            if (INVALID_EVENT_NAME_REGEX.test(name)) error("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name);
            warnedProperties$1[name] = true;
            return true;
        } // Let the ARIA attribute hook validate ARIA attributes
        if (rARIA$1.test(name) || rARIACamel$1.test(name)) return true;
        if (lowerCasedName === 'innerhtml') {
            error("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.");
            warnedProperties$1[name] = true;
            return true;
        }
        if (lowerCasedName === 'aria') {
            error("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.");
            warnedProperties$1[name] = true;
            return true;
        }
        if (lowerCasedName === 'is' && value !== null && value !== undefined && typeof value !== 'string') {
            error("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value);
            warnedProperties$1[name] = true;
            return true;
        }
        if (typeof value === 'number' && isNaN(value)) {
            error("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name);
            warnedProperties$1[name] = true;
            return true;
        }
        var propertyInfo = getPropertyInfo(name);
        var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED; // Known attributes should match the casing specified in the property config.
        if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
            var standardName = possibleStandardNames[lowerCasedName];
            if (standardName !== name) {
                error('Invalid DOM property `%s`. Did you mean `%s`?', name, standardName);
                warnedProperties$1[name] = true;
                return true;
            }
        } else if (!isReserved && name !== lowerCasedName) {
            // Unknown attributes should have lowercase casing since that's how they
            // will be cased anyway with server rendering.
            error("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name, lowerCasedName);
            warnedProperties$1[name] = true;
            return true;
        }
        if (typeof value === 'boolean' && shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
            if (value) error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value, name, name, value, name);
            else error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);
            warnedProperties$1[name] = true;
            return true;
        } // Now that we've validated casing, do not validate
        // data types for reserved props
        if (isReserved) return true;
         // Warn when a known attribute is a bad type
        if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
            warnedProperties$1[name] = true;
            return false;
        } // Warn when passing the strings 'false' or 'true' into a boolean prop
        if ((value === 'false' || value === 'true') && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
            error("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name, value === 'false' ? 'The browser will interpret it as a truthy value.' : 'Although this works, it will not work as expected if you pass the string "false".', name, value);
            warnedProperties$1[name] = true;
            return true;
        }
        return true;
    };
    var warnUnknownProperties = function(type, props, eventRegistry) {
        var unknownProps = [];
        for(var key in props){
            var isValid = validateProperty$1(type, key, props[key], eventRegistry);
            if (!isValid) unknownProps.push(key);
        }
        var unknownPropString = unknownProps.map(function(prop) {
            return '`' + prop + '`';
        }).join(', ');
        if (unknownProps.length === 1) error("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
        else if (unknownProps.length > 1) error("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
    };
    function validateProperties$2(type, props, eventRegistry) {
        if (isCustomComponent(type, props)) return;
        warnUnknownProperties(type, props, eventRegistry);
    }
    var warnValidStyle = function() {};
    // 'msTransform' is correct, but the other prefixes should be capitalized
    var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
    var msPattern = /^-ms-/;
    var hyphenPattern = /-(.)/g; // style values shouldn't contain a semicolon
    var badStyleValueWithSemicolonPattern = /;\s*$/;
    var warnedStyleNames = {};
    var warnedStyleValues = {};
    var warnedForNaNValue = false;
    var warnedForInfinityValue = false;
    var camelize = function(string) {
        return string.replace(hyphenPattern, function(_, character) {
            return character.toUpperCase();
        });
    };
    var warnHyphenatedStyleName = function(name) {
        if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) return;
        warnedStyleNames[name] = true;
        error('Unsupported style property %s. Did you mean %s?', name, // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
        // is converted to lowercase `ms`.
        camelize(name.replace(msPattern, 'ms-')));
    };
    var warnBadVendoredStyleName = function(name) {
        if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) return;
        warnedStyleNames[name] = true;
        error('Unsupported vendor-prefixed style property %s. Did you mean %s?', name, name.charAt(0).toUpperCase() + name.slice(1));
    };
    var warnStyleValueWithSemicolon = function(name, value) {
        if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) return;
        warnedStyleValues[value] = true;
        error('Style property values shouldn\'t contain a semicolon. Try "%s: %s" instead.', name, value.replace(badStyleValueWithSemicolonPattern, ''));
    };
    var warnStyleValueIsNaN = function(name, value) {
        if (warnedForNaNValue) return;
        warnedForNaNValue = true;
        error('`NaN` is an invalid value for the `%s` css style property.', name);
    };
    var warnStyleValueIsInfinity = function(name, value) {
        if (warnedForInfinityValue) return;
        warnedForInfinityValue = true;
        error('`Infinity` is an invalid value for the `%s` css style property.', name);
    };
    warnValidStyle = function(name, value) {
        if (name.indexOf('-') > -1) warnHyphenatedStyleName(name);
        else if (badVendoredStyleNamePattern.test(name)) warnBadVendoredStyleName(name);
        else if (badStyleValueWithSemicolonPattern.test(value)) warnStyleValueWithSemicolon(name, value);
        if (typeof value === 'number') {
            if (isNaN(value)) warnStyleValueIsNaN(name, value);
            else if (!isFinite(value)) warnStyleValueIsInfinity(name, value);
        }
    };
    var warnValidStyle$1 = warnValidStyle;
    // code copied and modified from escape-html
    var matchHtmlRegExp = /["'&<>]/;
    /**
 * Escapes special characters and HTML entities in a given html string.
 *
 * @param  {string} string HTML string to escape for later insertion
 * @return {string}
 * @public
 */ function escapeHtml(string) {
        checkHtmlStringCoercion(string);
        var str = '' + string;
        var match = matchHtmlRegExp.exec(str);
        if (!match) return str;
        var escape;
        var html = '';
        var index;
        var lastIndex = 0;
        for(index = match.index; index < str.length; index++){
            switch(str.charCodeAt(index)){
                case 34:
                    // "
                    escape = '&quot;';
                    break;
                case 38:
                    // &
                    escape = '&amp;';
                    break;
                case 39:
                    // '
                    escape = '&#x27;'; // modified from escape-html; used to be '&#39'
                    break;
                case 60:
                    // <
                    escape = '&lt;';
                    break;
                case 62:
                    // >
                    escape = '&gt;';
                    break;
                default:
                    continue;
            }
            if (lastIndex !== index) html += str.substring(lastIndex, index);
            lastIndex = index + 1;
            html += escape;
        }
        return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
    } // end code copied and modified from escape-html
    /**
 * Escapes text to prevent scripting attacks.
 *
 * @param {*} text Text value to escape.
 * @return {string} An escaped string.
 */ function escapeTextForBrowser(text) {
        if (typeof text === 'boolean' || typeof text === 'number') // this shortcircuit helps perf for types that we know will never have
        // special characters, especially given that this function is used often
        // for numeric dom ids.
        return '' + text;
        return escapeHtml(text);
    }
    var uppercasePattern = /([A-Z])/g;
    var msPattern$1 = /^ms-/;
    /**
 * Hyphenates a camelcased CSS property name, for example:
 *
 *   > hyphenateStyleName('backgroundColor')
 *   < "background-color"
 *   > hyphenateStyleName('MozTransition')
 *   < "-moz-transition"
 *   > hyphenateStyleName('msTransition')
 *   < "-ms-transition"
 *
 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
 * is converted to `-ms-`.
 */ function hyphenateStyleName(name) {
        return name.replace(uppercasePattern, '-$1').toLowerCase().replace(msPattern$1, '-ms-');
    }
    // and any newline or tab are filtered out as if they're not part of the URL.
    // https://url.spec.whatwg.org/#url-parsing
    // Tab or newline are defined as \r\n\t:
    // https://infra.spec.whatwg.org/#ascii-tab-or-newline
    // A C0 control is a code point in the range \u0000 NULL to \u001F
    // INFORMATION SEPARATOR ONE, inclusive:
    // https://infra.spec.whatwg.org/#c0-control-or-space
    /* eslint-disable max-len */ var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
    var didWarn = false;
    function sanitizeURL(url) {
        if (!didWarn && isJavaScriptProtocol.test(url)) {
            didWarn = true;
            error("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url));
        }
    }
    var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare
    function isArray(a) {
        return isArrayImpl(a);
    }
    var startInlineScript = stringToPrecomputedChunk('<script>');
    var endInlineScript = stringToPrecomputedChunk('</script>');
    var startScriptSrc = stringToPrecomputedChunk('<script src="');
    var startModuleSrc = stringToPrecomputedChunk('<script type="module" src="');
    var endAsyncScript = stringToPrecomputedChunk('" async=""></script>');
    /**
 * This escaping function is designed to work with bootstrapScriptContent only.
 * because we know we are escaping the entire script. We can avoid for instance
 * escaping html comment string sequences that are valid javascript as well because
 * if there are no sebsequent <script sequences the html parser will never enter
 * script data double escaped state (see: https://www.w3.org/TR/html53/syntax.html#script-data-double-escaped-state)
 *
 * While untrusted script content should be made safe before using this api it will
 * ensure that the script cannot be early terminated or never terminated state
 */ function escapeBootstrapScriptContent(scriptText) {
        checkHtmlStringCoercion(scriptText);
        return ('' + scriptText).replace(scriptRegex, scriptReplacer);
    }
    var scriptRegex = /(<\/|<)(s)(cript)/gi;
    var scriptReplacer = function(match, prefix, s, suffix) {
        return "" + prefix + (s === 's' ? "\\u0073" : "\\u0053") + suffix;
    }; // Allows us to keep track of what we've already written so we can refer back to it.
    function createResponseState(identifierPrefix, nonce, bootstrapScriptContent, bootstrapScripts, bootstrapModules) {
        var idPrefix = identifierPrefix === undefined ? '' : identifierPrefix;
        var inlineScriptWithNonce = nonce === undefined ? startInlineScript : stringToPrecomputedChunk('<script nonce="' + escapeTextForBrowser(nonce) + '">');
        var bootstrapChunks = [];
        if (bootstrapScriptContent !== undefined) bootstrapChunks.push(inlineScriptWithNonce, stringToChunk(escapeBootstrapScriptContent(bootstrapScriptContent)), endInlineScript);
        if (bootstrapScripts !== undefined) for(var i = 0; i < bootstrapScripts.length; i++)bootstrapChunks.push(startScriptSrc, stringToChunk(escapeTextForBrowser(bootstrapScripts[i])), endAsyncScript);
        if (bootstrapModules !== undefined) for(var _i = 0; _i < bootstrapModules.length; _i++)bootstrapChunks.push(startModuleSrc, stringToChunk(escapeTextForBrowser(bootstrapModules[_i])), endAsyncScript);
        return {
            bootstrapChunks: bootstrapChunks,
            startInlineScript: inlineScriptWithNonce,
            placeholderPrefix: stringToPrecomputedChunk(idPrefix + 'P:'),
            segmentPrefix: stringToPrecomputedChunk(idPrefix + 'S:'),
            boundaryPrefix: idPrefix + 'B:',
            idPrefix: idPrefix,
            nextSuspenseID: 0,
            sentCompleteSegmentFunction: false,
            sentCompleteBoundaryFunction: false,
            sentClientRenderFunction: false
        };
    } // Constants for the insertion mode we're currently writing in. We don't encode all HTML5 insertion
    // modes. We only include the variants as they matter for the sake of our purposes.
    // We don't actually provide the namespace therefore we use constants instead of the string.
    var ROOT_HTML_MODE = 0; // Used for the root most element tag.
    var HTML_MODE = 1;
    var SVG_MODE = 2;
    var MATHML_MODE = 3;
    var HTML_TABLE_MODE = 4;
    var HTML_TABLE_BODY_MODE = 5;
    var HTML_TABLE_ROW_MODE = 6;
    var HTML_COLGROUP_MODE = 7; // We have a greater than HTML_TABLE_MODE check elsewhere. If you add more cases here, make sure it
    // still makes sense
    function createFormatContext(insertionMode, selectedValue) {
        return {
            insertionMode: insertionMode,
            selectedValue: selectedValue
        };
    }
    function createRootFormatContext(namespaceURI) {
        var insertionMode = namespaceURI === 'http://www.w3.org/2000/svg' ? SVG_MODE : namespaceURI === 'http://www.w3.org/1998/Math/MathML' ? MATHML_MODE : ROOT_HTML_MODE;
        return createFormatContext(insertionMode, null);
    }
    function getChildFormatContext(parentContext, type, props) {
        switch(type){
            case 'select':
                return createFormatContext(HTML_MODE, props.value != null ? props.value : props.defaultValue);
            case 'svg':
                return createFormatContext(SVG_MODE, null);
            case 'math':
                return createFormatContext(MATHML_MODE, null);
            case 'foreignObject':
                return createFormatContext(HTML_MODE, null);
            // Table parents are special in that their children can only be created at all if they're
            // wrapped in a table parent. So we need to encode that we're entering this mode.
            case 'table':
                return createFormatContext(HTML_TABLE_MODE, null);
            case 'thead':
            case 'tbody':
            case 'tfoot':
                return createFormatContext(HTML_TABLE_BODY_MODE, null);
            case 'colgroup':
                return createFormatContext(HTML_COLGROUP_MODE, null);
            case 'tr':
                return createFormatContext(HTML_TABLE_ROW_MODE, null);
        }
        if (parentContext.insertionMode >= HTML_TABLE_MODE) // Whatever tag this was, it wasn't a table parent or other special parent, so we must have
        // entered plain HTML again.
        return createFormatContext(HTML_MODE, null);
        if (parentContext.insertionMode === ROOT_HTML_MODE) // We've emitted the root and is now in plain HTML mode.
        return createFormatContext(HTML_MODE, null);
        return parentContext;
    }
    var UNINITIALIZED_SUSPENSE_BOUNDARY_ID = null;
    function assignSuspenseBoundaryID(responseState) {
        var generatedID = responseState.nextSuspenseID++;
        return stringToPrecomputedChunk(responseState.boundaryPrefix + generatedID.toString(16));
    }
    function makeId(responseState, treeId, localId) {
        var idPrefix = responseState.idPrefix;
        var id = ':' + idPrefix + 'R' + treeId; // Unless this is the first id at this level, append a number at the end
        // that represents the position of this useId hook among all the useId
        // hooks for this fiber.
        if (localId > 0) id += 'H' + localId.toString(32);
        return id + ':';
    }
    function encodeHTMLTextNode(text) {
        return escapeTextForBrowser(text);
    }
    var textSeparator = stringToPrecomputedChunk('<!-- -->');
    function pushTextInstance(target, text, responseState, textEmbedded) {
        if (text === '') // Empty text doesn't have a DOM node representation and the hydration is aware of this.
        return textEmbedded;
        if (textEmbedded) target.push(textSeparator);
        target.push(stringToChunk(encodeHTMLTextNode(text)));
        return true;
    } // Called when Fizz is done with a Segment. Currently the only purpose is to conditionally
    // emit a text separator when we don't know for sure it is safe to omit
    function pushSegmentFinale(target, responseState, lastPushedText, textEmbedded) {
        if (lastPushedText && textEmbedded) target.push(textSeparator);
    }
    var styleNameCache = new Map();
    function processStyleName(styleName) {
        var chunk = styleNameCache.get(styleName);
        if (chunk !== undefined) return chunk;
        var result = stringToPrecomputedChunk(escapeTextForBrowser(hyphenateStyleName(styleName)));
        styleNameCache.set(styleName, result);
        return result;
    }
    var styleAttributeStart = stringToPrecomputedChunk(' style="');
    var styleAssign = stringToPrecomputedChunk(':');
    var styleSeparator = stringToPrecomputedChunk(';');
    function pushStyle(target, responseState, style) {
        if (typeof style !== 'object') throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
        var isFirst = true;
        for(var styleName in style){
            if (!hasOwnProperty.call(style, styleName)) continue;
             // If you provide unsafe user data here they can inject arbitrary CSS
            // which may be problematic (I couldn't repro this):
            // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
            // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
            // This is not an XSS hole but instead a potential CSS injection issue
            // which has lead to a greater discussion about how we're going to
            // trust URLs moving forward. See #2115901
            var styleValue = style[styleName];
            if (styleValue == null || typeof styleValue === 'boolean' || styleValue === '') continue;
            var nameChunk = void 0;
            var valueChunk = void 0;
            var isCustomProperty = styleName.indexOf('--') === 0;
            if (isCustomProperty) {
                nameChunk = stringToChunk(escapeTextForBrowser(styleName));
                checkCSSPropertyStringCoercion(styleValue, styleName);
                valueChunk = stringToChunk(escapeTextForBrowser(('' + styleValue).trim()));
            } else {
                warnValidStyle$1(styleName, styleValue);
                nameChunk = processStyleName(styleName);
                if (typeof styleValue === 'number') {
                    if (styleValue !== 0 && !hasOwnProperty.call(isUnitlessNumber, styleName)) valueChunk = stringToChunk(styleValue + 'px'); // Presumes implicit 'px' suffix for unitless numbers
                    else valueChunk = stringToChunk('' + styleValue);
                } else {
                    checkCSSPropertyStringCoercion(styleValue, styleName);
                    valueChunk = stringToChunk(escapeTextForBrowser(('' + styleValue).trim()));
                }
            }
            if (isFirst) {
                isFirst = false; // If it's first, we don't need any separators prefixed.
                target.push(styleAttributeStart, nameChunk, styleAssign, valueChunk);
            } else target.push(styleSeparator, nameChunk, styleAssign, valueChunk);
        }
        if (!isFirst) target.push(attributeEnd);
    }
    var attributeSeparator = stringToPrecomputedChunk(' ');
    var attributeAssign = stringToPrecomputedChunk('="');
    var attributeEnd = stringToPrecomputedChunk('"');
    var attributeEmptyString = stringToPrecomputedChunk('=""');
    function pushAttribute(target, responseState, name, value) {
        switch(name){
            case 'style':
                pushStyle(target, responseState, value);
                return;
            case 'defaultValue':
            case 'defaultChecked':
            case 'innerHTML':
            case 'suppressContentEditableWarning':
            case 'suppressHydrationWarning':
                // Ignored. These are built-in to React on the client.
                return;
        }
        if (// We have already filtered out null/undefined and reserved words.
        name.length > 2 && (name[0] === 'o' || name[0] === 'O') && (name[1] === 'n' || name[1] === 'N')) return;
        var propertyInfo = getPropertyInfo(name);
        if (propertyInfo !== null) {
            // shouldRemoveAttribute
            switch(typeof value){
                case 'function':
                case 'symbol':
                    // eslint-disable-line
                    return;
                case 'boolean':
                    if (!propertyInfo.acceptsBooleans) return;
            }
            var attributeName = propertyInfo.attributeName;
            var attributeNameChunk = stringToChunk(attributeName); // TODO: If it's known we can cache the chunk.
            switch(propertyInfo.type){
                case BOOLEAN:
                    if (value) target.push(attributeSeparator, attributeNameChunk, attributeEmptyString);
                    return;
                case OVERLOADED_BOOLEAN:
                    if (value === true) target.push(attributeSeparator, attributeNameChunk, attributeEmptyString);
                    else if (value === false) ;
                    else target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
                    return;
                case NUMERIC:
                    if (!isNaN(value)) target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
                    break;
                case POSITIVE_NUMERIC:
                    if (!isNaN(value) && value >= 1) target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
                    break;
                default:
                    if (propertyInfo.sanitizeURL) {
                        checkAttributeStringCoercion(value, attributeName);
                        value = '' + value;
                        sanitizeURL(value);
                    }
                    target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
            }
        } else if (isAttributeNameSafe(name)) {
            // shouldRemoveAttribute
            switch(typeof value){
                case 'function':
                case 'symbol':
                    // eslint-disable-line
                    return;
                case 'boolean':
                    var prefix = name.toLowerCase().slice(0, 5);
                    if (prefix !== 'data-' && prefix !== 'aria-') return;
            }
            target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);
        }
    }
    var endOfStartTag = stringToPrecomputedChunk('>');
    var endOfStartTagSelfClosing = stringToPrecomputedChunk('/>');
    function pushInnerHTML(target, innerHTML, children) {
        if (innerHTML != null) {
            if (children != null) throw new Error('Can only set one of `children` or `props.dangerouslySetInnerHTML`.');
            if (typeof innerHTML !== 'object' || !('__html' in innerHTML)) throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
            var html = innerHTML.__html;
            if (html !== null && html !== undefined) {
                checkHtmlStringCoercion(html);
                target.push(stringToChunk('' + html));
            }
        }
    } // TODO: Move these to ResponseState so that we warn for every request.
    // It would help debugging in stateful servers (e.g. service worker).
    var didWarnDefaultInputValue = false;
    var didWarnDefaultChecked = false;
    var didWarnDefaultSelectValue = false;
    var didWarnDefaultTextareaValue = false;
    var didWarnInvalidOptionChildren = false;
    var didWarnInvalidOptionInnerHTML = false;
    var didWarnSelectedSetOnOption = false;
    function checkSelectProp(props, propName) {
        var value = props[propName];
        if (value != null) {
            var array = isArray(value);
            if (props.multiple && !array) error("The `%s` prop supplied to <select> must be an array if `multiple` is true.", propName);
            else if (!props.multiple && array) error("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", propName);
        }
    }
    function pushStartSelect(target, props, responseState) {
        checkControlledValueProps('select', props);
        checkSelectProp(props, 'value');
        checkSelectProp(props, 'defaultValue');
        if (props.value !== undefined && props.defaultValue !== undefined && !didWarnDefaultSelectValue) {
            error("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components");
            didWarnDefaultSelectValue = true;
        }
        target.push(startChunkForTag('select'));
        var children = null;
        var innerHTML = null;
        for(var propKey in props)if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) continue;
            switch(propKey){
                case 'children':
                    children = propValue;
                    break;
                case 'dangerouslySetInnerHTML':
                    // TODO: This doesn't really make sense for select since it can't use the controlled
                    // value in the innerHTML.
                    innerHTML = propValue;
                    break;
                case 'defaultValue':
                case 'value':
                    break;
                default:
                    pushAttribute(target, responseState, propKey, propValue);
                    break;
            }
        }
        target.push(endOfStartTag);
        pushInnerHTML(target, innerHTML, children);
        return children;
    }
    function flattenOptionChildren(children) {
        var content = ''; // Flatten children and warn if they aren't strings or numbers;
        // invalid types are ignored.
        React.Children.forEach(children, function(child) {
            if (child == null) return;
            content += child;
            if (!didWarnInvalidOptionChildren && typeof child !== 'string' && typeof child !== 'number') {
                didWarnInvalidOptionChildren = true;
                error("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.");
            }
        });
        return content;
    }
    var selectedMarkerAttribute = stringToPrecomputedChunk(' selected=""');
    function pushStartOption(target, props, responseState, formatContext) {
        var selectedValue = formatContext.selectedValue;
        target.push(startChunkForTag('option'));
        var children = null;
        var value = null;
        var selected = null;
        var innerHTML = null;
        for(var propKey in props)if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) continue;
            switch(propKey){
                case 'children':
                    children = propValue;
                    break;
                case 'selected':
                    // ignore
                    selected = propValue;
                    // TODO: Remove support for `selected` in <option>.
                    if (!didWarnSelectedSetOnOption) {
                        error("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.");
                        didWarnSelectedSetOnOption = true;
                    }
                    break;
                case 'dangerouslySetInnerHTML':
                    innerHTML = propValue;
                    break;
                // eslint-disable-next-line-no-fallthrough
                case 'value':
                    value = propValue;
                // We intentionally fallthrough to also set the attribute on the node.
                // eslint-disable-next-line-no-fallthrough
                default:
                    pushAttribute(target, responseState, propKey, propValue);
                    break;
            }
        }
        if (selectedValue != null) {
            var stringValue;
            if (value !== null) {
                checkAttributeStringCoercion(value, 'value');
                stringValue = '' + value;
            } else {
                if (innerHTML !== null) {
                    if (!didWarnInvalidOptionInnerHTML) {
                        didWarnInvalidOptionInnerHTML = true;
                        error("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.");
                    }
                }
                stringValue = flattenOptionChildren(children);
            }
            if (isArray(selectedValue)) // multiple
            for(var i = 0; i < selectedValue.length; i++){
                checkAttributeStringCoercion(selectedValue[i], 'value');
                var v = '' + selectedValue[i];
                if (v === stringValue) {
                    target.push(selectedMarkerAttribute);
                    break;
                }
            }
            else {
                checkAttributeStringCoercion(selectedValue, 'select.value');
                if ('' + selectedValue === stringValue) target.push(selectedMarkerAttribute);
            }
        } else if (selected) target.push(selectedMarkerAttribute);
        target.push(endOfStartTag);
        pushInnerHTML(target, innerHTML, children);
        return children;
    }
    function pushInput(target, props, responseState) {
        checkControlledValueProps('input', props);
        if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnDefaultChecked) {
            error("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", 'A component', props.type);
            didWarnDefaultChecked = true;
        }
        if (props.value !== undefined && props.defaultValue !== undefined && !didWarnDefaultInputValue) {
            error("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", 'A component', props.type);
            didWarnDefaultInputValue = true;
        }
        target.push(startChunkForTag('input'));
        var value = null;
        var defaultValue = null;
        var checked = null;
        var defaultChecked = null;
        for(var propKey in props)if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) continue;
            switch(propKey){
                case 'children':
                case 'dangerouslySetInnerHTML':
                    throw new Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                // eslint-disable-next-line-no-fallthrough
                case 'defaultChecked':
                    defaultChecked = propValue;
                    break;
                case 'defaultValue':
                    defaultValue = propValue;
                    break;
                case 'checked':
                    checked = propValue;
                    break;
                case 'value':
                    value = propValue;
                    break;
                default:
                    pushAttribute(target, responseState, propKey, propValue);
                    break;
            }
        }
        if (checked !== null) pushAttribute(target, responseState, 'checked', checked);
        else if (defaultChecked !== null) pushAttribute(target, responseState, 'checked', defaultChecked);
        if (value !== null) pushAttribute(target, responseState, 'value', value);
        else if (defaultValue !== null) pushAttribute(target, responseState, 'value', defaultValue);
        target.push(endOfStartTagSelfClosing);
        return null;
    }
    function pushStartTextArea(target, props, responseState) {
        checkControlledValueProps('textarea', props);
        if (props.value !== undefined && props.defaultValue !== undefined && !didWarnDefaultTextareaValue) {
            error("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components");
            didWarnDefaultTextareaValue = true;
        }
        target.push(startChunkForTag('textarea'));
        var value = null;
        var defaultValue = null;
        var children = null;
        for(var propKey in props)if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) continue;
            switch(propKey){
                case 'children':
                    children = propValue;
                    break;
                case 'value':
                    value = propValue;
                    break;
                case 'defaultValue':
                    defaultValue = propValue;
                    break;
                case 'dangerouslySetInnerHTML':
                    throw new Error('`dangerouslySetInnerHTML` does not make sense on <textarea>.');
                // eslint-disable-next-line-no-fallthrough
                default:
                    pushAttribute(target, responseState, propKey, propValue);
                    break;
            }
        }
        if (value === null && defaultValue !== null) value = defaultValue;
        target.push(endOfStartTag); // TODO (yungsters): Remove support for children content in <textarea>.
        if (children != null) {
            error("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
            if (value != null) throw new Error('If you supply `defaultValue` on a <textarea>, do not pass children.');
            if (isArray(children)) {
                if (children.length > 1) throw new Error('<textarea> can only have at most one child.');
                 // TODO: remove the coercion and the DEV check below because it will
                checkHtmlStringCoercion(children[0]);
                value = '' + children[0];
            }
            checkHtmlStringCoercion(children);
            value = '' + children;
        }
        if (typeof value === 'string' && value[0] === '\n') // text/html ignores the first character in these tags if it's a newline
        // Prefer to break application/xml over text/html (for now) by adding
        // a newline specifically to get eaten by the parser. (Alternately for
        // textareas, replacing "^\n" with "\r\n" doesn't get eaten, and the first
        // \r is normalized out by HTMLTextAreaElement#value.)
        // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>
        // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>
        // See: <http://www.w3.org/TR/html5/syntax.html#newlines>
        // See: Parsing of "textarea" "listing" and "pre" elements
        //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>
        target.push(leadingNewline);
         // ToString and push directly instead of recurse over children.
        // We don't really support complex children in the value anyway.
        // This also currently avoids a trailing comment node which breaks textarea.
        if (value !== null) {
            checkAttributeStringCoercion(value, 'value');
            target.push(stringToChunk(encodeHTMLTextNode('' + value)));
        }
        return null;
    }
    function pushSelfClosing(target, props, tag, responseState) {
        target.push(startChunkForTag(tag));
        for(var propKey in props)if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) continue;
            switch(propKey){
                case 'children':
                case 'dangerouslySetInnerHTML':
                    throw new Error(tag + " is a self-closing tag and must neither have `children` nor " + 'use `dangerouslySetInnerHTML`.');
                // eslint-disable-next-line-no-fallthrough
                default:
                    pushAttribute(target, responseState, propKey, propValue);
                    break;
            }
        }
        target.push(endOfStartTagSelfClosing);
        return null;
    }
    function pushStartMenuItem(target, props, responseState) {
        target.push(startChunkForTag('menuitem'));
        for(var propKey in props)if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) continue;
            switch(propKey){
                case 'children':
                case 'dangerouslySetInnerHTML':
                    throw new Error('menuitems cannot have `children` nor `dangerouslySetInnerHTML`.');
                // eslint-disable-next-line-no-fallthrough
                default:
                    pushAttribute(target, responseState, propKey, propValue);
                    break;
            }
        }
        target.push(endOfStartTag);
        return null;
    }
    function pushStartTitle(target, props, responseState) {
        target.push(startChunkForTag('title'));
        var children = null;
        for(var propKey in props)if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) continue;
            switch(propKey){
                case 'children':
                    children = propValue;
                    break;
                case 'dangerouslySetInnerHTML':
                    throw new Error('`dangerouslySetInnerHTML` does not make sense on <title>.');
                // eslint-disable-next-line-no-fallthrough
                default:
                    pushAttribute(target, responseState, propKey, propValue);
                    break;
            }
        }
        target.push(endOfStartTag);
        var child = Array.isArray(children) && children.length < 2 ? children[0] || null : children;
        if (Array.isArray(children) && children.length > 1) error("A title element received an array with more than 1 element as children. In browsers title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
        else if (child != null && child.$$typeof != null) error("A title element received a React element for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
        else if (child != null && typeof child !== 'string' && typeof child !== 'number') error("A title element received a value that was not a string or number for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
        return children;
    }
    function pushStartGenericElement(target, props, tag, responseState) {
        target.push(startChunkForTag(tag));
        var children = null;
        var innerHTML = null;
        for(var propKey in props)if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) continue;
            switch(propKey){
                case 'children':
                    children = propValue;
                    break;
                case 'dangerouslySetInnerHTML':
                    innerHTML = propValue;
                    break;
                default:
                    pushAttribute(target, responseState, propKey, propValue);
                    break;
            }
        }
        target.push(endOfStartTag);
        pushInnerHTML(target, innerHTML, children);
        if (typeof children === 'string') {
            // Special case children as a string to avoid the unnecessary comment.
            // TODO: Remove this special case after the general optimization is in place.
            target.push(stringToChunk(encodeHTMLTextNode(children)));
            return null;
        }
        return children;
    }
    function pushStartCustomElement(target, props, tag, responseState) {
        target.push(startChunkForTag(tag));
        var children = null;
        var innerHTML = null;
        for(var propKey in props)if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) continue;
            switch(propKey){
                case 'children':
                    children = propValue;
                    break;
                case 'dangerouslySetInnerHTML':
                    innerHTML = propValue;
                    break;
                case 'style':
                    pushStyle(target, responseState, propValue);
                    break;
                case 'suppressContentEditableWarning':
                case 'suppressHydrationWarning':
                    break;
                default:
                    if (isAttributeNameSafe(propKey) && typeof propValue !== 'function' && typeof propValue !== 'symbol') target.push(attributeSeparator, stringToChunk(propKey), attributeAssign, stringToChunk(escapeTextForBrowser(propValue)), attributeEnd);
                    break;
            }
        }
        target.push(endOfStartTag);
        pushInnerHTML(target, innerHTML, children);
        return children;
    }
    var leadingNewline = stringToPrecomputedChunk('\n');
    function pushStartPreformattedElement(target, props, tag, responseState) {
        target.push(startChunkForTag(tag));
        var children = null;
        var innerHTML = null;
        for(var propKey in props)if (hasOwnProperty.call(props, propKey)) {
            var propValue = props[propKey];
            if (propValue == null) continue;
            switch(propKey){
                case 'children':
                    children = propValue;
                    break;
                case 'dangerouslySetInnerHTML':
                    innerHTML = propValue;
                    break;
                default:
                    pushAttribute(target, responseState, propKey, propValue);
                    break;
            }
        }
        target.push(endOfStartTag); // text/html ignores the first character in these tags if it's a newline
        // Prefer to break application/xml over text/html (for now) by adding
        // a newline specifically to get eaten by the parser. (Alternately for
        // textareas, replacing "^\n" with "\r\n" doesn't get eaten, and the first
        // \r is normalized out by HTMLTextAreaElement#value.)
        // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>
        // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>
        // See: <http://www.w3.org/TR/html5/syntax.html#newlines>
        // See: Parsing of "textarea" "listing" and "pre" elements
        //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>
        // TODO: This doesn't deal with the case where the child is an array
        // or component that returns a string.
        if (innerHTML != null) {
            if (children != null) throw new Error('Can only set one of `children` or `props.dangerouslySetInnerHTML`.');
            if (typeof innerHTML !== 'object' || !('__html' in innerHTML)) throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
            var html = innerHTML.__html;
            if (html !== null && html !== undefined) {
                if (typeof html === 'string' && html.length > 0 && html[0] === '\n') target.push(leadingNewline, stringToChunk(html));
                else {
                    checkHtmlStringCoercion(html);
                    target.push(stringToChunk('' + html));
                }
            }
        }
        if (typeof children === 'string' && children[0] === '\n') target.push(leadingNewline);
        return children;
    } // We accept any tag to be rendered but since this gets injected into arbitrary
    // HTML, we want to make sure that it's a safe tag.
    // http://www.w3.org/TR/REC-xml/#NT-Name
    var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/; // Simplified subset
    var validatedTagCache = new Map();
    function startChunkForTag(tag) {
        var tagStartChunk = validatedTagCache.get(tag);
        if (tagStartChunk === undefined) {
            if (!VALID_TAG_REGEX.test(tag)) throw new Error("Invalid tag: " + tag);
            tagStartChunk = stringToPrecomputedChunk('<' + tag);
            validatedTagCache.set(tag, tagStartChunk);
        }
        return tagStartChunk;
    }
    var DOCTYPE = stringToPrecomputedChunk('<!DOCTYPE html>');
    function pushStartInstance(target, type, props, responseState, formatContext) {
        validateProperties(type, props);
        validateProperties$1(type, props);
        validateProperties$2(type, props, null);
        if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) error("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
        if (formatContext.insertionMode !== SVG_MODE && formatContext.insertionMode !== MATHML_MODE) {
            if (type.indexOf('-') === -1 && typeof props.is !== 'string' && type.toLowerCase() !== type) error("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type);
        }
        switch(type){
            // Special tags
            case 'select':
                return pushStartSelect(target, props, responseState);
            case 'option':
                return pushStartOption(target, props, responseState, formatContext);
            case 'textarea':
                return pushStartTextArea(target, props, responseState);
            case 'input':
                return pushInput(target, props, responseState);
            case 'menuitem':
                return pushStartMenuItem(target, props, responseState);
            case 'title':
                return pushStartTitle(target, props, responseState);
            // Newline eating tags
            case 'listing':
            case 'pre':
                return pushStartPreformattedElement(target, props, type, responseState);
            // Omitted close tags
            case 'area':
            case 'base':
            case 'br':
            case 'col':
            case 'embed':
            case 'hr':
            case 'img':
            case 'keygen':
            case 'link':
            case 'meta':
            case 'param':
            case 'source':
            case 'track':
            case 'wbr':
                return pushSelfClosing(target, props, type, responseState);
            // These are reserved SVG and MathML elements, that are never custom elements.
            // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts
            case 'annotation-xml':
            case 'color-profile':
            case 'font-face':
            case 'font-face-src':
            case 'font-face-uri':
            case 'font-face-format':
            case 'font-face-name':
            case 'missing-glyph':
                return pushStartGenericElement(target, props, type, responseState);
            case 'html':
                if (formatContext.insertionMode === ROOT_HTML_MODE) // If we're rendering the html tag and we're at the root (i.e. not in foreignObject)
                // then we also emit the DOCTYPE as part of the root content as a convenience for
                // rendering the whole document.
                target.push(DOCTYPE);
                return pushStartGenericElement(target, props, type, responseState);
            default:
                if (type.indexOf('-') === -1 && typeof props.is !== 'string') // Generic element
                return pushStartGenericElement(target, props, type, responseState);
                else // Custom element
                return pushStartCustomElement(target, props, type, responseState);
        }
    }
    var endTag1 = stringToPrecomputedChunk('</');
    var endTag2 = stringToPrecomputedChunk('>');
    function pushEndInstance(target, type, props) {
        switch(type){
            // Omitted close tags
            // TODO: Instead of repeating this switch we could try to pass a flag from above.
            // That would require returning a tuple. Which might be ok if it gets inlined.
            case 'area':
            case 'base':
            case 'br':
            case 'col':
            case 'embed':
            case 'hr':
            case 'img':
            case 'input':
            case 'keygen':
            case 'link':
            case 'meta':
            case 'param':
            case 'source':
            case 'track':
            case 'wbr':
                break;
            default:
                target.push(endTag1, stringToChunk(type), endTag2);
        }
    }
    function writeCompletedRoot(destination, responseState) {
        var bootstrapChunks = responseState.bootstrapChunks;
        var i = 0;
        for(; i < bootstrapChunks.length - 1; i++)writeChunk(destination, bootstrapChunks[i]);
        if (i < bootstrapChunks.length) return writeChunkAndReturn(destination, bootstrapChunks[i]);
        return true;
    } // Structural Nodes
    // A placeholder is a node inside a hidden partial tree that can be filled in later, but before
    // display. It's never visible to users. We use the template tag because it can be used in every
    // type of parent. <script> tags also work in every other tag except <colgroup>.
    var placeholder1 = stringToPrecomputedChunk('<template id="');
    var placeholder2 = stringToPrecomputedChunk('"></template>');
    function writePlaceholder(destination, responseState, id) {
        writeChunk(destination, placeholder1);
        writeChunk(destination, responseState.placeholderPrefix);
        var formattedID = stringToChunk(id.toString(16));
        writeChunk(destination, formattedID);
        return writeChunkAndReturn(destination, placeholder2);
    } // Suspense boundaries are encoded as comments.
    var startCompletedSuspenseBoundary = stringToPrecomputedChunk('<!--$-->');
    var startPendingSuspenseBoundary1 = stringToPrecomputedChunk('<!--$?--><template id="');
    var startPendingSuspenseBoundary2 = stringToPrecomputedChunk('"></template>');
    var startClientRenderedSuspenseBoundary = stringToPrecomputedChunk('<!--$!-->');
    var endSuspenseBoundary = stringToPrecomputedChunk('<!--/$-->');
    var clientRenderedSuspenseBoundaryError1 = stringToPrecomputedChunk('<template');
    var clientRenderedSuspenseBoundaryErrorAttrInterstitial = stringToPrecomputedChunk('"');
    var clientRenderedSuspenseBoundaryError1A = stringToPrecomputedChunk(' data-dgst="');
    var clientRenderedSuspenseBoundaryError1B = stringToPrecomputedChunk(' data-msg="');
    var clientRenderedSuspenseBoundaryError1C = stringToPrecomputedChunk(' data-stck="');
    var clientRenderedSuspenseBoundaryError2 = stringToPrecomputedChunk('></template>');
    function writeStartCompletedSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, startCompletedSuspenseBoundary);
    }
    function writeStartPendingSuspenseBoundary(destination, responseState, id) {
        writeChunk(destination, startPendingSuspenseBoundary1);
        if (id === null) throw new Error('An ID must have been assigned before we can complete the boundary.');
        writeChunk(destination, id);
        return writeChunkAndReturn(destination, startPendingSuspenseBoundary2);
    }
    function writeStartClientRenderedSuspenseBoundary(destination, responseState, errorDigest, errorMesssage, errorComponentStack) {
        var result;
        result = writeChunkAndReturn(destination, startClientRenderedSuspenseBoundary);
        writeChunk(destination, clientRenderedSuspenseBoundaryError1);
        if (errorDigest) {
            writeChunk(destination, clientRenderedSuspenseBoundaryError1A);
            writeChunk(destination, stringToChunk(escapeTextForBrowser(errorDigest)));
            writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
        }
        if (errorMesssage) {
            writeChunk(destination, clientRenderedSuspenseBoundaryError1B);
            writeChunk(destination, stringToChunk(escapeTextForBrowser(errorMesssage)));
            writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
        }
        if (errorComponentStack) {
            writeChunk(destination, clientRenderedSuspenseBoundaryError1C);
            writeChunk(destination, stringToChunk(escapeTextForBrowser(errorComponentStack)));
            writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
        }
        result = writeChunkAndReturn(destination, clientRenderedSuspenseBoundaryError2);
        return result;
    }
    function writeEndCompletedSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, endSuspenseBoundary);
    }
    function writeEndPendingSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, endSuspenseBoundary);
    }
    function writeEndClientRenderedSuspenseBoundary(destination, responseState) {
        return writeChunkAndReturn(destination, endSuspenseBoundary);
    }
    var startSegmentHTML = stringToPrecomputedChunk('<div hidden id="');
    var startSegmentHTML2 = stringToPrecomputedChunk('">');
    var endSegmentHTML = stringToPrecomputedChunk('</div>');
    var startSegmentSVG = stringToPrecomputedChunk('<svg aria-hidden="true" style="display:none" id="');
    var startSegmentSVG2 = stringToPrecomputedChunk('">');
    var endSegmentSVG = stringToPrecomputedChunk('</svg>');
    var startSegmentMathML = stringToPrecomputedChunk('<math aria-hidden="true" style="display:none" id="');
    var startSegmentMathML2 = stringToPrecomputedChunk('">');
    var endSegmentMathML = stringToPrecomputedChunk('</math>');
    var startSegmentTable = stringToPrecomputedChunk('<table hidden id="');
    var startSegmentTable2 = stringToPrecomputedChunk('">');
    var endSegmentTable = stringToPrecomputedChunk('</table>');
    var startSegmentTableBody = stringToPrecomputedChunk('<table hidden><tbody id="');
    var startSegmentTableBody2 = stringToPrecomputedChunk('">');
    var endSegmentTableBody = stringToPrecomputedChunk('</tbody></table>');
    var startSegmentTableRow = stringToPrecomputedChunk('<table hidden><tr id="');
    var startSegmentTableRow2 = stringToPrecomputedChunk('">');
    var endSegmentTableRow = stringToPrecomputedChunk('</tr></table>');
    var startSegmentColGroup = stringToPrecomputedChunk('<table hidden><colgroup id="');
    var startSegmentColGroup2 = stringToPrecomputedChunk('">');
    var endSegmentColGroup = stringToPrecomputedChunk('</colgroup></table>');
    function writeStartSegment(destination, responseState, formatContext, id) {
        switch(formatContext.insertionMode){
            case ROOT_HTML_MODE:
            case HTML_MODE:
                writeChunk(destination, startSegmentHTML);
                writeChunk(destination, responseState.segmentPrefix);
                writeChunk(destination, stringToChunk(id.toString(16)));
                return writeChunkAndReturn(destination, startSegmentHTML2);
            case SVG_MODE:
                writeChunk(destination, startSegmentSVG);
                writeChunk(destination, responseState.segmentPrefix);
                writeChunk(destination, stringToChunk(id.toString(16)));
                return writeChunkAndReturn(destination, startSegmentSVG2);
            case MATHML_MODE:
                writeChunk(destination, startSegmentMathML);
                writeChunk(destination, responseState.segmentPrefix);
                writeChunk(destination, stringToChunk(id.toString(16)));
                return writeChunkAndReturn(destination, startSegmentMathML2);
            case HTML_TABLE_MODE:
                writeChunk(destination, startSegmentTable);
                writeChunk(destination, responseState.segmentPrefix);
                writeChunk(destination, stringToChunk(id.toString(16)));
                return writeChunkAndReturn(destination, startSegmentTable2);
            // TODO: For the rest of these, there will be extra wrapper nodes that never
            // get deleted from the document. We need to delete the table too as part
            // of the injected scripts. They are invisible though so it's not too terrible
            // and it's kind of an edge case to suspend in a table. Totally supported though.
            case HTML_TABLE_BODY_MODE:
                writeChunk(destination, startSegmentTableBody);
                writeChunk(destination, responseState.segmentPrefix);
                writeChunk(destination, stringToChunk(id.toString(16)));
                return writeChunkAndReturn(destination, startSegmentTableBody2);
            case HTML_TABLE_ROW_MODE:
                writeChunk(destination, startSegmentTableRow);
                writeChunk(destination, responseState.segmentPrefix);
                writeChunk(destination, stringToChunk(id.toString(16)));
                return writeChunkAndReturn(destination, startSegmentTableRow2);
            case HTML_COLGROUP_MODE:
                writeChunk(destination, startSegmentColGroup);
                writeChunk(destination, responseState.segmentPrefix);
                writeChunk(destination, stringToChunk(id.toString(16)));
                return writeChunkAndReturn(destination, startSegmentColGroup2);
            default:
                throw new Error('Unknown insertion mode. This is a bug in React.');
        }
    }
    function writeEndSegment(destination, formatContext) {
        switch(formatContext.insertionMode){
            case ROOT_HTML_MODE:
            case HTML_MODE:
                return writeChunkAndReturn(destination, endSegmentHTML);
            case SVG_MODE:
                return writeChunkAndReturn(destination, endSegmentSVG);
            case MATHML_MODE:
                return writeChunkAndReturn(destination, endSegmentMathML);
            case HTML_TABLE_MODE:
                return writeChunkAndReturn(destination, endSegmentTable);
            case HTML_TABLE_BODY_MODE:
                return writeChunkAndReturn(destination, endSegmentTableBody);
            case HTML_TABLE_ROW_MODE:
                return writeChunkAndReturn(destination, endSegmentTableRow);
            case HTML_COLGROUP_MODE:
                return writeChunkAndReturn(destination, endSegmentColGroup);
            default:
                throw new Error('Unknown insertion mode. This is a bug in React.');
        }
    } // Instruction Set
    // The following code is the source scripts that we then minify and inline below,
    // with renamed function names that we hope don't collide:
    // const COMMENT_NODE = 8;
    // const SUSPENSE_START_DATA = '$';
    // const SUSPENSE_END_DATA = '/$';
    // const SUSPENSE_PENDING_START_DATA = '$?';
    // const SUSPENSE_FALLBACK_START_DATA = '$!';
    //
    // function clientRenderBoundary(suspenseBoundaryID, errorDigest, errorMsg, errorComponentStack) {
    //   // Find the fallback's first element.
    //   const suspenseIdNode = document.getElementById(suspenseBoundaryID);
    //   if (!suspenseIdNode) {
    //     // The user must have already navigated away from this tree.
    //     // E.g. because the parent was hydrated.
    //     return;
    //   }
    //   // Find the boundary around the fallback. This is always the previous node.
    //   const suspenseNode = suspenseIdNode.previousSibling;
    //   // Tag it to be client rendered.
    //   suspenseNode.data = SUSPENSE_FALLBACK_START_DATA;
    //   // assign error metadata to first sibling
    //   let dataset = suspenseIdNode.dataset;
    //   if (errorDigest) dataset.dgst = errorDigest;
    //   if (errorMsg) dataset.msg = errorMsg;
    //   if (errorComponentStack) dataset.stck = errorComponentStack;
    //   // Tell React to retry it if the parent already hydrated.
    //   if (suspenseNode._reactRetry) {
    //     suspenseNode._reactRetry();
    //   }
    // }
    //
    // function completeBoundary(suspenseBoundaryID, contentID) {
    //   // Find the fallback's first element.
    //   const suspenseIdNode = document.getElementById(suspenseBoundaryID);
    //   const contentNode = document.getElementById(contentID);
    //   // We'll detach the content node so that regardless of what happens next we don't leave in the tree.
    //   // This might also help by not causing recalcing each time we move a child from here to the target.
    //   contentNode.parentNode.removeChild(contentNode);
    //   if (!suspenseIdNode) {
    //     // The user must have already navigated away from this tree.
    //     // E.g. because the parent was hydrated. That's fine there's nothing to do
    //     // but we have to make sure that we already deleted the container node.
    //     return;
    //   }
    //   // Find the boundary around the fallback. This is always the previous node.
    //   const suspenseNode = suspenseIdNode.previousSibling;
    //
    //   // Clear all the existing children. This is complicated because
    //   // there can be embedded Suspense boundaries in the fallback.
    //   // This is similar to clearSuspenseBoundary in ReactDOMHostConfig.
    //   // TODO: We could avoid this if we never emitted suspense boundaries in fallback trees.
    //   // They never hydrate anyway. However, currently we support incrementally loading the fallback.
    //   const parentInstance = suspenseNode.parentNode;
    //   let node = suspenseNode.nextSibling;
    //   let depth = 0;
    //   do {
    //     if (node && node.nodeType === COMMENT_NODE) {
    //       const data = node.data;
    //       if (data === SUSPENSE_END_DATA) {
    //         if (depth === 0) {
    //           break;
    //         } else {
    //           depth--;
    //         }
    //       } else if (
    //         data === SUSPENSE_START_DATA ||
    //         data === SUSPENSE_PENDING_START_DATA ||
    //         data === SUSPENSE_FALLBACK_START_DATA
    //       ) {
    //         depth++;
    //       }
    //     }
    //
    //     const nextNode = node.nextSibling;
    //     parentInstance.removeChild(node);
    //     node = nextNode;
    //   } while (node);
    //
    //   const endOfBoundary = node;
    //
    //   // Insert all the children from the contentNode between the start and end of suspense boundary.
    //   while (contentNode.firstChild) {
    //     parentInstance.insertBefore(contentNode.firstChild, endOfBoundary);
    //   }
    //   suspenseNode.data = SUSPENSE_START_DATA;
    //   if (suspenseNode._reactRetry) {
    //     suspenseNode._reactRetry();
    //   }
    // }
    //
    // function completeSegment(containerID, placeholderID) {
    //   const segmentContainer = document.getElementById(containerID);
    //   const placeholderNode = document.getElementById(placeholderID);
    //   // We always expect both nodes to exist here because, while we might
    //   // have navigated away from the main tree, we still expect the detached
    //   // tree to exist.
    //   segmentContainer.parentNode.removeChild(segmentContainer);
    //   while (segmentContainer.firstChild) {
    //     placeholderNode.parentNode.insertBefore(
    //       segmentContainer.firstChild,
    //       placeholderNode,
    //     );
    //   }
    //   placeholderNode.parentNode.removeChild(placeholderNode);
    // }
    var completeSegmentFunction = 'function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}';
    var completeBoundaryFunction = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}';
    var clientRenderFunction = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}';
    var completeSegmentScript1Full = stringToPrecomputedChunk(completeSegmentFunction + ';$RS("');
    var completeSegmentScript1Partial = stringToPrecomputedChunk('$RS("');
    var completeSegmentScript2 = stringToPrecomputedChunk('","');
    var completeSegmentScript3 = stringToPrecomputedChunk('")</script>');
    function writeCompletedSegmentInstruction(destination, responseState, contentSegmentID) {
        writeChunk(destination, responseState.startInlineScript);
        if (!responseState.sentCompleteSegmentFunction) {
            // The first time we write this, we'll need to include the full implementation.
            responseState.sentCompleteSegmentFunction = true;
            writeChunk(destination, completeSegmentScript1Full);
        } else // Future calls can just reuse the same function.
        writeChunk(destination, completeSegmentScript1Partial);
        writeChunk(destination, responseState.segmentPrefix);
        var formattedID = stringToChunk(contentSegmentID.toString(16));
        writeChunk(destination, formattedID);
        writeChunk(destination, completeSegmentScript2);
        writeChunk(destination, responseState.placeholderPrefix);
        writeChunk(destination, formattedID);
        return writeChunkAndReturn(destination, completeSegmentScript3);
    }
    var completeBoundaryScript1Full = stringToPrecomputedChunk(completeBoundaryFunction + ';$RC("');
    var completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC("');
    var completeBoundaryScript2 = stringToPrecomputedChunk('","');
    var completeBoundaryScript3 = stringToPrecomputedChunk('")</script>');
    function writeCompletedBoundaryInstruction(destination, responseState, boundaryID, contentSegmentID) {
        writeChunk(destination, responseState.startInlineScript);
        if (!responseState.sentCompleteBoundaryFunction) {
            // The first time we write this, we'll need to include the full implementation.
            responseState.sentCompleteBoundaryFunction = true;
            writeChunk(destination, completeBoundaryScript1Full);
        } else // Future calls can just reuse the same function.
        writeChunk(destination, completeBoundaryScript1Partial);
        if (boundaryID === null) throw new Error('An ID must have been assigned before we can complete the boundary.');
        var formattedContentID = stringToChunk(contentSegmentID.toString(16));
        writeChunk(destination, boundaryID);
        writeChunk(destination, completeBoundaryScript2);
        writeChunk(destination, responseState.segmentPrefix);
        writeChunk(destination, formattedContentID);
        return writeChunkAndReturn(destination, completeBoundaryScript3);
    }
    var clientRenderScript1Full = stringToPrecomputedChunk(clientRenderFunction + ';$RX("');
    var clientRenderScript1Partial = stringToPrecomputedChunk('$RX("');
    var clientRenderScript1A = stringToPrecomputedChunk('"');
    var clientRenderScript2 = stringToPrecomputedChunk(')</script>');
    var clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(',');
    function writeClientRenderBoundaryInstruction(destination, responseState, boundaryID, errorDigest, errorMessage, errorComponentStack) {
        writeChunk(destination, responseState.startInlineScript);
        if (!responseState.sentClientRenderFunction) {
            // The first time we write this, we'll need to include the full implementation.
            responseState.sentClientRenderFunction = true;
            writeChunk(destination, clientRenderScript1Full);
        } else // Future calls can just reuse the same function.
        writeChunk(destination, clientRenderScript1Partial);
        if (boundaryID === null) throw new Error('An ID must have been assigned before we can complete the boundary.');
        writeChunk(destination, boundaryID);
        writeChunk(destination, clientRenderScript1A);
        if (errorDigest || errorMessage || errorComponentStack) {
            writeChunk(destination, clientRenderErrorScriptArgInterstitial);
            writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorDigest || '')));
        }
        if (errorMessage || errorComponentStack) {
            writeChunk(destination, clientRenderErrorScriptArgInterstitial);
            writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorMessage || '')));
        }
        if (errorComponentStack) {
            writeChunk(destination, clientRenderErrorScriptArgInterstitial);
            writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorComponentStack)));
        }
        return writeChunkAndReturn(destination, clientRenderScript2);
    }
    var regexForJSStringsInScripts = /[<\u2028\u2029]/g;
    function escapeJSStringsForInstructionScripts(input) {
        var escaped = JSON.stringify(input);
        return escaped.replace(regexForJSStringsInScripts, function(match) {
            switch(match){
                // santizing breaking out of strings and script tags
                case '<':
                    return "\\u003c";
                case "\u2028":
                    return "\\u2028";
                case "\u2029":
                    return "\\u2029";
                default:
                    // eslint-disable-next-line react-internal/prod-error-codes
                    throw new Error('escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React');
            }
        });
    }
    var assign = Object.assign;
    // ATTENTION
    // When adding new symbols to this file,
    // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
    // The Symbol used to tag the ReactElement-like types.
    var REACT_ELEMENT_TYPE = Symbol.for('react.element');
    var REACT_PORTAL_TYPE = Symbol.for('react.portal');
    var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
    var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');
    var REACT_PROFILER_TYPE = Symbol.for('react.profiler');
    var REACT_PROVIDER_TYPE = Symbol.for('react.provider');
    var REACT_CONTEXT_TYPE = Symbol.for('react.context');
    var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
    var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');
    var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');
    var REACT_MEMO_TYPE = Symbol.for('react.memo');
    var REACT_LAZY_TYPE = Symbol.for('react.lazy');
    var REACT_SCOPE_TYPE = Symbol.for('react.scope');
    var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for('react.debug_trace_mode');
    var REACT_LEGACY_HIDDEN_TYPE = Symbol.for('react.legacy_hidden');
    var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for('react.default_value');
    var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = '@@iterator';
    function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable !== 'object') return null;
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        if (typeof maybeIterator === 'function') return maybeIterator;
        return null;
    }
    function getWrappedName(outerType, innerType, wrapperName) {
        var displayName = outerType.displayName;
        if (displayName) return displayName;
        var functionName = innerType.displayName || innerType.name || '';
        return functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName;
    } // Keep in sync with react-reconciler/getComponentNameFromFiber
    function getContextName(type) {
        return type.displayName || 'Context';
    } // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.
    function getComponentNameFromType(type) {
        if (type == null) // Host root, text node or just invalid type.
        return null;
        if (typeof type.tag === 'number') error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
        if (typeof type === 'function') return type.displayName || type.name || null;
        if (typeof type === 'string') return type;
        switch(type){
            case REACT_FRAGMENT_TYPE:
                return 'Fragment';
            case REACT_PORTAL_TYPE:
                return 'Portal';
            case REACT_PROFILER_TYPE:
                return 'Profiler';
            case REACT_STRICT_MODE_TYPE:
                return 'StrictMode';
            case REACT_SUSPENSE_TYPE:
                return 'Suspense';
            case REACT_SUSPENSE_LIST_TYPE:
                return 'SuspenseList';
        }
        if (typeof type === 'object') switch(type.$$typeof){
            case REACT_CONTEXT_TYPE:
                var context = type;
                return getContextName(context) + '.Consumer';
            case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + '.Provider';
            case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, 'ForwardRef');
            case REACT_MEMO_TYPE:
                var outerName = type.displayName || null;
                if (outerName !== null) return outerName;
                return getComponentNameFromType(type.type) || 'Memo';
            case REACT_LAZY_TYPE:
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                    return getComponentNameFromType(init(payload));
                } catch (x) {
                    return null;
                }
        }
        return null;
    }
    // Helpers to patch console.logs to avoid logging during side-effect free
    // replaying on render function. This currently only patches the object
    // lazily which won't cover if the log function was extracted eagerly.
    // We could also eagerly patch the method.
    var disabledDepth = 0;
    var prevLog;
    var prevInfo;
    var prevWarn;
    var prevError;
    var prevGroup;
    var prevGroupCollapsed;
    var prevGroupEnd;
    function disabledLog() {}
    disabledLog.__reactDisabledLog = true;
    function disableLogs() {
        if (disabledDepth === 0) {
            /* eslint-disable react-internal/no-production-logging */ prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099
            var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
            }; // $FlowFixMe Flow thinks console is immutable.
            Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
            });
        /* eslint-enable react-internal/no-production-logging */ }
        disabledDepth++;
    }
    function reenableLogs() {
        disabledDepth--;
        if (disabledDepth === 0) {
            /* eslint-disable react-internal/no-production-logging */ var props = {
                configurable: true,
                enumerable: true,
                writable: true
            }; // $FlowFixMe Flow thinks console is immutable.
            Object.defineProperties(console, {
                log: assign({}, props, {
                    value: prevLog
                }),
                info: assign({}, props, {
                    value: prevInfo
                }),
                warn: assign({}, props, {
                    value: prevWarn
                }),
                error: assign({}, props, {
                    value: prevError
                }),
                group: assign({}, props, {
                    value: prevGroup
                }),
                groupCollapsed: assign({}, props, {
                    value: prevGroupCollapsed
                }),
                groupEnd: assign({}, props, {
                    value: prevGroupEnd
                })
            });
        /* eslint-enable react-internal/no-production-logging */ }
        if (disabledDepth < 0) error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
    }
    var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
    var prefix;
    function describeBuiltInComponentFrame(name, source, ownerFn) {
        if (prefix === undefined) // Extract the VM specific prefix used by each line.
        try {
            throw Error();
        } catch (x) {
            var match = x.stack.trim().match(/\n( *(at )?)/);
            prefix = match && match[1] || '';
        }
         // We use the prefix to ensure our stacks line up with native stack frames.
        return '\n' + prefix + name;
    }
    var reentry = false;
    var componentFrameCache;
    var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
    componentFrameCache = new PossiblyWeakMap();
    function describeNativeComponentFrame(fn, construct) {
        // If something asked for a stack inside a fake render, it should get ignored.
        if (!fn || reentry) return '';
        var frame = componentFrameCache.get(fn);
        if (frame !== undefined) return frame;
        var control;
        reentry = true;
        var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.
        Error.prepareStackTrace = undefined;
        var previousDispatcher;
        previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function
        // for warnings.
        ReactCurrentDispatcher.current = null;
        disableLogs();
        try {
            // This should throw.
            if (construct) {
                // Something should be setting the props in the constructor.
                var Fake = function() {
                    throw Error();
                }; // $FlowFixMe
                Object.defineProperty(Fake.prototype, 'props', {
                    set: function() {
                        // We use a throwing setter instead of frozen or non-writable props
                        // because that won't throw in a non-strict mode function.
                        throw Error();
                    }
                });
                if (typeof Reflect === 'object' && Reflect.construct) {
                    // We construct a different control for this case to include any extra
                    // frames added by the construct call.
                    try {
                        Reflect.construct(Fake, []);
                    } catch (x) {
                        control = x;
                    }
                    Reflect.construct(fn, [], Fake);
                } else {
                    try {
                        Fake.call();
                    } catch (x) {
                        control = x;
                    }
                    fn.call(Fake.prototype);
                }
            } else {
                try {
                    throw Error();
                } catch (x) {
                    control = x;
                }
                fn();
            }
        } catch (sample) {
            // This is inlined manually because closure doesn't do it for us.
            if (sample && control && typeof sample.stack === 'string') {
                // This extracts the first frame from the sample that isn't also in the control.
                // Skipping one frame that we assume is the frame that calls the two.
                var sampleLines = sample.stack.split('\n');
                var controlLines = control.stack.split('\n');
                var s = sampleLines.length - 1;
                var c = controlLines.length - 1;
                while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c])// We expect at least one stack frame to be shared.
                // Typically this will be the root most one. However, stack frames may be
                // cut off due to maximum stack limits. In this case, one maybe cut off
                // earlier than the other. We assume that the sample is longer or the same
                // and there for cut off earlier. So we should find the root most frame in
                // the sample somewhere in the control.
                c--;
                for(; s >= 1 && c >= 0; s--, c--)// Next we find the first one that isn't the same which should be the
                // frame that called our sample function and the control.
                if (sampleLines[s] !== controlLines[c]) {
                    // In V8, the first line is describing the message but other VMs don't.
                    // If we're about to return the first line, and the control is also on the same
                    // line, that's a pretty good indicator that our sample threw at same line as
                    // the control. I.e. before we entered the sample frame. So we ignore this result.
                    // This can happen if you passed a class to function component, or non-function.
                    if (s !== 1 || c !== 1) do {
                        s--;
                        c--; // We may still have similar intermediate frames from the construct call.
                        // The next one that isn't the same should be our match though.
                        if (c < 0 || sampleLines[s] !== controlLines[c]) {
                            // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                            var _frame = '\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled "<anonymous>"
                            // but we have a user-provided "displayName"
                            // splice it in to make the stack more readable.
                            if (fn.displayName && _frame.includes('<anonymous>')) _frame = _frame.replace('<anonymous>', fn.displayName);
                            if (typeof fn === 'function') componentFrameCache.set(fn, _frame);
                            return _frame;
                        }
                    }while (s >= 1 && c >= 0)
                    break;
                }
            }
        } finally{
            reentry = false;
            ReactCurrentDispatcher.current = previousDispatcher;
            reenableLogs();
            Error.prepareStackTrace = previousPrepareStackTrace;
        } // Fallback to just using the name if we couldn't make it throw.
        var name = fn ? fn.displayName || fn.name : '';
        var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';
        if (typeof fn === 'function') componentFrameCache.set(fn, syntheticFrame);
        return syntheticFrame;
    }
    function describeClassComponentFrame(ctor, source, ownerFn) {
        return describeNativeComponentFrame(ctor, true);
    }
    function describeFunctionComponentFrame(fn, source, ownerFn) {
        return describeNativeComponentFrame(fn, false);
    }
    function shouldConstruct(Component) {
        var prototype = Component.prototype;
        return !!(prototype && prototype.isReactComponent);
    }
    function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
        if (type == null) return '';
        if (typeof type === 'function') return describeNativeComponentFrame(type, shouldConstruct(type));
        if (typeof type === 'string') return describeBuiltInComponentFrame(type);
        switch(type){
            case REACT_SUSPENSE_TYPE:
                return describeBuiltInComponentFrame('Suspense');
            case REACT_SUSPENSE_LIST_TYPE:
                return describeBuiltInComponentFrame('SuspenseList');
        }
        if (typeof type === 'object') switch(type.$$typeof){
            case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
            case REACT_MEMO_TYPE:
                // Memo may contain any component type so we recursively resolve it.
                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
            case REACT_LAZY_TYPE:
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                    // Lazy may contain any component type so we recursively resolve it.
                    return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                } catch (x) {}
        }
        return '';
    }
    var loggedTypeFailures = {};
    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    function setCurrentlyValidatingElement(element) {
        if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame.setExtraStackFrame(stack);
        } else ReactDebugCurrentFrame.setExtraStackFrame(null);
    }
    function checkPropTypes(typeSpecs, values, location, componentName, element) {
        // $FlowFixMe This is okay but Flow doesn't know it.
        var has = Function.call.bind(hasOwnProperty);
        for(var typeSpecName in typeSpecs)if (has(typeSpecs, typeSpecName)) {
            var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
            // fail the render phase where it didn't fail before. So we log it.
            // After these have been cleaned up, we'll let them throw.
            try {
                // This is intentionally an invariant that gets caught. It's the same
                // behavior as without this statement except with a better message.
                if (typeof typeSpecs[typeSpecName] !== 'function') {
                    // eslint-disable-next-line react-internal/prod-error-codes
                    var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
                    err.name = 'Invariant Violation';
                    throw err;
                }
                error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
            } catch (ex) {
                error$1 = ex;
            }
            if (error$1 && !(error$1 instanceof Error)) {
                setCurrentlyValidatingElement(element);
                error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || 'React class', location, typeSpecName, typeof error$1);
                setCurrentlyValidatingElement(null);
            }
            if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                // Only monitor this failure once because there tends to be a lot of the
                // same error.
                loggedTypeFailures[error$1.message] = true;
                setCurrentlyValidatingElement(element);
                error('Failed %s type: %s', location, error$1.message);
                setCurrentlyValidatingElement(null);
            }
        }
    }
    var warnedAboutMissingGetChildContext;
    warnedAboutMissingGetChildContext = {};
    var emptyContextObject = {};
    Object.freeze(emptyContextObject);
    function getMaskedContext(type, unmaskedContext) {
        var contextTypes = type.contextTypes;
        if (!contextTypes) return emptyContextObject;
        var context = {};
        for(var key in contextTypes)context[key] = unmaskedContext[key];
        var name = getComponentNameFromType(type) || 'Unknown';
        checkPropTypes(contextTypes, context, 'context', name);
        return context;
    }
    function processChildContext(instance, type, parentContext, childContextTypes) {
        // TODO (bvaughn) Replace this behavior with an invariant() in the future.
        // It has only been added in Fiber to match the (unintentional) behavior in Stack.
        if (typeof instance.getChildContext !== 'function') {
            var componentName = getComponentNameFromType(type) || 'Unknown';
            if (!warnedAboutMissingGetChildContext[componentName]) {
                warnedAboutMissingGetChildContext[componentName] = true;
                error("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", componentName, componentName);
            }
            return parentContext;
        }
        var childContext = instance.getChildContext();
        for(var contextKey in childContext){
            if (!(contextKey in childContextTypes)) throw new Error((getComponentNameFromType(type) || 'Unknown') + ".getChildContext(): key \"" + contextKey + "\" is not defined in childContextTypes.");
        }
        var name = getComponentNameFromType(type) || 'Unknown';
        checkPropTypes(childContextTypes, childContext, 'child context', name);
        return assign({}, parentContext, childContext);
    }
    var rendererSigil;
    // Use this to detect multiple renderers using the same context
    rendererSigil = {};
    // Forming a reverse tree.
    var rootContextSnapshot = null; // We assume that this runtime owns the "current" field on all ReactContext instances.
    // This global (actually thread local) state represents what state all those "current",
    // fields are currently in.
    var currentActiveSnapshot = null;
    function popNode(prev) {
        prev.context._currentValue = prev.parentValue;
    }
    function pushNode(next) {
        next.context._currentValue = next.value;
    }
    function popToNearestCommonAncestor(prev, next) {
        if (prev === next) ;
        else {
            popNode(prev);
            var parentPrev = prev.parent;
            var parentNext = next.parent;
            if (parentPrev === null) {
                if (parentNext !== null) throw new Error('The stacks must reach the root at the same time. This is a bug in React.');
            } else {
                if (parentNext === null) throw new Error('The stacks must reach the root at the same time. This is a bug in React.');
                popToNearestCommonAncestor(parentPrev, parentNext);
            } // On the way back, we push the new ones that weren't common.
            pushNode(next);
        }
    }
    function popAllPrevious(prev) {
        popNode(prev);
        var parentPrev = prev.parent;
        if (parentPrev !== null) popAllPrevious(parentPrev);
    }
    function pushAllNext(next) {
        var parentNext = next.parent;
        if (parentNext !== null) pushAllNext(parentNext);
        pushNode(next);
    }
    function popPreviousToCommonLevel(prev, next) {
        popNode(prev);
        var parentPrev = prev.parent;
        if (parentPrev === null) throw new Error('The depth must equal at least at zero before reaching the root. This is a bug in React.');
        if (parentPrev.depth === next.depth) // We found the same level. Now we just need to find a shared ancestor.
        popToNearestCommonAncestor(parentPrev, next);
        else // We must still be deeper.
        popPreviousToCommonLevel(parentPrev, next);
    }
    function popNextToCommonLevel(prev, next) {
        var parentNext = next.parent;
        if (parentNext === null) throw new Error('The depth must equal at least at zero before reaching the root. This is a bug in React.');
        if (prev.depth === parentNext.depth) // We found the same level. Now we just need to find a shared ancestor.
        popToNearestCommonAncestor(prev, parentNext);
        else // We must still be deeper.
        popNextToCommonLevel(prev, parentNext);
        pushNode(next);
    } // Perform context switching to the new snapshot.
    // To make it cheap to read many contexts, while not suspending, we make the switch eagerly by
    // updating all the context's current values. That way reads, always just read the current value.
    // At the cost of updating contexts even if they're never read by this subtree.
    function switchContext(newSnapshot) {
        // The basic algorithm we need to do is to pop back any contexts that are no longer on the stack.
        // We also need to update any new contexts that are now on the stack with the deepest value.
        // The easiest way to update new contexts is to just reapply them in reverse order from the
        // perspective of the backpointers. To avoid allocating a lot when switching, we use the stack
        // for that. Therefore this algorithm is recursive.
        // 1) First we pop which ever snapshot tree was deepest. Popping old contexts as we go.
        // 2) Then we find the nearest common ancestor from there. Popping old contexts as we go.
        // 3) Then we reapply new contexts on the way back up the stack.
        var prev = currentActiveSnapshot;
        var next = newSnapshot;
        if (prev !== next) {
            if (prev === null) // $FlowFixMe: This has to be non-null since it's not equal to prev.
            pushAllNext(next);
            else if (next === null) popAllPrevious(prev);
            else if (prev.depth === next.depth) popToNearestCommonAncestor(prev, next);
            else if (prev.depth > next.depth) popPreviousToCommonLevel(prev, next);
            else popNextToCommonLevel(prev, next);
            currentActiveSnapshot = next;
        }
    }
    function pushProvider(context, nextValue) {
        var prevValue;
        prevValue = context._currentValue;
        context._currentValue = nextValue;
        if (context._currentRenderer !== undefined && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
        context._currentRenderer = rendererSigil;
        var prevNode = currentActiveSnapshot;
        var newNode = {
            parent: prevNode,
            depth: prevNode === null ? 0 : prevNode.depth + 1,
            context: context,
            parentValue: prevValue,
            value: nextValue
        };
        currentActiveSnapshot = newNode;
        return newNode;
    }
    function popProvider(context) {
        var prevSnapshot = currentActiveSnapshot;
        if (prevSnapshot === null) throw new Error('Tried to pop a Context at the root of the app. This is a bug in React.');
        if (prevSnapshot.context !== context) error('The parent context is not the expected context. This is probably a bug in React.');
        var value = prevSnapshot.parentValue;
        if (value === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) prevSnapshot.context._currentValue = prevSnapshot.context._defaultValue;
        else prevSnapshot.context._currentValue = value;
        if (context._currentRenderer !== undefined && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
        context._currentRenderer = rendererSigil;
        return currentActiveSnapshot = prevSnapshot.parent;
    }
    function getActiveContext() {
        return currentActiveSnapshot;
    }
    function readContext(context) {
        var value = context._currentValue;
        return value;
    }
    /**
 * `ReactInstanceMap` maintains a mapping from a public facing stateful
 * instance (key) and the internal representation (value). This allows public
 * methods to accept the user facing instance as an argument and map them back
 * to internal methods.
 *
 * Note that this module is currently shared and assumed to be stateless.
 * If this becomes an actual Map, that will break.
 */ function get(key) {
        return key._reactInternals;
    }
    function set(key, value) {
        key._reactInternals = value;
    }
    var didWarnAboutNoopUpdateForComponent = {};
    var didWarnAboutDeprecatedWillMount = {};
    var didWarnAboutUninitializedState;
    var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
    var didWarnAboutLegacyLifecyclesAndDerivedState;
    var didWarnAboutUndefinedDerivedState;
    var warnOnUndefinedDerivedState;
    var warnOnInvalidCallback;
    var didWarnAboutDirectlyAssigningPropsToState;
    var didWarnAboutContextTypeAndContextTypes;
    var didWarnAboutInvalidateContextType;
    didWarnAboutUninitializedState = new Set();
    didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();
    didWarnAboutLegacyLifecyclesAndDerivedState = new Set();
    didWarnAboutDirectlyAssigningPropsToState = new Set();
    didWarnAboutUndefinedDerivedState = new Set();
    didWarnAboutContextTypeAndContextTypes = new Set();
    didWarnAboutInvalidateContextType = new Set();
    var didWarnOnInvalidCallback = new Set();
    warnOnInvalidCallback = function(callback, callerName) {
        if (callback === null || typeof callback === 'function') return;
        var key = callerName + '_' + callback;
        if (!didWarnOnInvalidCallback.has(key)) {
            didWarnOnInvalidCallback.add(key);
            error("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
        }
    };
    warnOnUndefinedDerivedState = function(type, partialState) {
        if (partialState === undefined) {
            var componentName = getComponentNameFromType(type) || 'Component';
            if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
                didWarnAboutUndefinedDerivedState.add(componentName);
                error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName);
            }
        }
    };
    function warnNoop(publicInstance, callerName) {
        var _constructor = publicInstance.constructor;
        var componentName = _constructor && getComponentNameFromType(_constructor) || 'ReactClass';
        var warningKey = componentName + '.' + callerName;
        if (didWarnAboutNoopUpdateForComponent[warningKey]) return;
        error("%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.\n\nPlease check the code for the %s component.", callerName, callerName, componentName);
        didWarnAboutNoopUpdateForComponent[warningKey] = true;
    }
    var classComponentUpdater = {
        isMounted: function(inst) {
            return false;
        },
        enqueueSetState: function(inst, payload, callback) {
            var internals = get(inst);
            if (internals.queue === null) warnNoop(inst, 'setState');
            else {
                internals.queue.push(payload);
                if (callback !== undefined && callback !== null) warnOnInvalidCallback(callback, 'setState');
            }
        },
        enqueueReplaceState: function(inst, payload, callback) {
            var internals = get(inst);
            internals.replace = true;
            internals.queue = [
                payload
            ];
            if (callback !== undefined && callback !== null) warnOnInvalidCallback(callback, 'setState');
        },
        enqueueForceUpdate: function(inst, callback) {
            var internals = get(inst);
            if (internals.queue === null) warnNoop(inst, 'forceUpdate');
            else if (callback !== undefined && callback !== null) warnOnInvalidCallback(callback, 'setState');
        }
    };
    function applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, prevState, nextProps) {
        var partialState = getDerivedStateFromProps(nextProps, prevState);
        warnOnUndefinedDerivedState(ctor, partialState);
        var newState = partialState === null || partialState === undefined ? prevState : assign({}, prevState, partialState);
        return newState;
    }
    function constructClassInstance(ctor, props, maskedLegacyContext) {
        var context = emptyContextObject;
        var contextType = ctor.contextType;
        if ('contextType' in ctor) {
            var isValid = contextType === null || contextType !== undefined && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === undefined; // Not a <Context.Consumer>
            if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {
                didWarnAboutInvalidateContextType.add(ctor);
                var addendum = '';
                if (contextType === undefined) addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.";
                else if (typeof contextType !== 'object') addendum = ' However, it is set to a ' + typeof contextType + '.';
                else if (contextType.$$typeof === REACT_PROVIDER_TYPE) addendum = ' Did you accidentally pass the Context.Provider instead?';
                else if (contextType._context !== undefined) // <Context.Consumer>
                addendum = ' Did you accidentally pass the Context.Consumer instead?';
                else addendum = ' However, it is set to an object with keys {' + Object.keys(contextType).join(', ') + '}.';
                error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(ctor) || 'Component', addendum);
            }
        }
        if (typeof contextType === 'object' && contextType !== null) context = readContext(contextType);
        else context = maskedLegacyContext;
        var instance = new ctor(props, context);
        if (typeof ctor.getDerivedStateFromProps === 'function' && (instance.state === null || instance.state === undefined)) {
            var componentName = getComponentNameFromType(ctor) || 'Component';
            if (!didWarnAboutUninitializedState.has(componentName)) {
                didWarnAboutUninitializedState.add(componentName);
                error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? 'null' : 'undefined', componentName);
            }
        } // If new component APIs are defined, "unsafe" lifecycles won't be called.
        // Warn about these lifecycles if they are present.
        // Don't warn about react-lifecycles-compat polyfilled methods though.
        if (typeof ctor.getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function') {
            var foundWillMountName = null;
            var foundWillReceivePropsName = null;
            var foundWillUpdateName = null;
            if (typeof instance.componentWillMount === 'function' && instance.componentWillMount.__suppressDeprecationWarning !== true) foundWillMountName = 'componentWillMount';
            else if (typeof instance.UNSAFE_componentWillMount === 'function') foundWillMountName = 'UNSAFE_componentWillMount';
            if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) foundWillReceivePropsName = 'componentWillReceiveProps';
            else if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';
            if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true) foundWillUpdateName = 'componentWillUpdate';
            else if (typeof instance.UNSAFE_componentWillUpdate === 'function') foundWillUpdateName = 'UNSAFE_componentWillUpdate';
            if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
                var _componentName = getComponentNameFromType(ctor) || 'Component';
                var newApiName = typeof ctor.getDerivedStateFromProps === 'function' ? 'getDerivedStateFromProps()' : 'getSnapshotBeforeUpdate()';
                if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
                    didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
                    error("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://reactjs.org/link/unsafe-component-lifecycles", _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : '', foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : '', foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : '');
                }
            }
        }
        return instance;
    }
    function checkClassInstance(instance, ctor, newProps) {
        var name = getComponentNameFromType(ctor) || 'Component';
        var renderPresent = instance.render;
        if (!renderPresent) {
            if (ctor.prototype && typeof ctor.prototype.render === 'function') error("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", name);
            else error("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", name);
        }
        if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) error("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name);
        if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) error("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name);
        if (instance.propTypes) error("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", name);
        if (instance.contextType) error("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name);
        if (instance.contextTypes) error("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", name);
        if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
            didWarnAboutContextTypeAndContextTypes.add(ctor);
            error("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", name);
        }
        if (typeof instance.componentShouldUpdate === 'function') error("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name);
        if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== 'undefined') error("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(ctor) || 'A pure component');
        if (typeof instance.componentDidUnmount === 'function') error("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name);
        if (typeof instance.componentDidReceiveProps === 'function') error("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name);
        if (typeof instance.componentWillRecieveProps === 'function') error("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name);
        if (typeof instance.UNSAFE_componentWillRecieveProps === 'function') error("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name);
        var hasMutatedProps = instance.props !== newProps;
        if (instance.props !== undefined && hasMutatedProps) error("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name, name);
        if (instance.defaultProps) error("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name, name);
        if (typeof instance.getSnapshotBeforeUpdate === 'function' && typeof instance.componentDidUpdate !== 'function' && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
            error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(ctor));
        }
        if (typeof instance.getDerivedStateFromProps === 'function') error("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
        if (typeof instance.getDerivedStateFromError === 'function') error("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
        if (typeof ctor.getSnapshotBeforeUpdate === 'function') error("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name);
        var _state = instance.state;
        if (_state && (typeof _state !== 'object' || isArray(_state))) error('%s.state: must be set to an object or null', name);
        if (typeof instance.getChildContext === 'function' && typeof ctor.childContextTypes !== 'object') error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name);
    }
    function callComponentWillMount(type, instance) {
        var oldState = instance.state;
        if (typeof instance.componentWillMount === 'function') {
            if (instance.componentWillMount.__suppressDeprecationWarning !== true) {
                var componentName = getComponentNameFromType(type) || 'Unknown';
                if (!didWarnAboutDeprecatedWillMount[componentName]) {
                    warn("componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.\n\nPlease update the following components: %s", componentName);
                    didWarnAboutDeprecatedWillMount[componentName] = true;
                }
            }
            instance.componentWillMount();
        }
        if (typeof instance.UNSAFE_componentWillMount === 'function') instance.UNSAFE_componentWillMount();
        if (oldState !== instance.state) {
            error("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromType(type) || 'Component');
            classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
        }
    }
    function processUpdateQueue(internalInstance, inst, props, maskedLegacyContext) {
        if (internalInstance.queue !== null && internalInstance.queue.length > 0) {
            var oldQueue = internalInstance.queue;
            var oldReplace = internalInstance.replace;
            internalInstance.queue = null;
            internalInstance.replace = false;
            if (oldReplace && oldQueue.length === 1) inst.state = oldQueue[0];
            else {
                var nextState = oldReplace ? oldQueue[0] : inst.state;
                var dontMutate = true;
                for(var i = oldReplace ? 1 : 0; i < oldQueue.length; i++){
                    var partial = oldQueue[i];
                    var partialState = typeof partial === 'function' ? partial.call(inst, nextState, props, maskedLegacyContext) : partial;
                    if (partialState != null) {
                        if (dontMutate) {
                            dontMutate = false;
                            nextState = assign({}, nextState, partialState);
                        } else assign(nextState, partialState);
                    }
                }
                inst.state = nextState;
            }
        } else internalInstance.queue = null;
    } // Invokes the mount life-cycles on a previously never rendered instance.
    function mountClassInstance(instance, ctor, newProps, maskedLegacyContext) {
        checkClassInstance(instance, ctor, newProps);
        var initialState = instance.state !== undefined ? instance.state : null;
        instance.updater = classComponentUpdater;
        instance.props = newProps;
        instance.state = initialState; // We don't bother initializing the refs object on the server, since we're not going to resolve them anyway.
        // The internal instance will be used to manage updates that happen during this mount.
        var internalInstance = {
            queue: [],
            replace: false
        };
        set(instance, internalInstance);
        var contextType = ctor.contextType;
        if (typeof contextType === 'object' && contextType !== null) instance.context = readContext(contextType);
        else instance.context = maskedLegacyContext;
        if (instance.state === newProps) {
            var componentName = getComponentNameFromType(ctor) || 'Component';
            if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
                didWarnAboutDirectlyAssigningPropsToState.add(componentName);
                error("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName);
            }
        }
        var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
        if (typeof getDerivedStateFromProps === 'function') instance.state = applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, initialState, newProps);
         // In order to support react-lifecycles-compat polyfilled components,
        // Unsafe lifecycles should not be invoked for components using the new APIs.
        if (typeof ctor.getDerivedStateFromProps !== 'function' && typeof instance.getSnapshotBeforeUpdate !== 'function' && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {
            callComponentWillMount(ctor, instance); // If we had additional state updates during this life-cycle, let's
            // process them now.
            processUpdateQueue(internalInstance, instance, newProps, maskedLegacyContext);
        }
    }
    // Ids are base 32 strings whose binary representation corresponds to the
    // position of a node in a tree.
    // Every time the tree forks into multiple children, we add additional bits to
    // the left of the sequence that represent the position of the child within the
    // current level of children.
    //
    //      00101       00010001011010101
    //             
    //   Fork 5 of 20       Parent id
    //
    // The leading 0s are important. In the above example, you only need 3 bits to
    // represent slot 5. However, you need 5 bits to represent all the forks at
    // the current level, so we must account for the empty bits at the end.
    //
    // For this same reason, slots are 1-indexed instead of 0-indexed. Otherwise,
    // the zeroth id at a level would be indistinguishable from its parent.
    //
    // If a node has only one child, and does not materialize an id (i.e. does not
    // contain a useId hook), then we don't need to allocate any space in the
    // sequence. It's treated as a transparent indirection. For example, these two
    // trees produce the same ids:
    //
    // <>                          <>
    //   <Indirection>               <A />
    //     <A />                     <B />
    //   </Indirection>            </>
    //   <B />
    // </>
    //
    // However, we cannot skip any node that materializes an id. Otherwise, a parent
    // id that does not fork would be indistinguishable from its child id. For
    // example, this tree does not fork, but the parent and child must have
    // different ids.
    //
    // <Parent>
    //   <Child />
    // </Parent>
    //
    // To handle this scenario, every time we materialize an id, we allocate a
    // new level with a single slot. You can think of this as a fork with only one
    // prong, or an array of children with length 1.
    //
    // It's possible for the size of the sequence to exceed 32 bits, the max
    // size for bitwise operations. When this happens, we make more room by
    // converting the right part of the id to a string and storing it in an overflow
    // variable. We use a base 32 string representation, because 32 is the largest
    // power of 2 that is supported by toString(). We want the base to be large so
    // that the resulting ids are compact, and we want the base to be a power of 2
    // because every log2(base) bits corresponds to a single character, i.e. every
    // log2(32) = 5 bits. That means we can lop bits off the end 5 at a time without
    // affecting the final result.
    var emptyTreeContext = {
        id: 1,
        overflow: ''
    };
    function getTreeId(context) {
        var overflow = context.overflow;
        var idWithLeadingBit = context.id;
        var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);
        return id.toString(32) + overflow;
    }
    function pushTreeContext(baseContext, totalChildren, index) {
        var baseIdWithLeadingBit = baseContext.id;
        var baseOverflow = baseContext.overflow; // The leftmost 1 marks the end of the sequence, non-inclusive. It's not part
        // of the id; we use it to account for leading 0s.
        var baseLength = getBitLength(baseIdWithLeadingBit) - 1;
        var baseId = baseIdWithLeadingBit & ~(1 << baseLength);
        var slot = index + 1;
        var length = getBitLength(totalChildren) + baseLength; // 30 is the max length we can store without overflowing, taking into
        // consideration the leading 1 we use to mark the end of the sequence.
        if (length > 30) {
            // We overflowed the bitwise-safe range. Fall back to slower algorithm.
            // This branch assumes the length of the base id is greater than 5; it won't
            // work for smaller ids, because you need 5 bits per character.
            //
            // We encode the id in multiple steps: first the base id, then the
            // remaining digits.
            //
            // Each 5 bit sequence corresponds to a single base 32 character. So for
            // example, if the current id is 23 bits long, we can convert 20 of those
            // bits into a string of 4 characters, with 3 bits left over.
            //
            // First calculate how many bits in the base id represent a complete
            // sequence of characters.
            var numberOfOverflowBits = baseLength - baseLength % 5; // Then create a bitmask that selects only those bits.
            var newOverflowBits = (1 << numberOfOverflowBits) - 1; // Select the bits, and convert them to a base 32 string.
            var newOverflow = (baseId & newOverflowBits).toString(32); // Now we can remove those bits from the base id.
            var restOfBaseId = baseId >> numberOfOverflowBits;
            var restOfBaseLength = baseLength - numberOfOverflowBits; // Finally, encode the rest of the bits using the normal algorithm. Because
            // we made more room, this time it won't overflow.
            var restOfLength = getBitLength(totalChildren) + restOfBaseLength;
            var restOfNewBits = slot << restOfBaseLength;
            var id = restOfNewBits | restOfBaseId;
            var overflow = newOverflow + baseOverflow;
            return {
                id: 1 << restOfLength | id,
                overflow: overflow
            };
        } else {
            // Normal path
            var newBits = slot << baseLength;
            var _id = newBits | baseId;
            var _overflow = baseOverflow;
            return {
                id: 1 << length | _id,
                overflow: _overflow
            };
        }
    }
    function getBitLength(number) {
        return 32 - clz32(number);
    }
    function getLeadingBit(id) {
        return 1 << getBitLength(id) - 1;
    } // TODO: Math.clz32 is supported in Node 12+. Maybe we can drop the fallback.
    var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback; // Count leading zeros.
    // Based on:
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32
    var log = Math.log;
    var LN2 = Math.LN2;
    function clz32Fallback(x) {
        var asUint = x >>> 0;
        if (asUint === 0) return 32;
        return 31 - (log(asUint) / LN2 | 0) | 0;
    }
    /**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */ function is(x, y) {
        return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare
        ;
    }
    var objectIs = typeof Object.is === 'function' ? Object.is : is;
    var currentlyRenderingComponent = null;
    var currentlyRenderingTask = null;
    var firstWorkInProgressHook = null;
    var workInProgressHook = null; // Whether the work-in-progress hook is a re-rendered hook
    var isReRender = false; // Whether an update was scheduled during the currently executing render pass.
    var didScheduleRenderPhaseUpdate = false; // Counts the number of useId hooks in this component
    var localIdCounter = 0; // Lazily created map of render-phase updates
    var renderPhaseUpdates = null; // Counter to prevent infinite loops.
    var numberOfReRenders = 0;
    var RE_RENDER_LIMIT = 25;
    var isInHookUserCodeInDev = false; // In DEV, this is the name of the currently executing primitive hook
    var currentHookNameInDev;
    function resolveCurrentlyRenderingComponent() {
        if (currentlyRenderingComponent === null) throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
        if (isInHookUserCodeInDev) error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
        return currentlyRenderingComponent;
    }
    function areHookInputsEqual(nextDeps, prevDeps) {
        if (prevDeps === null) {
            error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev);
            return false;
        }
        // Don't bother comparing lengths in prod because these arrays should be
        // passed inline.
        if (nextDeps.length !== prevDeps.length) error("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + nextDeps.join(', ') + "]", "[" + prevDeps.join(', ') + "]");
        for(var i = 0; i < prevDeps.length && i < nextDeps.length; i++){
            if (objectIs(nextDeps[i], prevDeps[i])) continue;
            return false;
        }
        return true;
    }
    function createHook() {
        if (numberOfReRenders > 0) throw new Error('Rendered more hooks than during the previous render');
        return {
            memoizedState: null,
            queue: null,
            next: null
        };
    }
    function createWorkInProgressHook() {
        if (workInProgressHook === null) {
            // This is the first hook in the list
            if (firstWorkInProgressHook === null) {
                isReRender = false;
                firstWorkInProgressHook = workInProgressHook = createHook();
            } else {
                // There's already a work-in-progress. Reuse it.
                isReRender = true;
                workInProgressHook = firstWorkInProgressHook;
            }
        } else if (workInProgressHook.next === null) {
            isReRender = false; // Append to the end of the list
            workInProgressHook = workInProgressHook.next = createHook();
        } else {
            // There's already a work-in-progress. Reuse it.
            isReRender = true;
            workInProgressHook = workInProgressHook.next;
        }
        return workInProgressHook;
    }
    function prepareToUseHooks(task, componentIdentity) {
        currentlyRenderingComponent = componentIdentity;
        currentlyRenderingTask = task;
        isInHookUserCodeInDev = false;
        // didScheduleRenderPhaseUpdate = false;
        // localIdCounter = 0;
        // firstWorkInProgressHook = null;
        // numberOfReRenders = 0;
        // renderPhaseUpdates = null;
        // workInProgressHook = null;
        localIdCounter = 0;
    }
    function finishHooks(Component, props, children, refOrContext) {
        // This must be called after every function component to prevent hooks from
        // being used in classes.
        while(didScheduleRenderPhaseUpdate){
            // Updates were scheduled during the render phase. They are stored in
            // the `renderPhaseUpdates` map. Call the component again, reusing the
            // work-in-progress hooks and applying the additional updates on top. Keep
            // restarting until no more updates are scheduled.
            didScheduleRenderPhaseUpdate = false;
            localIdCounter = 0;
            numberOfReRenders += 1; // Start over from the beginning of the list
            workInProgressHook = null;
            children = Component(props, refOrContext);
        }
        resetHooksState();
        return children;
    }
    function checkDidRenderIdHook() {
        // This should be called immediately after every finishHooks call.
        // Conceptually, it's part of the return value of finishHooks; it's only a
        // separate function to avoid using an array tuple.
        var didRenderIdHook = localIdCounter !== 0;
        return didRenderIdHook;
    } // Reset the internal hooks state if an error occurs while rendering a component
    function resetHooksState() {
        isInHookUserCodeInDev = false;
        currentlyRenderingComponent = null;
        currentlyRenderingTask = null;
        didScheduleRenderPhaseUpdate = false;
        firstWorkInProgressHook = null;
        numberOfReRenders = 0;
        renderPhaseUpdates = null;
        workInProgressHook = null;
    }
    function readContext$1(context) {
        if (isInHookUserCodeInDev) error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
        return readContext(context);
    }
    function useContext(context) {
        currentHookNameInDev = 'useContext';
        resolveCurrentlyRenderingComponent();
        return readContext(context);
    }
    function basicStateReducer(state, action) {
        // $FlowFixMe: Flow doesn't like mixed types
        return typeof action === 'function' ? action(state) : action;
    }
    function useState(initialState) {
        currentHookNameInDev = 'useState';
        return useReducer(basicStateReducer, initialState);
    }
    function useReducer(reducer, initialArg, init) {
        if (reducer !== basicStateReducer) currentHookNameInDev = 'useReducer';
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
        workInProgressHook = createWorkInProgressHook();
        if (isReRender) {
            // This is a re-render. Apply the new render phase updates to the previous
            // current hook.
            var queue = workInProgressHook.queue;
            var dispatch = queue.dispatch;
            if (renderPhaseUpdates !== null) {
                // Render phase updates are stored in a map of queue -> linked list
                var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
                if (firstRenderPhaseUpdate !== undefined) {
                    renderPhaseUpdates.delete(queue);
                    var newState = workInProgressHook.memoizedState;
                    var update = firstRenderPhaseUpdate;
                    do {
                        // Process this render phase update. We don't have to check the
                        // priority because it will always be the same as the current
                        // render's.
                        var action = update.action;
                        isInHookUserCodeInDev = true;
                        newState = reducer(newState, action);
                        isInHookUserCodeInDev = false;
                        update = update.next;
                    }while (update !== null)
                    workInProgressHook.memoizedState = newState;
                    return [
                        newState,
                        dispatch
                    ];
                }
            }
            return [
                workInProgressHook.memoizedState,
                dispatch
            ];
        } else {
            isInHookUserCodeInDev = true;
            var initialState;
            if (reducer === basicStateReducer) // Special case for `useState`.
            initialState = typeof initialArg === 'function' ? initialArg() : initialArg;
            else initialState = init !== undefined ? init(initialArg) : initialArg;
            isInHookUserCodeInDev = false;
            workInProgressHook.memoizedState = initialState;
            var _queue = workInProgressHook.queue = {
                last: null,
                dispatch: null
            };
            var _dispatch = _queue.dispatch = dispatchAction.bind(null, currentlyRenderingComponent, _queue);
            return [
                workInProgressHook.memoizedState,
                _dispatch
            ];
        }
    }
    function useMemo(nextCreate, deps) {
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
        workInProgressHook = createWorkInProgressHook();
        var nextDeps = deps === undefined ? null : deps;
        if (workInProgressHook !== null) {
            var prevState = workInProgressHook.memoizedState;
            if (prevState !== null) {
                if (nextDeps !== null) {
                    var prevDeps = prevState[1];
                    if (areHookInputsEqual(nextDeps, prevDeps)) return prevState[0];
                }
            }
        }
        isInHookUserCodeInDev = true;
        var nextValue = nextCreate();
        isInHookUserCodeInDev = false;
        workInProgressHook.memoizedState = [
            nextValue,
            nextDeps
        ];
        return nextValue;
    }
    function useRef(initialValue) {
        currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
        workInProgressHook = createWorkInProgressHook();
        var previousRef = workInProgressHook.memoizedState;
        if (previousRef === null) {
            var ref = {
                current: initialValue
            };
            Object.seal(ref);
            workInProgressHook.memoizedState = ref;
            return ref;
        } else return previousRef;
    }
    function useLayoutEffect(create, inputs) {
        currentHookNameInDev = 'useLayoutEffect';
        error("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
    }
    function dispatchAction(componentIdentity, queue, action) {
        if (numberOfReRenders >= RE_RENDER_LIMIT) throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
        if (componentIdentity === currentlyRenderingComponent) {
            // This is a render phase update. Stash it in a lazily-created map of
            // queue -> linked list of updates. After this render pass, we'll restart
            // and apply the stashed updates on top of the work-in-progress hook.
            didScheduleRenderPhaseUpdate = true;
            var update = {
                action: action,
                next: null
            };
            if (renderPhaseUpdates === null) renderPhaseUpdates = new Map();
            var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
            if (firstRenderPhaseUpdate === undefined) renderPhaseUpdates.set(queue, update);
            else {
                // Append the update to the end of the list.
                var lastRenderPhaseUpdate = firstRenderPhaseUpdate;
                while(lastRenderPhaseUpdate.next !== null)lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
                lastRenderPhaseUpdate.next = update;
            }
        }
    }
    function useCallback(callback, deps) {
        return useMemo(function() {
            return callback;
        }, deps);
    } // TODO Decide on how to implement this hook for server rendering.
    // If a mutation occurs during render, consider triggering a Suspense boundary
    // and falling back to client rendering.
    function useMutableSource(source, getSnapshot, subscribe) {
        resolveCurrentlyRenderingComponent();
        return getSnapshot(source._source);
    }
    function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
        if (getServerSnapshot === undefined) throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        return getServerSnapshot();
    }
    function useDeferredValue(value) {
        resolveCurrentlyRenderingComponent();
        return value;
    }
    function unsupportedStartTransition() {
        throw new Error('startTransition cannot be called during server rendering.');
    }
    function useTransition() {
        resolveCurrentlyRenderingComponent();
        return [
            false,
            unsupportedStartTransition
        ];
    }
    function useId() {
        var task = currentlyRenderingTask;
        var treeId = getTreeId(task.treeContext);
        var responseState = currentResponseState;
        if (responseState === null) throw new Error('Invalid hook call. Hooks can only be called inside of the body of a function component.');
        var localId = localIdCounter++;
        return makeId(responseState, treeId, localId);
    }
    function noop() {}
    var Dispatcher = {
        readContext: readContext$1,
        useContext: useContext,
        useMemo: useMemo,
        useReducer: useReducer,
        useRef: useRef,
        useState: useState,
        useInsertionEffect: noop,
        useLayoutEffect: useLayoutEffect,
        useCallback: useCallback,
        // useImperativeHandle is not run in the server environment
        useImperativeHandle: noop,
        // Effects are not run in the server environment.
        useEffect: noop,
        // Debugging effect
        useDebugValue: noop,
        useDeferredValue: useDeferredValue,
        useTransition: useTransition,
        useId: useId,
        // Subscriptions are not setup in a server environment.
        useMutableSource: useMutableSource,
        useSyncExternalStore: useSyncExternalStore
    };
    var currentResponseState = null;
    function setCurrentResponseState(responseState) {
        currentResponseState = responseState;
    }
    function getStackByComponentStackNode(componentStack) {
        try {
            var info = '';
            var node = componentStack;
            do {
                switch(node.tag){
                    case 0:
                        info += describeBuiltInComponentFrame(node.type, null, null);
                        break;
                    case 1:
                        info += describeFunctionComponentFrame(node.type, null, null);
                        break;
                    case 2:
                        info += describeClassComponentFrame(node.type, null, null);
                        break;
                }
                node = node.parent;
            }while (node)
            return info;
        } catch (x) {
            return '\nError generating stack: ' + x.message + '\n' + x.stack;
        }
    }
    var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
    var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
    var PENDING = 0;
    var COMPLETED = 1;
    var FLUSHED = 2;
    var ABORTED = 3;
    var ERRORED = 4;
    var OPEN = 0;
    var CLOSING = 1;
    var CLOSED = 2;
    // This is a default heuristic for how to split up the HTML content into progressive
    // loading. Our goal is to be able to display additional new content about every 500ms.
    // Faster than that is unnecessary and should be throttled on the client. It also
    // adds unnecessary overhead to do more splits. We don't know if it's a higher or lower
    // end device but higher end suffer less from the overhead than lower end does from
    // not getting small enough pieces. We error on the side of low end.
    // We base this on low end 3G speeds which is about 500kbits per second. We assume
    // that there can be a reasonable drop off from max bandwidth which leaves you with
    // as little as 80%. We can receive half of that each 500ms - at best. In practice,
    // a little bandwidth is lost to processing and contention - e.g. CSS and images that
    // are downloaded along with the main content. So we estimate about half of that to be
    // the lower end throughput. In other words, we expect that you can at least show
    // about 12.5kb of content per 500ms. Not counting starting latency for the first
    // paint.
    // 500 * 1024 / 8 * .8 * 0.5 / 2
    var DEFAULT_PROGRESSIVE_CHUNK_SIZE = 12800;
    function defaultErrorHandler(error) {
        console['error'](error); // Don't transform to our wrapper
        return null;
    }
    function noop$1() {}
    function createRequest(children, responseState, rootFormatContext, progressiveChunkSize, onError, onAllReady, onShellReady, onShellError, onFatalError) {
        var pingedTasks = [];
        var abortSet = new Set();
        var request = {
            destination: null,
            responseState: responseState,
            progressiveChunkSize: progressiveChunkSize === undefined ? DEFAULT_PROGRESSIVE_CHUNK_SIZE : progressiveChunkSize,
            status: OPEN,
            fatalError: null,
            nextSegmentId: 0,
            allPendingTasks: 0,
            pendingRootTasks: 0,
            completedRootSegment: null,
            abortableTasks: abortSet,
            pingedTasks: pingedTasks,
            clientRenderedBoundaries: [],
            completedBoundaries: [],
            partialBoundaries: [],
            onError: onError === undefined ? defaultErrorHandler : onError,
            onAllReady: onAllReady === undefined ? noop$1 : onAllReady,
            onShellReady: onShellReady === undefined ? noop$1 : onShellReady,
            onShellError: onShellError === undefined ? noop$1 : onShellError,
            onFatalError: onFatalError === undefined ? noop$1 : onFatalError
        }; // This segment represents the root fallback.
        var rootSegment = createPendingSegment(request, 0, null, rootFormatContext, false, false); // There is no parent so conceptually, we're unblocked to flush this segment.
        rootSegment.parentFlushed = true;
        var rootTask = createTask(request, children, null, rootSegment, abortSet, emptyContextObject, rootContextSnapshot, emptyTreeContext);
        pingedTasks.push(rootTask);
        return request;
    }
    function pingTask(request, task) {
        var pingedTasks = request.pingedTasks;
        pingedTasks.push(task);
        if (pingedTasks.length === 1) scheduleWork(function() {
            return performWork(request);
        });
    }
    function createSuspenseBoundary(request, fallbackAbortableTasks) {
        return {
            id: UNINITIALIZED_SUSPENSE_BOUNDARY_ID,
            rootSegmentID: -1,
            parentFlushed: false,
            pendingTasks: 0,
            forceClientRender: false,
            completedSegments: [],
            byteSize: 0,
            fallbackAbortableTasks: fallbackAbortableTasks,
            errorDigest: null
        };
    }
    function createTask(request, node, blockedBoundary, blockedSegment, abortSet, legacyContext, context, treeContext) {
        request.allPendingTasks++;
        if (blockedBoundary === null) request.pendingRootTasks++;
        else blockedBoundary.pendingTasks++;
        var task = {
            node: node,
            ping: function() {
                return pingTask(request, task);
            },
            blockedBoundary: blockedBoundary,
            blockedSegment: blockedSegment,
            abortSet: abortSet,
            legacyContext: legacyContext,
            context: context,
            treeContext: treeContext
        };
        task.componentStack = null;
        abortSet.add(task);
        return task;
    }
    function createPendingSegment(request, index, boundary, formatContext, lastPushedText, textEmbedded) {
        return {
            status: PENDING,
            id: -1,
            // lazily assigned later
            index: index,
            parentFlushed: false,
            chunks: [],
            children: [],
            formatContext: formatContext,
            boundary: boundary,
            lastPushedText: lastPushedText,
            textEmbedded: textEmbedded
        };
    } // DEV-only global reference to the currently executing task
    var currentTaskInDEV = null;
    function getCurrentStackInDEV() {
        if (currentTaskInDEV === null || currentTaskInDEV.componentStack === null) return '';
        return getStackByComponentStackNode(currentTaskInDEV.componentStack);
    }
    function pushBuiltInComponentStackInDEV(task, type) {
        task.componentStack = {
            tag: 0,
            parent: task.componentStack,
            type: type
        };
    }
    function pushFunctionComponentStackInDEV(task, type) {
        task.componentStack = {
            tag: 1,
            parent: task.componentStack,
            type: type
        };
    }
    function pushClassComponentStackInDEV(task, type) {
        task.componentStack = {
            tag: 2,
            parent: task.componentStack,
            type: type
        };
    }
    function popComponentStackInDEV(task) {
        if (task.componentStack === null) error('Unexpectedly popped too many stack frames. This is a bug in React.');
        else task.componentStack = task.componentStack.parent;
    } // stash the component stack of an unwinding error until it is processed
    var lastBoundaryErrorComponentStackDev = null;
    function captureBoundaryErrorDetailsDev(boundary, error) {
        var errorMessage;
        if (typeof error === 'string') errorMessage = error;
        else if (error && typeof error.message === 'string') errorMessage = error.message;
        else // eslint-disable-next-line react-internal/safe-string-coercion
        errorMessage = String(error);
        var errorComponentStack = lastBoundaryErrorComponentStackDev || getCurrentStackInDEV();
        lastBoundaryErrorComponentStackDev = null;
        boundary.errorMessage = errorMessage;
        boundary.errorComponentStack = errorComponentStack;
    }
    function logRecoverableError(request, error) {
        // If this callback errors, we intentionally let that error bubble up to become a fatal error
        // so that someone fixes the error reporting instead of hiding it.
        var errorDigest = request.onError(error);
        if (errorDigest != null && typeof errorDigest !== 'string') // eslint-disable-next-line react-internal/prod-error-codes
        throw new Error("onError returned something with a type other than \"string\". onError should return a string and may return null or undefined but must not return anything else. It received something of type \"" + typeof errorDigest + "\" instead");
        return errorDigest;
    }
    function fatalError(request, error) {
        // This is called outside error handling code such as if the root errors outside
        // a suspense boundary or if the root suspense boundary's fallback errors.
        // It's also called if React itself or its host configs errors.
        var onShellError = request.onShellError;
        onShellError(error);
        var onFatalError = request.onFatalError;
        onFatalError(error);
        if (request.destination !== null) {
            request.status = CLOSED;
            closeWithError(request.destination, error);
        } else {
            request.status = CLOSING;
            request.fatalError = error;
        }
    }
    function renderSuspenseBoundary(request, task, props) {
        pushBuiltInComponentStackInDEV(task, 'Suspense');
        var parentBoundary = task.blockedBoundary;
        var parentSegment = task.blockedSegment; // Each time we enter a suspense boundary, we split out into a new segment for
        // the fallback so that we can later replace that segment with the content.
        // This also lets us split out the main content even if it doesn't suspend,
        // in case it ends up generating a large subtree of content.
        var fallback = props.fallback;
        var content = props.children;
        var fallbackAbortSet = new Set();
        var newBoundary = createSuspenseBoundary(request, fallbackAbortSet);
        var insertionIndex = parentSegment.chunks.length; // The children of the boundary segment is actually the fallback.
        var boundarySegment = createPendingSegment(request, insertionIndex, newBoundary, parentSegment.formatContext, false, false);
        parentSegment.children.push(boundarySegment); // The parentSegment has a child Segment at this index so we reset the lastPushedText marker on the parent
        parentSegment.lastPushedText = false; // This segment is the actual child content. We can start rendering that immediately.
        var contentRootSegment = createPendingSegment(request, 0, null, parentSegment.formatContext, false, false); // We mark the root segment as having its parent flushed. It's not really flushed but there is
        // no parent segment so there's nothing to wait on.
        contentRootSegment.parentFlushed = true; // Currently this is running synchronously. We could instead schedule this to pingedTasks.
        // I suspect that there might be some efficiency benefits from not creating the suspended task
        // and instead just using the stack if possible.
        // TODO: Call this directly instead of messing with saving and restoring contexts.
        // We can reuse the current context and task to render the content immediately without
        // context switching. We just need to temporarily switch which boundary and which segment
        // we're writing to. If something suspends, it'll spawn new suspended task with that context.
        task.blockedBoundary = newBoundary;
        task.blockedSegment = contentRootSegment;
        try {
            // We use the safe form because we don't handle suspending here. Only error handling.
            renderNode(request, task, content);
            pushSegmentFinale(contentRootSegment.chunks, request.responseState, contentRootSegment.lastPushedText, contentRootSegment.textEmbedded);
            contentRootSegment.status = COMPLETED;
            queueCompletedSegment(newBoundary, contentRootSegment);
            if (newBoundary.pendingTasks === 0) {
                // This must have been the last segment we were waiting on. This boundary is now complete.
                // Therefore we won't need the fallback. We early return so that we don't have to create
                // the fallback.
                popComponentStackInDEV(task);
                return;
            }
        } catch (error) {
            contentRootSegment.status = ERRORED;
            newBoundary.forceClientRender = true;
            newBoundary.errorDigest = logRecoverableError(request, error);
            captureBoundaryErrorDetailsDev(newBoundary, error);
        // We don't need to schedule any task because we know the parent has written yet.
        // We do need to fallthrough to create the fallback though.
        } finally{
            task.blockedBoundary = parentBoundary;
            task.blockedSegment = parentSegment;
        } // We create suspended task for the fallback because we don't want to actually work
        // on it yet in case we finish the main content, so we queue for later.
        var suspendedFallbackTask = createTask(request, fallback, parentBoundary, boundarySegment, fallbackAbortSet, task.legacyContext, task.context, task.treeContext);
        suspendedFallbackTask.componentStack = task.componentStack;
        // on preparing fallbacks if we don't have any more main content to task on.
        request.pingedTasks.push(suspendedFallbackTask);
        popComponentStackInDEV(task);
    }
    function renderHostElement(request, task, type, props) {
        pushBuiltInComponentStackInDEV(task, type);
        var segment = task.blockedSegment;
        var children = pushStartInstance(segment.chunks, type, props, request.responseState, segment.formatContext);
        segment.lastPushedText = false;
        var prevContext = segment.formatContext;
        segment.formatContext = getChildFormatContext(prevContext, type, props); // We use the non-destructive form because if something suspends, we still
        // need to pop back up and finish this subtree of HTML.
        renderNode(request, task, children); // We expect that errors will fatal the whole task and that we don't need
        // the correct context. Therefore this is not in a finally.
        segment.formatContext = prevContext;
        pushEndInstance(segment.chunks, type);
        segment.lastPushedText = false;
        popComponentStackInDEV(task);
    }
    function shouldConstruct$1(Component) {
        return Component.prototype && Component.prototype.isReactComponent;
    }
    function renderWithHooks(request, task, Component, props, secondArg) {
        var componentIdentity = {};
        prepareToUseHooks(task, componentIdentity);
        var result = Component(props, secondArg);
        return finishHooks(Component, props, result, secondArg);
    }
    function finishClassComponent(request, task, instance, Component, props) {
        var nextChildren = instance.render();
        if (instance.props !== props) {
            if (!didWarnAboutReassigningProps) error("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromType(Component) || 'a component');
            didWarnAboutReassigningProps = true;
        }
        var childContextTypes = Component.childContextTypes;
        if (childContextTypes !== null && childContextTypes !== undefined) {
            var previousContext = task.legacyContext;
            var mergedContext = processChildContext(instance, Component, previousContext, childContextTypes);
            task.legacyContext = mergedContext;
            renderNodeDestructive(request, task, nextChildren);
            task.legacyContext = previousContext;
            return;
        }
        renderNodeDestructive(request, task, nextChildren);
    }
    function renderClassComponent(request, task, Component, props) {
        pushClassComponentStackInDEV(task, Component);
        var maskedContext = getMaskedContext(Component, task.legacyContext);
        var instance = constructClassInstance(Component, props, maskedContext);
        mountClassInstance(instance, Component, props, maskedContext);
        finishClassComponent(request, task, instance, Component, props);
        popComponentStackInDEV(task);
    }
    var didWarnAboutBadClass = {};
    var didWarnAboutModulePatternComponent = {};
    var didWarnAboutContextTypeOnFunctionComponent = {};
    var didWarnAboutGetDerivedStateOnFunctionComponent = {};
    var didWarnAboutReassigningProps = false;
    var didWarnAboutDefaultPropsOnFunctionComponent = {};
    var didWarnAboutGenerators = false;
    var didWarnAboutMaps = false;
    var hasWarnedAboutUsingContextAsConsumer = false; // This would typically be a function component but we still support module pattern
    // components for some reason.
    function renderIndeterminateComponent(request, task, Component, props) {
        var legacyContext;
        legacyContext = getMaskedContext(Component, task.legacyContext);
        pushFunctionComponentStackInDEV(task, Component);
        if (Component.prototype && typeof Component.prototype.render === 'function') {
            var componentName = getComponentNameFromType(Component) || 'Unknown';
            if (!didWarnAboutBadClass[componentName]) {
                error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName);
                didWarnAboutBadClass[componentName] = true;
            }
        }
        var value = renderWithHooks(request, task, Component, props, legacyContext);
        var hasId = checkDidRenderIdHook();
        // Support for module components is deprecated and is removed behind a flag.
        // Whether or not it would crash later, we want to show a good message in DEV first.
        if (typeof value === 'object' && value !== null && typeof value.render === 'function' && value.$$typeof === undefined) {
            var _componentName = getComponentNameFromType(Component) || 'Unknown';
            if (!didWarnAboutModulePatternComponent[_componentName]) {
                error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName, _componentName, _componentName);
                didWarnAboutModulePatternComponent[_componentName] = true;
            }
        }
        if (// Eventually we'll delete this branch altogether.
        typeof value === 'object' && value !== null && typeof value.render === 'function' && value.$$typeof === undefined) {
            var _componentName2 = getComponentNameFromType(Component) || 'Unknown';
            if (!didWarnAboutModulePatternComponent[_componentName2]) {
                error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName2, _componentName2, _componentName2);
                didWarnAboutModulePatternComponent[_componentName2] = true;
            }
            mountClassInstance(value, Component, props, legacyContext);
            finishClassComponent(request, task, value, Component, props);
        } else {
            validateFunctionComponentInDev(Component);
            // the previous task every again, so we can use the destructive recursive form.
            if (hasId) {
                // This component materialized an id. We treat this as its own level, with
                // a single "child" slot.
                var prevTreeContext = task.treeContext;
                var totalChildren = 1;
                var index = 0;
                task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index);
                try {
                    renderNodeDestructive(request, task, value);
                } finally{
                    task.treeContext = prevTreeContext;
                }
            } else renderNodeDestructive(request, task, value);
        }
        popComponentStackInDEV(task);
    }
    function validateFunctionComponentInDev(Component) {
        if (Component) {
            if (Component.childContextTypes) error('%s(...): childContextTypes cannot be defined on a function component.', Component.displayName || Component.name || 'Component');
        }
        if (Component.defaultProps !== undefined) {
            var componentName = getComponentNameFromType(Component) || 'Unknown';
            if (!didWarnAboutDefaultPropsOnFunctionComponent[componentName]) {
                error("%s: Support for defaultProps will be removed from function components in a future major release. Use JavaScript default parameters instead.", componentName);
                didWarnAboutDefaultPropsOnFunctionComponent[componentName] = true;
            }
        }
        if (typeof Component.getDerivedStateFromProps === 'function') {
            var _componentName3 = getComponentNameFromType(Component) || 'Unknown';
            if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
                error('%s: Function components do not support getDerivedStateFromProps.', _componentName3);
                didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;
            }
        }
        if (typeof Component.contextType === 'object' && Component.contextType !== null) {
            var _componentName4 = getComponentNameFromType(Component) || 'Unknown';
            if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
                error('%s: Function components do not support contextType.', _componentName4);
                didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;
            }
        }
    }
    function resolveDefaultProps(Component, baseProps) {
        if (Component && Component.defaultProps) {
            // Resolve default props. Taken from ReactElement
            var props = assign({}, baseProps);
            var defaultProps = Component.defaultProps;
            for(var propName in defaultProps)if (props[propName] === undefined) props[propName] = defaultProps[propName];
            return props;
        }
        return baseProps;
    }
    function renderForwardRef(request, task, type, props, ref) {
        pushFunctionComponentStackInDEV(task, type.render);
        var children = renderWithHooks(request, task, type.render, props, ref);
        var hasId = checkDidRenderIdHook();
        if (hasId) {
            // This component materialized an id. We treat this as its own level, with
            // a single "child" slot.
            var prevTreeContext = task.treeContext;
            var totalChildren = 1;
            var index = 0;
            task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index);
            try {
                renderNodeDestructive(request, task, children);
            } finally{
                task.treeContext = prevTreeContext;
            }
        } else renderNodeDestructive(request, task, children);
        popComponentStackInDEV(task);
    }
    function renderMemo(request, task, type, props, ref) {
        var innerType = type.type;
        var resolvedProps = resolveDefaultProps(innerType, props);
        renderElement(request, task, innerType, resolvedProps, ref);
    }
    function renderContextConsumer(request, task, context, props) {
        if (context._context === undefined) {
            // This may be because it's a Context (rather than a Consumer).
            // Or it may be because it's older React where they're the same thing.
            // We only want to warn if we're sure it's a new React.
            if (context !== context.Consumer) {
                if (!hasWarnedAboutUsingContextAsConsumer) {
                    hasWarnedAboutUsingContextAsConsumer = true;
                    error("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                }
            }
        } else context = context._context;
        var render = props.children;
        if (typeof render !== 'function') error("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
        var newValue = readContext(context);
        var newChildren = render(newValue);
        renderNodeDestructive(request, task, newChildren);
    }
    function renderContextProvider(request, task, type, props) {
        var context = type._context;
        var value = props.value;
        var children = props.children;
        var prevSnapshot;
        prevSnapshot = task.context;
        task.context = pushProvider(context, value);
        renderNodeDestructive(request, task, children);
        task.context = popProvider(context);
        if (prevSnapshot !== task.context) error('Popping the context provider did not return back to the original snapshot. This is a bug in React.');
    }
    function renderLazyComponent(request, task, lazyComponent, props, ref) {
        pushBuiltInComponentStackInDEV(task, 'Lazy');
        var payload = lazyComponent._payload;
        var init = lazyComponent._init;
        var Component = init(payload);
        var resolvedProps = resolveDefaultProps(Component, props);
        renderElement(request, task, Component, resolvedProps, ref);
        popComponentStackInDEV(task);
    }
    function renderElement(request, task, type, props, ref) {
        if (typeof type === 'function') {
            if (shouldConstruct$1(type)) {
                renderClassComponent(request, task, type, props);
                return;
            } else {
                renderIndeterminateComponent(request, task, type, props);
                return;
            }
        }
        if (typeof type === 'string') {
            renderHostElement(request, task, type, props);
            return;
        }
        switch(type){
            // TODO: LegacyHidden acts the same as a fragment. This only works
            // because we currently assume that every instance of LegacyHidden is
            // accompanied by a host component wrapper. In the hidden mode, the host
            // component is given a `hidden` attribute, which ensures that the
            // initial HTML is not visible. To support the use of LegacyHidden as a
            // true fragment, without an extra DOM node, we would have to hide the
            // initial HTML in some other way.
            // TODO: Add REACT_OFFSCREEN_TYPE here too with the same capability.
            case REACT_LEGACY_HIDDEN_TYPE:
            case REACT_DEBUG_TRACING_MODE_TYPE:
            case REACT_STRICT_MODE_TYPE:
            case REACT_PROFILER_TYPE:
            case REACT_FRAGMENT_TYPE:
                renderNodeDestructive(request, task, props.children);
                return;
            case REACT_SUSPENSE_LIST_TYPE:
                pushBuiltInComponentStackInDEV(task, 'SuspenseList'); // TODO: SuspenseList should control the boundaries.
                renderNodeDestructive(request, task, props.children);
                popComponentStackInDEV(task);
                return;
            case REACT_SCOPE_TYPE:
                throw new Error('ReactDOMServer does not yet support scope components.');
            // eslint-disable-next-line-no-fallthrough
            case REACT_SUSPENSE_TYPE:
                renderSuspenseBoundary(request, task, props);
                return;
        }
        if (typeof type === 'object' && type !== null) switch(type.$$typeof){
            case REACT_FORWARD_REF_TYPE:
                renderForwardRef(request, task, type, props, ref);
                return;
            case REACT_MEMO_TYPE:
                renderMemo(request, task, type, props, ref);
                return;
            case REACT_PROVIDER_TYPE:
                renderContextProvider(request, task, type, props);
                return;
            case REACT_CONTEXT_TYPE:
                renderContextConsumer(request, task, type, props);
                return;
            case REACT_LAZY_TYPE:
                renderLazyComponent(request, task, type, props);
                return;
        }
        var info = '';
        if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
        throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (type == null ? type : typeof type) + "." + info));
    }
    function validateIterable(iterable, iteratorFn) {
        // We don't support rendering Generators because it's a mutation.
        // See https://github.com/facebook/react/issues/12995
        if (typeof Symbol === 'function' && // $FlowFixMe Flow doesn't know about toStringTag
        iterable[Symbol.toStringTag] === 'Generator') {
            if (!didWarnAboutGenerators) error("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers.");
            didWarnAboutGenerators = true;
        } // Warn about using Maps as children
        if (iterable.entries === iteratorFn) {
            if (!didWarnAboutMaps) error("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
            didWarnAboutMaps = true;
        }
    }
    function renderNodeDestructive(request, task, node) {
        // In Dev we wrap renderNodeDestructiveImpl in a try / catch so we can capture
        // a component stack at the right place in the tree. We don't do this in renderNode
        // becuase it is not called at every layer of the tree and we may lose frames
        try {
            return renderNodeDestructiveImpl(request, task, node);
        } catch (x) {
            if (typeof x === 'object' && x !== null && typeof x.then === 'function') ;
            else // This is an error, stash the component stack if it is null.
            lastBoundaryErrorComponentStackDev = lastBoundaryErrorComponentStackDev !== null ? lastBoundaryErrorComponentStackDev : getCurrentStackInDEV();
             // rethrow so normal suspense logic can handle thrown value accordingly
            throw x;
        }
    } // This function by it self renders a node and consumes the task by mutating it
    // to update the current execution state.
    function renderNodeDestructiveImpl(request, task, node) {
        // Stash the node we're working on. We'll pick up from this task in case
        // something suspends.
        task.node = node; // Handle object types
        if (typeof node === 'object' && node !== null) {
            switch(node.$$typeof){
                case REACT_ELEMENT_TYPE:
                    var element = node;
                    var type = element.type;
                    var props = element.props;
                    var ref = element.ref;
                    renderElement(request, task, type, props, ref);
                    return;
                case REACT_PORTAL_TYPE:
                    throw new Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
                // eslint-disable-next-line-no-fallthrough
                case REACT_LAZY_TYPE:
                    var lazyNode = node;
                    var payload = lazyNode._payload;
                    var init = lazyNode._init;
                    var resolvedNode;
                    try {
                        resolvedNode = init(payload);
                    } catch (x) {
                        if (typeof x === 'object' && x !== null && typeof x.then === 'function') // this Lazy initializer is suspending. push a temporary frame onto the stack so it can be
                        // popped off in spawnNewSuspendedTask. This aligns stack behavior between Lazy in element position
                        // vs Component position. We do not want the frame for Errors so we exclusively do this in
                        // the wakeable branch
                        pushBuiltInComponentStackInDEV(task, 'Lazy');
                        throw x;
                    }
                    renderNodeDestructive(request, task, resolvedNode);
                    return;
            }
            if (isArray(node)) {
                renderChildrenArray(request, task, node);
                return;
            }
            var iteratorFn = getIteratorFn(node);
            if (iteratorFn) {
                validateIterable(node, iteratorFn);
                var iterator = iteratorFn.call(node);
                if (iterator) {
                    // We need to know how many total children are in this set, so that we
                    // can allocate enough id slots to acommodate them. So we must exhaust
                    // the iterator before we start recursively rendering the children.
                    // TODO: This is not great but I think it's inherent to the id
                    // generation algorithm.
                    var step = iterator.next(); // If there are not entries, we need to push an empty so we start by checking that.
                    if (!step.done) {
                        var children = [];
                        do {
                            children.push(step.value);
                            step = iterator.next();
                        }while (!step.done)
                        renderChildrenArray(request, task, children);
                        return;
                    }
                    return;
                }
            }
            var childString = Object.prototype.toString.call(node);
            throw new Error("Objects are not valid as a React child (found: " + (childString === '[object Object]' ? 'object with keys {' + Object.keys(node).join(', ') + '}' : childString) + "). " + 'If you meant to render a collection of children, use an array ' + 'instead.');
        }
        if (typeof node === 'string') {
            var segment = task.blockedSegment;
            segment.lastPushedText = pushTextInstance(task.blockedSegment.chunks, node, request.responseState, segment.lastPushedText);
            return;
        }
        if (typeof node === 'number') {
            var _segment = task.blockedSegment;
            _segment.lastPushedText = pushTextInstance(task.blockedSegment.chunks, '' + node, request.responseState, _segment.lastPushedText);
            return;
        }
        if (typeof node === 'function') error("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
    }
    function renderChildrenArray(request, task, children) {
        var totalChildren = children.length;
        for(var i = 0; i < totalChildren; i++){
            var prevTreeContext = task.treeContext;
            task.treeContext = pushTreeContext(prevTreeContext, totalChildren, i);
            try {
                // We need to use the non-destructive form so that we can safely pop back
                // up and render the sibling if something suspends.
                renderNode(request, task, children[i]);
            } finally{
                task.treeContext = prevTreeContext;
            }
        }
    }
    function spawnNewSuspendedTask(request, task, x) {
        // Something suspended, we'll need to create a new segment and resolve it later.
        var segment = task.blockedSegment;
        var insertionIndex = segment.chunks.length;
        var newSegment = createPendingSegment(request, insertionIndex, null, segment.formatContext, segment.lastPushedText, true);
        segment.children.push(newSegment); // Reset lastPushedText for current Segment since the new Segment "consumed" it
        segment.lastPushedText = false;
        var newTask = createTask(request, task.node, task.blockedBoundary, newSegment, task.abortSet, task.legacyContext, task.context, task.treeContext);
        if (task.componentStack !== null) // We pop one task off the stack because the node that suspended will be tried again,
        // which will add it back onto the stack.
        newTask.componentStack = task.componentStack.parent;
        var ping = newTask.ping;
        x.then(ping, ping);
    } // This is a non-destructive form of rendering a node. If it suspends it spawns
    // a new task and restores the context of this task to what it was before.
    function renderNode(request, task, node) {
        // TODO: Store segment.children.length here and reset it in case something
        // suspended partially through writing something.
        // Snapshot the current context in case something throws to interrupt the
        // process.
        var previousFormatContext = task.blockedSegment.formatContext;
        var previousLegacyContext = task.legacyContext;
        var previousContext = task.context;
        var previousComponentStack = null;
        previousComponentStack = task.componentStack;
        try {
            return renderNodeDestructive(request, task, node);
        } catch (x) {
            resetHooksState();
            if (typeof x === 'object' && x !== null && typeof x.then === 'function') {
                spawnNewSuspendedTask(request, task, x); // Restore the context. We assume that this will be restored by the inner
                // functions in case nothing throws so we don't use "finally" here.
                task.blockedSegment.formatContext = previousFormatContext;
                task.legacyContext = previousLegacyContext;
                task.context = previousContext; // Restore all active ReactContexts to what they were before.
                switchContext(previousContext);
                task.componentStack = previousComponentStack;
                return;
            } else {
                // Restore the context. We assume that this will be restored by the inner
                // functions in case nothing throws so we don't use "finally" here.
                task.blockedSegment.formatContext = previousFormatContext;
                task.legacyContext = previousLegacyContext;
                task.context = previousContext; // Restore all active ReactContexts to what they were before.
                switchContext(previousContext);
                task.componentStack = previousComponentStack;
                // Let's terminate the rest of the tree and don't render any siblings.
                throw x;
            }
        }
    }
    function erroredTask(request, boundary, segment, error) {
        // Report the error to a global handler.
        var errorDigest = logRecoverableError(request, error);
        if (boundary === null) fatalError(request, error);
        else {
            boundary.pendingTasks--;
            if (!boundary.forceClientRender) {
                boundary.forceClientRender = true;
                boundary.errorDigest = errorDigest;
                captureBoundaryErrorDetailsDev(boundary, error);
                // so we can flush it, if the parent already flushed.
                if (boundary.parentFlushed) // We don't have a preference where in the queue this goes since it's likely
                // to error on the client anyway. However, intentionally client-rendered
                // boundaries should be flushed earlier so that they can start on the client.
                // We reuse the same queue for errors.
                request.clientRenderedBoundaries.push(boundary);
            }
        }
        request.allPendingTasks--;
        if (request.allPendingTasks === 0) {
            var onAllReady = request.onAllReady;
            onAllReady();
        }
    }
    function abortTaskSoft(task) {
        // This aborts task without aborting the parent boundary that it blocks.
        // It's used for when we didn't need this task to complete the tree.
        // If task was needed, then it should use abortTask instead.
        var request = this;
        var boundary = task.blockedBoundary;
        var segment = task.blockedSegment;
        segment.status = ABORTED;
        finishedTask(request, boundary, segment);
    }
    function abortTask(task, request, reason) {
        // This aborts the task and aborts the parent that it blocks, putting it into
        // client rendered mode.
        var boundary = task.blockedBoundary;
        var segment = task.blockedSegment;
        segment.status = ABORTED;
        if (boundary === null) {
            request.allPendingTasks--; // We didn't complete the root so we have nothing to show. We can close
            // the request;
            if (request.status !== CLOSED) {
                request.status = CLOSED;
                if (request.destination !== null) close(request.destination);
            }
        } else {
            boundary.pendingTasks--;
            if (!boundary.forceClientRender) {
                boundary.forceClientRender = true;
                var _error = reason === undefined ? new Error('The render was aborted by the server without a reason.') : reason;
                boundary.errorDigest = request.onError(_error);
                var errorPrefix = 'The server did not finish this Suspense boundary: ';
                if (_error && typeof _error.message === 'string') _error = errorPrefix + _error.message;
                else // eslint-disable-next-line react-internal/safe-string-coercion
                _error = errorPrefix + String(_error);
                var previousTaskInDev = currentTaskInDEV;
                currentTaskInDEV = task;
                try {
                    captureBoundaryErrorDetailsDev(boundary, _error);
                } finally{
                    currentTaskInDEV = previousTaskInDev;
                }
                if (boundary.parentFlushed) request.clientRenderedBoundaries.push(boundary);
            } // If this boundary was still pending then we haven't already cancelled its fallbacks.
            // We'll need to abort the fallbacks, which will also error that parent boundary.
            boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {
                return abortTask(fallbackTask, request, reason);
            });
            boundary.fallbackAbortableTasks.clear();
            request.allPendingTasks--;
            if (request.allPendingTasks === 0) {
                var onAllReady = request.onAllReady;
                onAllReady();
            }
        }
    }
    function queueCompletedSegment(boundary, segment) {
        if (segment.chunks.length === 0 && segment.children.length === 1 && segment.children[0].boundary === null) {
            // This is an empty segment. There's nothing to write, so we can instead transfer the ID
            // to the child. That way any existing references point to the child.
            var childSegment = segment.children[0];
            childSegment.id = segment.id;
            childSegment.parentFlushed = true;
            if (childSegment.status === COMPLETED) queueCompletedSegment(boundary, childSegment);
        } else {
            var completedSegments = boundary.completedSegments;
            completedSegments.push(segment);
        }
    }
    function finishedTask(request, boundary, segment) {
        if (boundary === null) {
            if (segment.parentFlushed) {
                if (request.completedRootSegment !== null) throw new Error('There can only be one root segment. This is a bug in React.');
                request.completedRootSegment = segment;
            }
            request.pendingRootTasks--;
            if (request.pendingRootTasks === 0) {
                // We have completed the shell so the shell can't error anymore.
                request.onShellError = noop$1;
                var onShellReady = request.onShellReady;
                onShellReady();
            }
        } else {
            boundary.pendingTasks--;
            if (boundary.forceClientRender) ;
            else if (boundary.pendingTasks === 0) {
                // This must have been the last segment we were waiting on. This boundary is now complete.
                if (segment.parentFlushed) // Our parent segment already flushed, so we need to schedule this segment to be emitted.
                // If it is a segment that was aborted, we'll write other content instead so we don't need
                // to emit it.
                {
                    if (segment.status === COMPLETED) queueCompletedSegment(boundary, segment);
                }
                if (boundary.parentFlushed) // The segment might be part of a segment that didn't flush yet, but if the boundary's
                // parent flushed, we need to schedule the boundary to be emitted.
                request.completedBoundaries.push(boundary);
                 // We can now cancel any pending task on the fallback since we won't need to show it anymore.
                // This needs to happen after we read the parentFlushed flags because aborting can finish
                // work which can trigger user code, which can start flushing, which can change those flags.
                boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request);
                boundary.fallbackAbortableTasks.clear();
            } else {
                if (segment.parentFlushed) // Our parent already flushed, so we need to schedule this segment to be emitted.
                // If it is a segment that was aborted, we'll write other content instead so we don't need
                // to emit it.
                {
                    if (segment.status === COMPLETED) {
                        queueCompletedSegment(boundary, segment);
                        var completedSegments = boundary.completedSegments;
                        if (completedSegments.length === 1) // This is the first time since we last flushed that we completed anything.
                        // We can schedule this boundary to emit its partially completed segments early
                        // in case the parent has already been flushed.
                        {
                            if (boundary.parentFlushed) request.partialBoundaries.push(boundary);
                        }
                    }
                }
            }
        }
        request.allPendingTasks--;
        if (request.allPendingTasks === 0) {
            // This needs to be called at the very end so that we can synchronously write the result
            // in the callback if needed.
            var onAllReady = request.onAllReady;
            onAllReady();
        }
    }
    function retryTask(request, task) {
        var segment = task.blockedSegment;
        if (segment.status !== PENDING) // We completed this by other means before we had a chance to retry it.
        return;
         // We restore the context to what it was when we suspended.
        // We don't restore it after we leave because it's likely that we'll end up
        // needing a very similar context soon again.
        switchContext(task.context);
        var prevTaskInDEV = null;
        prevTaskInDEV = currentTaskInDEV;
        currentTaskInDEV = task;
        try {
            // We call the destructive form that mutates this task. That way if something
            // suspends again, we can reuse the same task instead of spawning a new one.
            renderNodeDestructive(request, task, task.node);
            pushSegmentFinale(segment.chunks, request.responseState, segment.lastPushedText, segment.textEmbedded);
            task.abortSet.delete(task);
            segment.status = COMPLETED;
            finishedTask(request, task.blockedBoundary, segment);
        } catch (x) {
            resetHooksState();
            if (typeof x === 'object' && x !== null && typeof x.then === 'function') {
                // Something suspended again, let's pick it back up later.
                var ping = task.ping;
                x.then(ping, ping);
            } else {
                task.abortSet.delete(task);
                segment.status = ERRORED;
                erroredTask(request, task.blockedBoundary, segment, x);
            }
        } finally{
            currentTaskInDEV = prevTaskInDEV;
        }
    }
    function performWork(request) {
        if (request.status === CLOSED) return;
        var prevContext = getActiveContext();
        var prevDispatcher = ReactCurrentDispatcher$1.current;
        ReactCurrentDispatcher$1.current = Dispatcher;
        var prevGetCurrentStackImpl;
        prevGetCurrentStackImpl = ReactDebugCurrentFrame$1.getCurrentStack;
        ReactDebugCurrentFrame$1.getCurrentStack = getCurrentStackInDEV;
        var prevResponseState = currentResponseState;
        setCurrentResponseState(request.responseState);
        try {
            var pingedTasks = request.pingedTasks;
            var i;
            for(i = 0; i < pingedTasks.length; i++){
                var task = pingedTasks[i];
                retryTask(request, task);
            }
            pingedTasks.splice(0, i);
            if (request.destination !== null) flushCompletedQueues(request, request.destination);
        } catch (error) {
            logRecoverableError(request, error);
            fatalError(request, error);
        } finally{
            setCurrentResponseState(prevResponseState);
            ReactCurrentDispatcher$1.current = prevDispatcher;
            ReactDebugCurrentFrame$1.getCurrentStack = prevGetCurrentStackImpl;
            if (prevDispatcher === Dispatcher) // This means that we were in a reentrant work loop. This could happen
            // in a renderer that supports synchronous work like renderToString,
            // when it's called from within another renderer.
            // Normally we don't bother switching the contexts to their root/default
            // values when leaving because we'll likely need the same or similar
            // context again. However, when we're inside a synchronous loop like this
            // we'll to restore the context to what it was before returning.
            switchContext(prevContext);
        }
    }
    function flushSubtree(request, destination, segment) {
        segment.parentFlushed = true;
        switch(segment.status){
            case PENDING:
                // We're emitting a placeholder for this segment to be filled in later.
                // Therefore we'll need to assign it an ID - to refer to it by.
                var segmentID = segment.id = request.nextSegmentId++; // When this segment finally completes it won't be embedded in text since it will flush separately
                segment.lastPushedText = false;
                segment.textEmbedded = false;
                return writePlaceholder(destination, request.responseState, segmentID);
            case COMPLETED:
                segment.status = FLUSHED;
                var r = true;
                var chunks = segment.chunks;
                var chunkIdx = 0;
                var children = segment.children;
                for(var childIdx = 0; childIdx < children.length; childIdx++){
                    var nextChild = children[childIdx]; // Write all the chunks up until the next child.
                    for(; chunkIdx < nextChild.index; chunkIdx++)writeChunk(destination, chunks[chunkIdx]);
                    r = flushSegment(request, destination, nextChild);
                } // Finally just write all the remaining chunks
                for(; chunkIdx < chunks.length - 1; chunkIdx++)writeChunk(destination, chunks[chunkIdx]);
                if (chunkIdx < chunks.length) r = writeChunkAndReturn(destination, chunks[chunkIdx]);
                return r;
            default:
                throw new Error('Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.');
        }
    }
    function flushSegment(request, destination, segment) {
        var boundary = segment.boundary;
        if (boundary === null) // Not a suspense boundary.
        return flushSubtree(request, destination, segment);
        boundary.parentFlushed = true; // This segment is a Suspense boundary. We need to decide whether to
        // emit the content or the fallback now.
        if (boundary.forceClientRender) {
            // Emit a client rendered suspense boundary wrapper.
            // We never queue the inner boundary so we'll never emit its content or partial segments.
            writeStartClientRenderedSuspenseBoundary(destination, request.responseState, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack); // Flush the fallback.
            flushSubtree(request, destination, segment);
            return writeEndClientRenderedSuspenseBoundary(destination, request.responseState);
        } else if (boundary.pendingTasks > 0) {
            // This boundary is still loading. Emit a pending suspense boundary wrapper.
            // Assign an ID to refer to the future content by.
            boundary.rootSegmentID = request.nextSegmentId++;
            if (boundary.completedSegments.length > 0) // If this is at least partially complete, we can queue it to be partially emitted early.
            request.partialBoundaries.push(boundary);
             /// This is the first time we should have referenced this ID.
            var id = boundary.id = assignSuspenseBoundaryID(request.responseState);
            writeStartPendingSuspenseBoundary(destination, request.responseState, id); // Flush the fallback.
            flushSubtree(request, destination, segment);
            return writeEndPendingSuspenseBoundary(destination, request.responseState);
        } else if (boundary.byteSize > request.progressiveChunkSize) {
            // This boundary is large and will be emitted separately so that we can progressively show
            // other content. We add it to the queue during the flush because we have to ensure that
            // the parent flushes first so that there's something to inject it into.
            // We also have to make sure that it's emitted into the queue in a deterministic slot.
            // I.e. we can't insert it here when it completes.
            // Assign an ID to refer to the future content by.
            boundary.rootSegmentID = request.nextSegmentId++;
            request.completedBoundaries.push(boundary); // Emit a pending rendered suspense boundary wrapper.
            writeStartPendingSuspenseBoundary(destination, request.responseState, boundary.id); // Flush the fallback.
            flushSubtree(request, destination, segment);
            return writeEndPendingSuspenseBoundary(destination, request.responseState);
        } else {
            // We can inline this boundary's content as a complete boundary.
            writeStartCompletedSuspenseBoundary(destination, request.responseState);
            var completedSegments = boundary.completedSegments;
            if (completedSegments.length !== 1) throw new Error('A previously unvisited boundary must have exactly one root segment. This is a bug in React.');
            var contentSegment = completedSegments[0];
            flushSegment(request, destination, contentSegment);
            return writeEndCompletedSuspenseBoundary(destination, request.responseState);
        }
    }
    function flushClientRenderedBoundary(request, destination, boundary) {
        return writeClientRenderBoundaryInstruction(destination, request.responseState, boundary.id, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack);
    }
    function flushSegmentContainer(request, destination, segment) {
        writeStartSegment(destination, request.responseState, segment.formatContext, segment.id);
        flushSegment(request, destination, segment);
        return writeEndSegment(destination, segment.formatContext);
    }
    function flushCompletedBoundary(request, destination, boundary) {
        var completedSegments = boundary.completedSegments;
        var i = 0;
        for(; i < completedSegments.length; i++){
            var segment = completedSegments[i];
            flushPartiallyCompletedSegment(request, destination, boundary, segment);
        }
        completedSegments.length = 0;
        return writeCompletedBoundaryInstruction(destination, request.responseState, boundary.id, boundary.rootSegmentID);
    }
    function flushPartialBoundary(request, destination, boundary) {
        var completedSegments = boundary.completedSegments;
        var i = 0;
        for(; i < completedSegments.length; i++){
            var segment = completedSegments[i];
            if (!flushPartiallyCompletedSegment(request, destination, boundary, segment)) {
                i++;
                completedSegments.splice(0, i); // Only write as much as the buffer wants. Something higher priority
                // might want to write later.
                return false;
            }
        }
        completedSegments.splice(0, i);
        return true;
    }
    function flushPartiallyCompletedSegment(request, destination, boundary, segment) {
        if (segment.status === FLUSHED) // We've already flushed this inline.
        return true;
        var segmentID = segment.id;
        if (segmentID === -1) {
            // This segment wasn't previously referred to. This happens at the root of
            // a boundary. We make kind of a leap here and assume this is the root.
            var rootSegmentID = segment.id = boundary.rootSegmentID;
            if (rootSegmentID === -1) throw new Error('A root segment ID must have been assigned by now. This is a bug in React.');
            return flushSegmentContainer(request, destination, segment);
        } else {
            flushSegmentContainer(request, destination, segment);
            return writeCompletedSegmentInstruction(destination, request.responseState, segmentID);
        }
    }
    function flushCompletedQueues(request, destination) {
        beginWriting();
        try {
            // The structure of this is to go through each queue one by one and write
            // until the sink tells us to stop. When we should stop, we still finish writing
            // that item fully and then yield. At that point we remove the already completed
            // items up until the point we completed them.
            // TODO: Emit preloading.
            // TODO: It's kind of unfortunate to keep checking this array after we've already
            // emitted the root.
            var completedRootSegment = request.completedRootSegment;
            if (completedRootSegment !== null && request.pendingRootTasks === 0) {
                flushSegment(request, destination, completedRootSegment);
                request.completedRootSegment = null;
                writeCompletedRoot(destination, request.responseState);
            } // We emit client rendering instructions for already emitted boundaries first.
            // This is so that we can signal to the client to start client rendering them as
            // soon as possible.
            var clientRenderedBoundaries = request.clientRenderedBoundaries;
            var i;
            for(i = 0; i < clientRenderedBoundaries.length; i++){
                var boundary = clientRenderedBoundaries[i];
                if (!flushClientRenderedBoundary(request, destination, boundary)) {
                    request.destination = null;
                    i++;
                    clientRenderedBoundaries.splice(0, i);
                    return;
                }
            }
            clientRenderedBoundaries.splice(0, i); // Next we emit any complete boundaries. It's better to favor boundaries
            // that are completely done since we can actually show them, than it is to emit
            // any individual segments from a partially complete boundary.
            var completedBoundaries = request.completedBoundaries;
            for(i = 0; i < completedBoundaries.length; i++){
                var _boundary = completedBoundaries[i];
                if (!flushCompletedBoundary(request, destination, _boundary)) {
                    request.destination = null;
                    i++;
                    completedBoundaries.splice(0, i);
                    return;
                }
            }
            completedBoundaries.splice(0, i); // Allow anything written so far to flush to the underlying sink before
            // we continue with lower priorities.
            completeWriting(destination);
            beginWriting(destination); // TODO: Here we'll emit data used by hydration.
            // Next we emit any segments of any boundaries that are partially complete
            // but not deeply complete.
            var partialBoundaries = request.partialBoundaries;
            for(i = 0; i < partialBoundaries.length; i++){
                var _boundary2 = partialBoundaries[i];
                if (!flushPartialBoundary(request, destination, _boundary2)) {
                    request.destination = null;
                    i++;
                    partialBoundaries.splice(0, i);
                    return;
                }
            }
            partialBoundaries.splice(0, i); // Next we check the completed boundaries again. This may have had
            // boundaries added to it in case they were too larged to be inlined.
            // New ones might be added in this loop.
            var largeBoundaries = request.completedBoundaries;
            for(i = 0; i < largeBoundaries.length; i++){
                var _boundary3 = largeBoundaries[i];
                if (!flushCompletedBoundary(request, destination, _boundary3)) {
                    request.destination = null;
                    i++;
                    largeBoundaries.splice(0, i);
                    return;
                }
            }
            largeBoundaries.splice(0, i);
        } finally{
            completeWriting(destination);
            if (request.allPendingTasks === 0 && request.pingedTasks.length === 0 && request.clientRenderedBoundaries.length === 0 && request.completedBoundaries.length === 0 // We don't need to check any partially completed segments because
            ) {
                if (request.abortableTasks.size !== 0) error('There was still abortable task at the root when we closed. This is a bug in React.');
                close(destination);
            }
        }
    }
    function startWork(request) {
        scheduleWork(function() {
            return performWork(request);
        });
    }
    function startFlowing(request, destination) {
        if (request.status === CLOSING) {
            request.status = CLOSED;
            closeWithError(destination, request.fatalError);
            return;
        }
        if (request.status === CLOSED) return;
        if (request.destination !== null) // We're already flowing.
        return;
        request.destination = destination;
        try {
            flushCompletedQueues(request, destination);
        } catch (error) {
            logRecoverableError(request, error);
            fatalError(request, error);
        }
    } // This is called to early terminate a request. It puts all pending boundaries in client rendered state.
    function abort(request, reason) {
        try {
            var abortableTasks = request.abortableTasks;
            abortableTasks.forEach(function(task) {
                return abortTask(task, request, reason);
            });
            abortableTasks.clear();
            if (request.destination !== null) flushCompletedQueues(request, request.destination);
        } catch (error) {
            logRecoverableError(request, error);
            fatalError(request, error);
        }
    }
    function renderToReadableStream(children, options) {
        return new Promise(function(resolve, reject) {
            var onFatalError;
            var onAllReady;
            var allReady = new Promise(function(res, rej) {
                onAllReady = res;
                onFatalError = rej;
            });
            function onShellReady() {
                var stream = new ReadableStream({
                    type: 'bytes',
                    pull: function(controller) {
                        startFlowing(request, controller);
                    },
                    cancel: function(reason) {
                        abort(request);
                    }
                }, {
                    highWaterMark: 0
                }); // TODO: Move to sub-classing ReadableStream.
                stream.allReady = allReady;
                resolve(stream);
            }
            function onShellError(error) {
                // If the shell errors the caller of `renderToReadableStream` won't have access to `allReady`.
                // However, `allReady` will be rejected by `onFatalError` as well.
                // So we need to catch the duplicate, uncatchable fatal error in `allReady` to prevent a `UnhandledPromiseRejection`.
                allReady.catch(function() {});
                reject(error);
            }
            var request = createRequest(children, createResponseState(options ? options.identifierPrefix : undefined, options ? options.nonce : undefined, options ? options.bootstrapScriptContent : undefined, options ? options.bootstrapScripts : undefined, options ? options.bootstrapModules : undefined), createRootFormatContext(options ? options.namespaceURI : undefined), options ? options.progressiveChunkSize : undefined, options ? options.onError : undefined, onAllReady, onShellReady, onShellError, onFatalError);
            if (options && options.signal) {
                var signal = options.signal;
                var listener = function() {
                    abort(request, signal.reason);
                    signal.removeEventListener('abort', listener);
                };
                signal.addEventListener('abort', listener);
            }
            startWork(request);
        });
    }
    exports.renderToReadableStream = renderToReadableStream;
    exports.version = ReactVersion;
})();

},
"node_modules/react-draggable/build/cjs/Draggable.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "DraggableCore", {
    enumerable: true,
    get: function() {
        return _DraggableCore.default;
    }
});
exports.default = void 0;
var React = _interopRequireWildcard(__mako_require__("node_modules/react/index.js"));
var _propTypes = _interopRequireDefault(__mako_require__("node_modules/prop-types/index.js"));
var _reactDom = _interopRequireDefault(__mako_require__("node_modules/react-dom/index.js"));
var _clsx = __mako_require__("node_modules/clsx/dist/clsx.js");
var _domFns = __mako_require__("node_modules/react-draggable/build/cjs/utils/domFns.js");
var _positionFns = __mako_require__("node_modules/react-draggable/build/cjs/utils/positionFns.js");
var _shims = __mako_require__("node_modules/react-draggable/build/cjs/utils/shims.js");
var _DraggableCore = _interopRequireDefault(__mako_require__("node_modules/react-draggable/build/cjs/DraggableCore.js"));
var _log = _interopRequireDefault(__mako_require__("node_modules/react-draggable/build/cjs/utils/log.js"));
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        default: e
    };
}
function _interopRequireWildcard(e, t) {
    if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap();
    return (_interopRequireWildcard = function(e, t) {
        if (!t && e && e.__esModule) return e;
        var o, i, f = {
            __proto__: null,
            default: e
        };
        if (null === e || "object" != typeof e && "function" != typeof e) return f;
        if (o = t ? n : r) {
            if (o.has(e)) return o.get(e);
            o.set(e, f);
        }
        for(const t in e)"default" !== t && ({}).hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]);
        return f;
    })(e, t);
}
function _extends() {
    return _extends = Object.assign ? Object.assign.bind() : function(n) {
        for(var e = 1; e < arguments.length; e++){
            var t = arguments[e];
            for(var r in t)({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
        }
        return n;
    }, _extends.apply(null, arguments);
}
function _defineProperty(e, r, t) {
    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[r] = t, e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
} /*:: import type {ControlPosition, PositionOffsetControlPosition, DraggableCoreProps, DraggableCoreDefaultProps} from './DraggableCore';*/ 
/*:: import type {Bounds, DraggableEventHandler} from './utils/types';*/ /*:: import type {Element as ReactElement} from 'react';*/ /*:: type DraggableState = {
  dragging: boolean,
  dragged: boolean,
  x: number, y: number,
  slackX: number, slackY: number,
  isElementSVG: boolean,
  prevPropsPosition: ?ControlPosition,
};*/ /*:: export type DraggableDefaultProps = {
  ...DraggableCoreDefaultProps,
  axis: 'both' | 'x' | 'y' | 'none',
  bounds: Bounds | string | false,
  defaultClassName: string,
  defaultClassNameDragging: string,
  defaultClassNameDragged: string,
  defaultPosition: ControlPosition,
  scale: number,
};*/ /*:: export type DraggableProps = {
  ...DraggableCoreProps,
  ...DraggableDefaultProps,
  positionOffset: PositionOffsetControlPosition,
  position: ControlPosition,
};*/ //
// Define <Draggable>
//
class Draggable extends React.Component /*:: <DraggableProps, DraggableState>*/  {
    // React 16.3+
    // Arity (props, state)
    static getDerivedStateFromProps(_ref /*:: */ , _ref2 /*:: */ ) /*: ?Partial<DraggableState>*/ {
        let { position } /*: DraggableProps*/  = _ref /*: DraggableProps*/ ;
        let { prevPropsPosition } /*: DraggableState*/  = _ref2 /*: DraggableState*/ ;
        // Set x/y if a new position is provided in props that is different than the previous.
        if (position && (!prevPropsPosition || position.x !== prevPropsPosition.x || position.y !== prevPropsPosition.y)) {
            (0, _log.default)('Draggable: getDerivedStateFromProps %j', {
                position,
                prevPropsPosition
            });
            return {
                x: position.x,
                y: position.y,
                prevPropsPosition: {
                    ...position
                }
            };
        }
        return null;
    }
    constructor(props /*: DraggableProps*/ ){
        super(props);
        _defineProperty(this, "onDragStart", (e, coreData)=>{
            (0, _log.default)('Draggable: onDragStart: %j', coreData);
            // Short-circuit if user's callback killed it.
            const shouldStart = this.props.onStart(e, (0, _positionFns.createDraggableData)(this, coreData));
            // Kills start event on core as well, so move handlers are never bound.
            if (shouldStart === false) return false;
            this.setState({
                dragging: true,
                dragged: true
            });
        });
        _defineProperty(this, "onDrag", (e, coreData)=>{
            if (!this.state.dragging) return false;
            (0, _log.default)('Draggable: onDrag: %j', coreData);
            const uiData = (0, _positionFns.createDraggableData)(this, coreData);
            const newState = {
                x: uiData.x,
                y: uiData.y,
                slackX: 0,
                slackY: 0
            };
            // Keep within bounds.
            if (this.props.bounds) {
                // Save original x and y.
                const { x, y } = newState;
                // Add slack to the values used to calculate bound position. This will ensure that if
                // we start removing slack, the element won't react to it right away until it's been
                // completely removed.
                newState.x += this.state.slackX;
                newState.y += this.state.slackY;
                // Get bound position. This will ceil/floor the x and y within the boundaries.
                const [newStateX, newStateY] = (0, _positionFns.getBoundPosition)(this, newState.x, newState.y);
                newState.x = newStateX;
                newState.y = newStateY;
                // Recalculate slack by noting how much was shaved by the boundPosition handler.
                newState.slackX = this.state.slackX + (x - newState.x);
                newState.slackY = this.state.slackY + (y - newState.y);
                // Update the event we fire to reflect what really happened after bounds took effect.
                uiData.x = newState.x;
                uiData.y = newState.y;
                uiData.deltaX = newState.x - this.state.x;
                uiData.deltaY = newState.y - this.state.y;
            }
            // Short-circuit if user's callback killed it.
            const shouldUpdate = this.props.onDrag(e, uiData);
            if (shouldUpdate === false) return false;
            this.setState(newState);
        });
        _defineProperty(this, "onDragStop", (e, coreData)=>{
            if (!this.state.dragging) return false;
            // Short-circuit if user's callback killed it.
            const shouldContinue = this.props.onStop(e, (0, _positionFns.createDraggableData)(this, coreData));
            if (shouldContinue === false) return false;
            (0, _log.default)('Draggable: onDragStop: %j', coreData);
            const newState /*: Partial<DraggableState>*/  = {
                dragging: false,
                slackX: 0,
                slackY: 0
            };
            // If this is a controlled component, the result of this operation will be to
            // revert back to the old position. We expect a handler on `onDragStop`, at the least.
            const controlled = Boolean(this.props.position);
            if (controlled) {
                const { x, y } = this.props.position;
                newState.x = x;
                newState.y = y;
            }
            this.setState(newState);
        });
        this.state = {
            // Whether or not we are currently dragging.
            dragging: false,
            // Whether or not we have been dragged before.
            dragged: false,
            // Current transform x and y.
            x: props.position ? props.position.x : props.defaultPosition.x,
            y: props.position ? props.position.y : props.defaultPosition.y,
            prevPropsPosition: {
                ...props.position
            },
            // Used for compensating for out-of-bounds drags
            slackX: 0,
            slackY: 0,
            // Can only determine if SVG after mounting
            isElementSVG: false
        };
        if (props.position && !(props.onDrag || props.onStop)) // eslint-disable-next-line no-console
        console.warn("A `position` was applied to this <Draggable>, without drag handlers. This will make this component effectively undraggable. Please attach `onDrag` or `onStop` handlers so you can adjust the `position` of this element.");
    }
    componentDidMount() {
        // Check to see if the element passed is an instanceof SVGElement
        if (typeof window.SVGElement !== 'undefined' && this.findDOMNode() instanceof window.SVGElement) this.setState({
            isElementSVG: true
        });
    }
    componentWillUnmount() {
        if (this.state.dragging) this.setState({
            dragging: false
        }); // prevents invariant if unmounted while dragging
    }
    // React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find
    // the underlying DOM node ourselves. See the README for more information.
    findDOMNode() /*: ?HTMLElement*/ {
        var _this_props_nodeRef, _this_props;
        return ((_this_props = this.props) === null || _this_props === void 0 ? void 0 : (_this_props_nodeRef = _this_props.nodeRef) === null || _this_props_nodeRef === void 0 ? void 0 : _this_props_nodeRef.current) ?? _reactDom.default.findDOMNode(this);
    }
    render() /*: ReactElement<any>*/ {
        const { axis, bounds, children, defaultPosition, defaultClassName, defaultClassNameDragging, defaultClassNameDragged, position, positionOffset, scale, ...draggableCoreProps } = this.props;
        let style = {};
        let svgTransform = null;
        // If this is controlled, we don't want to move it - unless it's dragging.
        const controlled = Boolean(position);
        const draggable = !controlled || this.state.dragging;
        const validPosition = position || defaultPosition;
        const transformOpts = {
            // Set left if horizontal drag is enabled
            x: (0, _positionFns.canDragX)(this) && draggable ? this.state.x : validPosition.x,
            // Set top if vertical drag is enabled
            y: (0, _positionFns.canDragY)(this) && draggable ? this.state.y : validPosition.y
        };
        // If this element was SVG, we use the `transform` attribute.
        if (this.state.isElementSVG) svgTransform = (0, _domFns.createSVGTransform)(transformOpts, positionOffset);
        else // Add a CSS transform to move the element around. This allows us to move the element around
        // without worrying about whether or not it is relatively or absolutely positioned.
        // If the item you are dragging already has a transform set, wrap it in a <span> so <Draggable>
        // has a clean slate.
        style = (0, _domFns.createCSSTransform)(transformOpts, positionOffset);
        // Mark with class while dragging
        const className = (0, _clsx.clsx)(children.props.className || '', defaultClassName, {
            [defaultClassNameDragging]: this.state.dragging,
            [defaultClassNameDragged]: this.state.dragged
        });
        // Reuse the child provided
        // This makes it flexible to use whatever element is wanted (div, ul, etc)
        return /*#__PURE__*/ React.createElement(_DraggableCore.default, _extends({}, draggableCoreProps, {
            onStart: this.onDragStart,
            onDrag: this.onDrag,
            onStop: this.onDragStop
        }), /*#__PURE__*/ React.cloneElement(React.Children.only(children), {
            className: className,
            style: {
                ...children.props.style,
                ...style
            },
            transform: svgTransform
        }));
    }
}
exports.default = Draggable;
_defineProperty(Draggable, "displayName", 'Draggable');
_defineProperty(Draggable, "propTypes", {
    // Accepts all props <DraggableCore> accepts.
    ..._DraggableCore.default.propTypes,
    /**
   * `axis` determines which axis the draggable can move.
   *
   *  Note that all callbacks will still return data as normal. This only
   *  controls flushing to the DOM.
   *
   * 'both' allows movement horizontally and vertically.
   * 'x' limits movement to horizontal axis.
   * 'y' limits movement to vertical axis.
   * 'none' limits all movement.
   *
   * Defaults to 'both'.
   */ axis: _propTypes.default.oneOf([
        'both',
        'x',
        'y',
        'none'
    ]),
    /**
   * `bounds` determines the range of movement available to the element.
   * Available values are:
   *
   * 'parent' restricts movement within the Draggable's parent node.
   *
   * Alternatively, pass an object with the following properties, all of which are optional:
   *
   * {left: LEFT_BOUND, right: RIGHT_BOUND, bottom: BOTTOM_BOUND, top: TOP_BOUND}
   *
   * All values are in px.
   *
   * Example:
   *
   * ```jsx
   *   let App = React.createClass({
   *       render: function () {
   *         return (
   *            <Draggable bounds={{right: 300, bottom: 300}}>
   *              <div>Content</div>
   *           </Draggable>
   *         );
   *       }
   *   });
   * ```
   */ bounds: _propTypes.default.oneOfType([
        _propTypes.default.shape({
            left: _propTypes.default.number,
            right: _propTypes.default.number,
            top: _propTypes.default.number,
            bottom: _propTypes.default.number
        }),
        _propTypes.default.string,
        _propTypes.default.oneOf([
            false
        ])
    ]),
    defaultClassName: _propTypes.default.string,
    defaultClassNameDragging: _propTypes.default.string,
    defaultClassNameDragged: _propTypes.default.string,
    /**
   * `defaultPosition` specifies the x and y that the dragged item should start at
   *
   * Example:
   *
   * ```jsx
   *      let App = React.createClass({
   *          render: function () {
   *              return (
   *                  <Draggable defaultPosition={{x: 25, y: 25}}>
   *                      <div>I start with transformX: 25px and transformY: 25px;</div>
   *                  </Draggable>
   *              );
   *          }
   *      });
   * ```
   */ defaultPosition: _propTypes.default.shape({
        x: _propTypes.default.number,
        y: _propTypes.default.number
    }),
    positionOffset: _propTypes.default.shape({
        x: _propTypes.default.oneOfType([
            _propTypes.default.number,
            _propTypes.default.string
        ]),
        y: _propTypes.default.oneOfType([
            _propTypes.default.number,
            _propTypes.default.string
        ])
    }),
    /**
   * `position`, if present, defines the current position of the element.
   *
   *  This is similar to how form elements in React work - if no `position` is supplied, the component
   *  is uncontrolled.
   *
   * Example:
   *
   * ```jsx
   *      let App = React.createClass({
   *          render: function () {
   *              return (
   *                  <Draggable position={{x: 25, y: 25}}>
   *                      <div>I start with transformX: 25px and transformY: 25px;</div>
   *                  </Draggable>
   *              );
   *          }
   *      });
   * ```
   */ position: _propTypes.default.shape({
        x: _propTypes.default.number,
        y: _propTypes.default.number
    }),
    /**
   * These properties should be defined on the child, not here.
   */ className: _shims.dontSetMe,
    style: _shims.dontSetMe,
    transform: _shims.dontSetMe
});
_defineProperty(Draggable, "defaultProps", {
    ..._DraggableCore.default.defaultProps,
    axis: 'both',
    bounds: false,
    defaultClassName: 'react-draggable',
    defaultClassNameDragging: 'react-draggable-dragging',
    defaultClassNameDragged: 'react-draggable-dragged',
    defaultPosition: {
        x: 0,
        y: 0
    },
    scale: 1
});

},
"node_modules/react-draggable/build/cjs/DraggableCore.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var React = _interopRequireWildcard(__mako_require__("node_modules/react/index.js"));
var _propTypes = _interopRequireDefault(__mako_require__("node_modules/prop-types/index.js"));
var _reactDom = _interopRequireDefault(__mako_require__("node_modules/react-dom/index.js"));
var _domFns = __mako_require__("node_modules/react-draggable/build/cjs/utils/domFns.js");
var _positionFns = __mako_require__("node_modules/react-draggable/build/cjs/utils/positionFns.js");
var _shims = __mako_require__("node_modules/react-draggable/build/cjs/utils/shims.js");
var _log = _interopRequireDefault(__mako_require__("node_modules/react-draggable/build/cjs/utils/log.js"));
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        default: e
    };
}
function _interopRequireWildcard(e, t) {
    if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap();
    return (_interopRequireWildcard = function(e, t) {
        if (!t && e && e.__esModule) return e;
        var o, i, f = {
            __proto__: null,
            default: e
        };
        if (null === e || "object" != typeof e && "function" != typeof e) return f;
        if (o = t ? n : r) {
            if (o.has(e)) return o.get(e);
            o.set(e, f);
        }
        for(const t in e)"default" !== t && ({}).hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]);
        return f;
    })(e, t);
}
function _defineProperty(e, r, t) {
    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[r] = t, e;
}
function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive(t, r) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
/*:: import type {EventHandler, MouseTouchEvent} from './utils/types';*/ /*:: import type {Element as ReactElement} from 'react';*/ // Simple abstraction for dragging events names.
const eventsFor = {
    touch: {
        start: 'touchstart',
        move: 'touchmove',
        stop: 'touchend'
    },
    mouse: {
        start: 'mousedown',
        move: 'mousemove',
        stop: 'mouseup'
    }
};
// Default to mouse events.
let dragEventFor = eventsFor.mouse;
/*:: export type DraggableData = {
  node: HTMLElement,
  x: number, y: number,
  deltaX: number, deltaY: number,
  lastX: number, lastY: number,
};*/ /*:: export type DraggableEventHandler = (e: MouseEvent, data: DraggableData) => void | false;*/ /*:: export type ControlPosition = {x: number, y: number};*/ /*:: export type PositionOffsetControlPosition = {x: number|string, y: number|string};*/ /*:: export type DraggableCoreDefaultProps = {
  allowAnyClick: boolean,
  allowMobileScroll: boolean,
  disabled: boolean,
  enableUserSelectHack: boolean,
  onStart: DraggableEventHandler,
  onDrag: DraggableEventHandler,
  onStop: DraggableEventHandler,
  onMouseDown: (e: MouseEvent) => void,
  scale: number,
};*/ /*:: export type DraggableCoreProps = {
  ...DraggableCoreDefaultProps,
  cancel: string,
  children: ReactElement<any>,
  offsetParent: HTMLElement,
  grid: [number, number],
  handle: string,
  nodeRef?: ?React.ElementRef<any>,
};*/ //
// Define <DraggableCore>.
//
// <DraggableCore> is for advanced usage of <Draggable>. It maintains minimal internal state so it can
// work well with libraries that require more control over the element.
//
class DraggableCore extends React.Component /*:: <DraggableCoreProps>*/  {
    constructor(){
        super(...arguments);
        _defineProperty(this, "dragging", false);
        // Used while dragging to determine deltas.
        _defineProperty(this, "lastX", NaN);
        _defineProperty(this, "lastY", NaN);
        _defineProperty(this, "touchIdentifier", null);
        _defineProperty(this, "mounted", false);
        _defineProperty(this, "handleDragStart", (e)=>{
            // Make it possible to attach event handlers on top of this one.
            this.props.onMouseDown(e);
            // Only accept left-clicks.
            if (!this.props.allowAnyClick && typeof e.button === 'number' && e.button !== 0) return false;
            // Get nodes. Be sure to grab relative document (could be iframed)
            const thisNode = this.findDOMNode();
            if (!thisNode || !thisNode.ownerDocument || !thisNode.ownerDocument.body) throw new Error('<DraggableCore> not mounted on DragStart!');
            const { ownerDocument } = thisNode;
            // Short circuit if handle or cancel prop was provided and selector doesn't match.
            if (this.props.disabled || !(e.target instanceof ownerDocument.defaultView.Node) || this.props.handle && !(0, _domFns.matchesSelectorAndParentsTo)(e.target, this.props.handle, thisNode) || this.props.cancel && (0, _domFns.matchesSelectorAndParentsTo)(e.target, this.props.cancel, thisNode)) return;
            // Prevent scrolling on mobile devices, like ipad/iphone.
            // Important that this is after handle/cancel.
            if (e.type === 'touchstart' && !this.props.allowMobileScroll) e.preventDefault();
            // Set touch identifier in component state if this is a touch event. This allows us to
            // distinguish between individual touches on multitouch screens by identifying which
            // touchpoint was set to this element.
            const touchIdentifier = (0, _domFns.getTouchIdentifier)(e);
            this.touchIdentifier = touchIdentifier;
            // Get the current drag point from the event. This is used as the offset.
            const position = (0, _positionFns.getControlPosition)(e, touchIdentifier, this);
            if (position == null) return; // not possible but satisfies flow
            const { x, y } = position;
            // Create an event object with all the data parents need to make a decision here.
            const coreEvent = (0, _positionFns.createCoreData)(this, x, y);
            (0, _log.default)('DraggableCore: handleDragStart: %j', coreEvent);
            // Call event handler. If it returns explicit false, cancel.
            (0, _log.default)('calling', this.props.onStart);
            const shouldUpdate = this.props.onStart(e, coreEvent);
            if (shouldUpdate === false || this.mounted === false) return;
            // Add a style to the body to disable user-select. This prevents text from
            // being selected all over the page.
            if (this.props.enableUserSelectHack) (0, _domFns.addUserSelectStyles)(ownerDocument);
            // Initiate dragging. Set the current x and y as offsets
            // so we know how much we've moved during the drag. This allows us
            // to drag elements around even if they have been moved, without issue.
            this.dragging = true;
            this.lastX = x;
            this.lastY = y;
            // Add events to the document directly so we catch when the user's mouse/touch moves outside of
            // this element. We use different events depending on whether or not we have detected that this
            // is a touch-capable device.
            (0, _domFns.addEvent)(ownerDocument, dragEventFor.move, this.handleDrag);
            (0, _domFns.addEvent)(ownerDocument, dragEventFor.stop, this.handleDragStop);
        });
        _defineProperty(this, "handleDrag", (e)=>{
            // Get the current drag point from the event. This is used as the offset.
            const position = (0, _positionFns.getControlPosition)(e, this.touchIdentifier, this);
            if (position == null) return;
            let { x, y } = position;
            // Snap to grid if prop has been provided
            if (Array.isArray(this.props.grid)) {
                let deltaX = x - this.lastX, deltaY = y - this.lastY;
                [deltaX, deltaY] = (0, _positionFns.snapToGrid)(this.props.grid, deltaX, deltaY);
                if (!deltaX && !deltaY) return; // skip useless drag
                x = this.lastX + deltaX, y = this.lastY + deltaY;
            }
            const coreEvent = (0, _positionFns.createCoreData)(this, x, y);
            (0, _log.default)('DraggableCore: handleDrag: %j', coreEvent);
            // Call event handler. If it returns explicit false, trigger end.
            const shouldUpdate = this.props.onDrag(e, coreEvent);
            if (shouldUpdate === false || this.mounted === false) {
                try {
                    // $FlowIgnore
                    this.handleDragStop(new MouseEvent('mouseup'));
                } catch (err) {
                    // Old browsers
                    const event = document.createEvent('MouseEvents');
                    // I see why this insanity was deprecated
                    // $FlowIgnore
                    event.initMouseEvent('mouseup', true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
                    this.handleDragStop(event);
                }
                return;
            }
            this.lastX = x;
            this.lastY = y;
        });
        _defineProperty(this, "handleDragStop", (e)=>{
            if (!this.dragging) return;
            const position = (0, _positionFns.getControlPosition)(e, this.touchIdentifier, this);
            if (position == null) return;
            let { x, y } = position;
            // Snap to grid if prop has been provided
            if (Array.isArray(this.props.grid)) {
                let deltaX = x - this.lastX || 0;
                let deltaY = y - this.lastY || 0;
                [deltaX, deltaY] = (0, _positionFns.snapToGrid)(this.props.grid, deltaX, deltaY);
                x = this.lastX + deltaX, y = this.lastY + deltaY;
            }
            const coreEvent = (0, _positionFns.createCoreData)(this, x, y);
            // Call event handler
            const shouldContinue = this.props.onStop(e, coreEvent);
            if (shouldContinue === false || this.mounted === false) return false;
            const thisNode = this.findDOMNode();
            if (thisNode) // Remove user-select hack
            {
                if (this.props.enableUserSelectHack) (0, _domFns.scheduleRemoveUserSelectStyles)(thisNode.ownerDocument);
            }
            (0, _log.default)('DraggableCore: handleDragStop: %j', coreEvent);
            // Reset the el.
            this.dragging = false;
            this.lastX = NaN;
            this.lastY = NaN;
            if (thisNode) {
                // Remove event handlers
                (0, _log.default)('DraggableCore: Removing handlers');
                (0, _domFns.removeEvent)(thisNode.ownerDocument, dragEventFor.move, this.handleDrag);
                (0, _domFns.removeEvent)(thisNode.ownerDocument, dragEventFor.stop, this.handleDragStop);
            }
        });
        _defineProperty(this, "onMouseDown", (e)=>{
            dragEventFor = eventsFor.mouse; // on touchscreen laptops we could switch back to mouse
            return this.handleDragStart(e);
        });
        _defineProperty(this, "onMouseUp", (e)=>{
            dragEventFor = eventsFor.mouse;
            return this.handleDragStop(e);
        });
        // Same as onMouseDown (start drag), but now consider this a touch device.
        _defineProperty(this, "onTouchStart", (e)=>{
            // We're on a touch device now, so change the event handlers
            dragEventFor = eventsFor.touch;
            return this.handleDragStart(e);
        });
        _defineProperty(this, "onTouchEnd", (e)=>{
            // We're on a touch device now, so change the event handlers
            dragEventFor = eventsFor.touch;
            return this.handleDragStop(e);
        });
    }
    componentDidMount() {
        this.mounted = true;
        // Touch handlers must be added with {passive: false} to be cancelable.
        // https://developers.google.com/web/updates/2017/01/scrolling-intervention
        const thisNode = this.findDOMNode();
        if (thisNode) (0, _domFns.addEvent)(thisNode, eventsFor.touch.start, this.onTouchStart, {
            passive: false
        });
    }
    componentWillUnmount() {
        this.mounted = false;
        // Remove any leftover event handlers. Remove both touch and mouse handlers in case
        // some browser quirk caused a touch event to fire during a mouse move, or vice versa.
        const thisNode = this.findDOMNode();
        if (thisNode) {
            const { ownerDocument } = thisNode;
            (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.move, this.handleDrag);
            (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.move, this.handleDrag);
            (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.stop, this.handleDragStop);
            (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.stop, this.handleDragStop);
            (0, _domFns.removeEvent)(thisNode, eventsFor.touch.start, this.onTouchStart, {
                passive: false
            });
            if (this.props.enableUserSelectHack) (0, _domFns.scheduleRemoveUserSelectStyles)(ownerDocument);
        }
    }
    // React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find
    // the underlying DOM node ourselves. See the README for more information.
    findDOMNode() /*: ?HTMLElement*/ {
        var _this_props, _this_props_nodeRef, _this_props1;
        return ((_this_props = this.props) === null || _this_props === void 0 ? void 0 : _this_props.nodeRef) ? (_this_props1 = this.props) === null || _this_props1 === void 0 ? void 0 : (_this_props_nodeRef = _this_props1.nodeRef) === null || _this_props_nodeRef === void 0 ? void 0 : _this_props_nodeRef.current : _reactDom.default.findDOMNode(this);
    }
    render() /*: React.Element<any>*/ {
        // Reuse the child provided
        // This makes it flexible to use whatever element is wanted (div, ul, etc)
        return /*#__PURE__*/ React.cloneElement(React.Children.only(this.props.children), {
            // Note: mouseMove handler is attached to document so it will still function
            // when the user drags quickly and leaves the bounds of the element.
            onMouseDown: this.onMouseDown,
            onMouseUp: this.onMouseUp,
            // onTouchStart is added on `componentDidMount` so they can be added with
            // {passive: false}, which allows it to cancel. See
            // https://developers.google.com/web/updates/2017/01/scrolling-intervention
            onTouchEnd: this.onTouchEnd
        });
    }
}
exports.default = DraggableCore;
_defineProperty(DraggableCore, "displayName", 'DraggableCore');
_defineProperty(DraggableCore, "propTypes", {
    /**
   * `allowAnyClick` allows dragging using any mouse button.
   * By default, we only accept the left button.
   *
   * Defaults to `false`.
   */ allowAnyClick: _propTypes.default.bool,
    /**
   * `allowMobileScroll` turns off cancellation of the 'touchstart' event
   * on mobile devices. Only enable this if you are having trouble with click
   * events. Prefer using 'handle' / 'cancel' instead.
   *
   * Defaults to `false`.
   */ allowMobileScroll: _propTypes.default.bool,
    children: _propTypes.default.node.isRequired,
    /**
   * `disabled`, if true, stops the <Draggable> from dragging. All handlers,
   * with the exception of `onMouseDown`, will not fire.
   */ disabled: _propTypes.default.bool,
    /**
   * By default, we add 'user-select:none' attributes to the document body
   * to prevent ugly text selection during drag. If this is causing problems
   * for your app, set this to `false`.
   */ enableUserSelectHack: _propTypes.default.bool,
    /**
   * `offsetParent`, if set, uses the passed DOM node to compute drag offsets
   * instead of using the parent node.
   */ offsetParent: function(props /*: DraggableCoreProps*/ , propName /*: $Keys<DraggableCoreProps>*/ ) {
        if (props[propName] && props[propName].nodeType !== 1) throw new Error('Draggable\'s offsetParent must be a DOM Node.');
    },
    /**
   * `grid` specifies the x and y that dragging should snap to.
   */ grid: _propTypes.default.arrayOf(_propTypes.default.number),
    /**
   * `handle` specifies a selector to be used as the handle that initiates drag.
   *
   * Example:
   *
   * ```jsx
   *   let App = React.createClass({
   *       render: function () {
   *         return (
   *            <Draggable handle=".handle">
   *              <div>
   *                  <div className="handle">Click me to drag</div>
   *                  <div>This is some other content</div>
   *              </div>
   *           </Draggable>
   *         );
   *       }
   *   });
   * ```
   */ handle: _propTypes.default.string,
    /**
   * `cancel` specifies a selector to be used to prevent drag initialization.
   *
   * Example:
   *
   * ```jsx
   *   let App = React.createClass({
   *       render: function () {
   *           return(
   *               <Draggable cancel=".cancel">
   *                   <div>
   *                     <div className="cancel">You can't drag from here</div>
   *                     <div>Dragging here works fine</div>
   *                   </div>
   *               </Draggable>
   *           );
   *       }
   *   });
   * ```
   */ cancel: _propTypes.default.string,
    /* If running in React Strict mode, ReactDOM.findDOMNode() is deprecated.
   * Unfortunately, in order for <Draggable> to work properly, we need raw access
   * to the underlying DOM node. If you want to avoid the warning, pass a `nodeRef`
   * as in this example:
   *
   * function MyComponent() {
   *   const nodeRef = React.useRef(null);
   *   return (
   *     <Draggable nodeRef={nodeRef}>
   *       <div ref={nodeRef}>Example Target</div>
   *     </Draggable>
   *   );
   * }
   *
   * This can be used for arbitrarily nested components, so long as the ref ends up
   * pointing to the actual child DOM node and not a custom component.
   */ nodeRef: _propTypes.default.object,
    /**
   * Called when dragging starts.
   * If this function returns the boolean false, dragging will be canceled.
   */ onStart: _propTypes.default.func,
    /**
   * Called while dragging.
   * If this function returns the boolean false, dragging will be canceled.
   */ onDrag: _propTypes.default.func,
    /**
   * Called when dragging stops.
   * If this function returns the boolean false, the drag will remain active.
   */ onStop: _propTypes.default.func,
    /**
   * A workaround option which can be passed if onMouseDown needs to be accessed,
   * since it'll always be blocked (as there is internal use of onMouseDown)
   */ onMouseDown: _propTypes.default.func,
    /**
   * `scale`, if set, applies scaling while dragging an element
   */ scale: _propTypes.default.number,
    /**
   * These properties should be defined on the child, not here.
   */ className: _shims.dontSetMe,
    style: _shims.dontSetMe,
    transform: _shims.dontSetMe
});
_defineProperty(DraggableCore, "defaultProps", {
    allowAnyClick: false,
    // by default only accept left click
    allowMobileScroll: false,
    disabled: false,
    enableUserSelectHack: true,
    onStart: function() {},
    onDrag: function() {},
    onStop: function() {},
    onMouseDown: function() {},
    scale: 1
});

},
"node_modules/react-draggable/build/cjs/cjs.js": function (module, exports, __mako_require__){
"use strict";
const { default: Draggable, DraggableCore } = __mako_require__("node_modules/react-draggable/build/cjs/Draggable.js");
// Previous versions of this lib exported <Draggable> as the root export. As to no-// them, or TypeScript, we export *both* as the root and as 'default'.
// See https://github.com/mzabriskie/react-draggable/pull/254
// and https://github.com/mzabriskie/react-draggable/issues/266
module.exports = Draggable;
module.exports.default = Draggable;
module.exports.DraggableCore = DraggableCore;

},
"node_modules/react-draggable/build/cjs/utils/domFns.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
exports.addClassName = addClassName;
exports.addEvent = addEvent;
exports.addUserSelectStyles = addUserSelectStyles;
exports.createCSSTransform = createCSSTransform;
exports.createSVGTransform = createSVGTransform;
exports.getTouch = getTouch;
exports.getTouchIdentifier = getTouchIdentifier;
exports.getTranslation = getTranslation;
exports.innerHeight = innerHeight;
exports.innerWidth = innerWidth;
exports.matchesSelector = matchesSelector;
exports.matchesSelectorAndParentsTo = matchesSelectorAndParentsTo;
exports.offsetXYFromParent = offsetXYFromParent;
exports.outerHeight = outerHeight;
exports.outerWidth = outerWidth;
exports.removeClassName = removeClassName;
exports.removeEvent = removeEvent;
exports.scheduleRemoveUserSelectStyles = scheduleRemoveUserSelectStyles;
var _shims = __mako_require__("node_modules/react-draggable/build/cjs/utils/shims.js");
var _getPrefix = _interopRequireWildcard(__mako_require__("node_modules/react-draggable/build/cjs/utils/getPrefix.js"));
function _interopRequireWildcard(e, t) {
    if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap();
    return (_interopRequireWildcard = function(e, t) {
        if (!t && e && e.__esModule) return e;
        var o, i, f = {
            __proto__: null,
            default: e
        };
        if (null === e || "object" != typeof e && "function" != typeof e) return f;
        if (o = t ? n : r) {
            if (o.has(e)) return o.get(e);
            o.set(e, f);
        }
        for(const t in e)"default" !== t && ({}).hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]);
        return f;
    })(e, t);
}
/*:: import type {ControlPosition, PositionOffsetControlPosition, MouseTouchEvent} from './types';*/ let matchesSelectorFunc = '';
function matchesSelector(el /*: Node*/ , selector /*: string*/ ) /*: boolean*/ {
    if (!matchesSelectorFunc) matchesSelectorFunc = (0, _shims.findInArray)([
        'matches',
        'webkitMatchesSelector',
        'mozMatchesSelector',
        'msMatchesSelector',
        'oMatchesSelector'
    ], function(method) {
        // $FlowIgnore: Doesn't think elements are indexable
        return (0, _shims.isFunction)(el[method]);
    });
    // Might not be found entirely (not an Element?) - in that case, bail
    // $FlowIgnore: Doesn't think elements are indexable
    if (!(0, _shims.isFunction)(el[matchesSelectorFunc])) return false;
    // $FlowIgnore: Doesn't think elements are indexable
    return el[matchesSelectorFunc](selector);
}
// Works up the tree to the draggable itself attempting to match selector.
function matchesSelectorAndParentsTo(el /*: Node*/ , selector /*: string*/ , baseNode /*: Node*/ ) /*: boolean*/ {
    let node = el;
    do {
        if (matchesSelector(node, selector)) return true;
        if (node === baseNode) return false;
        // $FlowIgnore[incompatible-type]
        node = node.parentNode;
    }while (node)
    return false;
}
function addEvent(el /*: ?Node*/ , event /*: string*/ , handler /*: Function*/ , inputOptions /*: Object*/ ) /*: void*/ {
    if (!el) return;
    const options = {
        capture: true,
        ...inputOptions
    };
    // $FlowIgnore[method-unbinding]
    if (el.addEventListener) el.addEventListener(event, handler, options);
    else if (el.attachEvent) el.attachEvent('on' + event, handler);
    else // $FlowIgnore: Doesn't think elements are indexable
    el['on' + event] = handler;
}
function removeEvent(el /*: ?Node*/ , event /*: string*/ , handler /*: Function*/ , inputOptions /*: Object*/ ) /*: void*/ {
    if (!el) return;
    const options = {
        capture: true,
        ...inputOptions
    };
    // $FlowIgnore[method-unbinding]
    if (el.removeEventListener) el.removeEventListener(event, handler, options);
    else if (el.detachEvent) el.detachEvent('on' + event, handler);
    else // $FlowIgnore: Doesn't think elements are indexable
    el['on' + event] = null;
}
function outerHeight(node /*: HTMLElement*/ ) /*: number*/ {
    // This is deliberately excluding margin for our calculations, since we are using
    // offsetTop which is including margin. See getBoundPosition
    let height = node.clientHeight;
    const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
    height += (0, _shims.int)(computedStyle.borderTopWidth);
    height += (0, _shims.int)(computedStyle.borderBottomWidth);
    return height;
}
function outerWidth(node /*: HTMLElement*/ ) /*: number*/ {
    // This is deliberately excluding margin for our calculations, since we are using
    // offsetLeft which is including margin. See getBoundPosition
    let width = node.clientWidth;
    const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
    width += (0, _shims.int)(computedStyle.borderLeftWidth);
    width += (0, _shims.int)(computedStyle.borderRightWidth);
    return width;
}
function innerHeight(node /*: HTMLElement*/ ) /*: number*/ {
    let height = node.clientHeight;
    const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
    height -= (0, _shims.int)(computedStyle.paddingTop);
    height -= (0, _shims.int)(computedStyle.paddingBottom);
    return height;
}
function innerWidth(node /*: HTMLElement*/ ) /*: number*/ {
    let width = node.clientWidth;
    const computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
    width -= (0, _shims.int)(computedStyle.paddingLeft);
    width -= (0, _shims.int)(computedStyle.paddingRight);
    return width;
}
/*:: interface EventWithOffset {
  clientX: number, clientY: number
}*/ // Get from offsetParent
function offsetXYFromParent(evt /*: EventWithOffset*/ , offsetParent /*: HTMLElement*/ , scale /*: number*/ ) /*: ControlPosition*/ {
    const isBody = offsetParent === offsetParent.ownerDocument.body;
    const offsetParentRect = isBody ? {
        left: 0,
        top: 0
    } : offsetParent.getBoundingClientRect();
    const x = (evt.clientX + offsetParent.scrollLeft - offsetParentRect.left) / scale;
    const y = (evt.clientY + offsetParent.scrollTop - offsetParentRect.top) / scale;
    return {
        x,
        y
    };
}
function createCSSTransform(controlPos /*: ControlPosition*/ , positionOffset /*: PositionOffsetControlPosition*/ ) /*: Object*/ {
    const translation = getTranslation(controlPos, positionOffset, 'px');
    return {
        [(0, _getPrefix.browserPrefixToKey)('transform', _getPrefix.default)]: translation
    };
}
function createSVGTransform(controlPos /*: ControlPosition*/ , positionOffset /*: PositionOffsetControlPosition*/ ) /*: string*/ {
    const translation = getTranslation(controlPos, positionOffset, '');
    return translation;
}
function getTranslation(_ref /*:: */ , positionOffset /*: PositionOffsetControlPosition*/ , unitSuffix /*: string*/ ) /*: string*/ {
    let { x, y } /*: ControlPosition*/  = _ref /*: ControlPosition*/ ;
    let translation = `translate(${x}${unitSuffix},${y}${unitSuffix})`;
    if (positionOffset) {
        const defaultX = `${typeof positionOffset.x === 'string' ? positionOffset.x : positionOffset.x + unitSuffix}`;
        const defaultY = `${typeof positionOffset.y === 'string' ? positionOffset.y : positionOffset.y + unitSuffix}`;
        translation = `translate(${defaultX}, ${defaultY})` + translation;
    }
    return translation;
}
function getTouch(e /*: MouseTouchEvent*/ , identifier /*: number*/ ) /*: ?{clientX: number, clientY: number}*/ {
    return e.targetTouches && (0, _shims.findInArray)(e.targetTouches, (t)=>identifier === t.identifier) || e.changedTouches && (0, _shims.findInArray)(e.changedTouches, (t)=>identifier === t.identifier);
}
function getTouchIdentifier(e /*: MouseTouchEvent*/ ) /*: ?number*/ {
    if (e.targetTouches && e.targetTouches[0]) return e.targetTouches[0].identifier;
    if (e.changedTouches && e.changedTouches[0]) return e.changedTouches[0].identifier;
}
// User-select Hacks:
//
// Useful for preventing blue highlights all over everything when dragging.
// Note we're passing `document` b/c we could be iframed
function addUserSelectStyles(doc /*: ?Document*/ ) {
    if (!doc) return;
    let styleEl = doc.getElementById('react-draggable-style-el');
    if (!styleEl) {
        styleEl = doc.createElement('style');
        styleEl.type = 'text/css';
        styleEl.id = 'react-draggable-style-el';
        styleEl.innerHTML = '.react-draggable-transparent-selection *::-moz-selection {all: inherit;}\n';
        styleEl.innerHTML += '.react-draggable-transparent-selection *::selection {all: inherit;}\n';
        doc.getElementsByTagName('head')[0].appendChild(styleEl);
    }
    if (doc.body) addClassName(doc.body, 'react-draggable-transparent-selection');
}
function scheduleRemoveUserSelectStyles(doc /*: ?Document*/ ) {
    // Prevent a possible "forced reflow"
    if (window.requestAnimationFrame) window.requestAnimationFrame(()=>{
        removeUserSelectStyles(doc);
    });
    else removeUserSelectStyles(doc);
}
function removeUserSelectStyles(doc /*: ?Document*/ ) {
    if (!doc) return;
    try {
        if (doc.body) removeClassName(doc.body, 'react-draggable-transparent-selection');
        // $FlowIgnore: IE
        if (doc.selection) // $FlowIgnore: IE
        doc.selection.empty();
        else {
            // Remove selection caused by scroll, unless it's a focused input
            // (we use doc.defaultView in case we're in an iframe)
            const selection = (doc.defaultView || window).getSelection();
            if (selection && selection.type !== 'Caret') selection.removeAllRanges();
        }
    } catch (e) {
    // probably IE
    }
}
function addClassName(el /*: HTMLElement*/ , className /*: string*/ ) {
    if (el.classList) el.classList.add(className);
    else if (!el.className.match(new RegExp(`(?:^|\\s)${className}(?!\\S)`))) el.className += ` ${className}`;
}
function removeClassName(el /*: HTMLElement*/ , className /*: string*/ ) {
    if (el.classList) el.classList.remove(className);
    else el.className = el.className.replace(new RegExp(`(?:^|\\s)${className}(?!\\S)`, 'g'), '');
}

},
"node_modules/react-draggable/build/cjs/utils/getPrefix.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
exports.browserPrefixToKey = browserPrefixToKey;
exports.browserPrefixToStyle = browserPrefixToStyle;
exports.default = void 0;
exports.getPrefix = getPrefix;
const prefixes = [
    'Moz',
    'Webkit',
    'O',
    'ms'
];
function getPrefix() /*: string*/ {
    var _window_document_documentElement, _window_document;
    let prop /*: string*/  = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'transform';
    // Ensure we're running in an environment where there is actually a global
    // `window` obj
    if (typeof window === 'undefined') return '';
    // If we're in a pseudo-browser server-side environment, this access
    // path may not exist, so bail out if it doesn't.
    const style = (_window_document = window.document) === null || _window_document === void 0 ? void 0 : (_window_document_documentElement = _window_document.documentElement) === null || _window_document_documentElement === void 0 ? void 0 : _window_document_documentElement.style;
    if (!style) return '';
    if (prop in style) return '';
    for(let i = 0; i < prefixes.length; i++){
        if (browserPrefixToKey(prop, prefixes[i]) in style) return prefixes[i];
    }
    return '';
}
function browserPrefixToKey(prop /*: string*/ , prefix /*: string*/ ) /*: string*/ {
    return prefix ? `${prefix}${kebabToTitleCase(prop)}` : prop;
}
function browserPrefixToStyle(prop /*: string*/ , prefix /*: string*/ ) /*: string*/ {
    return prefix ? `-${prefix.toLowerCase()}-${prop}` : prop;
}
function kebabToTitleCase(str /*: string*/ ) /*: string*/ {
    let out = '';
    let shouldCapitalize = true;
    for(let i = 0; i < str.length; i++){
        if (shouldCapitalize) {
            out += str[i].toUpperCase();
            shouldCapitalize = false;
        } else if (str[i] === '-') shouldCapitalize = true;
        else out += str[i];
    }
    return out;
}
// Default export is the prefix itself, like 'Moz', 'Webkit', etc
// Note that you may have to re-test for certain things; for instance, Chrome 50
// can handle unprefixed `transform`, but not unprefixed `user-select`
var _default = exports.default = getPrefix();

},
"node_modules/react-draggable/build/cjs/utils/log.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
exports.default = log;
/*eslint no-console:0*/ function log() {}

},
"node_modules/react-draggable/build/cjs/utils/positionFns.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
exports.canDragX = canDragX;
exports.canDragY = canDragY;
exports.createCoreData = createCoreData;
exports.createDraggableData = createDraggableData;
exports.getBoundPosition = getBoundPosition;
exports.getControlPosition = getControlPosition;
exports.snapToGrid = snapToGrid;
var _shims = __mako_require__("node_modules/react-draggable/build/cjs/utils/shims.js");
var _domFns = __mako_require__("node_modules/react-draggable/build/cjs/utils/domFns.js");
/*:: import type Draggable from '../Draggable';*/ /*:: import type {Bounds, ControlPosition, DraggableData, MouseTouchEvent} from './types';*/ /*:: import type DraggableCore from '../DraggableCore';*/ function getBoundPosition(draggable /*: Draggable*/ , x /*: number*/ , y /*: number*/ ) /*: [number, number]*/ {
    // If no bounds, short-circuit and move on
    if (!draggable.props.bounds) return [
        x,
        y
    ];
    // Clone new bounds
    let { bounds } = draggable.props;
    bounds = typeof bounds === 'string' ? bounds : cloneBounds(bounds);
    const node = findDOMNode(draggable);
    if (typeof bounds === 'string') {
        const { ownerDocument } = node;
        const ownerWindow = ownerDocument.defaultView;
        let boundNode;
        if (bounds === 'parent') boundNode = node.parentNode;
        else {
            // Flow assigns the wrong return type (Node) for getRootNode(),
            // so we cast it to one of the correct types (Element).
            // The others are Document and ShadowRoot.
            // All three implement querySelector() so it's safe to call.
            const rootNode = node.getRootNode();
            boundNode = rootNode.querySelector(bounds);
        }
        if (!(boundNode instanceof ownerWindow.HTMLElement)) throw new Error('Bounds selector "' + bounds + '" could not find an element.');
        const boundNodeEl /*: HTMLElement*/  = boundNode; // for Flow, can't seem to refine correctly
        const nodeStyle = ownerWindow.getComputedStyle(node);
        const boundNodeStyle = ownerWindow.getComputedStyle(boundNodeEl);
        // Compute bounds. This is a pain with padding and offsets but this gets it exactly right.
        bounds = {
            left: -node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingLeft) + (0, _shims.int)(nodeStyle.marginLeft),
            top: -node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingTop) + (0, _shims.int)(nodeStyle.marginTop),
            right: (0, _domFns.innerWidth)(boundNodeEl) - (0, _domFns.outerWidth)(node) - node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingRight) - (0, _shims.int)(nodeStyle.marginRight),
            bottom: (0, _domFns.innerHeight)(boundNodeEl) - (0, _domFns.outerHeight)(node) - node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingBottom) - (0, _shims.int)(nodeStyle.marginBottom)
        };
    }
    // Keep x and y below right and bottom limits...
    if ((0, _shims.isNum)(bounds.right)) x = Math.min(x, bounds.right);
    if ((0, _shims.isNum)(bounds.bottom)) y = Math.min(y, bounds.bottom);
    // But above left and top limits.
    if ((0, _shims.isNum)(bounds.left)) x = Math.max(x, bounds.left);
    if ((0, _shims.isNum)(bounds.top)) y = Math.max(y, bounds.top);
    return [
        x,
        y
    ];
}
function snapToGrid(grid /*: [number, number]*/ , pendingX /*: number*/ , pendingY /*: number*/ ) /*: [number, number]*/ {
    const x = Math.round(pendingX / grid[0]) * grid[0];
    const y = Math.round(pendingY / grid[1]) * grid[1];
    return [
        x,
        y
    ];
}
function canDragX(draggable /*: Draggable*/ ) /*: boolean*/ {
    return draggable.props.axis === 'both' || draggable.props.axis === 'x';
}
function canDragY(draggable /*: Draggable*/ ) /*: boolean*/ {
    return draggable.props.axis === 'both' || draggable.props.axis === 'y';
}
// Get {x, y} positions from event.
function getControlPosition(e /*: MouseTouchEvent*/ , touchIdentifier /*: ?number*/ , draggableCore /*: DraggableCore*/ ) /*: ?ControlPosition*/ {
    const touchObj = typeof touchIdentifier === 'number' ? (0, _domFns.getTouch)(e, touchIdentifier) : null;
    if (typeof touchIdentifier === 'number' && !touchObj) return null; // not the right touch
    const node = findDOMNode(draggableCore);
    // User can provide an offsetParent if desired.
    const offsetParent = draggableCore.props.offsetParent || node.offsetParent || node.ownerDocument.body;
    return (0, _domFns.offsetXYFromParent)(touchObj || e, offsetParent, draggableCore.props.scale);
}
// Create an data object exposed by <DraggableCore>'s events
function createCoreData(draggable /*: DraggableCore*/ , x /*: number*/ , y /*: number*/ ) /*: DraggableData*/ {
    const isStart = !(0, _shims.isNum)(draggable.lastX);
    const node = findDOMNode(draggable);
    if (isStart) // If this is our first move, use the x and y as last coords.
    return {
        node,
        deltaX: 0,
        deltaY: 0,
        lastX: x,
        lastY: y,
        x,
        y
    };
    else // Otherwise calculate proper values.
    return {
        node,
        deltaX: x - draggable.lastX,
        deltaY: y - draggable.lastY,
        lastX: draggable.lastX,
        lastY: draggable.lastY,
        x,
        y
    };
}
// Create an data exposed by <Draggable>'s events
function createDraggableData(draggable /*: Draggable*/ , coreData /*: DraggableData*/ ) /*: DraggableData*/ {
    const scale = draggable.props.scale;
    return {
        node: coreData.node,
        x: draggable.state.x + coreData.deltaX / scale,
        y: draggable.state.y + coreData.deltaY / scale,
        deltaX: coreData.deltaX / scale,
        deltaY: coreData.deltaY / scale,
        lastX: draggable.state.x,
        lastY: draggable.state.y
    };
}
// A lot faster than stringify/parse
function cloneBounds(bounds /*: Bounds*/ ) /*: Bounds*/ {
    return {
        left: bounds.left,
        top: bounds.top,
        right: bounds.right,
        bottom: bounds.bottom
    };
}
function findDOMNode(draggable /*: Draggable | DraggableCore*/ ) /*: HTMLElement*/ {
    const node = draggable.findDOMNode();
    if (!node) throw new Error('<DraggableCore>: Unmounted during event!');
    // $FlowIgnore we can't assert on HTMLElement due to tests... FIXME
    return node;
}

},
"node_modules/react-draggable/build/cjs/utils/shims.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
exports.dontSetMe = dontSetMe;
exports.findInArray = findInArray;
exports.int = int;
exports.isFunction = isFunction;
exports.isNum = isNum;
// @credits https://gist.github.com/rogozhnikoff/a43cfed27c41e4e68cdc
function findInArray(array /*: Array<any> | TouchList*/ , callback /*: Function*/ ) /*: any*/ {
    for(let i = 0, length = array.length; i < length; i++){
        if (callback.apply(callback, [
            array[i],
            i,
            array
        ])) return array[i];
    }
}
function isFunction(func /*: any*/ ) /*: boolean %checks*/ {
    // $FlowIgnore[method-unbinding]
    return typeof func === 'function' || Object.prototype.toString.call(func) === '[object Function]';
}
function isNum(num /*: any*/ ) /*: boolean %checks*/ {
    return typeof num === 'number' && !isNaN(num);
}
function int(a /*: string*/ ) /*: number*/ {
    return parseInt(a, 10);
}
function dontSetMe(props /*: Object*/ , propName /*: string*/ , componentName /*: string*/ ) /*: ?Error*/ {
    if (props[propName]) return new Error(`Invalid prop ${propName} passed to ${componentName} - do not set this, set it on the child.`);
}

},
"node_modules/sucrase/dist/esm/CJSImportProcessor.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, /**
 * Class responsible for preprocessing and bookkeeping import and export declarations within the
 * file.
 *
 * TypeScript uses a simpler mechanism that does not use functions like interopRequireDefault and
 * interopRequireWildcard, so we also allow that mode for compatibility.
 */ "default", {
    enumerable: true,
    get: function() {
        return CJSImportProcessor;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _tokenizer = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/index.js");
var _keywords = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/keywords.js");
var _types = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/types.js");
var _getImportExportSpecifierInfo = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/sucrase/dist/esm/util/getImportExportSpecifierInfo.js"));
var _getNonTypeIdentifiers = __mako_require__("node_modules/sucrase/dist/esm/util/getNonTypeIdentifiers.js");
class CJSImportProcessor {
    __init() {
        this.nonTypeIdentifiers = new Set();
    }
    __init2() {
        this.importInfoByPath = new Map();
    }
    __init3() {
        this.importsToReplace = new Map();
    }
    __init4() {
        this.identifierReplacements = new Map();
    }
    __init5() {
        this.exportBindingsByLocalName = new Map();
    }
    constructor(nameManager, tokens, enableLegacyTypeScriptModuleInterop, options, isTypeScriptTransformEnabled, keepUnusedImports, helperManager){
        this.nameManager = nameManager;
        this.tokens = tokens;
        this.enableLegacyTypeScriptModuleInterop = enableLegacyTypeScriptModuleInterop;
        this.options = options;
        this.isTypeScriptTransformEnabled = isTypeScriptTransformEnabled;
        this.keepUnusedImports = keepUnusedImports;
        this.helperManager = helperManager;
        CJSImportProcessor.prototype.__init.call(this);
        CJSImportProcessor.prototype.__init2.call(this);
        CJSImportProcessor.prototype.__init3.call(this);
        CJSImportProcessor.prototype.__init4.call(this);
        CJSImportProcessor.prototype.__init5.call(this);
    }
    preprocessTokens() {
        for(let i = 0; i < this.tokens.tokens.length; i++){
            if (this.tokens.matches1AtIndex(i, _types.TokenType._import) && !this.tokens.matches3AtIndex(i, _types.TokenType._import, _types.TokenType.name, _types.TokenType.eq)) this.preprocessImportAtIndex(i);
            if (this.tokens.matches1AtIndex(i, _types.TokenType._export) && !this.tokens.matches2AtIndex(i, _types.TokenType._export, _types.TokenType.eq)) this.preprocessExportAtIndex(i);
        }
        this.generateImportReplacements();
    }
    /**
   * In TypeScript, import statements that only import types should be removed.
   * This includes `import {} from 'foo';`, but not `import 'foo';`.
   */ pruneTypeOnlyImports() {
        this.nonTypeIdentifiers = (0, _getNonTypeIdentifiers.getNonTypeIdentifiers)(this.tokens, this.options);
        for (const [path, importInfo] of this.importInfoByPath.entries()){
            if (importInfo.hasBareImport || importInfo.hasStarExport || importInfo.exportStarNames.length > 0 || importInfo.namedExports.length > 0) continue;
            const names = [
                ...importInfo.defaultNames,
                ...importInfo.wildcardNames,
                ...importInfo.namedImports.map(({ localName })=>localName)
            ];
            if (names.every((name)=>this.shouldAutomaticallyElideImportedName(name))) this.importsToReplace.set(path, "");
        }
    }
    shouldAutomaticallyElideImportedName(name) {
        return this.isTypeScriptTransformEnabled && !this.keepUnusedImports && !this.nonTypeIdentifiers.has(name);
    }
    generateImportReplacements() {
        for (const [path, importInfo] of this.importInfoByPath.entries()){
            const { defaultNames, wildcardNames, namedImports, namedExports, exportStarNames, hasStarExport } = importInfo;
            if (defaultNames.length === 0 && wildcardNames.length === 0 && namedImports.length === 0 && namedExports.length === 0 && exportStarNames.length === 0 && !hasStarExport) {
                // Import is never used, so don't even assign a name.
                this.importsToReplace.set(path, `require('${path}');`);
                continue;
            }
            const primaryImportName = this.getFreeIdentifierForPath(path);
            let secondaryImportName;
            if (this.enableLegacyTypeScriptModuleInterop) secondaryImportName = primaryImportName;
            else secondaryImportName = wildcardNames.length > 0 ? wildcardNames[0] : this.getFreeIdentifierForPath(path);
            let requireCode = `var ${primaryImportName} = require('${path}');`;
            if (wildcardNames.length > 0) for (const wildcardName of wildcardNames){
                const moduleExpr = this.enableLegacyTypeScriptModuleInterop ? primaryImportName : `${this.helperManager.getHelperName("interopRequireWildcard")}(${primaryImportName})`;
                requireCode += ` var ${wildcardName} = ${moduleExpr};`;
            }
            else if (exportStarNames.length > 0 && secondaryImportName !== primaryImportName) requireCode += ` var ${secondaryImportName} = ${this.helperManager.getHelperName("interopRequireWildcard")}(${primaryImportName});`;
            else if (defaultNames.length > 0 && secondaryImportName !== primaryImportName) requireCode += ` var ${secondaryImportName} = ${this.helperManager.getHelperName("interopRequireDefault")}(${primaryImportName});`;
            for (const { importedName, localName } of namedExports)requireCode += ` ${this.helperManager.getHelperName("createNamedExportFrom")}(${primaryImportName}, '${localName}', '${importedName}');`;
            for (const exportStarName of exportStarNames)requireCode += ` exports.${exportStarName} = ${secondaryImportName};`;
            if (hasStarExport) requireCode += ` ${this.helperManager.getHelperName("createStarExport")}(${primaryImportName});`;
            this.importsToReplace.set(path, requireCode);
            for (const defaultName of defaultNames)this.identifierReplacements.set(defaultName, `${secondaryImportName}.default`);
            for (const { importedName, localName } of namedImports)this.identifierReplacements.set(localName, `${primaryImportName}.${importedName}`);
        }
    }
    getFreeIdentifierForPath(path) {
        const components = path.split("/");
        const lastComponent = components[components.length - 1];
        const baseName = lastComponent.replace(/\W/g, "");
        return this.nameManager.claimFreeName(`_${baseName}`);
    }
    preprocessImportAtIndex(index) {
        const defaultNames = [];
        const wildcardNames = [];
        const namedImports = [];
        index++;
        if ((this.tokens.matchesContextualAtIndex(index, _keywords.ContextualKeyword._type) || this.tokens.matches1AtIndex(index, _types.TokenType._typeof)) && !this.tokens.matches1AtIndex(index + 1, _types.TokenType.comma) && !this.tokens.matchesContextualAtIndex(index + 1, _keywords.ContextualKeyword._from)) // import type declaration, so no need to process anything.
        return;
        if (this.tokens.matches1AtIndex(index, _types.TokenType.parenL)) // Dynamic import, so nothing to do
        return;
        if (this.tokens.matches1AtIndex(index, _types.TokenType.name)) {
            defaultNames.push(this.tokens.identifierNameAtIndex(index));
            index++;
            if (this.tokens.matches1AtIndex(index, _types.TokenType.comma)) index++;
        }
        if (this.tokens.matches1AtIndex(index, _types.TokenType.star)) {
            // * as
            index += 2;
            wildcardNames.push(this.tokens.identifierNameAtIndex(index));
            index++;
        }
        if (this.tokens.matches1AtIndex(index, _types.TokenType.braceL)) {
            const result = this.getNamedImports(index + 1);
            index = result.newIndex;
            for (const namedImport of result.namedImports)// Treat {default as X} as a default import to ensure usage of require interop helper
            if (namedImport.importedName === "default") defaultNames.push(namedImport.localName);
            else namedImports.push(namedImport);
        }
        if (this.tokens.matchesContextualAtIndex(index, _keywords.ContextualKeyword._from)) index++;
        if (!this.tokens.matches1AtIndex(index, _types.TokenType.string)) throw new Error("Expected string token at the end of import statement.");
        const path = this.tokens.stringValueAtIndex(index);
        const importInfo = this.getImportInfo(path);
        importInfo.defaultNames.push(...defaultNames);
        importInfo.wildcardNames.push(...wildcardNames);
        importInfo.namedImports.push(...namedImports);
        if (defaultNames.length === 0 && wildcardNames.length === 0 && namedImports.length === 0) importInfo.hasBareImport = true;
    }
    preprocessExportAtIndex(index) {
        if (this.tokens.matches2AtIndex(index, _types.TokenType._export, _types.TokenType._var) || this.tokens.matches2AtIndex(index, _types.TokenType._export, _types.TokenType._let) || this.tokens.matches2AtIndex(index, _types.TokenType._export, _types.TokenType._const)) this.preprocessVarExportAtIndex(index);
        else if (this.tokens.matches2AtIndex(index, _types.TokenType._export, _types.TokenType._function) || this.tokens.matches2AtIndex(index, _types.TokenType._export, _types.TokenType._class)) {
            const exportName = this.tokens.identifierNameAtIndex(index + 2);
            this.addExportBinding(exportName, exportName);
        } else if (this.tokens.matches3AtIndex(index, _types.TokenType._export, _types.TokenType.name, _types.TokenType._function)) {
            const exportName = this.tokens.identifierNameAtIndex(index + 3);
            this.addExportBinding(exportName, exportName);
        } else if (this.tokens.matches2AtIndex(index, _types.TokenType._export, _types.TokenType.braceL)) this.preprocessNamedExportAtIndex(index);
        else if (this.tokens.matches2AtIndex(index, _types.TokenType._export, _types.TokenType.star)) this.preprocessExportStarAtIndex(index);
    }
    preprocessVarExportAtIndex(index) {
        let depth = 0;
        // Handle cases like `export let {x} = y;`, starting at the open-brace in that case.
        for(let i = index + 2;; i++){
            if (this.tokens.matches1AtIndex(i, _types.TokenType.braceL) || this.tokens.matches1AtIndex(i, _types.TokenType.dollarBraceL) || this.tokens.matches1AtIndex(i, _types.TokenType.bracketL)) depth++;
            else if (this.tokens.matches1AtIndex(i, _types.TokenType.braceR) || this.tokens.matches1AtIndex(i, _types.TokenType.bracketR)) depth--;
            else if (depth === 0 && !this.tokens.matches1AtIndex(i, _types.TokenType.name)) break;
            else if (this.tokens.matches1AtIndex(1, _types.TokenType.eq)) {
                const endIndex = this.tokens.currentToken().rhsEndIndex;
                if (endIndex == null) throw new Error("Expected = token with an end index.");
                i = endIndex - 1;
            } else {
                const token = this.tokens.tokens[i];
                if ((0, _tokenizer.isDeclaration)(token)) {
                    const exportName = this.tokens.identifierNameAtIndex(i);
                    this.identifierReplacements.set(exportName, `exports.${exportName}`);
                }
            }
        }
    }
    /**
   * Walk this export statement just in case it's an export...from statement.
   * If it is, combine it into the import info for that path. Otherwise, just
   * bail out; it'll be handled later.
   */ preprocessNamedExportAtIndex(index) {
        // export {
        index += 2;
        const { newIndex, namedImports } = this.getNamedImports(index);
        index = newIndex;
        if (this.tokens.matchesContextualAtIndex(index, _keywords.ContextualKeyword._from)) index++;
        else {
            // Reinterpret "a as b" to be local/exported rather than imported/local.
            for (const { importedName: localName, localName: exportedName } of namedImports)this.addExportBinding(localName, exportedName);
            return;
        }
        if (!this.tokens.matches1AtIndex(index, _types.TokenType.string)) throw new Error("Expected string token at the end of import statement.");
        const path = this.tokens.stringValueAtIndex(index);
        const importInfo = this.getImportInfo(path);
        importInfo.namedExports.push(...namedImports);
    }
    preprocessExportStarAtIndex(index) {
        let exportedName = null;
        if (this.tokens.matches3AtIndex(index, _types.TokenType._export, _types.TokenType.star, _types.TokenType._as)) {
            // export * as
            index += 3;
            exportedName = this.tokens.identifierNameAtIndex(index);
            // foo from
            index += 2;
        } else // export * from
        index += 3;
        if (!this.tokens.matches1AtIndex(index, _types.TokenType.string)) throw new Error("Expected string token at the end of star export statement.");
        const path = this.tokens.stringValueAtIndex(index);
        const importInfo = this.getImportInfo(path);
        if (exportedName !== null) importInfo.exportStarNames.push(exportedName);
        else importInfo.hasStarExport = true;
    }
    getNamedImports(index) {
        const namedImports = [];
        while(true){
            if (this.tokens.matches1AtIndex(index, _types.TokenType.braceR)) {
                index++;
                break;
            }
            const specifierInfo = (0, _getImportExportSpecifierInfo.default)(this.tokens, index);
            index = specifierInfo.endIndex;
            if (!specifierInfo.isType) namedImports.push({
                importedName: specifierInfo.leftName,
                localName: specifierInfo.rightName
            });
            if (this.tokens.matches2AtIndex(index, _types.TokenType.comma, _types.TokenType.braceR)) {
                index += 2;
                break;
            } else if (this.tokens.matches1AtIndex(index, _types.TokenType.braceR)) {
                index++;
                break;
            } else if (this.tokens.matches1AtIndex(index, _types.TokenType.comma)) index++;
            else throw new Error(`Unexpected token: ${JSON.stringify(this.tokens.tokens[index])}`);
        }
        return {
            newIndex: index,
            namedImports
        };
    }
    /**
   * Get a mutable import info object for this path, creating one if it doesn't
   * exist yet.
   */ getImportInfo(path) {
        const existingInfo = this.importInfoByPath.get(path);
        if (existingInfo) return existingInfo;
        const newInfo = {
            defaultNames: [],
            wildcardNames: [],
            namedImports: [],
            namedExports: [],
            hasBareImport: false,
            exportStarNames: [],
            hasStarExport: false
        };
        this.importInfoByPath.set(path, newInfo);
        return newInfo;
    }
    addExportBinding(localName, exportedName) {
        if (!this.exportBindingsByLocalName.has(localName)) this.exportBindingsByLocalName.set(localName, []);
        this.exportBindingsByLocalName.get(localName).push(exportedName);
    }
    /**
   * Return the code to use for the import for this path, or the empty string if
   * the code has already been "claimed" by a previous import.
   */ claimImportCode(importPath) {
        const result = this.importsToReplace.get(importPath);
        this.importsToReplace.set(importPath, "");
        return result || "";
    }
    getIdentifierReplacement(identifierName) {
        return this.identifierReplacements.get(identifierName) || null;
    }
    /**
   * Return a string like `exports.foo = exports.bar`.
   */ resolveExportBinding(assignedName) {
        const exportedNames = this.exportBindingsByLocalName.get(assignedName);
        if (!exportedNames || exportedNames.length === 0) return null;
        return exportedNames.map((exportedName)=>`exports.${exportedName}`).join(" = ");
    }
    /**
   * Return all imported/exported names where we might be interested in whether usages of those
   * names are shadowed.
   */ getGlobalNames() {
        return new Set([
            ...this.identifierReplacements.keys(),
            ...this.exportBindingsByLocalName.keys()
        ]);
    }
}

},
"node_modules/sucrase/dist/esm/HelperManager.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "HelperManager", {
    enumerable: true,
    get: function() {
        return HelperManager;
    }
});
const HELPERS = {
    require: `
    import {createRequire as CREATE_REQUIRE_NAME} from "module";
    const require = CREATE_REQUIRE_NAME(import.meta.url);
  `,
    interopRequireWildcard: `
    function interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              newObj[key] = obj[key];
            }
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
  `,
    interopRequireDefault: `
    function interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
  `,
    createNamedExportFrom: `
    function createNamedExportFrom(obj, localName, importedName) {
      Object.defineProperty(exports, localName, {enumerable: true, configurable: true, get: () => obj[importedName]});
    }
  `,
    // Note that TypeScript and Babel do this differently; TypeScript does a simple existence
    // check in the exports object and does a plain assignment, whereas Babel uses
    // defineProperty and builds an object of explicitly-exported names so that star exports can
    // always take lower precedence. For now, we do the easier TypeScript thing.
    createStarExport: `
    function createStarExport(obj) {
      Object.keys(obj)
        .filter((key) => key !== "default" && key !== "__esModule")
        .forEach((key) => {
          if (exports.hasOwnProperty(key)) {
            return;
          }
          Object.defineProperty(exports, key, {enumerable: true, configurable: true, get: () => obj[key]});
        });
    }
  `,
    nullishCoalesce: `
    function nullishCoalesce(lhs, rhsFn) {
      if (lhs != null) {
        return lhs;
      } else {
        return rhsFn();
      }
    }
  `,
    asyncNullishCoalesce: `
    async function asyncNullishCoalesce(lhs, rhsFn) {
      if (lhs != null) {
        return lhs;
      } else {
        return await rhsFn();
      }
    }
  `,
    optionalChain: `
    function optionalChain(ops) {
      let lastAccessLHS = undefined;
      let value = ops[0];
      let i = 1;
      while (i < ops.length) {
        const op = ops[i];
        const fn = ops[i + 1];
        i += 2;
        if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {
          return undefined;
        }
        if (op === 'access' || op === 'optionalAccess') {
          lastAccessLHS = value;
          value = fn(value);
        } else if (op === 'call' || op === 'optionalCall') {
          value = fn((...args) => value.call(lastAccessLHS, ...args));
          lastAccessLHS = undefined;
        }
      }
      return value;
    }
  `,
    asyncOptionalChain: `
    async function asyncOptionalChain(ops) {
      let lastAccessLHS = undefined;
      let value = ops[0];
      let i = 1;
      while (i < ops.length) {
        const op = ops[i];
        const fn = ops[i + 1];
        i += 2;
        if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {
          return undefined;
        }
        if (op === 'access' || op === 'optionalAccess') {
          lastAccessLHS = value;
          value = await fn(value);
        } else if (op === 'call' || op === 'optionalCall') {
          value = await fn((...args) => value.call(lastAccessLHS, ...args));
          lastAccessLHS = undefined;
        }
      }
      return value;
    }
  `,
    optionalChainDelete: `
    function optionalChainDelete(ops) {
      const result = OPTIONAL_CHAIN_NAME(ops);
      return result == null ? true : result;
    }
  `,
    asyncOptionalChainDelete: `
    async function asyncOptionalChainDelete(ops) {
      const result = await ASYNC_OPTIONAL_CHAIN_NAME(ops);
      return result == null ? true : result;
    }
  `
};
class HelperManager {
    __init() {
        this.helperNames = {};
    }
    __init2() {
        this.createRequireName = null;
    }
    constructor(nameManager){
        this.nameManager = nameManager;
        HelperManager.prototype.__init.call(this);
        HelperManager.prototype.__init2.call(this);
    }
    getHelperName(baseName) {
        let helperName = this.helperNames[baseName];
        if (helperName) return helperName;
        helperName = this.nameManager.claimFreeName(`_${baseName}`);
        this.helperNames[baseName] = helperName;
        return helperName;
    }
    emitHelpers() {
        let resultCode = "";
        if (this.helperNames.optionalChainDelete) this.getHelperName("optionalChain");
        if (this.helperNames.asyncOptionalChainDelete) this.getHelperName("asyncOptionalChain");
        for (const [baseName, helperCodeTemplate] of Object.entries(HELPERS)){
            const helperName = this.helperNames[baseName];
            let helperCode = helperCodeTemplate;
            if (baseName === "optionalChainDelete") helperCode = helperCode.replace("OPTIONAL_CHAIN_NAME", this.helperNames.optionalChain);
            else if (baseName === "asyncOptionalChainDelete") helperCode = helperCode.replace("ASYNC_OPTIONAL_CHAIN_NAME", this.helperNames.asyncOptionalChain);
            else if (baseName === "require") {
                if (this.createRequireName === null) this.createRequireName = this.nameManager.claimFreeName("_createRequire");
                helperCode = helperCode.replace(/CREATE_REQUIRE_NAME/g, this.createRequireName);
            }
            if (helperName) {
                resultCode += " ";
                resultCode += helperCode.replace(baseName, helperName).replace(/\s+/g, " ").trim();
            }
        }
        return resultCode;
    }
}

},
"node_modules/sucrase/dist/esm/NameManager.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return NameManager;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _getIdentifierNames = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/sucrase/dist/esm/util/getIdentifierNames.js"));
class NameManager {
    __init() {
        this.usedNames = new Set();
    }
    constructor(code, tokens){
        NameManager.prototype.__init.call(this);
        this.usedNames = new Set((0, _getIdentifierNames.default)(code, tokens));
    }
    claimFreeName(name) {
        const newName = this.findFreeName(name);
        this.usedNames.add(newName);
        return newName;
    }
    findFreeName(name) {
        if (!this.usedNames.has(name)) return name;
        let suffixNum = 2;
        while(this.usedNames.has(name + String(suffixNum)))suffixNum++;
        return name + String(suffixNum);
    }
}

},
"node_modules/sucrase/dist/esm/Options-gen-types.js": function (module, exports, __mako_require__){
/**
 * This module was automatically generated by `ts-interface-builder`
 */ "use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    Options: function() {
        return Options;
    },
    SourceMapOptions: function() {
        return SourceMapOptions;
    },
    Transform: function() {
        return Transform;
    },
    default: function() {
        return _default;
    }
});
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _tsinterfacechecker = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/ts-interface-checker/dist/index.js"));
const Transform = _tsinterfacechecker.union(_tsinterfacechecker.lit("jsx"), _tsinterfacechecker.lit("typescript"), _tsinterfacechecker.lit("flow"), _tsinterfacechecker.lit("imports"), _tsinterfacechecker.lit("react-hot-loader"), _tsinterfacechecker.lit("jest"));
const SourceMapOptions = _tsinterfacechecker.iface([], {
    compiledFilename: "string"
});
const Options = _tsinterfacechecker.iface([], {
    transforms: _tsinterfacechecker.array("Transform"),
    disableESTransforms: _tsinterfacechecker.opt("boolean"),
    jsxRuntime: _tsinterfacechecker.opt(_tsinterfacechecker.union(_tsinterfacechecker.lit("classic"), _tsinterfacechecker.lit("automatic"), _tsinterfacechecker.lit("preserve"))),
    production: _tsinterfacechecker.opt("boolean"),
    jsxImportSource: _tsinterfacechecker.opt("string"),
    jsxPragma: _tsinterfacechecker.opt("string"),
    jsxFragmentPragma: _tsinterfacechecker.opt("string"),
    keepUnusedImports: _tsinterfacechecker.opt("boolean"),
    preserveDynamicImport: _tsinterfacechecker.opt("boolean"),
    injectCreateRequireForImportRequire: _tsinterfacechecker.opt("boolean"),
    enableLegacyTypeScriptModuleInterop: _tsinterfacechecker.opt("boolean"),
    enableLegacyBabel5ModuleInterop: _tsinterfacechecker.opt("boolean"),
    sourceMapOptions: _tsinterfacechecker.opt("SourceMapOptions"),
    filePath: _tsinterfacechecker.opt("string")
});
const exportedTypeSuite = {
    Transform,
    SourceMapOptions,
    Options
};
var _default = exportedTypeSuite;

},
"node_modules/sucrase/dist/esm/Options.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "validateOptions", {
    enumerable: true,
    get: function() {
        return validateOptions;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _tsinterfacechecker = __mako_require__("node_modules/ts-interface-checker/dist/index.js");
var _Optionsgentypes = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/sucrase/dist/esm/Options-gen-types.js"));
const { Options: OptionsChecker } = (0, _tsinterfacechecker.createCheckers)(_Optionsgentypes.default);
function validateOptions(options) {
    OptionsChecker.strictCheck(options);
}

},
"node_modules/sucrase/dist/esm/TokenProcessor.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return TokenProcessor;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _types = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/types.js");
var _isAsyncOperation = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/sucrase/dist/esm/util/isAsyncOperation.js"));
class TokenProcessor {
    __init() {
        this.resultCode = "";
    }
    // Array mapping input token index to optional string index position in the
    // output code.
    __init2() {
        this.resultMappings = new Array(this.tokens.length);
    }
    __init3() {
        this.tokenIndex = 0;
    }
    constructor(code, tokens, isFlowEnabled, disableESTransforms, helperManager){
        this.code = code;
        this.tokens = tokens;
        this.isFlowEnabled = isFlowEnabled;
        this.disableESTransforms = disableESTransforms;
        this.helperManager = helperManager;
        TokenProcessor.prototype.__init.call(this);
        TokenProcessor.prototype.__init2.call(this);
        TokenProcessor.prototype.__init3.call(this);
    }
    /**
   * Snapshot the token state in a way that can be restored later, useful for
   * things like lookahead.
   *
   * resultMappings do not need to be copied since in all use cases, they will
   * be overwritten anyway after restore.
   */ snapshot() {
        return {
            resultCode: this.resultCode,
            tokenIndex: this.tokenIndex
        };
    }
    restoreToSnapshot(snapshot) {
        this.resultCode = snapshot.resultCode;
        this.tokenIndex = snapshot.tokenIndex;
    }
    /**
   * Remove and return the code generated since the snapshot, leaving the
   * current token position in-place. Unlike most TokenProcessor operations,
   * this operation can result in input/output line number mismatches because
   * the removed code may contain newlines, so this operation should be used
   * sparingly.
   */ dangerouslyGetAndRemoveCodeSinceSnapshot(snapshot) {
        const result = this.resultCode.slice(snapshot.resultCode.length);
        this.resultCode = snapshot.resultCode;
        return result;
    }
    reset() {
        this.resultCode = "";
        this.resultMappings = new Array(this.tokens.length);
        this.tokenIndex = 0;
    }
    matchesContextualAtIndex(index, contextualKeyword) {
        return this.matches1AtIndex(index, _types.TokenType.name) && this.tokens[index].contextualKeyword === contextualKeyword;
    }
    identifierNameAtIndex(index) {
        // TODO: We need to process escapes since technically you can have unicode escapes in variable
        // names.
        return this.identifierNameForToken(this.tokens[index]);
    }
    identifierNameAtRelativeIndex(relativeIndex) {
        return this.identifierNameForToken(this.tokenAtRelativeIndex(relativeIndex));
    }
    identifierName() {
        return this.identifierNameForToken(this.currentToken());
    }
    identifierNameForToken(token) {
        return this.code.slice(token.start, token.end);
    }
    rawCodeForToken(token) {
        return this.code.slice(token.start, token.end);
    }
    stringValueAtIndex(index) {
        return this.stringValueForToken(this.tokens[index]);
    }
    stringValue() {
        return this.stringValueForToken(this.currentToken());
    }
    stringValueForToken(token) {
        // This is used to identify when two imports are the same and to resolve TypeScript enum keys.
        // Ideally we'd process escapes within the strings, but for now we pretty much take the raw
        // code.
        return this.code.slice(token.start + 1, token.end - 1);
    }
    matches1AtIndex(index, t1) {
        return this.tokens[index].type === t1;
    }
    matches2AtIndex(index, t1, t2) {
        return this.tokens[index].type === t1 && this.tokens[index + 1].type === t2;
    }
    matches3AtIndex(index, t1, t2, t3) {
        return this.tokens[index].type === t1 && this.tokens[index + 1].type === t2 && this.tokens[index + 2].type === t3;
    }
    matches1(t1) {
        return this.tokens[this.tokenIndex].type === t1;
    }
    matches2(t1, t2) {
        return this.tokens[this.tokenIndex].type === t1 && this.tokens[this.tokenIndex + 1].type === t2;
    }
    matches3(t1, t2, t3) {
        return this.tokens[this.tokenIndex].type === t1 && this.tokens[this.tokenIndex + 1].type === t2 && this.tokens[this.tokenIndex + 2].type === t3;
    }
    matches4(t1, t2, t3, t4) {
        return this.tokens[this.tokenIndex].type === t1 && this.tokens[this.tokenIndex + 1].type === t2 && this.tokens[this.tokenIndex + 2].type === t3 && this.tokens[this.tokenIndex + 3].type === t4;
    }
    matches5(t1, t2, t3, t4, t5) {
        return this.tokens[this.tokenIndex].type === t1 && this.tokens[this.tokenIndex + 1].type === t2 && this.tokens[this.tokenIndex + 2].type === t3 && this.tokens[this.tokenIndex + 3].type === t4 && this.tokens[this.tokenIndex + 4].type === t5;
    }
    matchesContextual(contextualKeyword) {
        return this.matchesContextualAtIndex(this.tokenIndex, contextualKeyword);
    }
    matchesContextIdAndLabel(type, contextId) {
        return this.matches1(type) && this.currentToken().contextId === contextId;
    }
    previousWhitespaceAndComments() {
        let whitespaceAndComments = this.code.slice(this.tokenIndex > 0 ? this.tokens[this.tokenIndex - 1].end : 0, this.tokenIndex < this.tokens.length ? this.tokens[this.tokenIndex].start : this.code.length);
        if (this.isFlowEnabled) whitespaceAndComments = whitespaceAndComments.replace(/@flow/g, "");
        return whitespaceAndComments;
    }
    replaceToken(newCode) {
        this.resultCode += this.previousWhitespaceAndComments();
        this.appendTokenPrefix();
        this.resultMappings[this.tokenIndex] = this.resultCode.length;
        this.resultCode += newCode;
        this.appendTokenSuffix();
        this.tokenIndex++;
    }
    replaceTokenTrimmingLeftWhitespace(newCode) {
        this.resultCode += this.previousWhitespaceAndComments().replace(/[^\r\n]/g, "");
        this.appendTokenPrefix();
        this.resultMappings[this.tokenIndex] = this.resultCode.length;
        this.resultCode += newCode;
        this.appendTokenSuffix();
        this.tokenIndex++;
    }
    removeInitialToken() {
        this.replaceToken("");
    }
    removeToken() {
        this.replaceTokenTrimmingLeftWhitespace("");
    }
    /**
   * Remove all code until the next }, accounting for balanced braces.
   */ removeBalancedCode() {
        let braceDepth = 0;
        while(!this.isAtEnd()){
            if (this.matches1(_types.TokenType.braceL)) braceDepth++;
            else if (this.matches1(_types.TokenType.braceR)) {
                if (braceDepth === 0) return;
                braceDepth--;
            }
            this.removeToken();
        }
    }
    copyExpectedToken(tokenType) {
        if (this.tokens[this.tokenIndex].type !== tokenType) throw new Error(`Expected token ${tokenType}`);
        this.copyToken();
    }
    copyToken() {
        this.resultCode += this.previousWhitespaceAndComments();
        this.appendTokenPrefix();
        this.resultMappings[this.tokenIndex] = this.resultCode.length;
        this.resultCode += this.code.slice(this.tokens[this.tokenIndex].start, this.tokens[this.tokenIndex].end);
        this.appendTokenSuffix();
        this.tokenIndex++;
    }
    copyTokenWithPrefix(prefix) {
        this.resultCode += this.previousWhitespaceAndComments();
        this.appendTokenPrefix();
        this.resultCode += prefix;
        this.resultMappings[this.tokenIndex] = this.resultCode.length;
        this.resultCode += this.code.slice(this.tokens[this.tokenIndex].start, this.tokens[this.tokenIndex].end);
        this.appendTokenSuffix();
        this.tokenIndex++;
    }
    appendTokenPrefix() {
        const token = this.currentToken();
        if (token.numNullishCoalesceStarts || token.isOptionalChainStart) token.isAsyncOperation = (0, _isAsyncOperation.default)(this);
        if (this.disableESTransforms) return;
        if (token.numNullishCoalesceStarts) for(let i = 0; i < token.numNullishCoalesceStarts; i++){
            if (token.isAsyncOperation) {
                this.resultCode += "await ";
                this.resultCode += this.helperManager.getHelperName("asyncNullishCoalesce");
            } else this.resultCode += this.helperManager.getHelperName("nullishCoalesce");
            this.resultCode += "(";
        }
        if (token.isOptionalChainStart) {
            if (token.isAsyncOperation) this.resultCode += "await ";
            if (this.tokenIndex > 0 && this.tokenAtRelativeIndex(-1).type === _types.TokenType._delete) {
                if (token.isAsyncOperation) this.resultCode += this.helperManager.getHelperName("asyncOptionalChainDelete");
                else this.resultCode += this.helperManager.getHelperName("optionalChainDelete");
            } else if (token.isAsyncOperation) this.resultCode += this.helperManager.getHelperName("asyncOptionalChain");
            else this.resultCode += this.helperManager.getHelperName("optionalChain");
            this.resultCode += "([";
        }
    }
    appendTokenSuffix() {
        const token = this.currentToken();
        if (token.isOptionalChainEnd && !this.disableESTransforms) this.resultCode += "])";
        if (token.numNullishCoalesceEnds && !this.disableESTransforms) for(let i = 0; i < token.numNullishCoalesceEnds; i++)this.resultCode += "))";
    }
    appendCode(code) {
        this.resultCode += code;
    }
    currentToken() {
        return this.tokens[this.tokenIndex];
    }
    currentTokenCode() {
        const token = this.currentToken();
        return this.code.slice(token.start, token.end);
    }
    tokenAtRelativeIndex(relativeIndex) {
        return this.tokens[this.tokenIndex + relativeIndex];
    }
    currentIndex() {
        return this.tokenIndex;
    }
    /**
   * Move to the next token. Only suitable in preprocessing steps. When
   * generating new code, you should use copyToken or removeToken.
   */ nextToken() {
        if (this.tokenIndex === this.tokens.length) throw new Error("Unexpectedly reached end of input.");
        this.tokenIndex++;
    }
    previousToken() {
        this.tokenIndex--;
    }
    finish() {
        if (this.tokenIndex !== this.tokens.length) throw new Error("Tried to finish processing tokens before reaching the end.");
        this.resultCode += this.previousWhitespaceAndComments();
        return {
            code: this.resultCode,
            mappings: this.resultMappings
        };
    }
    isAtEnd() {
        return this.tokenIndex === this.tokens.length;
    }
}

},
"node_modules/sucrase/dist/esm/computeSourceMap.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, /**
 * Generate a source map indicating that each line maps directly to the original line,
 * with the tokens in their new positions.
 */ "default", {
    enumerable: true,
    get: function() {
        return computeSourceMap;
    }
});
var _genmapping = __mako_require__("node_modules/@jridgewell/gen-mapping/dist/gen-mapping.mjs");
var _charcodes = __mako_require__("node_modules/sucrase/dist/esm/parser/util/charcodes.js");
function computeSourceMap({ code: generatedCode, mappings: rawMappings }, filePath, options, source, tokens) {
    const sourceColumns = computeSourceColumns(source, tokens);
    const map = new _genmapping.GenMapping({
        file: options.compiledFilename
    });
    let tokenIndex = 0;
    // currentMapping is the output source index for the current input token being
    // considered.
    let currentMapping = rawMappings[0];
    while(currentMapping === undefined && tokenIndex < rawMappings.length - 1){
        tokenIndex++;
        currentMapping = rawMappings[tokenIndex];
    }
    let line = 0;
    let lineStart = 0;
    if (currentMapping !== lineStart) (0, _genmapping.maybeAddSegment)(map, line, 0, filePath, line, 0);
    for(let i = 0; i < generatedCode.length; i++){
        if (i === currentMapping) {
            const genColumn = currentMapping - lineStart;
            const sourceColumn = sourceColumns[tokenIndex];
            (0, _genmapping.maybeAddSegment)(map, line, genColumn, filePath, line, sourceColumn);
            while((currentMapping === i || currentMapping === undefined) && tokenIndex < rawMappings.length - 1){
                tokenIndex++;
                currentMapping = rawMappings[tokenIndex];
            }
        }
        if (generatedCode.charCodeAt(i) === _charcodes.charCodes.lineFeed) {
            line++;
            lineStart = i + 1;
            if (currentMapping !== lineStart) (0, _genmapping.maybeAddSegment)(map, line, 0, filePath, line, 0);
        }
    }
    const { sourceRoot, sourcesContent, ...sourceMap } = (0, _genmapping.toEncodedMap)(map);
    return sourceMap;
}
/**
 * Create an array mapping each token index to the 0-based column of the start
 * position of the token.
 */ function computeSourceColumns(code, tokens) {
    const sourceColumns = new Array(tokens.length);
    let tokenIndex = 0;
    let currentMapping = tokens[tokenIndex].start;
    let lineStart = 0;
    for(let i = 0; i < code.length; i++){
        if (i === currentMapping) {
            sourceColumns[tokenIndex] = currentMapping - lineStart;
            tokenIndex++;
            currentMapping = tokens[tokenIndex].start;
        }
        if (code.charCodeAt(i) === _charcodes.charCodes.lineFeed) lineStart = i + 1;
    }
    return sourceColumns;
}

},
"node_modules/sucrase/dist/esm/identifyShadowedGlobals.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    /**
 * Traverse the given tokens and modify them if necessary to indicate that some names shadow global
 * variables.
 */ default: function() {
        return identifyShadowedGlobals;
    },
    hasShadowedGlobals: function() {
        return hasShadowedGlobals;
    }
});
var _tokenizer = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/index.js");
var _types = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/types.js");
function identifyShadowedGlobals(tokens, scopes, globalNames) {
    if (!hasShadowedGlobals(tokens, globalNames)) return;
    markShadowedGlobals(tokens, scopes, globalNames);
}
function hasShadowedGlobals(tokens, globalNames) {
    for (const token of tokens.tokens){
        if (token.type === _types.TokenType.name && !token.isType && (0, _tokenizer.isNonTopLevelDeclaration)(token) && globalNames.has(tokens.identifierNameForToken(token))) return true;
    }
    return false;
}
function markShadowedGlobals(tokens, scopes, globalNames) {
    const scopeStack = [];
    let scopeIndex = scopes.length - 1;
    // Scopes were generated at completion time, so they're sorted by end index, so we can maintain a
    // good stack by going backwards through them.
    for(let i = tokens.tokens.length - 1;; i--){
        while(scopeStack.length > 0 && scopeStack[scopeStack.length - 1].startTokenIndex === i + 1)scopeStack.pop();
        while(scopeIndex >= 0 && scopes[scopeIndex].endTokenIndex === i + 1){
            scopeStack.push(scopes[scopeIndex]);
            scopeIndex--;
        }
        // Process scopes after the last iteration so we can make sure we pop all of them.
        if (i < 0) break;
        const token = tokens.tokens[i];
        const name = tokens.identifierNameForToken(token);
        if (scopeStack.length > 1 && !token.isType && token.type === _types.TokenType.name && globalNames.has(name)) {
            if ((0, _tokenizer.isBlockScopedDeclaration)(token)) markShadowedForScope(scopeStack[scopeStack.length - 1], tokens, name);
            else if ((0, _tokenizer.isFunctionScopedDeclaration)(token)) {
                let stackIndex = scopeStack.length - 1;
                while(stackIndex > 0 && !scopeStack[stackIndex].isFunctionScope)stackIndex--;
                if (stackIndex < 0) throw new Error("Did not find parent function scope.");
                markShadowedForScope(scopeStack[stackIndex], tokens, name);
            }
        }
    }
    if (scopeStack.length > 0) throw new Error("Expected empty scope stack after processing file.");
}
function markShadowedForScope(scope, tokens, name) {
    for(let i = scope.startTokenIndex; i < scope.endTokenIndex; i++){
        const token = tokens.tokens[i];
        if ((token.type === _types.TokenType.name || token.type === _types.TokenType.jsxName) && tokens.identifierNameForToken(token) === name) token.shadowsGlobal = true;
    }
}

},
"node_modules/sucrase/dist/esm/index.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    getFormattedTokens: function() {
        return getFormattedTokens;
    },
    getVersion: function() {
        return getVersion;
    },
    transform: function() {
        return transform;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _CJSImportProcessor = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/sucrase/dist/esm/CJSImportProcessor.js"));
var _computeSourceMap = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/sucrase/dist/esm/computeSourceMap.js"));
var _HelperManager = __mako_require__("node_modules/sucrase/dist/esm/HelperManager.js");
var _identifyShadowedGlobals = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/sucrase/dist/esm/identifyShadowedGlobals.js"));
var _NameManager = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/sucrase/dist/esm/NameManager.js"));
var _Options = __mako_require__("node_modules/sucrase/dist/esm/Options.js");
var _parser = __mako_require__("node_modules/sucrase/dist/esm/parser/index.js");
var _TokenProcessor = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/sucrase/dist/esm/TokenProcessor.js"));
var _RootTransformer = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/sucrase/dist/esm/transformers/RootTransformer.js"));
var _formatTokens = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/sucrase/dist/esm/util/formatTokens.js"));
var _getTSImportedNames = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/sucrase/dist/esm/util/getTSImportedNames.js"));
function getVersion() {
    /* istanbul ignore next */ return "3.35.0";
}
function transform(code, options) {
    (0, _Options.validateOptions)(options);
    try {
        const sucraseContext = getSucraseContext(code, options);
        const transformer = new _RootTransformer.default(sucraseContext, options.transforms, Boolean(options.enableLegacyBabel5ModuleInterop), options);
        const transformerResult = transformer.transform();
        let result = {
            code: transformerResult.code
        };
        if (options.sourceMapOptions) {
            if (!options.filePath) throw new Error("filePath must be specified when generating a source map.");
            result = {
                ...result,
                sourceMap: (0, _computeSourceMap.default)(transformerResult, options.filePath, options.sourceMapOptions, code, sucraseContext.tokenProcessor.tokens)
            };
        }
        return result;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (e) {
        if (options.filePath) e.message = `Error transforming ${options.filePath}: ${e.message}`;
        throw e;
    }
}
function getFormattedTokens(code, options) {
    const tokens = getSucraseContext(code, options).tokenProcessor.tokens;
    return (0, _formatTokens.default)(code, tokens);
}
/**
 * Call into the parser/tokenizer and do some further preprocessing:
 * - Come up with a set of used names so that we can assign new names.
 * - Preprocess all import/export statements so we know which globals we are interested in.
 * - Compute situations where any of those globals are shadowed.
 *
 * In the future, some of these preprocessing steps can be skipped based on what actual work is
 * being done.
 */ function getSucraseContext(code, options) {
    const isJSXEnabled = options.transforms.includes("jsx");
    const isTypeScriptEnabled = options.transforms.includes("typescript");
    const isFlowEnabled = options.transforms.includes("flow");
    const disableESTransforms = options.disableESTransforms === true;
    const file = (0, _parser.parse)(code, isJSXEnabled, isTypeScriptEnabled, isFlowEnabled);
    const tokens = file.tokens;
    const scopes = file.scopes;
    const nameManager = new _NameManager.default(code, tokens);
    const helperManager = new _HelperManager.HelperManager(nameManager);
    const tokenProcessor = new _TokenProcessor.default(code, tokens, isFlowEnabled, disableESTransforms, helperManager);
    const enableLegacyTypeScriptModuleInterop = Boolean(options.enableLegacyTypeScriptModuleInterop);
    let importProcessor = null;
    if (options.transforms.includes("imports")) {
        importProcessor = new _CJSImportProcessor.default(nameManager, tokenProcessor, enableLegacyTypeScriptModuleInterop, options, options.transforms.includes("typescript"), Boolean(options.keepUnusedImports), helperManager);
        importProcessor.preprocessTokens();
        // We need to mark shadowed globals after processing imports so we know that the globals are,
        // but before type-only import pruning, since that relies on shadowing information.
        (0, _identifyShadowedGlobals.default)(tokenProcessor, scopes, importProcessor.getGlobalNames());
        if (options.transforms.includes("typescript") && !options.keepUnusedImports) importProcessor.pruneTypeOnlyImports();
    } else if (options.transforms.includes("typescript") && !options.keepUnusedImports) // Shadowed global detection is needed for TS implicit elision of imported names.
    (0, _identifyShadowedGlobals.default)(tokenProcessor, scopes, (0, _getTSImportedNames.default)(tokenProcessor));
    return {
        tokenProcessor,
        scopes,
        nameManager,
        importProcessor,
        helperManager
    };
}

},
"node_modules/sucrase/dist/esm/parser/index.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    File: function() {
        return File;
    },
    parse: function() {
        return parse;
    }
});
var _base = __mako_require__("node_modules/sucrase/dist/esm/parser/traverser/base.js");
var _index = __mako_require__("node_modules/sucrase/dist/esm/parser/traverser/index.js");
class File {
    constructor(tokens, scopes){
        this.tokens = tokens;
        this.scopes = scopes;
    }
}
function parse(input, isJSXEnabled, isTypeScriptEnabled, isFlowEnabled) {
    if (isFlowEnabled && isTypeScriptEnabled) throw new Error("Cannot combine flow and typescript plugins.");
    (0, _base.initParser)(input, isJSXEnabled, isTypeScriptEnabled, isFlowEnabled);
    const result = (0, _index.parseFile)();
    if (_base.state.error) throw (0, _base.augmentError)(_base.state.error);
    return result;
}

},
"node_modules/sucrase/dist/esm/parser/plugins/flow.js": function (module, exports, __mako_require__){
/* eslint max-len: 0 */ "use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    flowAfterParseClassSuper: function() {
        return flowAfterParseClassSuper;
    },
    flowAfterParseVarHead: function() {
        return flowAfterParseVarHead;
    },
    flowParseArrow: function() {
        return flowParseArrow;
    },
    flowParseAssignableListItemTypes: function() {
        return flowParseAssignableListItemTypes;
    },
    flowParseExportDeclaration: function() {
        return flowParseExportDeclaration;
    },
    flowParseExportStar: function() {
        return flowParseExportStar;
    },
    flowParseFunctionBodyAndFinish: function() {
        return flowParseFunctionBodyAndFinish;
    },
    flowParseIdentifierStatement: function() {
        return flowParseIdentifierStatement;
    },
    flowParseImportSpecifier: function() {
        return flowParseImportSpecifier;
    },
    flowParseMaybeAssign: function() {
        return flowParseMaybeAssign;
    },
    flowParseSubscript: function() {
        return flowParseSubscript;
    },
    flowParseSubscripts: function() {
        return flowParseSubscripts;
    },
    flowParseTypeAnnotation: function() {
        return flowParseTypeAnnotation;
    },
    flowParseTypeParameterDeclaration: function() {
        return flowParseTypeParameterDeclaration;
    },
    flowParseVariance: function() {
        return flowParseVariance;
    },
    flowShouldDisallowExportDefaultSpecifier: function() {
        return flowShouldDisallowExportDefaultSpecifier;
    },
    flowShouldParseExportDeclaration: function() {
        return flowShouldParseExportDeclaration;
    },
    flowShouldParseExportStar: function() {
        return flowShouldParseExportStar;
    },
    flowStartParseAsyncArrowFromCallExpression: function() {
        return flowStartParseAsyncArrowFromCallExpression;
    },
    flowStartParseFunctionParams: function() {
        return flowStartParseFunctionParams;
    },
    flowStartParseImportSpecifiers: function() {
        return flowStartParseImportSpecifiers;
    },
    flowStartParseNewArguments: function() {
        return flowStartParseNewArguments;
    },
    flowStartParseObjPropValue: function() {
        return flowStartParseObjPropValue;
    },
    flowTryParseExportDefaultExpression: function() {
        return flowTryParseExportDefaultExpression;
    },
    flowTryParseStatement: function() {
        return flowTryParseStatement;
    }
});
var _index = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/index.js");
var _keywords = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/keywords.js");
var _types = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/types.js");
var _base = __mako_require__("node_modules/sucrase/dist/esm/parser/traverser/base.js");
var _expression = __mako_require__("node_modules/sucrase/dist/esm/parser/traverser/expression.js");
var _statement = __mako_require__("node_modules/sucrase/dist/esm/parser/traverser/statement.js");
var _util = __mako_require__("node_modules/sucrase/dist/esm/parser/traverser/util.js");
function isMaybeDefaultImport(lookahead) {
    return (lookahead.type === _types.TokenType.name || !!(lookahead.type & _types.TokenType.IS_KEYWORD)) && lookahead.contextualKeyword !== _keywords.ContextualKeyword._from;
}
function flowParseTypeInitialiser(tok) {
    const oldIsType = (0, _index.pushTypeContext)(0);
    (0, _util.expect)(tok || _types.TokenType.colon);
    flowParseType();
    (0, _index.popTypeContext)(oldIsType);
}
function flowParsePredicate() {
    (0, _util.expect)(_types.TokenType.modulo);
    (0, _util.expectContextual)(_keywords.ContextualKeyword._checks);
    if ((0, _index.eat)(_types.TokenType.parenL)) {
        (0, _expression.parseExpression)();
        (0, _util.expect)(_types.TokenType.parenR);
    }
}
function flowParseTypeAndPredicateInitialiser() {
    const oldIsType = (0, _index.pushTypeContext)(0);
    (0, _util.expect)(_types.TokenType.colon);
    if ((0, _index.match)(_types.TokenType.modulo)) flowParsePredicate();
    else {
        flowParseType();
        if ((0, _index.match)(_types.TokenType.modulo)) flowParsePredicate();
    }
    (0, _index.popTypeContext)(oldIsType);
}
function flowParseDeclareClass() {
    (0, _index.next)();
    flowParseInterfaceish(/* isClass */ true);
}
function flowParseDeclareFunction() {
    (0, _index.next)();
    (0, _expression.parseIdentifier)();
    if ((0, _index.match)(_types.TokenType.lessThan)) flowParseTypeParameterDeclaration();
    (0, _util.expect)(_types.TokenType.parenL);
    flowParseFunctionTypeParams();
    (0, _util.expect)(_types.TokenType.parenR);
    flowParseTypeAndPredicateInitialiser();
    (0, _util.semicolon)();
}
function flowParseDeclare() {
    if ((0, _index.match)(_types.TokenType._class)) flowParseDeclareClass();
    else if ((0, _index.match)(_types.TokenType._function)) flowParseDeclareFunction();
    else if ((0, _index.match)(_types.TokenType._var)) flowParseDeclareVariable();
    else if ((0, _util.eatContextual)(_keywords.ContextualKeyword._module)) {
        if ((0, _index.eat)(_types.TokenType.dot)) flowParseDeclareModuleExports();
        else flowParseDeclareModule();
    } else if ((0, _util.isContextual)(_keywords.ContextualKeyword._type)) flowParseDeclareTypeAlias();
    else if ((0, _util.isContextual)(_keywords.ContextualKeyword._opaque)) flowParseDeclareOpaqueType();
    else if ((0, _util.isContextual)(_keywords.ContextualKeyword._interface)) flowParseDeclareInterface();
    else if ((0, _index.match)(_types.TokenType._export)) flowParseDeclareExportDeclaration();
    else (0, _util.unexpected)();
}
function flowParseDeclareVariable() {
    (0, _index.next)();
    flowParseTypeAnnotatableIdentifier();
    (0, _util.semicolon)();
}
function flowParseDeclareModule() {
    if ((0, _index.match)(_types.TokenType.string)) (0, _expression.parseExprAtom)();
    else (0, _expression.parseIdentifier)();
    (0, _util.expect)(_types.TokenType.braceL);
    while(!(0, _index.match)(_types.TokenType.braceR) && !_base.state.error)if ((0, _index.match)(_types.TokenType._import)) {
        (0, _index.next)();
        (0, _statement.parseImport)();
    } else (0, _util.unexpected)();
    (0, _util.expect)(_types.TokenType.braceR);
}
function flowParseDeclareExportDeclaration() {
    (0, _util.expect)(_types.TokenType._export);
    if ((0, _index.eat)(_types.TokenType._default)) {
        if ((0, _index.match)(_types.TokenType._function) || (0, _index.match)(_types.TokenType._class)) // declare export default class ...
        // declare export default function ...
        flowParseDeclare();
        else {
            // declare export default [type];
            flowParseType();
            (0, _util.semicolon)();
        }
    } else if ((0, _index.match)(_types.TokenType._var) || // declare export var ...
    (0, _index.match)(_types.TokenType._function) || // declare export function ...
    (0, _index.match)(_types.TokenType._class) || // declare export class ...
    (0, _util.isContextual)(_keywords.ContextualKeyword._opaque) // declare export opaque ..
    ) flowParseDeclare();
    else if ((0, _index.match)(_types.TokenType.star) || // declare export * from ''
    (0, _index.match)(_types.TokenType.braceL) || // declare export {} ...
    (0, _util.isContextual)(_keywords.ContextualKeyword._interface) || // declare export interface ...
    (0, _util.isContextual)(_keywords.ContextualKeyword._type) || // declare export type ...
    (0, _util.isContextual)(_keywords.ContextualKeyword._opaque) // declare export opaque type ...
    ) (0, _statement.parseExport)();
    else (0, _util.unexpected)();
}
function flowParseDeclareModuleExports() {
    (0, _util.expectContextual)(_keywords.ContextualKeyword._exports);
    flowParseTypeAnnotation();
    (0, _util.semicolon)();
}
function flowParseDeclareTypeAlias() {
    (0, _index.next)();
    flowParseTypeAlias();
}
function flowParseDeclareOpaqueType() {
    (0, _index.next)();
    flowParseOpaqueType(true);
}
function flowParseDeclareInterface() {
    (0, _index.next)();
    flowParseInterfaceish();
}
// Interfaces
function flowParseInterfaceish(isClass = false) {
    flowParseRestrictedIdentifier();
    if ((0, _index.match)(_types.TokenType.lessThan)) flowParseTypeParameterDeclaration();
    if ((0, _index.eat)(_types.TokenType._extends)) do flowParseInterfaceExtends();
    while (!isClass && (0, _index.eat)(_types.TokenType.comma))
    if ((0, _util.isContextual)(_keywords.ContextualKeyword._mixins)) {
        (0, _index.next)();
        do flowParseInterfaceExtends();
        while ((0, _index.eat)(_types.TokenType.comma))
    }
    if ((0, _util.isContextual)(_keywords.ContextualKeyword._implements)) {
        (0, _index.next)();
        do flowParseInterfaceExtends();
        while ((0, _index.eat)(_types.TokenType.comma))
    }
    flowParseObjectType(isClass, false, isClass);
}
function flowParseInterfaceExtends() {
    flowParseQualifiedTypeIdentifier(false);
    if ((0, _index.match)(_types.TokenType.lessThan)) flowParseTypeParameterInstantiation();
}
function flowParseInterface() {
    flowParseInterfaceish();
}
function flowParseRestrictedIdentifier() {
    (0, _expression.parseIdentifier)();
}
function flowParseTypeAlias() {
    flowParseRestrictedIdentifier();
    if ((0, _index.match)(_types.TokenType.lessThan)) flowParseTypeParameterDeclaration();
    flowParseTypeInitialiser(_types.TokenType.eq);
    (0, _util.semicolon)();
}
function flowParseOpaqueType(declare) {
    (0, _util.expectContextual)(_keywords.ContextualKeyword._type);
    flowParseRestrictedIdentifier();
    if ((0, _index.match)(_types.TokenType.lessThan)) flowParseTypeParameterDeclaration();
    // Parse the supertype
    if ((0, _index.match)(_types.TokenType.colon)) flowParseTypeInitialiser(_types.TokenType.colon);
    if (!declare) flowParseTypeInitialiser(_types.TokenType.eq);
    (0, _util.semicolon)();
}
function flowParseTypeParameter() {
    flowParseVariance();
    flowParseTypeAnnotatableIdentifier();
    if ((0, _index.eat)(_types.TokenType.eq)) flowParseType();
}
function flowParseTypeParameterDeclaration() {
    const oldIsType = (0, _index.pushTypeContext)(0);
    // istanbul ignore else: this condition is already checked at all call sites
    if ((0, _index.match)(_types.TokenType.lessThan) || (0, _index.match)(_types.TokenType.typeParameterStart)) (0, _index.next)();
    else (0, _util.unexpected)();
    do {
        flowParseTypeParameter();
        if (!(0, _index.match)(_types.TokenType.greaterThan)) (0, _util.expect)(_types.TokenType.comma);
    }while (!(0, _index.match)(_types.TokenType.greaterThan) && !_base.state.error)
    (0, _util.expect)(_types.TokenType.greaterThan);
    (0, _index.popTypeContext)(oldIsType);
}
function flowParseTypeParameterInstantiation() {
    const oldIsType = (0, _index.pushTypeContext)(0);
    (0, _util.expect)(_types.TokenType.lessThan);
    while(!(0, _index.match)(_types.TokenType.greaterThan) && !_base.state.error){
        flowParseType();
        if (!(0, _index.match)(_types.TokenType.greaterThan)) (0, _util.expect)(_types.TokenType.comma);
    }
    (0, _util.expect)(_types.TokenType.greaterThan);
    (0, _index.popTypeContext)(oldIsType);
}
function flowParseInterfaceType() {
    (0, _util.expectContextual)(_keywords.ContextualKeyword._interface);
    if ((0, _index.eat)(_types.TokenType._extends)) do flowParseInterfaceExtends();
    while ((0, _index.eat)(_types.TokenType.comma))
    flowParseObjectType(false, false, false);
}
function flowParseObjectPropertyKey() {
    if ((0, _index.match)(_types.TokenType.num) || (0, _index.match)(_types.TokenType.string)) (0, _expression.parseExprAtom)();
    else (0, _expression.parseIdentifier)();
}
function flowParseObjectTypeIndexer() {
    // Note: bracketL has already been consumed
    if ((0, _index.lookaheadType)() === _types.TokenType.colon) {
        flowParseObjectPropertyKey();
        flowParseTypeInitialiser();
    } else flowParseType();
    (0, _util.expect)(_types.TokenType.bracketR);
    flowParseTypeInitialiser();
}
function flowParseObjectTypeInternalSlot() {
    // Note: both bracketL have already been consumed
    flowParseObjectPropertyKey();
    (0, _util.expect)(_types.TokenType.bracketR);
    (0, _util.expect)(_types.TokenType.bracketR);
    if ((0, _index.match)(_types.TokenType.lessThan) || (0, _index.match)(_types.TokenType.parenL)) flowParseObjectTypeMethodish();
    else {
        (0, _index.eat)(_types.TokenType.question);
        flowParseTypeInitialiser();
    }
}
function flowParseObjectTypeMethodish() {
    if ((0, _index.match)(_types.TokenType.lessThan)) flowParseTypeParameterDeclaration();
    (0, _util.expect)(_types.TokenType.parenL);
    while(!(0, _index.match)(_types.TokenType.parenR) && !(0, _index.match)(_types.TokenType.ellipsis) && !_base.state.error){
        flowParseFunctionTypeParam();
        if (!(0, _index.match)(_types.TokenType.parenR)) (0, _util.expect)(_types.TokenType.comma);
    }
    if ((0, _index.eat)(_types.TokenType.ellipsis)) flowParseFunctionTypeParam();
    (0, _util.expect)(_types.TokenType.parenR);
    flowParseTypeInitialiser();
}
function flowParseObjectTypeCallProperty() {
    flowParseObjectTypeMethodish();
}
function flowParseObjectType(allowStatic, allowExact, allowProto) {
    let endDelim;
    if (allowExact && (0, _index.match)(_types.TokenType.braceBarL)) {
        (0, _util.expect)(_types.TokenType.braceBarL);
        endDelim = _types.TokenType.braceBarR;
    } else {
        (0, _util.expect)(_types.TokenType.braceL);
        endDelim = _types.TokenType.braceR;
    }
    while(!(0, _index.match)(endDelim) && !_base.state.error){
        if (allowProto && (0, _util.isContextual)(_keywords.ContextualKeyword._proto)) {
            const lookahead = (0, _index.lookaheadType)();
            if (lookahead !== _types.TokenType.colon && lookahead !== _types.TokenType.question) {
                (0, _index.next)();
                allowStatic = false;
            }
        }
        if (allowStatic && (0, _util.isContextual)(_keywords.ContextualKeyword._static)) {
            const lookahead = (0, _index.lookaheadType)();
            if (lookahead !== _types.TokenType.colon && lookahead !== _types.TokenType.question) (0, _index.next)();
        }
        flowParseVariance();
        if ((0, _index.eat)(_types.TokenType.bracketL)) {
            if ((0, _index.eat)(_types.TokenType.bracketL)) flowParseObjectTypeInternalSlot();
            else flowParseObjectTypeIndexer();
        } else if ((0, _index.match)(_types.TokenType.parenL) || (0, _index.match)(_types.TokenType.lessThan)) flowParseObjectTypeCallProperty();
        else {
            if ((0, _util.isContextual)(_keywords.ContextualKeyword._get) || (0, _util.isContextual)(_keywords.ContextualKeyword._set)) {
                const lookahead = (0, _index.lookaheadType)();
                if (lookahead === _types.TokenType.name || lookahead === _types.TokenType.string || lookahead === _types.TokenType.num) (0, _index.next)();
            }
            flowParseObjectTypeProperty();
        }
        flowObjectTypeSemicolon();
    }
    (0, _util.expect)(endDelim);
}
function flowParseObjectTypeProperty() {
    if ((0, _index.match)(_types.TokenType.ellipsis)) {
        (0, _util.expect)(_types.TokenType.ellipsis);
        if (!(0, _index.eat)(_types.TokenType.comma)) (0, _index.eat)(_types.TokenType.semi);
        // Explicit inexact object syntax.
        if ((0, _index.match)(_types.TokenType.braceR)) return;
        flowParseType();
    } else {
        flowParseObjectPropertyKey();
        if ((0, _index.match)(_types.TokenType.lessThan) || (0, _index.match)(_types.TokenType.parenL)) // This is a method property
        flowParseObjectTypeMethodish();
        else {
            (0, _index.eat)(_types.TokenType.question);
            flowParseTypeInitialiser();
        }
    }
}
function flowObjectTypeSemicolon() {
    if (!(0, _index.eat)(_types.TokenType.semi) && !(0, _index.eat)(_types.TokenType.comma) && !(0, _index.match)(_types.TokenType.braceR) && !(0, _index.match)(_types.TokenType.braceBarR)) (0, _util.unexpected)();
}
function flowParseQualifiedTypeIdentifier(initialIdAlreadyParsed) {
    if (!initialIdAlreadyParsed) (0, _expression.parseIdentifier)();
    while((0, _index.eat)(_types.TokenType.dot))(0, _expression.parseIdentifier)();
}
function flowParseGenericType() {
    flowParseQualifiedTypeIdentifier(true);
    if ((0, _index.match)(_types.TokenType.lessThan)) flowParseTypeParameterInstantiation();
}
function flowParseTypeofType() {
    (0, _util.expect)(_types.TokenType._typeof);
    flowParsePrimaryType();
}
function flowParseTupleType() {
    (0, _util.expect)(_types.TokenType.bracketL);
    // We allow trailing commas
    while(_base.state.pos < _base.input.length && !(0, _index.match)(_types.TokenType.bracketR)){
        flowParseType();
        if ((0, _index.match)(_types.TokenType.bracketR)) break;
        (0, _util.expect)(_types.TokenType.comma);
    }
    (0, _util.expect)(_types.TokenType.bracketR);
}
function flowParseFunctionTypeParam() {
    const lookahead = (0, _index.lookaheadType)();
    if (lookahead === _types.TokenType.colon || lookahead === _types.TokenType.question) {
        (0, _expression.parseIdentifier)();
        (0, _index.eat)(_types.TokenType.question);
        flowParseTypeInitialiser();
    } else flowParseType();
}
function flowParseFunctionTypeParams() {
    while(!(0, _index.match)(_types.TokenType.parenR) && !(0, _index.match)(_types.TokenType.ellipsis) && !_base.state.error){
        flowParseFunctionTypeParam();
        if (!(0, _index.match)(_types.TokenType.parenR)) (0, _util.expect)(_types.TokenType.comma);
    }
    if ((0, _index.eat)(_types.TokenType.ellipsis)) flowParseFunctionTypeParam();
}
// The parsing of types roughly parallels the parsing of expressions, and
// primary types are kind of like primary expressions...they're the
// primitives with which other types are constructed.
function flowParsePrimaryType() {
    let isGroupedType = false;
    const oldNoAnonFunctionType = _base.state.noAnonFunctionType;
    switch(_base.state.type){
        case _types.TokenType.name:
            if ((0, _util.isContextual)(_keywords.ContextualKeyword._interface)) {
                flowParseInterfaceType();
                return;
            }
            (0, _expression.parseIdentifier)();
            flowParseGenericType();
            return;
        case _types.TokenType.braceL:
            flowParseObjectType(false, false, false);
            return;
        case _types.TokenType.braceBarL:
            flowParseObjectType(false, true, false);
            return;
        case _types.TokenType.bracketL:
            flowParseTupleType();
            return;
        case _types.TokenType.lessThan:
            flowParseTypeParameterDeclaration();
            (0, _util.expect)(_types.TokenType.parenL);
            flowParseFunctionTypeParams();
            (0, _util.expect)(_types.TokenType.parenR);
            (0, _util.expect)(_types.TokenType.arrow);
            flowParseType();
            return;
        case _types.TokenType.parenL:
            (0, _index.next)();
            // Check to see if this is actually a grouped type
            if (!(0, _index.match)(_types.TokenType.parenR) && !(0, _index.match)(_types.TokenType.ellipsis)) {
                if ((0, _index.match)(_types.TokenType.name)) {
                    const token = (0, _index.lookaheadType)();
                    isGroupedType = token !== _types.TokenType.question && token !== _types.TokenType.colon;
                } else isGroupedType = true;
            }
            if (isGroupedType) {
                _base.state.noAnonFunctionType = false;
                flowParseType();
                _base.state.noAnonFunctionType = oldNoAnonFunctionType;
                // A `,` or a `) =>` means this is an anonymous function type
                if (_base.state.noAnonFunctionType || !((0, _index.match)(_types.TokenType.comma) || (0, _index.match)(_types.TokenType.parenR) && (0, _index.lookaheadType)() === _types.TokenType.arrow)) {
                    (0, _util.expect)(_types.TokenType.parenR);
                    return;
                } else // Eat a comma if there is one
                (0, _index.eat)(_types.TokenType.comma);
            }
            flowParseFunctionTypeParams();
            (0, _util.expect)(_types.TokenType.parenR);
            (0, _util.expect)(_types.TokenType.arrow);
            flowParseType();
            return;
        case _types.TokenType.minus:
            (0, _index.next)();
            (0, _expression.parseLiteral)();
            return;
        case _types.TokenType.string:
        case _types.TokenType.num:
        case _types.TokenType._true:
        case _types.TokenType._false:
        case _types.TokenType._null:
        case _types.TokenType._this:
        case _types.TokenType._void:
        case _types.TokenType.star:
            (0, _index.next)();
            return;
        default:
            if (_base.state.type === _types.TokenType._typeof) {
                flowParseTypeofType();
                return;
            } else if (_base.state.type & _types.TokenType.IS_KEYWORD) {
                (0, _index.next)();
                _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType.name;
                return;
            }
    }
    (0, _util.unexpected)();
}
function flowParsePostfixType() {
    flowParsePrimaryType();
    while(!(0, _util.canInsertSemicolon)() && ((0, _index.match)(_types.TokenType.bracketL) || (0, _index.match)(_types.TokenType.questionDot))){
        (0, _index.eat)(_types.TokenType.questionDot);
        (0, _util.expect)(_types.TokenType.bracketL);
        if ((0, _index.eat)(_types.TokenType.bracketR)) ;
        else {
            // Indexed access type
            flowParseType();
            (0, _util.expect)(_types.TokenType.bracketR);
        }
    }
}
function flowParsePrefixType() {
    if ((0, _index.eat)(_types.TokenType.question)) flowParsePrefixType();
    else flowParsePostfixType();
}
function flowParseAnonFunctionWithoutParens() {
    flowParsePrefixType();
    if (!_base.state.noAnonFunctionType && (0, _index.eat)(_types.TokenType.arrow)) flowParseType();
}
function flowParseIntersectionType() {
    (0, _index.eat)(_types.TokenType.bitwiseAND);
    flowParseAnonFunctionWithoutParens();
    while((0, _index.eat)(_types.TokenType.bitwiseAND))flowParseAnonFunctionWithoutParens();
}
function flowParseUnionType() {
    (0, _index.eat)(_types.TokenType.bitwiseOR);
    flowParseIntersectionType();
    while((0, _index.eat)(_types.TokenType.bitwiseOR))flowParseIntersectionType();
}
function flowParseType() {
    flowParseUnionType();
}
function flowParseTypeAnnotation() {
    flowParseTypeInitialiser();
}
function flowParseTypeAnnotatableIdentifier() {
    (0, _expression.parseIdentifier)();
    if ((0, _index.match)(_types.TokenType.colon)) flowParseTypeAnnotation();
}
function flowParseVariance() {
    if ((0, _index.match)(_types.TokenType.plus) || (0, _index.match)(_types.TokenType.minus)) {
        (0, _index.next)();
        _base.state.tokens[_base.state.tokens.length - 1].isType = true;
    }
}
function flowParseFunctionBodyAndFinish(funcContextId) {
    // For arrow functions, `parseArrow` handles the return type itself.
    if ((0, _index.match)(_types.TokenType.colon)) flowParseTypeAndPredicateInitialiser();
    (0, _expression.parseFunctionBody)(false, funcContextId);
}
function flowParseSubscript(startTokenIndex, noCalls, stopState) {
    if ((0, _index.match)(_types.TokenType.questionDot) && (0, _index.lookaheadType)() === _types.TokenType.lessThan) {
        if (noCalls) {
            stopState.stop = true;
            return;
        }
        (0, _index.next)();
        flowParseTypeParameterInstantiation();
        (0, _util.expect)(_types.TokenType.parenL);
        (0, _expression.parseCallExpressionArguments)();
        return;
    } else if (!noCalls && (0, _index.match)(_types.TokenType.lessThan)) {
        const snapshot = _base.state.snapshot();
        flowParseTypeParameterInstantiation();
        (0, _util.expect)(_types.TokenType.parenL);
        (0, _expression.parseCallExpressionArguments)();
        if (_base.state.error) _base.state.restoreFromSnapshot(snapshot);
        else return;
    }
    (0, _expression.baseParseSubscript)(startTokenIndex, noCalls, stopState);
}
function flowStartParseNewArguments() {
    if ((0, _index.match)(_types.TokenType.lessThan)) {
        const snapshot = _base.state.snapshot();
        flowParseTypeParameterInstantiation();
        if (_base.state.error) _base.state.restoreFromSnapshot(snapshot);
    }
}
function flowTryParseStatement() {
    if ((0, _index.match)(_types.TokenType.name) && _base.state.contextualKeyword === _keywords.ContextualKeyword._interface) {
        const oldIsType = (0, _index.pushTypeContext)(0);
        (0, _index.next)();
        flowParseInterface();
        (0, _index.popTypeContext)(oldIsType);
        return true;
    } else if ((0, _util.isContextual)(_keywords.ContextualKeyword._enum)) {
        flowParseEnumDeclaration();
        return true;
    }
    return false;
}
function flowTryParseExportDefaultExpression() {
    if ((0, _util.isContextual)(_keywords.ContextualKeyword._enum)) {
        flowParseEnumDeclaration();
        return true;
    }
    return false;
}
function flowParseIdentifierStatement(contextualKeyword) {
    if (contextualKeyword === _keywords.ContextualKeyword._declare) {
        if ((0, _index.match)(_types.TokenType._class) || (0, _index.match)(_types.TokenType.name) || (0, _index.match)(_types.TokenType._function) || (0, _index.match)(_types.TokenType._var) || (0, _index.match)(_types.TokenType._export)) {
            const oldIsType = (0, _index.pushTypeContext)(1);
            flowParseDeclare();
            (0, _index.popTypeContext)(oldIsType);
        }
    } else if ((0, _index.match)(_types.TokenType.name)) {
        if (contextualKeyword === _keywords.ContextualKeyword._interface) {
            const oldIsType = (0, _index.pushTypeContext)(1);
            flowParseInterface();
            (0, _index.popTypeContext)(oldIsType);
        } else if (contextualKeyword === _keywords.ContextualKeyword._type) {
            const oldIsType = (0, _index.pushTypeContext)(1);
            flowParseTypeAlias();
            (0, _index.popTypeContext)(oldIsType);
        } else if (contextualKeyword === _keywords.ContextualKeyword._opaque) {
            const oldIsType = (0, _index.pushTypeContext)(1);
            flowParseOpaqueType(false);
            (0, _index.popTypeContext)(oldIsType);
        }
    }
    (0, _util.semicolon)();
}
function flowShouldParseExportDeclaration() {
    return (0, _util.isContextual)(_keywords.ContextualKeyword._type) || (0, _util.isContextual)(_keywords.ContextualKeyword._interface) || (0, _util.isContextual)(_keywords.ContextualKeyword._opaque) || (0, _util.isContextual)(_keywords.ContextualKeyword._enum);
}
function flowShouldDisallowExportDefaultSpecifier() {
    return (0, _index.match)(_types.TokenType.name) && (_base.state.contextualKeyword === _keywords.ContextualKeyword._type || _base.state.contextualKeyword === _keywords.ContextualKeyword._interface || _base.state.contextualKeyword === _keywords.ContextualKeyword._opaque || _base.state.contextualKeyword === _keywords.ContextualKeyword._enum);
}
function flowParseExportDeclaration() {
    if ((0, _util.isContextual)(_keywords.ContextualKeyword._type)) {
        const oldIsType = (0, _index.pushTypeContext)(1);
        (0, _index.next)();
        if ((0, _index.match)(_types.TokenType.braceL)) {
            // export type { foo, bar };
            (0, _statement.parseExportSpecifiers)();
            (0, _statement.parseExportFrom)();
        } else // export type Foo = Bar;
        flowParseTypeAlias();
        (0, _index.popTypeContext)(oldIsType);
    } else if ((0, _util.isContextual)(_keywords.ContextualKeyword._opaque)) {
        const oldIsType = (0, _index.pushTypeContext)(1);
        (0, _index.next)();
        // export opaque type Foo = Bar;
        flowParseOpaqueType(false);
        (0, _index.popTypeContext)(oldIsType);
    } else if ((0, _util.isContextual)(_keywords.ContextualKeyword._interface)) {
        const oldIsType = (0, _index.pushTypeContext)(1);
        (0, _index.next)();
        flowParseInterface();
        (0, _index.popTypeContext)(oldIsType);
    } else (0, _statement.parseStatement)(true);
}
function flowShouldParseExportStar() {
    return (0, _index.match)(_types.TokenType.star) || (0, _util.isContextual)(_keywords.ContextualKeyword._type) && (0, _index.lookaheadType)() === _types.TokenType.star;
}
function flowParseExportStar() {
    if ((0, _util.eatContextual)(_keywords.ContextualKeyword._type)) {
        const oldIsType = (0, _index.pushTypeContext)(2);
        (0, _statement.baseParseExportStar)();
        (0, _index.popTypeContext)(oldIsType);
    } else (0, _statement.baseParseExportStar)();
}
function flowAfterParseClassSuper(hasSuper) {
    if (hasSuper && (0, _index.match)(_types.TokenType.lessThan)) flowParseTypeParameterInstantiation();
    if ((0, _util.isContextual)(_keywords.ContextualKeyword._implements)) {
        const oldIsType = (0, _index.pushTypeContext)(0);
        (0, _index.next)();
        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._implements;
        do {
            flowParseRestrictedIdentifier();
            if ((0, _index.match)(_types.TokenType.lessThan)) flowParseTypeParameterInstantiation();
        }while ((0, _index.eat)(_types.TokenType.comma))
        (0, _index.popTypeContext)(oldIsType);
    }
}
function flowStartParseObjPropValue() {
    // method shorthand
    if ((0, _index.match)(_types.TokenType.lessThan)) {
        flowParseTypeParameterDeclaration();
        if (!(0, _index.match)(_types.TokenType.parenL)) (0, _util.unexpected)();
    }
}
function flowParseAssignableListItemTypes() {
    const oldIsType = (0, _index.pushTypeContext)(0);
    (0, _index.eat)(_types.TokenType.question);
    if ((0, _index.match)(_types.TokenType.colon)) flowParseTypeAnnotation();
    (0, _index.popTypeContext)(oldIsType);
}
function flowStartParseImportSpecifiers() {
    if ((0, _index.match)(_types.TokenType._typeof) || (0, _util.isContextual)(_keywords.ContextualKeyword._type)) {
        const lh = (0, _index.lookaheadTypeAndKeyword)();
        if (isMaybeDefaultImport(lh) || lh.type === _types.TokenType.braceL || lh.type === _types.TokenType.star) (0, _index.next)();
    }
}
function flowParseImportSpecifier() {
    const isTypeKeyword = _base.state.contextualKeyword === _keywords.ContextualKeyword._type || _base.state.type === _types.TokenType._typeof;
    if (isTypeKeyword) (0, _index.next)();
    else (0, _expression.parseIdentifier)();
    if ((0, _util.isContextual)(_keywords.ContextualKeyword._as) && !(0, _util.isLookaheadContextual)(_keywords.ContextualKeyword._as)) {
        (0, _expression.parseIdentifier)();
        if (isTypeKeyword && !(0, _index.match)(_types.TokenType.name) && !(_base.state.type & _types.TokenType.IS_KEYWORD)) ;
        else // `import {type as foo`
        (0, _expression.parseIdentifier)();
    } else {
        if (isTypeKeyword && ((0, _index.match)(_types.TokenType.name) || !!(_base.state.type & _types.TokenType.IS_KEYWORD))) // `import {type foo`
        (0, _expression.parseIdentifier)();
        if ((0, _util.eatContextual)(_keywords.ContextualKeyword._as)) (0, _expression.parseIdentifier)();
    }
}
function flowStartParseFunctionParams() {
    // Originally this checked if the method is a getter/setter, but if it was, we'd crash soon
    // anyway, so don't try to propagate that information.
    if ((0, _index.match)(_types.TokenType.lessThan)) {
        const oldIsType = (0, _index.pushTypeContext)(0);
        flowParseTypeParameterDeclaration();
        (0, _index.popTypeContext)(oldIsType);
    }
}
function flowAfterParseVarHead() {
    if ((0, _index.match)(_types.TokenType.colon)) flowParseTypeAnnotation();
}
function flowStartParseAsyncArrowFromCallExpression() {
    if ((0, _index.match)(_types.TokenType.colon)) {
        const oldNoAnonFunctionType = _base.state.noAnonFunctionType;
        _base.state.noAnonFunctionType = true;
        flowParseTypeAnnotation();
        _base.state.noAnonFunctionType = oldNoAnonFunctionType;
    }
}
function flowParseMaybeAssign(noIn, isWithinParens) {
    if ((0, _index.match)(_types.TokenType.lessThan)) {
        const snapshot = _base.state.snapshot();
        let wasArrow = (0, _expression.baseParseMaybeAssign)(noIn, isWithinParens);
        if (_base.state.error) {
            _base.state.restoreFromSnapshot(snapshot);
            _base.state.type = _types.TokenType.typeParameterStart;
        } else return wasArrow;
        const oldIsType = (0, _index.pushTypeContext)(0);
        flowParseTypeParameterDeclaration();
        (0, _index.popTypeContext)(oldIsType);
        wasArrow = (0, _expression.baseParseMaybeAssign)(noIn, isWithinParens);
        if (wasArrow) return true;
        (0, _util.unexpected)();
    }
    return (0, _expression.baseParseMaybeAssign)(noIn, isWithinParens);
}
function flowParseArrow() {
    if ((0, _index.match)(_types.TokenType.colon)) {
        const oldIsType = (0, _index.pushTypeContext)(0);
        const snapshot = _base.state.snapshot();
        const oldNoAnonFunctionType = _base.state.noAnonFunctionType;
        _base.state.noAnonFunctionType = true;
        flowParseTypeAndPredicateInitialiser();
        _base.state.noAnonFunctionType = oldNoAnonFunctionType;
        if ((0, _util.canInsertSemicolon)()) (0, _util.unexpected)();
        if (!(0, _index.match)(_types.TokenType.arrow)) (0, _util.unexpected)();
        if (_base.state.error) _base.state.restoreFromSnapshot(snapshot);
        (0, _index.popTypeContext)(oldIsType);
    }
    return (0, _index.eat)(_types.TokenType.arrow);
}
function flowParseSubscripts(startTokenIndex, noCalls = false) {
    if (_base.state.tokens[_base.state.tokens.length - 1].contextualKeyword === _keywords.ContextualKeyword._async && (0, _index.match)(_types.TokenType.lessThan)) {
        const snapshot = _base.state.snapshot();
        const wasArrow = parseAsyncArrowWithTypeParameters();
        if (wasArrow && !_base.state.error) return;
        _base.state.restoreFromSnapshot(snapshot);
    }
    (0, _expression.baseParseSubscripts)(startTokenIndex, noCalls);
}
// Returns true if there was an arrow function here.
function parseAsyncArrowWithTypeParameters() {
    _base.state.scopeDepth++;
    const startTokenIndex = _base.state.tokens.length;
    (0, _statement.parseFunctionParams)();
    if (!(0, _expression.parseArrow)()) return false;
    (0, _expression.parseArrowExpression)(startTokenIndex);
    return true;
}
function flowParseEnumDeclaration() {
    (0, _util.expectContextual)(_keywords.ContextualKeyword._enum);
    _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._enum;
    (0, _expression.parseIdentifier)();
    flowParseEnumBody();
}
function flowParseEnumBody() {
    if ((0, _util.eatContextual)(_keywords.ContextualKeyword._of)) (0, _index.next)();
    (0, _util.expect)(_types.TokenType.braceL);
    flowParseEnumMembers();
    (0, _util.expect)(_types.TokenType.braceR);
}
function flowParseEnumMembers() {
    while(!(0, _index.match)(_types.TokenType.braceR) && !_base.state.error){
        if ((0, _index.eat)(_types.TokenType.ellipsis)) break;
        flowParseEnumMember();
        if (!(0, _index.match)(_types.TokenType.braceR)) (0, _util.expect)(_types.TokenType.comma);
    }
}
function flowParseEnumMember() {
    (0, _expression.parseIdentifier)();
    if ((0, _index.eat)(_types.TokenType.eq)) // Flow enum values are always just one token (a string, number, or boolean literal).
    (0, _index.next)();
}

},
"node_modules/sucrase/dist/esm/parser/plugins/jsx/index.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    jsxParseElement: function() {
        return jsxParseElement;
    },
    nextJSXTagToken: function() {
        return nextJSXTagToken;
    }
});
var _index = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/index.js");
var _types = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/types.js");
var _base = __mako_require__("node_modules/sucrase/dist/esm/parser/traverser/base.js");
var _expression = __mako_require__("node_modules/sucrase/dist/esm/parser/traverser/expression.js");
var _util = __mako_require__("node_modules/sucrase/dist/esm/parser/traverser/util.js");
var _charcodes = __mako_require__("node_modules/sucrase/dist/esm/parser/util/charcodes.js");
var _identifier = __mako_require__("node_modules/sucrase/dist/esm/parser/util/identifier.js");
var _typescript = __mako_require__("node_modules/sucrase/dist/esm/parser/plugins/typescript.js");
/**
 * Read token with JSX contents.
 *
 * In addition to detecting jsxTagStart and also regular tokens that might be
 * part of an expression, this code detects the start and end of text ranges
 * within JSX children. In order to properly count the number of children, we
 * distinguish jsxText from jsxEmptyText, which is a text range that simplifies
 * to the empty string after JSX whitespace trimming.
 *
 * It turns out that a JSX text range will simplify to the empty string if and
 * only if both of these conditions hold:
 * - The range consists entirely of whitespace characters (only counting space,
 *   tab, \r, and \n).
 * - The range has at least one newline.
 * This can be proven by analyzing any implementation of whitespace trimming,
 * e.g. formatJSXTextLiteral in Sucrase or cleanJSXElementLiteralChild in Babel.
 */ function jsxReadToken() {
    let sawNewline = false;
    let sawNonWhitespace = false;
    while(true){
        if (_base.state.pos >= _base.input.length) {
            (0, _util.unexpected)("Unterminated JSX contents");
            return;
        }
        const ch = _base.input.charCodeAt(_base.state.pos);
        if (ch === _charcodes.charCodes.lessThan || ch === _charcodes.charCodes.leftCurlyBrace) {
            if (_base.state.pos === _base.state.start) {
                if (ch === _charcodes.charCodes.lessThan) {
                    _base.state.pos++;
                    (0, _index.finishToken)(_types.TokenType.jsxTagStart);
                    return;
                }
                (0, _index.getTokenFromCode)(ch);
                return;
            }
            if (sawNewline && !sawNonWhitespace) (0, _index.finishToken)(_types.TokenType.jsxEmptyText);
            else (0, _index.finishToken)(_types.TokenType.jsxText);
            return;
        }
        // This is part of JSX text.
        if (ch === _charcodes.charCodes.lineFeed) sawNewline = true;
        else if (ch !== _charcodes.charCodes.space && ch !== _charcodes.charCodes.carriageReturn && ch !== _charcodes.charCodes.tab) sawNonWhitespace = true;
        _base.state.pos++;
    }
}
function jsxReadString(quote) {
    _base.state.pos++;
    for(;;){
        if (_base.state.pos >= _base.input.length) {
            (0, _util.unexpected)("Unterminated string constant");
            return;
        }
        const ch = _base.input.charCodeAt(_base.state.pos);
        if (ch === quote) {
            _base.state.pos++;
            break;
        }
        _base.state.pos++;
    }
    (0, _index.finishToken)(_types.TokenType.string);
}
// Read a JSX identifier (valid tag or attribute name).
//
// Optimized version since JSX identifiers can't contain
// escape characters and so can be read as single slice.
// Also assumes that first character was already checked
// by isIdentifierStart in readToken.
function jsxReadWord() {
    let ch;
    do {
        if (_base.state.pos > _base.input.length) {
            (0, _util.unexpected)("Unexpectedly reached the end of input.");
            return;
        }
        ch = _base.input.charCodeAt(++_base.state.pos);
    }while (_identifier.IS_IDENTIFIER_CHAR[ch] || ch === _charcodes.charCodes.dash)
    (0, _index.finishToken)(_types.TokenType.jsxName);
}
// Parse next token as JSX identifier
function jsxParseIdentifier() {
    nextJSXTagToken();
}
// Parse namespaced identifier.
function jsxParseNamespacedName(identifierRole) {
    jsxParseIdentifier();
    if (!(0, _index.eat)(_types.TokenType.colon)) {
        // Plain identifier, so this is an access.
        _base.state.tokens[_base.state.tokens.length - 1].identifierRole = identifierRole;
        return;
    }
    // Process the second half of the namespaced name.
    jsxParseIdentifier();
}
// Parses element name in any form - namespaced, member
// or single identifier.
function jsxParseElementName() {
    const firstTokenIndex = _base.state.tokens.length;
    jsxParseNamespacedName(_index.IdentifierRole.Access);
    let hadDot = false;
    while((0, _index.match)(_types.TokenType.dot)){
        hadDot = true;
        nextJSXTagToken();
        jsxParseIdentifier();
    }
    // For tags like <div> with a lowercase letter and no dots, the name is
    // actually *not* an identifier access, since it's referring to a built-in
    // tag name. Remove the identifier role in this case so that it's not
    // accidentally transformed by the imports transform when preserving JSX.
    if (!hadDot) {
        const firstToken = _base.state.tokens[firstTokenIndex];
        const firstChar = _base.input.charCodeAt(firstToken.start);
        if (firstChar >= _charcodes.charCodes.lowercaseA && firstChar <= _charcodes.charCodes.lowercaseZ) firstToken.identifierRole = null;
    }
}
// Parses any type of JSX attribute value.
function jsxParseAttributeValue() {
    switch(_base.state.type){
        case _types.TokenType.braceL:
            (0, _index.next)();
            (0, _expression.parseExpression)();
            nextJSXTagToken();
            return;
        case _types.TokenType.jsxTagStart:
            jsxParseElement();
            nextJSXTagToken();
            return;
        case _types.TokenType.string:
            nextJSXTagToken();
            return;
        default:
            (0, _util.unexpected)("JSX value should be either an expression or a quoted JSX text");
    }
}
// Parse JSX spread child, after already processing the {
// Does not parse the closing }
function jsxParseSpreadChild() {
    (0, _util.expect)(_types.TokenType.ellipsis);
    (0, _expression.parseExpression)();
}
// Parses JSX opening tag starting after "<".
// Returns true if the tag was self-closing.
// Does not parse the last token.
function jsxParseOpeningElement(initialTokenIndex) {
    if ((0, _index.match)(_types.TokenType.jsxTagEnd)) // This is an open-fragment.
    return false;
    jsxParseElementName();
    if (_base.isTypeScriptEnabled) (0, _typescript.tsTryParseJSXTypeArgument)();
    let hasSeenPropSpread = false;
    while(!(0, _index.match)(_types.TokenType.slash) && !(0, _index.match)(_types.TokenType.jsxTagEnd) && !_base.state.error){
        if ((0, _index.eat)(_types.TokenType.braceL)) {
            hasSeenPropSpread = true;
            (0, _util.expect)(_types.TokenType.ellipsis);
            (0, _expression.parseMaybeAssign)();
            // }
            nextJSXTagToken();
            continue;
        }
        if (hasSeenPropSpread && _base.state.end - _base.state.start === 3 && _base.input.charCodeAt(_base.state.start) === _charcodes.charCodes.lowercaseK && _base.input.charCodeAt(_base.state.start + 1) === _charcodes.charCodes.lowercaseE && _base.input.charCodeAt(_base.state.start + 2) === _charcodes.charCodes.lowercaseY) _base.state.tokens[initialTokenIndex].jsxRole = _index.JSXRole.KeyAfterPropSpread;
        jsxParseNamespacedName(_index.IdentifierRole.ObjectKey);
        if ((0, _index.match)(_types.TokenType.eq)) {
            nextJSXTagToken();
            jsxParseAttributeValue();
        }
    }
    const isSelfClosing = (0, _index.match)(_types.TokenType.slash);
    if (isSelfClosing) // /
    nextJSXTagToken();
    return isSelfClosing;
}
// Parses JSX closing tag starting after "</".
// Does not parse the last token.
function jsxParseClosingElement() {
    if ((0, _index.match)(_types.TokenType.jsxTagEnd)) // Fragment syntax, so we immediately have a tag end.
    return;
    jsxParseElementName();
}
// Parses entire JSX element, including its opening tag
// (starting after "<"), attributes, contents and closing tag.
// Does not parse the last token.
function jsxParseElementAt() {
    const initialTokenIndex = _base.state.tokens.length - 1;
    _base.state.tokens[initialTokenIndex].jsxRole = _index.JSXRole.NoChildren;
    let numExplicitChildren = 0;
    const isSelfClosing = jsxParseOpeningElement(initialTokenIndex);
    if (!isSelfClosing) {
        nextJSXExprToken();
        while(true)switch(_base.state.type){
            case _types.TokenType.jsxTagStart:
                nextJSXTagToken();
                if ((0, _index.match)(_types.TokenType.slash)) {
                    nextJSXTagToken();
                    jsxParseClosingElement();
                    // Key after prop spread takes precedence over number of children,
                    // since it means we switch to createElement, which doesn't care
                    // about number of children.
                    if (_base.state.tokens[initialTokenIndex].jsxRole !== _index.JSXRole.KeyAfterPropSpread) {
                        if (numExplicitChildren === 1) _base.state.tokens[initialTokenIndex].jsxRole = _index.JSXRole.OneChild;
                        else if (numExplicitChildren > 1) _base.state.tokens[initialTokenIndex].jsxRole = _index.JSXRole.StaticChildren;
                    }
                    return;
                }
                numExplicitChildren++;
                jsxParseElementAt();
                nextJSXExprToken();
                break;
            case _types.TokenType.jsxText:
                numExplicitChildren++;
                nextJSXExprToken();
                break;
            case _types.TokenType.jsxEmptyText:
                nextJSXExprToken();
                break;
            case _types.TokenType.braceL:
                (0, _index.next)();
                if ((0, _index.match)(_types.TokenType.ellipsis)) {
                    jsxParseSpreadChild();
                    nextJSXExprToken();
                    // Spread children are a mechanism to explicitly mark children as
                    // static, so count it as 2 children to satisfy the "more than one
                    // child" condition.
                    numExplicitChildren += 2;
                } else {
                    // If we see {}, this is an empty pseudo-expression that doesn't
                    // count as a child.
                    if (!(0, _index.match)(_types.TokenType.braceR)) {
                        numExplicitChildren++;
                        (0, _expression.parseExpression)();
                    }
                    nextJSXExprToken();
                }
                break;
            // istanbul ignore next - should never happen
            default:
                (0, _util.unexpected)();
                return;
        }
    }
}
function jsxParseElement() {
    nextJSXTagToken();
    jsxParseElementAt();
}
function nextJSXTagToken() {
    _base.state.tokens.push(new _index.Token());
    (0, _index.skipSpace)();
    _base.state.start = _base.state.pos;
    const code = _base.input.charCodeAt(_base.state.pos);
    if (_identifier.IS_IDENTIFIER_START[code]) jsxReadWord();
    else if (code === _charcodes.charCodes.quotationMark || code === _charcodes.charCodes.apostrophe) jsxReadString(code);
    else {
        // The following tokens are just one character each.
        ++_base.state.pos;
        switch(code){
            case _charcodes.charCodes.greaterThan:
                (0, _index.finishToken)(_types.TokenType.jsxTagEnd);
                break;
            case _charcodes.charCodes.lessThan:
                (0, _index.finishToken)(_types.TokenType.jsxTagStart);
                break;
            case _charcodes.charCodes.slash:
                (0, _index.finishToken)(_types.TokenType.slash);
                break;
            case _charcodes.charCodes.equalsTo:
                (0, _index.finishToken)(_types.TokenType.eq);
                break;
            case _charcodes.charCodes.leftCurlyBrace:
                (0, _index.finishToken)(_types.TokenType.braceL);
                break;
            case _charcodes.charCodes.dot:
                (0, _index.finishToken)(_types.TokenType.dot);
                break;
            case _charcodes.charCodes.colon:
                (0, _index.finishToken)(_types.TokenType.colon);
                break;
            default:
                (0, _util.unexpected)();
        }
    }
}
function nextJSXExprToken() {
    _base.state.tokens.push(new _index.Token());
    _base.state.start = _base.state.pos;
    jsxReadToken();
}

},
"node_modules/sucrase/dist/esm/parser/plugins/jsx/xhtml.js": function (module, exports, __mako_require__){
// Use a Map rather than object to avoid unexpected __proto__ access.
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
var _default = new Map([
    [
        "quot",
        "\u0022"
    ],
    [
        "amp",
        "&"
    ],
    [
        "apos",
        "\u0027"
    ],
    [
        "lt",
        "<"
    ],
    [
        "gt",
        ">"
    ],
    [
        "nbsp",
        "\u00A0"
    ],
    [
        "iexcl",
        "\u00A1"
    ],
    [
        "cent",
        "\u00A2"
    ],
    [
        "pound",
        "\u00A3"
    ],
    [
        "curren",
        "\u00A4"
    ],
    [
        "yen",
        "\u00A5"
    ],
    [
        "brvbar",
        "\u00A6"
    ],
    [
        "sect",
        "\u00A7"
    ],
    [
        "uml",
        "\u00A8"
    ],
    [
        "copy",
        "\u00A9"
    ],
    [
        "ordf",
        "\u00AA"
    ],
    [
        "laquo",
        "\u00AB"
    ],
    [
        "not",
        "\u00AC"
    ],
    [
        "shy",
        "\u00AD"
    ],
    [
        "reg",
        "\u00AE"
    ],
    [
        "macr",
        "\u00AF"
    ],
    [
        "deg",
        "\u00B0"
    ],
    [
        "plusmn",
        "\u00B1"
    ],
    [
        "sup2",
        "\u00B2"
    ],
    [
        "sup3",
        "\u00B3"
    ],
    [
        "acute",
        "\u00B4"
    ],
    [
        "micro",
        "\u00B5"
    ],
    [
        "para",
        "\u00B6"
    ],
    [
        "middot",
        "\u00B7"
    ],
    [
        "cedil",
        "\u00B8"
    ],
    [
        "sup1",
        "\u00B9"
    ],
    [
        "ordm",
        "\u00BA"
    ],
    [
        "raquo",
        "\u00BB"
    ],
    [
        "frac14",
        "\u00BC"
    ],
    [
        "frac12",
        "\u00BD"
    ],
    [
        "frac34",
        "\u00BE"
    ],
    [
        "iquest",
        "\u00BF"
    ],
    [
        "Agrave",
        "\u00C0"
    ],
    [
        "Aacute",
        "\u00C1"
    ],
    [
        "Acirc",
        "\u00C2"
    ],
    [
        "Atilde",
        "\u00C3"
    ],
    [
        "Auml",
        "\u00C4"
    ],
    [
        "Aring",
        "\u00C5"
    ],
    [
        "AElig",
        "\u00C6"
    ],
    [
        "Ccedil",
        "\u00C7"
    ],
    [
        "Egrave",
        "\u00C8"
    ],
    [
        "Eacute",
        "\u00C9"
    ],
    [
        "Ecirc",
        "\u00CA"
    ],
    [
        "Euml",
        "\u00CB"
    ],
    [
        "Igrave",
        "\u00CC"
    ],
    [
        "Iacute",
        "\u00CD"
    ],
    [
        "Icirc",
        "\u00CE"
    ],
    [
        "Iuml",
        "\u00CF"
    ],
    [
        "ETH",
        "\u00D0"
    ],
    [
        "Ntilde",
        "\u00D1"
    ],
    [
        "Ograve",
        "\u00D2"
    ],
    [
        "Oacute",
        "\u00D3"
    ],
    [
        "Ocirc",
        "\u00D4"
    ],
    [
        "Otilde",
        "\u00D5"
    ],
    [
        "Ouml",
        "\u00D6"
    ],
    [
        "times",
        "\u00D7"
    ],
    [
        "Oslash",
        "\u00D8"
    ],
    [
        "Ugrave",
        "\u00D9"
    ],
    [
        "Uacute",
        "\u00DA"
    ],
    [
        "Ucirc",
        "\u00DB"
    ],
    [
        "Uuml",
        "\u00DC"
    ],
    [
        "Yacute",
        "\u00DD"
    ],
    [
        "THORN",
        "\u00DE"
    ],
    [
        "szlig",
        "\u00DF"
    ],
    [
        "agrave",
        "\u00E0"
    ],
    [
        "aacute",
        "\u00E1"
    ],
    [
        "acirc",
        "\u00E2"
    ],
    [
        "atilde",
        "\u00E3"
    ],
    [
        "auml",
        "\u00E4"
    ],
    [
        "aring",
        "\u00E5"
    ],
    [
        "aelig",
        "\u00E6"
    ],
    [
        "ccedil",
        "\u00E7"
    ],
    [
        "egrave",
        "\u00E8"
    ],
    [
        "eacute",
        "\u00E9"
    ],
    [
        "ecirc",
        "\u00EA"
    ],
    [
        "euml",
        "\u00EB"
    ],
    [
        "igrave",
        "\u00EC"
    ],
    [
        "iacute",
        "\u00ED"
    ],
    [
        "icirc",
        "\u00EE"
    ],
    [
        "iuml",
        "\u00EF"
    ],
    [
        "eth",
        "\u00F0"
    ],
    [
        "ntilde",
        "\u00F1"
    ],
    [
        "ograve",
        "\u00F2"
    ],
    [
        "oacute",
        "\u00F3"
    ],
    [
        "ocirc",
        "\u00F4"
    ],
    [
        "otilde",
        "\u00F5"
    ],
    [
        "ouml",
        "\u00F6"
    ],
    [
        "divide",
        "\u00F7"
    ],
    [
        "oslash",
        "\u00F8"
    ],
    [
        "ugrave",
        "\u00F9"
    ],
    [
        "uacute",
        "\u00FA"
    ],
    [
        "ucirc",
        "\u00FB"
    ],
    [
        "uuml",
        "\u00FC"
    ],
    [
        "yacute",
        "\u00FD"
    ],
    [
        "thorn",
        "\u00FE"
    ],
    [
        "yuml",
        "\u00FF"
    ],
    [
        "OElig",
        "\u0152"
    ],
    [
        "oelig",
        "\u0153"
    ],
    [
        "Scaron",
        "\u0160"
    ],
    [
        "scaron",
        "\u0161"
    ],
    [
        "Yuml",
        "\u0178"
    ],
    [
        "fnof",
        "\u0192"
    ],
    [
        "circ",
        "\u02C6"
    ],
    [
        "tilde",
        "\u02DC"
    ],
    [
        "Alpha",
        "\u0391"
    ],
    [
        "Beta",
        "\u0392"
    ],
    [
        "Gamma",
        "\u0393"
    ],
    [
        "Delta",
        "\u0394"
    ],
    [
        "Epsilon",
        "\u0395"
    ],
    [
        "Zeta",
        "\u0396"
    ],
    [
        "Eta",
        "\u0397"
    ],
    [
        "Theta",
        "\u0398"
    ],
    [
        "Iota",
        "\u0399"
    ],
    [
        "Kappa",
        "\u039A"
    ],
    [
        "Lambda",
        "\u039B"
    ],
    [
        "Mu",
        "\u039C"
    ],
    [
        "Nu",
        "\u039D"
    ],
    [
        "Xi",
        "\u039E"
    ],
    [
        "Omicron",
        "\u039F"
    ],
    [
        "Pi",
        "\u03A0"
    ],
    [
        "Rho",
        "\u03A1"
    ],
    [
        "Sigma",
        "\u03A3"
    ],
    [
        "Tau",
        "\u03A4"
    ],
    [
        "Upsilon",
        "\u03A5"
    ],
    [
        "Phi",
        "\u03A6"
    ],
    [
        "Chi",
        "\u03A7"
    ],
    [
        "Psi",
        "\u03A8"
    ],
    [
        "Omega",
        "\u03A9"
    ],
    [
        "alpha",
        "\u03B1"
    ],
    [
        "beta",
        "\u03B2"
    ],
    [
        "gamma",
        "\u03B3"
    ],
    [
        "delta",
        "\u03B4"
    ],
    [
        "epsilon",
        "\u03B5"
    ],
    [
        "zeta",
        "\u03B6"
    ],
    [
        "eta",
        "\u03B7"
    ],
    [
        "theta",
        "\u03B8"
    ],
    [
        "iota",
        "\u03B9"
    ],
    [
        "kappa",
        "\u03BA"
    ],
    [
        "lambda",
        "\u03BB"
    ],
    [
        "mu",
        "\u03BC"
    ],
    [
        "nu",
        "\u03BD"
    ],
    [
        "xi",
        "\u03BE"
    ],
    [
        "omicron",
        "\u03BF"
    ],
    [
        "pi",
        "\u03C0"
    ],
    [
        "rho",
        "\u03C1"
    ],
    [
        "sigmaf",
        "\u03C2"
    ],
    [
        "sigma",
        "\u03C3"
    ],
    [
        "tau",
        "\u03C4"
    ],
    [
        "upsilon",
        "\u03C5"
    ],
    [
        "phi",
        "\u03C6"
    ],
    [
        "chi",
        "\u03C7"
    ],
    [
        "psi",
        "\u03C8"
    ],
    [
        "omega",
        "\u03C9"
    ],
    [
        "thetasym",
        "\u03D1"
    ],
    [
        "upsih",
        "\u03D2"
    ],
    [
        "piv",
        "\u03D6"
    ],
    [
        "ensp",
        "\u2002"
    ],
    [
        "emsp",
        "\u2003"
    ],
    [
        "thinsp",
        "\u2009"
    ],
    [
        "zwnj",
        "\u200C"
    ],
    [
        "zwj",
        "\u200D"
    ],
    [
        "lrm",
        "\u200E"
    ],
    [
        "rlm",
        "\u200F"
    ],
    [
        "ndash",
        "\u2013"
    ],
    [
        "mdash",
        "\u2014"
    ],
    [
        "lsquo",
        "\u2018"
    ],
    [
        "rsquo",
        "\u2019"
    ],
    [
        "sbquo",
        "\u201A"
    ],
    [
        "ldquo",
        "\u201C"
    ],
    [
        "rdquo",
        "\u201D"
    ],
    [
        "bdquo",
        "\u201E"
    ],
    [
        "dagger",
        "\u2020"
    ],
    [
        "Dagger",
        "\u2021"
    ],
    [
        "bull",
        "\u2022"
    ],
    [
        "hellip",
        "\u2026"
    ],
    [
        "permil",
        "\u2030"
    ],
    [
        "prime",
        "\u2032"
    ],
    [
        "Prime",
        "\u2033"
    ],
    [
        "lsaquo",
        "\u2039"
    ],
    [
        "rsaquo",
        "\u203A"
    ],
    [
        "oline",
        "\u203E"
    ],
    [
        "frasl",
        "\u2044"
    ],
    [
        "euro",
        "\u20AC"
    ],
    [
        "image",
        "\u2111"
    ],
    [
        "weierp",
        "\u2118"
    ],
    [
        "real",
        "\u211C"
    ],
    [
        "trade",
        "\u2122"
    ],
    [
        "alefsym",
        "\u2135"
    ],
    [
        "larr",
        "\u2190"
    ],
    [
        "uarr",
        "\u2191"
    ],
    [
        "rarr",
        "\u2192"
    ],
    [
        "darr",
        "\u2193"
    ],
    [
        "harr",
        "\u2194"
    ],
    [
        "crarr",
        "\u21B5"
    ],
    [
        "lArr",
        "\u21D0"
    ],
    [
        "uArr",
        "\u21D1"
    ],
    [
        "rArr",
        "\u21D2"
    ],
    [
        "dArr",
        "\u21D3"
    ],
    [
        "hArr",
        "\u21D4"
    ],
    [
        "forall",
        "\u2200"
    ],
    [
        "part",
        "\u2202"
    ],
    [
        "exist",
        "\u2203"
    ],
    [
        "empty",
        "\u2205"
    ],
    [
        "nabla",
        "\u2207"
    ],
    [
        "isin",
        "\u2208"
    ],
    [
        "notin",
        "\u2209"
    ],
    [
        "ni",
        "\u220B"
    ],
    [
        "prod",
        "\u220F"
    ],
    [
        "sum",
        "\u2211"
    ],
    [
        "minus",
        "\u2212"
    ],
    [
        "lowast",
        "\u2217"
    ],
    [
        "radic",
        "\u221A"
    ],
    [
        "prop",
        "\u221D"
    ],
    [
        "infin",
        "\u221E"
    ],
    [
        "ang",
        "\u2220"
    ],
    [
        "and",
        "\u2227"
    ],
    [
        "or",
        "\u2228"
    ],
    [
        "cap",
        "\u2229"
    ],
    [
        "cup",
        "\u222A"
    ],
    [
        "int",
        "\u222B"
    ],
    [
        "there4",
        "\u2234"
    ],
    [
        "sim",
        "\u223C"
    ],
    [
        "cong",
        "\u2245"
    ],
    [
        "asymp",
        "\u2248"
    ],
    [
        "ne",
        "\u2260"
    ],
    [
        "equiv",
        "\u2261"
    ],
    [
        "le",
        "\u2264"
    ],
    [
        "ge",
        "\u2265"
    ],
    [
        "sub",
        "\u2282"
    ],
    [
        "sup",
        "\u2283"
    ],
    [
        "nsub",
        "\u2284"
    ],
    [
        "sube",
        "\u2286"
    ],
    [
        "supe",
        "\u2287"
    ],
    [
        "oplus",
        "\u2295"
    ],
    [
        "otimes",
        "\u2297"
    ],
    [
        "perp",
        "\u22A5"
    ],
    [
        "sdot",
        "\u22C5"
    ],
    [
        "lceil",
        "\u2308"
    ],
    [
        "rceil",
        "\u2309"
    ],
    [
        "lfloor",
        "\u230A"
    ],
    [
        "rfloor",
        "\u230B"
    ],
    [
        "lang",
        "\u2329"
    ],
    [
        "rang",
        "\u232A"
    ],
    [
        "loz",
        "\u25CA"
    ],
    [
        "spades",
        "\u2660"
    ],
    [
        "clubs",
        "\u2663"
    ],
    [
        "hearts",
        "\u2665"
    ],
    [
        "diams",
        "\u2666"
    ]
]);

},
"node_modules/sucrase/dist/esm/parser/plugins/types.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    typedParseConditional: function() {
        return typedParseConditional;
    },
    typedParseParenItem: function() {
        return typedParseParenItem;
    }
});
var _index = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/index.js");
var _types = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/types.js");
var _base = __mako_require__("node_modules/sucrase/dist/esm/parser/traverser/base.js");
var _expression = __mako_require__("node_modules/sucrase/dist/esm/parser/traverser/expression.js");
var _flow = __mako_require__("node_modules/sucrase/dist/esm/parser/plugins/flow.js");
var _typescript = __mako_require__("node_modules/sucrase/dist/esm/parser/plugins/typescript.js");
function typedParseConditional(noIn) {
    // If we see ?:, this can't possibly be a valid conditional. typedParseParenItem will be called
    // later to finish off the arrow parameter. We also need to handle bare ? tokens for optional
    // parameters without type annotations, i.e. ?, and ?) .
    if ((0, _index.match)(_types.TokenType.question)) {
        const nextType = (0, _index.lookaheadType)();
        if (nextType === _types.TokenType.colon || nextType === _types.TokenType.comma || nextType === _types.TokenType.parenR) return;
    }
    (0, _expression.baseParseConditional)(noIn);
}
function typedParseParenItem() {
    (0, _index.eatTypeToken)(_types.TokenType.question);
    if ((0, _index.match)(_types.TokenType.colon)) {
        if (_base.isTypeScriptEnabled) (0, _typescript.tsParseTypeAnnotation)();
        else if (_base.isFlowEnabled) (0, _flow.flowParseTypeAnnotation)();
    }
}

},
"node_modules/sucrase/dist/esm/parser/plugins/typescript.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    tsAfterParseClassSuper: function() {
        return tsAfterParseClassSuper;
    },
    tsAfterParseVarHead: function() {
        return tsAfterParseVarHead;
    },
    tsIsDeclarationStart: function() {
        return tsIsDeclarationStart;
    },
    tsParseArrow: function() {
        return tsParseArrow;
    },
    tsParseAssignableListItemTypes: function() {
        return tsParseAssignableListItemTypes;
    },
    tsParseExportDeclaration: function() {
        return tsParseExportDeclaration;
    },
    tsParseExportSpecifier: function() {
        return tsParseExportSpecifier;
    },
    tsParseFunctionBodyAndFinish: function() {
        return tsParseFunctionBodyAndFinish;
    },
    tsParseIdentifierStatement: function() {
        return tsParseIdentifierStatement;
    },
    tsParseImportEqualsDeclaration: function() {
        return tsParseImportEqualsDeclaration;
    },
    tsParseImportSpecifier: function() {
        return tsParseImportSpecifier;
    },
    tsParseMaybeAssign: function() {
        return tsParseMaybeAssign;
    },
    tsParseMaybeAssignWithJSX: function() {
        return tsParseMaybeAssignWithJSX;
    },
    tsParseMaybeAssignWithoutJSX: function() {
        return tsParseMaybeAssignWithoutJSX;
    },
    tsParseMaybeDecoratorArguments: function() {
        return tsParseMaybeDecoratorArguments;
    },
    tsParseModifier: function() {
        return tsParseModifier;
    },
    tsParseModifiers: function() {
        return tsParseModifiers;
    },
    tsParseNonConditionalType: function() {
        return tsParseNonConditionalType;
    },
    tsParseSubscript: function() {
        return tsParseSubscript;
    },
    tsParseType: function() {
        return tsParseType;
    },
    tsParseTypeAnnotation: function() {
        return tsParseTypeAnnotation;
    },
    tsParseTypeAssertion: function() {
        return tsParseTypeAssertion;
    },
    tsStartParseAsyncArrowFromCallExpression: function() {
        return tsStartParseAsyncArrowFromCallExpression;
    },
    tsStartParseFunctionParams: function() {
        return tsStartParseFunctionParams;
    },
    tsStartParseObjPropValue: function() {
        return tsStartParseObjPropValue;
    },
    tsTryParseClassMemberWithIsStatic: function() {
        return tsTryParseClassMemberWithIsStatic;
    },
    tsTryParseExport: function() {
        return tsTryParseExport;
    },
    tsTryParseExportDefaultExpression: function() {
        return tsTryParseExportDefaultExpression;
    },
    tsTryParseJSXTypeArgument: function() {
        return tsTryParseJSXTypeArgument;
    },
    tsTryParseStatementContent: function() {
        return tsTryParseStatementContent;
    },
    tsTryParseTypeAnnotation: function() {
        return tsTryParseTypeAnnotation;
    },
    tsTryParseTypeParameters: function() {
        return tsTryParseTypeParameters;
    }
});
var _index = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/index.js");
var _keywords = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/keywords.js");
var _types = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/types.js");
var _base = __mako_require__("node_modules/sucrase/dist/esm/parser/traverser/base.js");
var _expression = __mako_require__("node_modules/sucrase/dist/esm/parser/traverser/expression.js");
var _lval = __mako_require__("node_modules/sucrase/dist/esm/parser/traverser/lval.js");
var _statement = __mako_require__("node_modules/sucrase/dist/esm/parser/traverser/statement.js");
var _util = __mako_require__("node_modules/sucrase/dist/esm/parser/traverser/util.js");
var _jsx = __mako_require__("node_modules/sucrase/dist/esm/parser/plugins/jsx/index.js");
function tsIsIdentifier() {
    // TODO: actually a bit more complex in TypeScript, but shouldn't matter.
    // See https://github.com/Microsoft/TypeScript/issues/15008
    return (0, _index.match)(_types.TokenType.name);
}
function isLiteralPropertyName() {
    return (0, _index.match)(_types.TokenType.name) || Boolean(_base.state.type & _types.TokenType.IS_KEYWORD) || (0, _index.match)(_types.TokenType.string) || (0, _index.match)(_types.TokenType.num) || (0, _index.match)(_types.TokenType.bigint) || (0, _index.match)(_types.TokenType.decimal);
}
function tsNextTokenCanFollowModifier() {
    // Note: TypeScript's implementation is much more complicated because
    // more things are considered modifiers there.
    // This implementation only handles modifiers not handled by babylon itself. And "static".
    // TODO: Would be nice to avoid lookahead. Want a hasLineBreakUpNext() method...
    const snapshot = _base.state.snapshot();
    (0, _index.next)();
    const canFollowModifier = ((0, _index.match)(_types.TokenType.bracketL) || (0, _index.match)(_types.TokenType.braceL) || (0, _index.match)(_types.TokenType.star) || (0, _index.match)(_types.TokenType.ellipsis) || (0, _index.match)(_types.TokenType.hash) || isLiteralPropertyName()) && !(0, _util.hasPrecedingLineBreak)();
    if (canFollowModifier) return true;
    else {
        _base.state.restoreFromSnapshot(snapshot);
        return false;
    }
}
function tsParseModifiers(allowedModifiers) {
    while(true){
        const modifier = tsParseModifier(allowedModifiers);
        if (modifier === null) break;
    }
}
function tsParseModifier(allowedModifiers) {
    if (!(0, _index.match)(_types.TokenType.name)) return null;
    const modifier = _base.state.contextualKeyword;
    if (allowedModifiers.indexOf(modifier) !== -1 && tsNextTokenCanFollowModifier()) {
        switch(modifier){
            case _keywords.ContextualKeyword._readonly:
                _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._readonly;
                break;
            case _keywords.ContextualKeyword._abstract:
                _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._abstract;
                break;
            case _keywords.ContextualKeyword._static:
                _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._static;
                break;
            case _keywords.ContextualKeyword._public:
                _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._public;
                break;
            case _keywords.ContextualKeyword._private:
                _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._private;
                break;
            case _keywords.ContextualKeyword._protected:
                _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._protected;
                break;
            case _keywords.ContextualKeyword._override:
                _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._override;
                break;
            case _keywords.ContextualKeyword._declare:
                _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._declare;
                break;
            default:
                break;
        }
        return modifier;
    }
    return null;
}
function tsParseEntityName() {
    (0, _expression.parseIdentifier)();
    while((0, _index.eat)(_types.TokenType.dot))(0, _expression.parseIdentifier)();
}
function tsParseTypeReference() {
    tsParseEntityName();
    if (!(0, _util.hasPrecedingLineBreak)() && (0, _index.match)(_types.TokenType.lessThan)) tsParseTypeArguments();
}
function tsParseThisTypePredicate() {
    (0, _index.next)();
    tsParseTypeAnnotation();
}
function tsParseThisTypeNode() {
    (0, _index.next)();
}
function tsParseTypeQuery() {
    (0, _util.expect)(_types.TokenType._typeof);
    if ((0, _index.match)(_types.TokenType._import)) tsParseImportType();
    else tsParseEntityName();
    if (!(0, _util.hasPrecedingLineBreak)() && (0, _index.match)(_types.TokenType.lessThan)) tsParseTypeArguments();
}
function tsParseImportType() {
    (0, _util.expect)(_types.TokenType._import);
    (0, _util.expect)(_types.TokenType.parenL);
    (0, _util.expect)(_types.TokenType.string);
    (0, _util.expect)(_types.TokenType.parenR);
    if ((0, _index.eat)(_types.TokenType.dot)) tsParseEntityName();
    if ((0, _index.match)(_types.TokenType.lessThan)) tsParseTypeArguments();
}
function tsParseTypeParameter() {
    (0, _index.eat)(_types.TokenType._const);
    const hadIn = (0, _index.eat)(_types.TokenType._in);
    const hadOut = (0, _util.eatContextual)(_keywords.ContextualKeyword._out);
    (0, _index.eat)(_types.TokenType._const);
    if ((hadIn || hadOut) && !(0, _index.match)(_types.TokenType.name)) // The "in" or "out" keyword must have actually been the type parameter
    // name, so set it as the name.
    _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType.name;
    else (0, _expression.parseIdentifier)();
    if ((0, _index.eat)(_types.TokenType._extends)) tsParseType();
    if ((0, _index.eat)(_types.TokenType.eq)) tsParseType();
}
function tsTryParseTypeParameters() {
    if ((0, _index.match)(_types.TokenType.lessThan)) tsParseTypeParameters();
}
function tsParseTypeParameters() {
    const oldIsType = (0, _index.pushTypeContext)(0);
    if ((0, _index.match)(_types.TokenType.lessThan) || (0, _index.match)(_types.TokenType.typeParameterStart)) (0, _index.next)();
    else (0, _util.unexpected)();
    while(!(0, _index.eat)(_types.TokenType.greaterThan) && !_base.state.error){
        tsParseTypeParameter();
        (0, _index.eat)(_types.TokenType.comma);
    }
    (0, _index.popTypeContext)(oldIsType);
}
// Note: In TypeScript implementation we must provide `yieldContext` and `awaitContext`,
// but here it's always false, because this is only used for types.
function tsFillSignature(returnToken) {
    // Arrow fns *must* have return token (`=>`). Normal functions can omit it.
    const returnTokenRequired = returnToken === _types.TokenType.arrow;
    tsTryParseTypeParameters();
    (0, _util.expect)(_types.TokenType.parenL);
    // Create a scope even though we're doing type parsing so we don't accidentally
    // treat params as top-level bindings.
    _base.state.scopeDepth++;
    tsParseBindingListForSignature(false);
    _base.state.scopeDepth--;
    if (returnTokenRequired) tsParseTypeOrTypePredicateAnnotation(returnToken);
    else if ((0, _index.match)(returnToken)) tsParseTypeOrTypePredicateAnnotation(returnToken);
}
function tsParseBindingListForSignature(isBlockScope) {
    (0, _lval.parseBindingList)(_types.TokenType.parenR, isBlockScope);
}
function tsParseTypeMemberSemicolon() {
    if (!(0, _index.eat)(_types.TokenType.comma)) (0, _util.semicolon)();
}
function tsParseSignatureMember() {
    tsFillSignature(_types.TokenType.colon);
    tsParseTypeMemberSemicolon();
}
function tsIsUnambiguouslyIndexSignature() {
    const snapshot = _base.state.snapshot();
    (0, _index.next)(); // Skip '{'
    const isIndexSignature = (0, _index.eat)(_types.TokenType.name) && (0, _index.match)(_types.TokenType.colon);
    _base.state.restoreFromSnapshot(snapshot);
    return isIndexSignature;
}
function tsTryParseIndexSignature() {
    if (!((0, _index.match)(_types.TokenType.bracketL) && tsIsUnambiguouslyIndexSignature())) return false;
    const oldIsType = (0, _index.pushTypeContext)(0);
    (0, _util.expect)(_types.TokenType.bracketL);
    (0, _expression.parseIdentifier)();
    tsParseTypeAnnotation();
    (0, _util.expect)(_types.TokenType.bracketR);
    tsTryParseTypeAnnotation();
    tsParseTypeMemberSemicolon();
    (0, _index.popTypeContext)(oldIsType);
    return true;
}
function tsParsePropertyOrMethodSignature(isReadonly) {
    (0, _index.eat)(_types.TokenType.question);
    if (!isReadonly && ((0, _index.match)(_types.TokenType.parenL) || (0, _index.match)(_types.TokenType.lessThan))) {
        tsFillSignature(_types.TokenType.colon);
        tsParseTypeMemberSemicolon();
    } else {
        tsTryParseTypeAnnotation();
        tsParseTypeMemberSemicolon();
    }
}
function tsParseTypeMember() {
    if ((0, _index.match)(_types.TokenType.parenL) || (0, _index.match)(_types.TokenType.lessThan)) {
        // call signature
        tsParseSignatureMember();
        return;
    }
    if ((0, _index.match)(_types.TokenType._new)) {
        (0, _index.next)();
        if ((0, _index.match)(_types.TokenType.parenL) || (0, _index.match)(_types.TokenType.lessThan)) // constructor signature
        tsParseSignatureMember();
        else tsParsePropertyOrMethodSignature(false);
        return;
    }
    const readonly = !!tsParseModifier([
        _keywords.ContextualKeyword._readonly
    ]);
    const found = tsTryParseIndexSignature();
    if (found) return;
    ((0, _util.isContextual)(_keywords.ContextualKeyword._get) || (0, _util.isContextual)(_keywords.ContextualKeyword._set)) && tsNextTokenCanFollowModifier();
    (0, _expression.parsePropertyName)(-1 /* Types don't need context IDs. */ );
    tsParsePropertyOrMethodSignature(readonly);
}
function tsParseTypeLiteral() {
    tsParseObjectTypeMembers();
}
function tsParseObjectTypeMembers() {
    (0, _util.expect)(_types.TokenType.braceL);
    while(!(0, _index.eat)(_types.TokenType.braceR) && !_base.state.error)tsParseTypeMember();
}
function tsLookaheadIsStartOfMappedType() {
    const snapshot = _base.state.snapshot();
    const isStartOfMappedType = tsIsStartOfMappedType();
    _base.state.restoreFromSnapshot(snapshot);
    return isStartOfMappedType;
}
function tsIsStartOfMappedType() {
    (0, _index.next)();
    if ((0, _index.eat)(_types.TokenType.plus) || (0, _index.eat)(_types.TokenType.minus)) return (0, _util.isContextual)(_keywords.ContextualKeyword._readonly);
    if ((0, _util.isContextual)(_keywords.ContextualKeyword._readonly)) (0, _index.next)();
    if (!(0, _index.match)(_types.TokenType.bracketL)) return false;
    (0, _index.next)();
    if (!tsIsIdentifier()) return false;
    (0, _index.next)();
    return (0, _index.match)(_types.TokenType._in);
}
function tsParseMappedTypeParameter() {
    (0, _expression.parseIdentifier)();
    (0, _util.expect)(_types.TokenType._in);
    tsParseType();
}
function tsParseMappedType() {
    (0, _util.expect)(_types.TokenType.braceL);
    if ((0, _index.match)(_types.TokenType.plus) || (0, _index.match)(_types.TokenType.minus)) {
        (0, _index.next)();
        (0, _util.expectContextual)(_keywords.ContextualKeyword._readonly);
    } else (0, _util.eatContextual)(_keywords.ContextualKeyword._readonly);
    (0, _util.expect)(_types.TokenType.bracketL);
    tsParseMappedTypeParameter();
    if ((0, _util.eatContextual)(_keywords.ContextualKeyword._as)) tsParseType();
    (0, _util.expect)(_types.TokenType.bracketR);
    if ((0, _index.match)(_types.TokenType.plus) || (0, _index.match)(_types.TokenType.minus)) {
        (0, _index.next)();
        (0, _util.expect)(_types.TokenType.question);
    } else (0, _index.eat)(_types.TokenType.question);
    tsTryParseType();
    (0, _util.semicolon)();
    (0, _util.expect)(_types.TokenType.braceR);
}
function tsParseTupleType() {
    (0, _util.expect)(_types.TokenType.bracketL);
    while(!(0, _index.eat)(_types.TokenType.bracketR) && !_base.state.error){
        // Do not validate presence of either none or only labeled elements
        tsParseTupleElementType();
        (0, _index.eat)(_types.TokenType.comma);
    }
}
function tsParseTupleElementType() {
    // parses `...TsType[]`
    if ((0, _index.eat)(_types.TokenType.ellipsis)) tsParseType();
    else {
        // parses `TsType?`
        tsParseType();
        (0, _index.eat)(_types.TokenType.question);
    }
    // The type we parsed above was actually a label
    if ((0, _index.eat)(_types.TokenType.colon)) // Labeled tuple types must affix the label with `...` or `?`, so no need to handle those here
    tsParseType();
}
function tsParseParenthesizedType() {
    (0, _util.expect)(_types.TokenType.parenL);
    tsParseType();
    (0, _util.expect)(_types.TokenType.parenR);
}
function tsParseTemplateLiteralType() {
    // Finish `, read quasi
    (0, _index.nextTemplateToken)();
    // Finish quasi, read ${
    (0, _index.nextTemplateToken)();
    while(!(0, _index.match)(_types.TokenType.backQuote) && !_base.state.error){
        (0, _util.expect)(_types.TokenType.dollarBraceL);
        tsParseType();
        // Finish }, read quasi
        (0, _index.nextTemplateToken)();
        // Finish quasi, read either ${ or `
        (0, _index.nextTemplateToken)();
    }
    (0, _index.next)();
}
var FunctionType;
(function(FunctionType) {
    const TSFunctionType = 0;
    FunctionType[FunctionType["TSFunctionType"] = TSFunctionType] = "TSFunctionType";
    const TSConstructorType = TSFunctionType + 1;
    FunctionType[FunctionType["TSConstructorType"] = TSConstructorType] = "TSConstructorType";
    const TSAbstractConstructorType = TSConstructorType + 1;
    FunctionType[FunctionType["TSAbstractConstructorType"] = TSAbstractConstructorType] = "TSAbstractConstructorType";
})(FunctionType || (FunctionType = {}));
function tsParseFunctionOrConstructorType(type) {
    if (type === FunctionType.TSAbstractConstructorType) (0, _util.expectContextual)(_keywords.ContextualKeyword._abstract);
    if (type === FunctionType.TSConstructorType || type === FunctionType.TSAbstractConstructorType) (0, _util.expect)(_types.TokenType._new);
    const oldInDisallowConditionalTypesContext = _base.state.inDisallowConditionalTypesContext;
    _base.state.inDisallowConditionalTypesContext = false;
    tsFillSignature(_types.TokenType.arrow);
    _base.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
}
function tsParseNonArrayType() {
    switch(_base.state.type){
        case _types.TokenType.name:
            tsParseTypeReference();
            return;
        case _types.TokenType._void:
        case _types.TokenType._null:
            (0, _index.next)();
            return;
        case _types.TokenType.string:
        case _types.TokenType.num:
        case _types.TokenType.bigint:
        case _types.TokenType.decimal:
        case _types.TokenType._true:
        case _types.TokenType._false:
            (0, _expression.parseLiteral)();
            return;
        case _types.TokenType.minus:
            (0, _index.next)();
            (0, _expression.parseLiteral)();
            return;
        case _types.TokenType._this:
            tsParseThisTypeNode();
            if ((0, _util.isContextual)(_keywords.ContextualKeyword._is) && !(0, _util.hasPrecedingLineBreak)()) tsParseThisTypePredicate();
            return;
        case _types.TokenType._typeof:
            tsParseTypeQuery();
            return;
        case _types.TokenType._import:
            tsParseImportType();
            return;
        case _types.TokenType.braceL:
            if (tsLookaheadIsStartOfMappedType()) tsParseMappedType();
            else tsParseTypeLiteral();
            return;
        case _types.TokenType.bracketL:
            tsParseTupleType();
            return;
        case _types.TokenType.parenL:
            tsParseParenthesizedType();
            return;
        case _types.TokenType.backQuote:
            tsParseTemplateLiteralType();
            return;
        default:
            if (_base.state.type & _types.TokenType.IS_KEYWORD) {
                (0, _index.next)();
                _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType.name;
                return;
            }
            break;
    }
    (0, _util.unexpected)();
}
function tsParseArrayTypeOrHigher() {
    tsParseNonArrayType();
    while(!(0, _util.hasPrecedingLineBreak)() && (0, _index.eat)(_types.TokenType.bracketL))if (!(0, _index.eat)(_types.TokenType.bracketR)) {
        // If we hit ] immediately, this is an array type, otherwise it's an indexed access type.
        tsParseType();
        (0, _util.expect)(_types.TokenType.bracketR);
    }
}
function tsParseInferType() {
    (0, _util.expectContextual)(_keywords.ContextualKeyword._infer);
    (0, _expression.parseIdentifier)();
    if ((0, _index.match)(_types.TokenType._extends)) {
        // Infer type constraints introduce an ambiguity about whether the "extends"
        // is a constraint for this infer type or is another conditional type.
        const snapshot = _base.state.snapshot();
        (0, _util.expect)(_types.TokenType._extends);
        const oldInDisallowConditionalTypesContext = _base.state.inDisallowConditionalTypesContext;
        _base.state.inDisallowConditionalTypesContext = true;
        tsParseType();
        _base.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
        if (_base.state.error || !_base.state.inDisallowConditionalTypesContext && (0, _index.match)(_types.TokenType.question)) _base.state.restoreFromSnapshot(snapshot);
    }
}
function tsParseTypeOperatorOrHigher() {
    if ((0, _util.isContextual)(_keywords.ContextualKeyword._keyof) || (0, _util.isContextual)(_keywords.ContextualKeyword._unique) || (0, _util.isContextual)(_keywords.ContextualKeyword._readonly)) {
        (0, _index.next)();
        tsParseTypeOperatorOrHigher();
    } else if ((0, _util.isContextual)(_keywords.ContextualKeyword._infer)) tsParseInferType();
    else {
        const oldInDisallowConditionalTypesContext = _base.state.inDisallowConditionalTypesContext;
        _base.state.inDisallowConditionalTypesContext = false;
        tsParseArrayTypeOrHigher();
        _base.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
    }
}
function tsParseIntersectionTypeOrHigher() {
    (0, _index.eat)(_types.TokenType.bitwiseAND);
    tsParseTypeOperatorOrHigher();
    if ((0, _index.match)(_types.TokenType.bitwiseAND)) while((0, _index.eat)(_types.TokenType.bitwiseAND))tsParseTypeOperatorOrHigher();
}
function tsParseUnionTypeOrHigher() {
    (0, _index.eat)(_types.TokenType.bitwiseOR);
    tsParseIntersectionTypeOrHigher();
    if ((0, _index.match)(_types.TokenType.bitwiseOR)) while((0, _index.eat)(_types.TokenType.bitwiseOR))tsParseIntersectionTypeOrHigher();
}
function tsIsStartOfFunctionType() {
    if ((0, _index.match)(_types.TokenType.lessThan)) return true;
    return (0, _index.match)(_types.TokenType.parenL) && tsLookaheadIsUnambiguouslyStartOfFunctionType();
}
function tsSkipParameterStart() {
    if ((0, _index.match)(_types.TokenType.name) || (0, _index.match)(_types.TokenType._this)) {
        (0, _index.next)();
        return true;
    }
    // If this is a possible array/object destructure, walk to the matching bracket/brace.
    // The next token after will tell us definitively whether this is a function param.
    if ((0, _index.match)(_types.TokenType.braceL) || (0, _index.match)(_types.TokenType.bracketL)) {
        let depth = 1;
        (0, _index.next)();
        while(depth > 0 && !_base.state.error){
            if ((0, _index.match)(_types.TokenType.braceL) || (0, _index.match)(_types.TokenType.bracketL)) depth++;
            else if ((0, _index.match)(_types.TokenType.braceR) || (0, _index.match)(_types.TokenType.bracketR)) depth--;
            (0, _index.next)();
        }
        return true;
    }
    return false;
}
function tsLookaheadIsUnambiguouslyStartOfFunctionType() {
    const snapshot = _base.state.snapshot();
    const isUnambiguouslyStartOfFunctionType = tsIsUnambiguouslyStartOfFunctionType();
    _base.state.restoreFromSnapshot(snapshot);
    return isUnambiguouslyStartOfFunctionType;
}
function tsIsUnambiguouslyStartOfFunctionType() {
    (0, _index.next)();
    if ((0, _index.match)(_types.TokenType.parenR) || (0, _index.match)(_types.TokenType.ellipsis)) // ( )
    // ( ...
    return true;
    if (tsSkipParameterStart()) {
        if ((0, _index.match)(_types.TokenType.colon) || (0, _index.match)(_types.TokenType.comma) || (0, _index.match)(_types.TokenType.question) || (0, _index.match)(_types.TokenType.eq)) // ( xxx :
        // ( xxx ,
        // ( xxx ?
        // ( xxx =
        return true;
        if ((0, _index.match)(_types.TokenType.parenR)) {
            (0, _index.next)();
            if ((0, _index.match)(_types.TokenType.arrow)) // ( xxx ) =>
            return true;
        }
    }
    return false;
}
function tsParseTypeOrTypePredicateAnnotation(returnToken) {
    const oldIsType = (0, _index.pushTypeContext)(0);
    (0, _util.expect)(returnToken);
    const finishedReturn = tsParseTypePredicateOrAssertsPrefix();
    if (!finishedReturn) tsParseType();
    (0, _index.popTypeContext)(oldIsType);
}
function tsTryParseTypeOrTypePredicateAnnotation() {
    if ((0, _index.match)(_types.TokenType.colon)) tsParseTypeOrTypePredicateAnnotation(_types.TokenType.colon);
}
function tsTryParseTypeAnnotation() {
    if ((0, _index.match)(_types.TokenType.colon)) tsParseTypeAnnotation();
}
function tsTryParseType() {
    if ((0, _index.eat)(_types.TokenType.colon)) tsParseType();
}
/**
 * Detect a few special return syntax cases: `x is T`, `asserts x`, `asserts x is T`,
 * `asserts this is T`.
 *
 * Returns true if we parsed the return type, false if there's still a type to be parsed.
 */ function tsParseTypePredicateOrAssertsPrefix() {
    const snapshot = _base.state.snapshot();
    if ((0, _util.isContextual)(_keywords.ContextualKeyword._asserts)) {
        // Normally this is `asserts x is T`, but at this point, it might be `asserts is T` (a user-
        // defined type guard on the `asserts` variable) or just a type called `asserts`.
        (0, _index.next)();
        if ((0, _util.eatContextual)(_keywords.ContextualKeyword._is)) {
            // If we see `asserts is`, then this must be of the form `asserts is T`, since
            // `asserts is is T` isn't valid.
            tsParseType();
            return true;
        } else if (tsIsIdentifier() || (0, _index.match)(_types.TokenType._this)) {
            (0, _index.next)();
            if ((0, _util.eatContextual)(_keywords.ContextualKeyword._is)) // If we see `is`, then this is `asserts x is T`. Otherwise, it's `asserts x`.
            tsParseType();
            return true;
        } else {
            // Regular type, so bail out and start type parsing from scratch.
            _base.state.restoreFromSnapshot(snapshot);
            return false;
        }
    } else if (tsIsIdentifier() || (0, _index.match)(_types.TokenType._this)) {
        // This is a regular identifier, which may or may not have "is" after it.
        (0, _index.next)();
        if ((0, _util.isContextual)(_keywords.ContextualKeyword._is) && !(0, _util.hasPrecedingLineBreak)()) {
            (0, _index.next)();
            tsParseType();
            return true;
        } else {
            // Regular type, so bail out and start type parsing from scratch.
            _base.state.restoreFromSnapshot(snapshot);
            return false;
        }
    }
    return false;
}
function tsParseTypeAnnotation() {
    const oldIsType = (0, _index.pushTypeContext)(0);
    (0, _util.expect)(_types.TokenType.colon);
    tsParseType();
    (0, _index.popTypeContext)(oldIsType);
}
function tsParseType() {
    tsParseNonConditionalType();
    if (_base.state.inDisallowConditionalTypesContext || (0, _util.hasPrecedingLineBreak)() || !(0, _index.eat)(_types.TokenType._extends)) return;
    // extends type
    const oldInDisallowConditionalTypesContext = _base.state.inDisallowConditionalTypesContext;
    _base.state.inDisallowConditionalTypesContext = true;
    tsParseNonConditionalType();
    _base.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
    (0, _util.expect)(_types.TokenType.question);
    // true type
    tsParseType();
    (0, _util.expect)(_types.TokenType.colon);
    // false type
    tsParseType();
}
function isAbstractConstructorSignature() {
    return (0, _util.isContextual)(_keywords.ContextualKeyword._abstract) && (0, _index.lookaheadType)() === _types.TokenType._new;
}
function tsParseNonConditionalType() {
    if (tsIsStartOfFunctionType()) {
        tsParseFunctionOrConstructorType(FunctionType.TSFunctionType);
        return;
    }
    if ((0, _index.match)(_types.TokenType._new)) {
        // As in `new () => Date`
        tsParseFunctionOrConstructorType(FunctionType.TSConstructorType);
        return;
    } else if (isAbstractConstructorSignature()) {
        // As in `abstract new () => Date`
        tsParseFunctionOrConstructorType(FunctionType.TSAbstractConstructorType);
        return;
    }
    tsParseUnionTypeOrHigher();
}
function tsParseTypeAssertion() {
    const oldIsType = (0, _index.pushTypeContext)(1);
    tsParseType();
    (0, _util.expect)(_types.TokenType.greaterThan);
    (0, _index.popTypeContext)(oldIsType);
    (0, _expression.parseMaybeUnary)();
}
function tsTryParseJSXTypeArgument() {
    if ((0, _index.eat)(_types.TokenType.jsxTagStart)) {
        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType.typeParameterStart;
        const oldIsType = (0, _index.pushTypeContext)(1);
        while(!(0, _index.match)(_types.TokenType.greaterThan) && !_base.state.error){
            tsParseType();
            (0, _index.eat)(_types.TokenType.comma);
        }
        // Process >, but the one after needs to be parsed JSX-style.
        (0, _jsx.nextJSXTagToken)();
        (0, _index.popTypeContext)(oldIsType);
    }
}
function tsParseHeritageClause() {
    while(!(0, _index.match)(_types.TokenType.braceL) && !_base.state.error){
        tsParseExpressionWithTypeArguments();
        (0, _index.eat)(_types.TokenType.comma);
    }
}
function tsParseExpressionWithTypeArguments() {
    // Note: TS uses parseLeftHandSideExpressionOrHigher,
    // then has grammar errors later if it's not an EntityName.
    tsParseEntityName();
    if ((0, _index.match)(_types.TokenType.lessThan)) tsParseTypeArguments();
}
function tsParseInterfaceDeclaration() {
    (0, _lval.parseBindingIdentifier)(false);
    tsTryParseTypeParameters();
    if ((0, _index.eat)(_types.TokenType._extends)) tsParseHeritageClause();
    tsParseObjectTypeMembers();
}
function tsParseTypeAliasDeclaration() {
    (0, _lval.parseBindingIdentifier)(false);
    tsTryParseTypeParameters();
    (0, _util.expect)(_types.TokenType.eq);
    tsParseType();
    (0, _util.semicolon)();
}
function tsParseEnumMember() {
    // Computed property names are grammar errors in an enum, so accept just string literal or identifier.
    if ((0, _index.match)(_types.TokenType.string)) (0, _expression.parseLiteral)();
    else (0, _expression.parseIdentifier)();
    if ((0, _index.eat)(_types.TokenType.eq)) {
        const eqIndex = _base.state.tokens.length - 1;
        (0, _expression.parseMaybeAssign)();
        _base.state.tokens[eqIndex].rhsEndIndex = _base.state.tokens.length;
    }
}
function tsParseEnumDeclaration() {
    (0, _lval.parseBindingIdentifier)(false);
    (0, _util.expect)(_types.TokenType.braceL);
    while(!(0, _index.eat)(_types.TokenType.braceR) && !_base.state.error){
        tsParseEnumMember();
        (0, _index.eat)(_types.TokenType.comma);
    }
}
function tsParseModuleBlock() {
    (0, _util.expect)(_types.TokenType.braceL);
    (0, _statement.parseBlockBody)(/* end */ _types.TokenType.braceR);
}
function tsParseModuleOrNamespaceDeclaration() {
    (0, _lval.parseBindingIdentifier)(false);
    if ((0, _index.eat)(_types.TokenType.dot)) tsParseModuleOrNamespaceDeclaration();
    else tsParseModuleBlock();
}
function tsParseAmbientExternalModuleDeclaration() {
    if ((0, _util.isContextual)(_keywords.ContextualKeyword._global)) (0, _expression.parseIdentifier)();
    else if ((0, _index.match)(_types.TokenType.string)) (0, _expression.parseExprAtom)();
    else (0, _util.unexpected)();
    if ((0, _index.match)(_types.TokenType.braceL)) tsParseModuleBlock();
    else (0, _util.semicolon)();
}
function tsParseImportEqualsDeclaration() {
    (0, _lval.parseImportedIdentifier)();
    (0, _util.expect)(_types.TokenType.eq);
    tsParseModuleReference();
    (0, _util.semicolon)();
}
function tsIsExternalModuleReference() {
    return (0, _util.isContextual)(_keywords.ContextualKeyword._require) && (0, _index.lookaheadType)() === _types.TokenType.parenL;
}
function tsParseModuleReference() {
    if (tsIsExternalModuleReference()) tsParseExternalModuleReference();
    else tsParseEntityName();
}
function tsParseExternalModuleReference() {
    (0, _util.expectContextual)(_keywords.ContextualKeyword._require);
    (0, _util.expect)(_types.TokenType.parenL);
    if (!(0, _index.match)(_types.TokenType.string)) (0, _util.unexpected)();
    (0, _expression.parseLiteral)();
    (0, _util.expect)(_types.TokenType.parenR);
}
// Utilities
// Returns true if a statement matched.
function tsTryParseDeclare() {
    if ((0, _util.isLineTerminator)()) return false;
    switch(_base.state.type){
        case _types.TokenType._function:
            {
                const oldIsType = (0, _index.pushTypeContext)(1);
                (0, _index.next)();
                // We don't need to precisely get the function start here, since it's only used to mark
                // the function as a type if it's bodiless, and it's already a type here.
                const functionStart = _base.state.start;
                (0, _statement.parseFunction)(functionStart, /* isStatement */ true);
                (0, _index.popTypeContext)(oldIsType);
                return true;
            }
        case _types.TokenType._class:
            {
                const oldIsType = (0, _index.pushTypeContext)(1);
                (0, _statement.parseClass)(/* isStatement */ true, /* optionalId */ false);
                (0, _index.popTypeContext)(oldIsType);
                return true;
            }
        case _types.TokenType._const:
            if ((0, _index.match)(_types.TokenType._const) && (0, _util.isLookaheadContextual)(_keywords.ContextualKeyword._enum)) {
                const oldIsType = (0, _index.pushTypeContext)(1);
                // `const enum = 0;` not allowed because "enum" is a strict mode reserved word.
                (0, _util.expect)(_types.TokenType._const);
                (0, _util.expectContextual)(_keywords.ContextualKeyword._enum);
                _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._enum;
                tsParseEnumDeclaration();
                (0, _index.popTypeContext)(oldIsType);
                return true;
            }
        // falls through
        case _types.TokenType._var:
        case _types.TokenType._let:
            {
                const oldIsType = (0, _index.pushTypeContext)(1);
                (0, _statement.parseVarStatement)(_base.state.type !== _types.TokenType._var);
                (0, _index.popTypeContext)(oldIsType);
                return true;
            }
        case _types.TokenType.name:
            {
                const oldIsType = (0, _index.pushTypeContext)(1);
                const contextualKeyword = _base.state.contextualKeyword;
                let matched = false;
                if (contextualKeyword === _keywords.ContextualKeyword._global) {
                    tsParseAmbientExternalModuleDeclaration();
                    matched = true;
                } else matched = tsParseDeclaration(contextualKeyword, /* isBeforeToken */ true);
                (0, _index.popTypeContext)(oldIsType);
                return matched;
            }
        default:
            return false;
    }
}
// Note: this won't be called unless the keyword is allowed in `shouldParseExportDeclaration`.
// Returns true if it matched a declaration.
function tsTryParseExportDeclaration() {
    return tsParseDeclaration(_base.state.contextualKeyword, /* isBeforeToken */ true);
}
// Returns true if it matched a statement.
function tsParseExpressionStatement(contextualKeyword) {
    switch(contextualKeyword){
        case _keywords.ContextualKeyword._declare:
            {
                const declareTokenIndex = _base.state.tokens.length - 1;
                const matched = tsTryParseDeclare();
                if (matched) {
                    _base.state.tokens[declareTokenIndex].type = _types.TokenType._declare;
                    return true;
                }
                break;
            }
        case _keywords.ContextualKeyword._global:
            // `global { }` (with no `declare`) may appear inside an ambient module declaration.
            // Would like to use tsParseAmbientExternalModuleDeclaration here, but already ran past "global".
            if ((0, _index.match)(_types.TokenType.braceL)) {
                tsParseModuleBlock();
                return true;
            }
            break;
        default:
            return tsParseDeclaration(contextualKeyword, /* isBeforeToken */ false);
    }
    return false;
}
/**
 * Common code for parsing a declaration.
 *
 * isBeforeToken indicates that the current parser state is at the contextual
 * keyword (and that it is not yet emitted) rather than reading the token after
 * it. When isBeforeToken is true, we may be preceded by an `export` token and
 * should include that token in a type context we create, e.g. to handle
 * `export interface` or `export type`. (This is a bit of a hack and should be
 * cleaned up at some point.)
 *
 * Returns true if it matched a declaration.
 */ function tsParseDeclaration(contextualKeyword, isBeforeToken) {
    switch(contextualKeyword){
        case _keywords.ContextualKeyword._abstract:
            if (tsCheckLineTerminator(isBeforeToken) && (0, _index.match)(_types.TokenType._class)) {
                _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._abstract;
                (0, _statement.parseClass)(/* isStatement */ true, /* optionalId */ false);
                return true;
            }
            break;
        case _keywords.ContextualKeyword._enum:
            if (tsCheckLineTerminator(isBeforeToken) && (0, _index.match)(_types.TokenType.name)) {
                _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._enum;
                tsParseEnumDeclaration();
                return true;
            }
            break;
        case _keywords.ContextualKeyword._interface:
            if (tsCheckLineTerminator(isBeforeToken) && (0, _index.match)(_types.TokenType.name)) {
                // `next` is true in "export" and "declare" contexts, so we want to remove that token
                // as well.
                const oldIsType = (0, _index.pushTypeContext)(isBeforeToken ? 2 : 1);
                tsParseInterfaceDeclaration();
                (0, _index.popTypeContext)(oldIsType);
                return true;
            }
            break;
        case _keywords.ContextualKeyword._module:
            if (tsCheckLineTerminator(isBeforeToken)) {
                if ((0, _index.match)(_types.TokenType.string)) {
                    const oldIsType = (0, _index.pushTypeContext)(isBeforeToken ? 2 : 1);
                    tsParseAmbientExternalModuleDeclaration();
                    (0, _index.popTypeContext)(oldIsType);
                    return true;
                } else if ((0, _index.match)(_types.TokenType.name)) {
                    const oldIsType = (0, _index.pushTypeContext)(isBeforeToken ? 2 : 1);
                    tsParseModuleOrNamespaceDeclaration();
                    (0, _index.popTypeContext)(oldIsType);
                    return true;
                }
            }
            break;
        case _keywords.ContextualKeyword._namespace:
            if (tsCheckLineTerminator(isBeforeToken) && (0, _index.match)(_types.TokenType.name)) {
                const oldIsType = (0, _index.pushTypeContext)(isBeforeToken ? 2 : 1);
                tsParseModuleOrNamespaceDeclaration();
                (0, _index.popTypeContext)(oldIsType);
                return true;
            }
            break;
        case _keywords.ContextualKeyword._type:
            if (tsCheckLineTerminator(isBeforeToken) && (0, _index.match)(_types.TokenType.name)) {
                const oldIsType = (0, _index.pushTypeContext)(isBeforeToken ? 2 : 1);
                tsParseTypeAliasDeclaration();
                (0, _index.popTypeContext)(oldIsType);
                return true;
            }
            break;
        default:
            break;
    }
    return false;
}
function tsCheckLineTerminator(isBeforeToken) {
    if (isBeforeToken) {
        // Babel checks hasFollowingLineBreak here and returns false, but this
        // doesn't actually come up, e.g. `export interface` can never be on its own
        // line in valid code.
        (0, _index.next)();
        return true;
    } else return !(0, _util.isLineTerminator)();
}
// Returns true if there was a generic async arrow function.
function tsTryParseGenericAsyncArrowFunction() {
    const snapshot = _base.state.snapshot();
    tsParseTypeParameters();
    (0, _statement.parseFunctionParams)();
    tsTryParseTypeOrTypePredicateAnnotation();
    (0, _util.expect)(_types.TokenType.arrow);
    if (_base.state.error) {
        _base.state.restoreFromSnapshot(snapshot);
        return false;
    }
    (0, _expression.parseFunctionBody)(true);
    return true;
}
/**
 * If necessary, hack the tokenizer state so that this bitshift was actually a
 * less-than token, then keep parsing. This should only be used in situations
 * where we restore from snapshot on error (which reverts this change) or
 * where bitshift would be illegal anyway (e.g. in a class "extends" clause).
 *
 * This hack is useful to handle situations like foo<<T>() => void>() where
 * there can legitimately be two open-angle-brackets in a row in TS.
 */ function tsParseTypeArgumentsWithPossibleBitshift() {
    if (_base.state.type === _types.TokenType.bitShiftL) {
        _base.state.pos -= 1;
        (0, _index.finishToken)(_types.TokenType.lessThan);
    }
    tsParseTypeArguments();
}
function tsParseTypeArguments() {
    const oldIsType = (0, _index.pushTypeContext)(0);
    (0, _util.expect)(_types.TokenType.lessThan);
    while(!(0, _index.match)(_types.TokenType.greaterThan) && !_base.state.error){
        tsParseType();
        (0, _index.eat)(_types.TokenType.comma);
    }
    if (!oldIsType) {
        // If the type arguments are present in an expression context, e.g.
        // f<number>(), then the > sign should be tokenized as a non-type token.
        // In particular, f(a < b, c >= d) should parse the >= as a single token,
        // resulting in a syntax error and fallback to the non-type-args
        // interpretation. In the success case, even though the > is tokenized as a
        // non-type token, it still must be marked as a type token so that it is
        // erased.
        (0, _index.popTypeContext)(oldIsType);
        (0, _index.rescan_gt)();
        (0, _util.expect)(_types.TokenType.greaterThan);
        _base.state.tokens[_base.state.tokens.length - 1].isType = true;
    } else {
        (0, _util.expect)(_types.TokenType.greaterThan);
        (0, _index.popTypeContext)(oldIsType);
    }
}
function tsIsDeclarationStart() {
    if ((0, _index.match)(_types.TokenType.name)) switch(_base.state.contextualKeyword){
        case _keywords.ContextualKeyword._abstract:
        case _keywords.ContextualKeyword._declare:
        case _keywords.ContextualKeyword._enum:
        case _keywords.ContextualKeyword._interface:
        case _keywords.ContextualKeyword._module:
        case _keywords.ContextualKeyword._namespace:
        case _keywords.ContextualKeyword._type:
            return true;
        default:
            break;
    }
    return false;
}
function tsParseFunctionBodyAndFinish(functionStart, funcContextId) {
    // For arrow functions, `parseArrow` handles the return type itself.
    if ((0, _index.match)(_types.TokenType.colon)) tsParseTypeOrTypePredicateAnnotation(_types.TokenType.colon);
    // The original code checked the node type to make sure this function type allows a missing
    // body, but we skip that to avoid sending around the node type. We instead just use the
    // allowExpressionBody boolean to make sure it's not an arrow function.
    if (!(0, _index.match)(_types.TokenType.braceL) && (0, _util.isLineTerminator)()) {
        // Retroactively mark the function declaration as a type.
        let i = _base.state.tokens.length - 1;
        while(i >= 0 && (_base.state.tokens[i].start >= functionStart || _base.state.tokens[i].type === _types.TokenType._default || _base.state.tokens[i].type === _types.TokenType._export)){
            _base.state.tokens[i].isType = true;
            i--;
        }
        return;
    }
    (0, _expression.parseFunctionBody)(false, funcContextId);
}
function tsParseSubscript(startTokenIndex, noCalls, stopState) {
    if (!(0, _util.hasPrecedingLineBreak)() && (0, _index.eat)(_types.TokenType.bang)) {
        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType.nonNullAssertion;
        return;
    }
    if ((0, _index.match)(_types.TokenType.lessThan) || (0, _index.match)(_types.TokenType.bitShiftL)) {
        // There are number of things we are going to "maybe" parse, like type arguments on
        // tagged template expressions. If any of them fail, walk it back and continue.
        const snapshot = _base.state.snapshot();
        if (!noCalls && (0, _expression.atPossibleAsync)()) {
            // Almost certainly this is a generic async function `async <T>() => ...
            // But it might be a call with a type argument `async<T>();`
            const asyncArrowFn = tsTryParseGenericAsyncArrowFunction();
            if (asyncArrowFn) return;
        }
        tsParseTypeArgumentsWithPossibleBitshift();
        if (!noCalls && (0, _index.eat)(_types.TokenType.parenL)) {
            // With f<T>(), the subscriptStartIndex marker is on the ( token.
            _base.state.tokens[_base.state.tokens.length - 1].subscriptStartIndex = startTokenIndex;
            (0, _expression.parseCallExpressionArguments)();
        } else if ((0, _index.match)(_types.TokenType.backQuote)) // Tagged template with a type argument.
        (0, _expression.parseTemplate)();
        else if (// The remaining possible case is an instantiation expression, e.g.
        // Array<number> . Check for a few cases that would disqualify it and
        // cause us to bail out.
        // a<b>>c is not (a<b>)>c, but a<(b>>c)
        _base.state.type === _types.TokenType.greaterThan || _base.state.type !== _types.TokenType.parenL && Boolean(_base.state.type & _types.TokenType.IS_EXPRESSION_START) && !(0, _util.hasPrecedingLineBreak)()) // Bail out. We have something like a<b>c, which is not an expression with
        // type arguments but an (a < b) > c comparison.
        (0, _util.unexpected)();
        if (_base.state.error) _base.state.restoreFromSnapshot(snapshot);
        else return;
    } else if (!noCalls && (0, _index.match)(_types.TokenType.questionDot) && (0, _index.lookaheadType)() === _types.TokenType.lessThan) {
        // If we see f?.<, then this must be an optional call with a type argument.
        (0, _index.next)();
        _base.state.tokens[startTokenIndex].isOptionalChainStart = true;
        // With f?.<T>(), the subscriptStartIndex marker is on the ?. token.
        _base.state.tokens[_base.state.tokens.length - 1].subscriptStartIndex = startTokenIndex;
        tsParseTypeArguments();
        (0, _util.expect)(_types.TokenType.parenL);
        (0, _expression.parseCallExpressionArguments)();
    }
    (0, _expression.baseParseSubscript)(startTokenIndex, noCalls, stopState);
}
function tsTryParseExport() {
    if ((0, _index.eat)(_types.TokenType._import)) {
        // One of these cases:
        // export import A = B;
        // export import type A = require("A");
        if ((0, _util.isContextual)(_keywords.ContextualKeyword._type) && (0, _index.lookaheadType)() !== _types.TokenType.eq) // Eat a `type` token, unless it's actually an identifier name.
        (0, _util.expectContextual)(_keywords.ContextualKeyword._type);
        tsParseImportEqualsDeclaration();
        return true;
    } else if ((0, _index.eat)(_types.TokenType.eq)) {
        // `export = x;`
        (0, _expression.parseExpression)();
        (0, _util.semicolon)();
        return true;
    } else if ((0, _util.eatContextual)(_keywords.ContextualKeyword._as)) {
        // `export as namespace A;`
        // See `parseNamespaceExportDeclaration` in TypeScript's own parser
        (0, _util.expectContextual)(_keywords.ContextualKeyword._namespace);
        (0, _expression.parseIdentifier)();
        (0, _util.semicolon)();
        return true;
    } else {
        if ((0, _util.isContextual)(_keywords.ContextualKeyword._type)) {
            const nextType = (0, _index.lookaheadType)();
            // export type {foo} from 'a';
            // export type * from 'a';'
            // export type * as ns from 'a';'
            if (nextType === _types.TokenType.braceL || nextType === _types.TokenType.star) (0, _index.next)();
        }
        return false;
    }
}
function tsParseImportSpecifier() {
    (0, _expression.parseIdentifier)();
    if ((0, _index.match)(_types.TokenType.comma) || (0, _index.match)(_types.TokenType.braceR)) {
        // import {foo}
        _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _index.IdentifierRole.ImportDeclaration;
        return;
    }
    (0, _expression.parseIdentifier)();
    if ((0, _index.match)(_types.TokenType.comma) || (0, _index.match)(_types.TokenType.braceR)) {
        // import {type foo}
        _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _index.IdentifierRole.ImportDeclaration;
        _base.state.tokens[_base.state.tokens.length - 2].isType = true;
        _base.state.tokens[_base.state.tokens.length - 1].isType = true;
        return;
    }
    (0, _expression.parseIdentifier)();
    if ((0, _index.match)(_types.TokenType.comma) || (0, _index.match)(_types.TokenType.braceR)) {
        // import {foo as bar}
        _base.state.tokens[_base.state.tokens.length - 3].identifierRole = _index.IdentifierRole.ImportAccess;
        _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _index.IdentifierRole.ImportDeclaration;
        return;
    }
    (0, _expression.parseIdentifier)();
    // import {type foo as bar}
    _base.state.tokens[_base.state.tokens.length - 3].identifierRole = _index.IdentifierRole.ImportAccess;
    _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _index.IdentifierRole.ImportDeclaration;
    _base.state.tokens[_base.state.tokens.length - 4].isType = true;
    _base.state.tokens[_base.state.tokens.length - 3].isType = true;
    _base.state.tokens[_base.state.tokens.length - 2].isType = true;
    _base.state.tokens[_base.state.tokens.length - 1].isType = true;
}
function tsParseExportSpecifier() {
    (0, _expression.parseIdentifier)();
    if ((0, _index.match)(_types.TokenType.comma) || (0, _index.match)(_types.TokenType.braceR)) {
        // export {foo}
        _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _index.IdentifierRole.ExportAccess;
        return;
    }
    (0, _expression.parseIdentifier)();
    if ((0, _index.match)(_types.TokenType.comma) || (0, _index.match)(_types.TokenType.braceR)) {
        // export {type foo}
        _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _index.IdentifierRole.ExportAccess;
        _base.state.tokens[_base.state.tokens.length - 2].isType = true;
        _base.state.tokens[_base.state.tokens.length - 1].isType = true;
        return;
    }
    (0, _expression.parseIdentifier)();
    if ((0, _index.match)(_types.TokenType.comma) || (0, _index.match)(_types.TokenType.braceR)) {
        // export {foo as bar}
        _base.state.tokens[_base.state.tokens.length - 3].identifierRole = _index.IdentifierRole.ExportAccess;
        return;
    }
    (0, _expression.parseIdentifier)();
    // export {type foo as bar}
    _base.state.tokens[_base.state.tokens.length - 3].identifierRole = _index.IdentifierRole.ExportAccess;
    _base.state.tokens[_base.state.tokens.length - 4].isType = true;
    _base.state.tokens[_base.state.tokens.length - 3].isType = true;
    _base.state.tokens[_base.state.tokens.length - 2].isType = true;
    _base.state.tokens[_base.state.tokens.length - 1].isType = true;
}
function tsTryParseExportDefaultExpression() {
    if ((0, _util.isContextual)(_keywords.ContextualKeyword._abstract) && (0, _index.lookaheadType)() === _types.TokenType._class) {
        _base.state.type = _types.TokenType._abstract;
        (0, _index.next)(); // Skip "abstract"
        (0, _statement.parseClass)(true, true);
        return true;
    }
    if ((0, _util.isContextual)(_keywords.ContextualKeyword._interface)) {
        // Make sure "export default" are considered type tokens so the whole thing is removed.
        const oldIsType = (0, _index.pushTypeContext)(2);
        tsParseDeclaration(_keywords.ContextualKeyword._interface, true);
        (0, _index.popTypeContext)(oldIsType);
        return true;
    }
    return false;
}
function tsTryParseStatementContent() {
    if (_base.state.type === _types.TokenType._const) {
        const ahead = (0, _index.lookaheadTypeAndKeyword)();
        if (ahead.type === _types.TokenType.name && ahead.contextualKeyword === _keywords.ContextualKeyword._enum) {
            (0, _util.expect)(_types.TokenType._const);
            (0, _util.expectContextual)(_keywords.ContextualKeyword._enum);
            _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._enum;
            tsParseEnumDeclaration();
            return true;
        }
    }
    return false;
}
function tsTryParseClassMemberWithIsStatic(isStatic) {
    const memberStartIndexAfterStatic = _base.state.tokens.length;
    tsParseModifiers([
        _keywords.ContextualKeyword._abstract,
        _keywords.ContextualKeyword._readonly,
        _keywords.ContextualKeyword._declare,
        _keywords.ContextualKeyword._static,
        _keywords.ContextualKeyword._override
    ]);
    const modifiersEndIndex = _base.state.tokens.length;
    const found = tsTryParseIndexSignature();
    if (found) {
        // Index signatures are type declarations, so set the modifier tokens as
        // type tokens. Most tokens could be assumed to be type tokens, but `static`
        // is ambiguous unless we set it explicitly here.
        const memberStartIndex = isStatic ? memberStartIndexAfterStatic - 1 : memberStartIndexAfterStatic;
        for(let i = memberStartIndex; i < modifiersEndIndex; i++)_base.state.tokens[i].isType = true;
        return true;
    }
    return false;
}
function tsParseIdentifierStatement(contextualKeyword) {
    const matched = tsParseExpressionStatement(contextualKeyword);
    if (!matched) (0, _util.semicolon)();
}
function tsParseExportDeclaration() {
    // "export declare" is equivalent to just "export".
    const isDeclare = (0, _util.eatContextual)(_keywords.ContextualKeyword._declare);
    if (isDeclare) _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._declare;
    let matchedDeclaration = false;
    if ((0, _index.match)(_types.TokenType.name)) {
        if (isDeclare) {
            const oldIsType = (0, _index.pushTypeContext)(2);
            matchedDeclaration = tsTryParseExportDeclaration();
            (0, _index.popTypeContext)(oldIsType);
        } else matchedDeclaration = tsTryParseExportDeclaration();
    }
    if (!matchedDeclaration) {
        if (isDeclare) {
            const oldIsType = (0, _index.pushTypeContext)(2);
            (0, _statement.parseStatement)(true);
            (0, _index.popTypeContext)(oldIsType);
        } else (0, _statement.parseStatement)(true);
    }
}
function tsAfterParseClassSuper(hasSuper) {
    if (hasSuper && ((0, _index.match)(_types.TokenType.lessThan) || (0, _index.match)(_types.TokenType.bitShiftL))) tsParseTypeArgumentsWithPossibleBitshift();
    if ((0, _util.eatContextual)(_keywords.ContextualKeyword._implements)) {
        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._implements;
        const oldIsType = (0, _index.pushTypeContext)(1);
        tsParseHeritageClause();
        (0, _index.popTypeContext)(oldIsType);
    }
}
function tsStartParseObjPropValue() {
    tsTryParseTypeParameters();
}
function tsStartParseFunctionParams() {
    tsTryParseTypeParameters();
}
function tsAfterParseVarHead() {
    const oldIsType = (0, _index.pushTypeContext)(0);
    if (!(0, _util.hasPrecedingLineBreak)()) (0, _index.eat)(_types.TokenType.bang);
    tsTryParseTypeAnnotation();
    (0, _index.popTypeContext)(oldIsType);
}
function tsStartParseAsyncArrowFromCallExpression() {
    if ((0, _index.match)(_types.TokenType.colon)) tsParseTypeAnnotation();
}
function tsParseMaybeAssign(noIn, isWithinParens) {
    // Note: When the JSX plugin is on, type assertions (`<T> x`) aren't valid syntax.
    if (_base.isJSXEnabled) return tsParseMaybeAssignWithJSX(noIn, isWithinParens);
    else return tsParseMaybeAssignWithoutJSX(noIn, isWithinParens);
}
function tsParseMaybeAssignWithJSX(noIn, isWithinParens) {
    if (!(0, _index.match)(_types.TokenType.lessThan)) return (0, _expression.baseParseMaybeAssign)(noIn, isWithinParens);
    // Prefer to parse JSX if possible. But may be an arrow fn.
    const snapshot = _base.state.snapshot();
    let wasArrow = (0, _expression.baseParseMaybeAssign)(noIn, isWithinParens);
    if (_base.state.error) _base.state.restoreFromSnapshot(snapshot);
    else return wasArrow;
    // Otherwise, try as type-parameterized arrow function.
    _base.state.type = _types.TokenType.typeParameterStart;
    // This is similar to TypeScript's `tryParseParenthesizedArrowFunctionExpression`.
    tsParseTypeParameters();
    wasArrow = (0, _expression.baseParseMaybeAssign)(noIn, isWithinParens);
    if (!wasArrow) (0, _util.unexpected)();
    return wasArrow;
}
function tsParseMaybeAssignWithoutJSX(noIn, isWithinParens) {
    if (!(0, _index.match)(_types.TokenType.lessThan)) return (0, _expression.baseParseMaybeAssign)(noIn, isWithinParens);
    const snapshot = _base.state.snapshot();
    // This is similar to TypeScript's `tryParseParenthesizedArrowFunctionExpression`.
    tsParseTypeParameters();
    const wasArrow = (0, _expression.baseParseMaybeAssign)(noIn, isWithinParens);
    if (!wasArrow) (0, _util.unexpected)();
    if (_base.state.error) _base.state.restoreFromSnapshot(snapshot);
    else return wasArrow;
    // Try parsing a type cast instead of an arrow function.
    // This will start with a type assertion (via parseMaybeUnary).
    // But don't directly call `tsParseTypeAssertion` because we want to handle any binary after it.
    return (0, _expression.baseParseMaybeAssign)(noIn, isWithinParens);
}
function tsParseArrow() {
    if ((0, _index.match)(_types.TokenType.colon)) {
        // This is different from how the TS parser does it.
        // TS uses lookahead. Babylon parses it as a parenthesized expression and converts.
        const snapshot = _base.state.snapshot();
        tsParseTypeOrTypePredicateAnnotation(_types.TokenType.colon);
        if ((0, _util.canInsertSemicolon)()) (0, _util.unexpected)();
        if (!(0, _index.match)(_types.TokenType.arrow)) (0, _util.unexpected)();
        if (_base.state.error) _base.state.restoreFromSnapshot(snapshot);
    }
    return (0, _index.eat)(_types.TokenType.arrow);
}
function tsParseAssignableListItemTypes() {
    const oldIsType = (0, _index.pushTypeContext)(0);
    (0, _index.eat)(_types.TokenType.question);
    tsTryParseTypeAnnotation();
    (0, _index.popTypeContext)(oldIsType);
}
function tsParseMaybeDecoratorArguments() {
    if ((0, _index.match)(_types.TokenType.lessThan) || (0, _index.match)(_types.TokenType.bitShiftL)) tsParseTypeArgumentsWithPossibleBitshift();
    (0, _statement.baseParseMaybeDecoratorArguments)();
}

},
"node_modules/sucrase/dist/esm/parser/tokenizer/index.js": function (module, exports, __mako_require__){
/* eslint max-len: 0 */ "use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    IdentifierRole: function() {
        return IdentifierRole;
    },
    JSXRole: function() {
        return JSXRole;
    },
    Token: function() {
        return Token;
    },
    TypeAndKeyword: function() {
        return TypeAndKeyword;
    },
    eat: function() {
        return eat;
    },
    eatTypeToken: function() {
        return eatTypeToken;
    },
    finishToken: function() {
        return finishToken;
    },
    getTokenFromCode: function() {
        return getTokenFromCode;
    },
    isBlockScopedDeclaration: function() {
        return isBlockScopedDeclaration;
    },
    isDeclaration: function() {
        return isDeclaration;
    },
    isFunctionScopedDeclaration: function() {
        return isFunctionScopedDeclaration;
    },
    isNonTopLevelDeclaration: function() {
        return isNonTopLevelDeclaration;
    },
    isObjectShorthandDeclaration: function() {
        return isObjectShorthandDeclaration;
    },
    isTopLevelDeclaration: function() {
        return isTopLevelDeclaration;
    },
    lookaheadCharCode: function() {
        return lookaheadCharCode;
    },
    lookaheadType: function() {
        return lookaheadType;
    },
    lookaheadTypeAndKeyword: function() {
        return lookaheadTypeAndKeyword;
    },
    match: function() {
        return match;
    },
    next: function() {
        return next;
    },
    nextTemplateToken: function() {
        return nextTemplateToken;
    },
    nextToken: function() {
        return nextToken;
    },
    nextTokenStart: function() {
        return nextTokenStart;
    },
    nextTokenStartSince: function() {
        return nextTokenStartSince;
    },
    popTypeContext: function() {
        return popTypeContext;
    },
    pushTypeContext: function() {
        return pushTypeContext;
    },
    rescan_gt: function() {
        return rescan_gt;
    },
    retokenizeSlashAsRegex: function() {
        return retokenizeSlashAsRegex;
    },
    skipLineComment: function() {
        return skipLineComment;
    },
    skipSpace: function() {
        return skipSpace;
    },
    skipWord: function() {
        return skipWord;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _base = __mako_require__("node_modules/sucrase/dist/esm/parser/traverser/base.js");
var _util = __mako_require__("node_modules/sucrase/dist/esm/parser/traverser/util.js");
var _charcodes = __mako_require__("node_modules/sucrase/dist/esm/parser/util/charcodes.js");
var _identifier = __mako_require__("node_modules/sucrase/dist/esm/parser/util/identifier.js");
var _whitespace = __mako_require__("node_modules/sucrase/dist/esm/parser/util/whitespace.js");
var _keywords = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/keywords.js");
var _readWord = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/readWord.js"));
var _types = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/types.js");
var IdentifierRole;
(function(IdentifierRole) {
    const Access = 0;
    IdentifierRole[IdentifierRole["Access"] = Access] = "Access";
    const ExportAccess = Access + 1;
    IdentifierRole[IdentifierRole["ExportAccess"] = ExportAccess] = "ExportAccess";
    const TopLevelDeclaration = ExportAccess + 1;
    IdentifierRole[IdentifierRole["TopLevelDeclaration"] = TopLevelDeclaration] = "TopLevelDeclaration";
    const FunctionScopedDeclaration = TopLevelDeclaration + 1;
    IdentifierRole[IdentifierRole["FunctionScopedDeclaration"] = FunctionScopedDeclaration] = "FunctionScopedDeclaration";
    const BlockScopedDeclaration = FunctionScopedDeclaration + 1;
    IdentifierRole[IdentifierRole["BlockScopedDeclaration"] = BlockScopedDeclaration] = "BlockScopedDeclaration";
    const ObjectShorthandTopLevelDeclaration = BlockScopedDeclaration + 1;
    IdentifierRole[IdentifierRole["ObjectShorthandTopLevelDeclaration"] = ObjectShorthandTopLevelDeclaration] = "ObjectShorthandTopLevelDeclaration";
    const ObjectShorthandFunctionScopedDeclaration = ObjectShorthandTopLevelDeclaration + 1;
    IdentifierRole[IdentifierRole["ObjectShorthandFunctionScopedDeclaration"] = ObjectShorthandFunctionScopedDeclaration] = "ObjectShorthandFunctionScopedDeclaration";
    const ObjectShorthandBlockScopedDeclaration = ObjectShorthandFunctionScopedDeclaration + 1;
    IdentifierRole[IdentifierRole["ObjectShorthandBlockScopedDeclaration"] = ObjectShorthandBlockScopedDeclaration] = "ObjectShorthandBlockScopedDeclaration";
    const ObjectShorthand = ObjectShorthandBlockScopedDeclaration + 1;
    IdentifierRole[IdentifierRole["ObjectShorthand"] = ObjectShorthand] = "ObjectShorthand";
    // Any identifier bound in an import statement, e.g. both A and b from
    // `import A, * as b from 'A';`
    const ImportDeclaration = ObjectShorthand + 1;
    IdentifierRole[IdentifierRole["ImportDeclaration"] = ImportDeclaration] = "ImportDeclaration";
    const ObjectKey = ImportDeclaration + 1;
    IdentifierRole[IdentifierRole["ObjectKey"] = ObjectKey] = "ObjectKey";
    // The `foo` in `import {foo as bar} from "./abc";`.
    const ImportAccess = ObjectKey + 1;
    IdentifierRole[IdentifierRole["ImportAccess"] = ImportAccess] = "ImportAccess";
})(IdentifierRole || (IdentifierRole = {}));
var JSXRole;
(function(JSXRole) {
    // The element is self-closing or has a body that resolves to empty. We
    // shouldn't emit children at all in this case.
    const NoChildren = 0;
    JSXRole[JSXRole["NoChildren"] = NoChildren] = "NoChildren";
    // The element has a single explicit child, which might still be an arbitrary
    // expression like an array. We should emit that expression as the children.
    const OneChild = NoChildren + 1;
    JSXRole[JSXRole["OneChild"] = OneChild] = "OneChild";
    // The element has at least two explicitly-specified children or has spread
    // children, so child positions are assumed to be "static". We should wrap
    // these children in an array.
    const StaticChildren = OneChild + 1;
    JSXRole[JSXRole["StaticChildren"] = StaticChildren] = "StaticChildren";
    // The element has a prop named "key" after a prop spread, so we should fall
    // back to the createElement function.
    const KeyAfterPropSpread = StaticChildren + 1;
    JSXRole[JSXRole["KeyAfterPropSpread"] = KeyAfterPropSpread] = "KeyAfterPropSpread";
})(JSXRole || (JSXRole = {}));
function isDeclaration(token) {
    const role = token.identifierRole;
    return role === IdentifierRole.TopLevelDeclaration || role === IdentifierRole.FunctionScopedDeclaration || role === IdentifierRole.BlockScopedDeclaration || role === IdentifierRole.ObjectShorthandTopLevelDeclaration || role === IdentifierRole.ObjectShorthandFunctionScopedDeclaration || role === IdentifierRole.ObjectShorthandBlockScopedDeclaration;
}
function isNonTopLevelDeclaration(token) {
    const role = token.identifierRole;
    return role === IdentifierRole.FunctionScopedDeclaration || role === IdentifierRole.BlockScopedDeclaration || role === IdentifierRole.ObjectShorthandFunctionScopedDeclaration || role === IdentifierRole.ObjectShorthandBlockScopedDeclaration;
}
function isTopLevelDeclaration(token) {
    const role = token.identifierRole;
    return role === IdentifierRole.TopLevelDeclaration || role === IdentifierRole.ObjectShorthandTopLevelDeclaration || role === IdentifierRole.ImportDeclaration;
}
function isBlockScopedDeclaration(token) {
    const role = token.identifierRole;
    // Treat top-level declarations as block scope since the distinction doesn't matter here.
    return role === IdentifierRole.TopLevelDeclaration || role === IdentifierRole.BlockScopedDeclaration || role === IdentifierRole.ObjectShorthandTopLevelDeclaration || role === IdentifierRole.ObjectShorthandBlockScopedDeclaration;
}
function isFunctionScopedDeclaration(token) {
    const role = token.identifierRole;
    return role === IdentifierRole.FunctionScopedDeclaration || role === IdentifierRole.ObjectShorthandFunctionScopedDeclaration;
}
function isObjectShorthandDeclaration(token) {
    return token.identifierRole === IdentifierRole.ObjectShorthandTopLevelDeclaration || token.identifierRole === IdentifierRole.ObjectShorthandBlockScopedDeclaration || token.identifierRole === IdentifierRole.ObjectShorthandFunctionScopedDeclaration;
}
class Token {
    constructor(){
        this.type = _base.state.type;
        this.contextualKeyword = _base.state.contextualKeyword;
        this.start = _base.state.start;
        this.end = _base.state.end;
        this.scopeDepth = _base.state.scopeDepth;
        this.isType = _base.state.isType;
        this.identifierRole = null;
        this.jsxRole = null;
        this.shadowsGlobal = false;
        this.isAsyncOperation = false;
        this.contextId = null;
        this.rhsEndIndex = null;
        this.isExpression = false;
        this.numNullishCoalesceStarts = 0;
        this.numNullishCoalesceEnds = 0;
        this.isOptionalChainStart = false;
        this.isOptionalChainEnd = false;
        this.subscriptStartIndex = null;
        this.nullishStartIndex = null;
    }
}
function next() {
    _base.state.tokens.push(new Token());
    nextToken();
}
function nextTemplateToken() {
    _base.state.tokens.push(new Token());
    _base.state.start = _base.state.pos;
    readTmplToken();
}
function retokenizeSlashAsRegex() {
    if (_base.state.type === _types.TokenType.assign) --_base.state.pos;
    readRegexp();
}
function pushTypeContext(existingTokensInType) {
    for(let i = _base.state.tokens.length - existingTokensInType; i < _base.state.tokens.length; i++)_base.state.tokens[i].isType = true;
    const oldIsType = _base.state.isType;
    _base.state.isType = true;
    return oldIsType;
}
function popTypeContext(oldIsType) {
    _base.state.isType = oldIsType;
}
function eat(type) {
    if (match(type)) {
        next();
        return true;
    } else return false;
}
function eatTypeToken(tokenType) {
    const oldIsType = _base.state.isType;
    _base.state.isType = true;
    eat(tokenType);
    _base.state.isType = oldIsType;
}
function match(type) {
    return _base.state.type === type;
}
function lookaheadType() {
    const snapshot = _base.state.snapshot();
    next();
    const type = _base.state.type;
    _base.state.restoreFromSnapshot(snapshot);
    return type;
}
class TypeAndKeyword {
    constructor(type, contextualKeyword){
        this.type = type;
        this.contextualKeyword = contextualKeyword;
    }
}
function lookaheadTypeAndKeyword() {
    const snapshot = _base.state.snapshot();
    next();
    const type = _base.state.type;
    const contextualKeyword = _base.state.contextualKeyword;
    _base.state.restoreFromSnapshot(snapshot);
    return new TypeAndKeyword(type, contextualKeyword);
}
function nextTokenStart() {
    return nextTokenStartSince(_base.state.pos);
}
function nextTokenStartSince(pos) {
    _whitespace.skipWhiteSpace.lastIndex = pos;
    const skip = _whitespace.skipWhiteSpace.exec(_base.input);
    return pos + skip[0].length;
}
function lookaheadCharCode() {
    return _base.input.charCodeAt(nextTokenStart());
}
function nextToken() {
    skipSpace();
    _base.state.start = _base.state.pos;
    if (_base.state.pos >= _base.input.length) {
        const tokens = _base.state.tokens;
        // We normally run past the end a bit, but if we're way past the end, avoid an infinite loop.
        // Also check the token positions rather than the types since sometimes we rewrite the token
        // type to something else.
        if (tokens.length >= 2 && tokens[tokens.length - 1].start >= _base.input.length && tokens[tokens.length - 2].start >= _base.input.length) (0, _util.unexpected)("Unexpectedly reached the end of input.");
        finishToken(_types.TokenType.eof);
        return;
    }
    readToken(_base.input.charCodeAt(_base.state.pos));
}
function readToken(code) {
    // Identifier or keyword. '\uXXXX' sequences are allowed in
    // identifiers, so '\' also dispatches to that.
    if (_identifier.IS_IDENTIFIER_START[code] || code === _charcodes.charCodes.backslash || code === _charcodes.charCodes.atSign && _base.input.charCodeAt(_base.state.pos + 1) === _charcodes.charCodes.atSign) (0, _readWord.default)();
    else getTokenFromCode(code);
}
function skipBlockComment() {
    while(_base.input.charCodeAt(_base.state.pos) !== _charcodes.charCodes.asterisk || _base.input.charCodeAt(_base.state.pos + 1) !== _charcodes.charCodes.slash){
        _base.state.pos++;
        if (_base.state.pos > _base.input.length) {
            (0, _util.unexpected)("Unterminated comment", _base.state.pos - 2);
            return;
        }
    }
    _base.state.pos += 2;
}
function skipLineComment(startSkip) {
    let ch = _base.input.charCodeAt(_base.state.pos += startSkip);
    if (_base.state.pos < _base.input.length) while(ch !== _charcodes.charCodes.lineFeed && ch !== _charcodes.charCodes.carriageReturn && ch !== _charcodes.charCodes.lineSeparator && ch !== _charcodes.charCodes.paragraphSeparator && ++_base.state.pos < _base.input.length)ch = _base.input.charCodeAt(_base.state.pos);
}
function skipSpace() {
    while(_base.state.pos < _base.input.length){
        const ch = _base.input.charCodeAt(_base.state.pos);
        switch(ch){
            case _charcodes.charCodes.carriageReturn:
                if (_base.input.charCodeAt(_base.state.pos + 1) === _charcodes.charCodes.lineFeed) ++_base.state.pos;
            case _charcodes.charCodes.lineFeed:
            case _charcodes.charCodes.lineSeparator:
            case _charcodes.charCodes.paragraphSeparator:
                ++_base.state.pos;
                break;
            case _charcodes.charCodes.slash:
                switch(_base.input.charCodeAt(_base.state.pos + 1)){
                    case _charcodes.charCodes.asterisk:
                        _base.state.pos += 2;
                        skipBlockComment();
                        break;
                    case _charcodes.charCodes.slash:
                        skipLineComment(2);
                        break;
                    default:
                        return;
                }
                break;
            default:
                if (_whitespace.IS_WHITESPACE[ch]) ++_base.state.pos;
                else return;
        }
    }
}
function finishToken(type, contextualKeyword = _keywords.ContextualKeyword.NONE) {
    _base.state.end = _base.state.pos;
    _base.state.type = type;
    _base.state.contextualKeyword = contextualKeyword;
}
// ### Token reading
// This is the function that is called to fetch the next token. It
// is somewhat obscure, because it works in character codes rather
// than characters, and because operator parsing has been inlined
// into it.
//
// All in the name of speed.
function readToken_dot() {
    const nextChar = _base.input.charCodeAt(_base.state.pos + 1);
    if (nextChar >= _charcodes.charCodes.digit0 && nextChar <= _charcodes.charCodes.digit9) {
        readNumber(true);
        return;
    }
    if (nextChar === _charcodes.charCodes.dot && _base.input.charCodeAt(_base.state.pos + 2) === _charcodes.charCodes.dot) {
        _base.state.pos += 3;
        finishToken(_types.TokenType.ellipsis);
    } else {
        ++_base.state.pos;
        finishToken(_types.TokenType.dot);
    }
}
function readToken_slash() {
    const nextChar = _base.input.charCodeAt(_base.state.pos + 1);
    if (nextChar === _charcodes.charCodes.equalsTo) finishOp(_types.TokenType.assign, 2);
    else finishOp(_types.TokenType.slash, 1);
}
function readToken_mult_modulo(code) {
    // '%*'
    let tokenType = code === _charcodes.charCodes.asterisk ? _types.TokenType.star : _types.TokenType.modulo;
    let width = 1;
    let nextChar = _base.input.charCodeAt(_base.state.pos + 1);
    // Exponentiation operator **
    if (code === _charcodes.charCodes.asterisk && nextChar === _charcodes.charCodes.asterisk) {
        width++;
        nextChar = _base.input.charCodeAt(_base.state.pos + 2);
        tokenType = _types.TokenType.exponent;
    }
    // Match *= or %=, disallowing *=> which can be valid in flow.
    if (nextChar === _charcodes.charCodes.equalsTo && _base.input.charCodeAt(_base.state.pos + 2) !== _charcodes.charCodes.greaterThan) {
        width++;
        tokenType = _types.TokenType.assign;
    }
    finishOp(tokenType, width);
}
function readToken_pipe_amp(code) {
    // '|&'
    const nextChar = _base.input.charCodeAt(_base.state.pos + 1);
    if (nextChar === code) {
        if (_base.input.charCodeAt(_base.state.pos + 2) === _charcodes.charCodes.equalsTo) // ||= or &&=
        finishOp(_types.TokenType.assign, 3);
        else // || or &&
        finishOp(code === _charcodes.charCodes.verticalBar ? _types.TokenType.logicalOR : _types.TokenType.logicalAND, 2);
        return;
    }
    if (code === _charcodes.charCodes.verticalBar) {
        // '|>'
        if (nextChar === _charcodes.charCodes.greaterThan) {
            finishOp(_types.TokenType.pipeline, 2);
            return;
        } else if (nextChar === _charcodes.charCodes.rightCurlyBrace && _base.isFlowEnabled) {
            // '|}'
            finishOp(_types.TokenType.braceBarR, 2);
            return;
        }
    }
    if (nextChar === _charcodes.charCodes.equalsTo) {
        finishOp(_types.TokenType.assign, 2);
        return;
    }
    finishOp(code === _charcodes.charCodes.verticalBar ? _types.TokenType.bitwiseOR : _types.TokenType.bitwiseAND, 1);
}
function readToken_caret() {
    // '^'
    const nextChar = _base.input.charCodeAt(_base.state.pos + 1);
    if (nextChar === _charcodes.charCodes.equalsTo) finishOp(_types.TokenType.assign, 2);
    else finishOp(_types.TokenType.bitwiseXOR, 1);
}
function readToken_plus_min(code) {
    // '+-'
    const nextChar = _base.input.charCodeAt(_base.state.pos + 1);
    if (nextChar === code) {
        // Tentatively call this a prefix operator, but it might be changed to postfix later.
        finishOp(_types.TokenType.preIncDec, 2);
        return;
    }
    if (nextChar === _charcodes.charCodes.equalsTo) finishOp(_types.TokenType.assign, 2);
    else if (code === _charcodes.charCodes.plusSign) finishOp(_types.TokenType.plus, 1);
    else finishOp(_types.TokenType.minus, 1);
}
function readToken_lt() {
    const nextChar = _base.input.charCodeAt(_base.state.pos + 1);
    if (nextChar === _charcodes.charCodes.lessThan) {
        if (_base.input.charCodeAt(_base.state.pos + 2) === _charcodes.charCodes.equalsTo) {
            finishOp(_types.TokenType.assign, 3);
            return;
        }
        // We see <<, but need to be really careful about whether to treat it as a
        // true left-shift or as two < tokens.
        if (_base.state.isType) // Within a type, << might come up in a snippet like `Array<<T>() => void>`,
        // so treat it as two < tokens. Importantly, this should only override <<
        // rather than other tokens like <= . If we treated <= as < in a type
        // context, then the snippet `a as T <= 1` would incorrectly start parsing
        // a type argument on T. We don't need to worry about `a as T << 1`
        // because TypeScript disallows that syntax.
        finishOp(_types.TokenType.lessThan, 1);
        else // Outside a type, this might be a true left-shift operator, or it might
        // still be two open-type-arg tokens, such as in `f<<T>() => void>()`. We
        // look at the token while considering the `f`, so we don't yet know that
        // we're in a type context. In this case, we initially tokenize as a
        // left-shift and correct after-the-fact as necessary in
        // tsParseTypeArgumentsWithPossibleBitshift .
        finishOp(_types.TokenType.bitShiftL, 2);
        return;
    }
    if (nextChar === _charcodes.charCodes.equalsTo) // <=
    finishOp(_types.TokenType.relationalOrEqual, 2);
    else finishOp(_types.TokenType.lessThan, 1);
}
function readToken_gt() {
    if (_base.state.isType) {
        // Avoid right-shift for things like `Array<Array<string>>` and
        // greater-than-or-equal for things like `const a: Array<number>=[];`.
        finishOp(_types.TokenType.greaterThan, 1);
        return;
    }
    const nextChar = _base.input.charCodeAt(_base.state.pos + 1);
    if (nextChar === _charcodes.charCodes.greaterThan) {
        const size = _base.input.charCodeAt(_base.state.pos + 2) === _charcodes.charCodes.greaterThan ? 3 : 2;
        if (_base.input.charCodeAt(_base.state.pos + size) === _charcodes.charCodes.equalsTo) {
            finishOp(_types.TokenType.assign, size + 1);
            return;
        }
        finishOp(_types.TokenType.bitShiftR, size);
        return;
    }
    if (nextChar === _charcodes.charCodes.equalsTo) // >=
    finishOp(_types.TokenType.relationalOrEqual, 2);
    else finishOp(_types.TokenType.greaterThan, 1);
}
function rescan_gt() {
    if (_base.state.type === _types.TokenType.greaterThan) {
        _base.state.pos -= 1;
        readToken_gt();
    }
}
function readToken_eq_excl(code) {
    // '=!'
    const nextChar = _base.input.charCodeAt(_base.state.pos + 1);
    if (nextChar === _charcodes.charCodes.equalsTo) {
        finishOp(_types.TokenType.equality, _base.input.charCodeAt(_base.state.pos + 2) === _charcodes.charCodes.equalsTo ? 3 : 2);
        return;
    }
    if (code === _charcodes.charCodes.equalsTo && nextChar === _charcodes.charCodes.greaterThan) {
        // '=>'
        _base.state.pos += 2;
        finishToken(_types.TokenType.arrow);
        return;
    }
    finishOp(code === _charcodes.charCodes.equalsTo ? _types.TokenType.eq : _types.TokenType.bang, 1);
}
function readToken_question() {
    // '?'
    const nextChar = _base.input.charCodeAt(_base.state.pos + 1);
    const nextChar2 = _base.input.charCodeAt(_base.state.pos + 2);
    if (nextChar === _charcodes.charCodes.questionMark && // In Flow (but not TypeScript), ??string is a valid type that should be
    // tokenized as two individual ? tokens.
    !(_base.isFlowEnabled && _base.state.isType)) {
        if (nextChar2 === _charcodes.charCodes.equalsTo) // '??='
        finishOp(_types.TokenType.assign, 3);
        else // '??'
        finishOp(_types.TokenType.nullishCoalescing, 2);
    } else if (nextChar === _charcodes.charCodes.dot && !(nextChar2 >= _charcodes.charCodes.digit0 && nextChar2 <= _charcodes.charCodes.digit9)) {
        // '.' not followed by a number
        _base.state.pos += 2;
        finishToken(_types.TokenType.questionDot);
    } else {
        ++_base.state.pos;
        finishToken(_types.TokenType.question);
    }
}
function getTokenFromCode(code) {
    switch(code){
        case _charcodes.charCodes.numberSign:
            ++_base.state.pos;
            finishToken(_types.TokenType.hash);
            return;
        // The interpretation of a dot depends on whether it is followed
        // by a digit or another two dots.
        case _charcodes.charCodes.dot:
            readToken_dot();
            return;
        // Punctuation tokens.
        case _charcodes.charCodes.leftParenthesis:
            ++_base.state.pos;
            finishToken(_types.TokenType.parenL);
            return;
        case _charcodes.charCodes.rightParenthesis:
            ++_base.state.pos;
            finishToken(_types.TokenType.parenR);
            return;
        case _charcodes.charCodes.semicolon:
            ++_base.state.pos;
            finishToken(_types.TokenType.semi);
            return;
        case _charcodes.charCodes.comma:
            ++_base.state.pos;
            finishToken(_types.TokenType.comma);
            return;
        case _charcodes.charCodes.leftSquareBracket:
            ++_base.state.pos;
            finishToken(_types.TokenType.bracketL);
            return;
        case _charcodes.charCodes.rightSquareBracket:
            ++_base.state.pos;
            finishToken(_types.TokenType.bracketR);
            return;
        case _charcodes.charCodes.leftCurlyBrace:
            if (_base.isFlowEnabled && _base.input.charCodeAt(_base.state.pos + 1) === _charcodes.charCodes.verticalBar) finishOp(_types.TokenType.braceBarL, 2);
            else {
                ++_base.state.pos;
                finishToken(_types.TokenType.braceL);
            }
            return;
        case _charcodes.charCodes.rightCurlyBrace:
            ++_base.state.pos;
            finishToken(_types.TokenType.braceR);
            return;
        case _charcodes.charCodes.colon:
            if (_base.input.charCodeAt(_base.state.pos + 1) === _charcodes.charCodes.colon) finishOp(_types.TokenType.doubleColon, 2);
            else {
                ++_base.state.pos;
                finishToken(_types.TokenType.colon);
            }
            return;
        case _charcodes.charCodes.questionMark:
            readToken_question();
            return;
        case _charcodes.charCodes.atSign:
            ++_base.state.pos;
            finishToken(_types.TokenType.at);
            return;
        case _charcodes.charCodes.graveAccent:
            ++_base.state.pos;
            finishToken(_types.TokenType.backQuote);
            return;
        case _charcodes.charCodes.digit0:
            {
                const nextChar = _base.input.charCodeAt(_base.state.pos + 1);
                // '0x', '0X', '0o', '0O', '0b', '0B'
                if (nextChar === _charcodes.charCodes.lowercaseX || nextChar === _charcodes.charCodes.uppercaseX || nextChar === _charcodes.charCodes.lowercaseO || nextChar === _charcodes.charCodes.uppercaseO || nextChar === _charcodes.charCodes.lowercaseB || nextChar === _charcodes.charCodes.uppercaseB) {
                    readRadixNumber();
                    return;
                }
            }
        // Anything else beginning with a digit is an integer, octal
        // number, or float.
        case _charcodes.charCodes.digit1:
        case _charcodes.charCodes.digit2:
        case _charcodes.charCodes.digit3:
        case _charcodes.charCodes.digit4:
        case _charcodes.charCodes.digit5:
        case _charcodes.charCodes.digit6:
        case _charcodes.charCodes.digit7:
        case _charcodes.charCodes.digit8:
        case _charcodes.charCodes.digit9:
            readNumber(false);
            return;
        // Quotes produce strings.
        case _charcodes.charCodes.quotationMark:
        case _charcodes.charCodes.apostrophe:
            readString(code);
            return;
        // Operators are parsed inline in tiny state machines. '=' (charCodes.equalsTo) is
        // often referred to. `finishOp` simply skips the amount of
        // characters it is given as second argument, and returns a token
        // of the type given by its first argument.
        case _charcodes.charCodes.slash:
            readToken_slash();
            return;
        case _charcodes.charCodes.percentSign:
        case _charcodes.charCodes.asterisk:
            readToken_mult_modulo(code);
            return;
        case _charcodes.charCodes.verticalBar:
        case _charcodes.charCodes.ampersand:
            readToken_pipe_amp(code);
            return;
        case _charcodes.charCodes.caret:
            readToken_caret();
            return;
        case _charcodes.charCodes.plusSign:
        case _charcodes.charCodes.dash:
            readToken_plus_min(code);
            return;
        case _charcodes.charCodes.lessThan:
            readToken_lt();
            return;
        case _charcodes.charCodes.greaterThan:
            readToken_gt();
            return;
        case _charcodes.charCodes.equalsTo:
        case _charcodes.charCodes.exclamationMark:
            readToken_eq_excl(code);
            return;
        case _charcodes.charCodes.tilde:
            finishOp(_types.TokenType.tilde, 1);
            return;
        default:
            break;
    }
    (0, _util.unexpected)(`Unexpected character '${String.fromCharCode(code)}'`, _base.state.pos);
}
function finishOp(type, size) {
    _base.state.pos += size;
    finishToken(type);
}
function readRegexp() {
    const start = _base.state.pos;
    let escaped = false;
    let inClass = false;
    for(;;){
        if (_base.state.pos >= _base.input.length) {
            (0, _util.unexpected)("Unterminated regular expression", start);
            return;
        }
        const code = _base.input.charCodeAt(_base.state.pos);
        if (escaped) escaped = false;
        else {
            if (code === _charcodes.charCodes.leftSquareBracket) inClass = true;
            else if (code === _charcodes.charCodes.rightSquareBracket && inClass) inClass = false;
            else if (code === _charcodes.charCodes.slash && !inClass) break;
            escaped = code === _charcodes.charCodes.backslash;
        }
        ++_base.state.pos;
    }
    ++_base.state.pos;
    // Need to use `skipWord` because '\uXXXX' sequences are allowed here (don't ask).
    skipWord();
    finishToken(_types.TokenType.regexp);
}
/**
 * Read a decimal integer. Note that this can't be unified with the similar code
 * in readRadixNumber (which also handles hex digits) because "e" needs to be
 * the end of the integer so that we can properly handle scientific notation.
 */ function readInt() {
    while(true){
        const code = _base.input.charCodeAt(_base.state.pos);
        if (code >= _charcodes.charCodes.digit0 && code <= _charcodes.charCodes.digit9 || code === _charcodes.charCodes.underscore) _base.state.pos++;
        else break;
    }
}
function readRadixNumber() {
    _base.state.pos += 2; // 0x
    // Walk to the end of the number, allowing hex digits.
    while(true){
        const code = _base.input.charCodeAt(_base.state.pos);
        if (code >= _charcodes.charCodes.digit0 && code <= _charcodes.charCodes.digit9 || code >= _charcodes.charCodes.lowercaseA && code <= _charcodes.charCodes.lowercaseF || code >= _charcodes.charCodes.uppercaseA && code <= _charcodes.charCodes.uppercaseF || code === _charcodes.charCodes.underscore) _base.state.pos++;
        else break;
    }
    const nextChar = _base.input.charCodeAt(_base.state.pos);
    if (nextChar === _charcodes.charCodes.lowercaseN) {
        ++_base.state.pos;
        finishToken(_types.TokenType.bigint);
    } else finishToken(_types.TokenType.num);
}
// Read an integer, octal integer, or floating-point number.
function readNumber(startsWithDot) {
    let isBigInt = false;
    let isDecimal = false;
    if (!startsWithDot) readInt();
    let nextChar = _base.input.charCodeAt(_base.state.pos);
    if (nextChar === _charcodes.charCodes.dot) {
        ++_base.state.pos;
        readInt();
        nextChar = _base.input.charCodeAt(_base.state.pos);
    }
    if (nextChar === _charcodes.charCodes.uppercaseE || nextChar === _charcodes.charCodes.lowercaseE) {
        nextChar = _base.input.charCodeAt(++_base.state.pos);
        if (nextChar === _charcodes.charCodes.plusSign || nextChar === _charcodes.charCodes.dash) ++_base.state.pos;
        readInt();
        nextChar = _base.input.charCodeAt(_base.state.pos);
    }
    if (nextChar === _charcodes.charCodes.lowercaseN) {
        ++_base.state.pos;
        isBigInt = true;
    } else if (nextChar === _charcodes.charCodes.lowercaseM) {
        ++_base.state.pos;
        isDecimal = true;
    }
    if (isBigInt) {
        finishToken(_types.TokenType.bigint);
        return;
    }
    if (isDecimal) {
        finishToken(_types.TokenType.decimal);
        return;
    }
    finishToken(_types.TokenType.num);
}
function readString(quote) {
    _base.state.pos++;
    for(;;){
        if (_base.state.pos >= _base.input.length) {
            (0, _util.unexpected)("Unterminated string constant");
            return;
        }
        const ch = _base.input.charCodeAt(_base.state.pos);
        if (ch === _charcodes.charCodes.backslash) _base.state.pos++;
        else if (ch === quote) break;
        _base.state.pos++;
    }
    _base.state.pos++;
    finishToken(_types.TokenType.string);
}
// Reads template string tokens.
function readTmplToken() {
    for(;;){
        if (_base.state.pos >= _base.input.length) {
            (0, _util.unexpected)("Unterminated template");
            return;
        }
        const ch = _base.input.charCodeAt(_base.state.pos);
        if (ch === _charcodes.charCodes.graveAccent || ch === _charcodes.charCodes.dollarSign && _base.input.charCodeAt(_base.state.pos + 1) === _charcodes.charCodes.leftCurlyBrace) {
            if (_base.state.pos === _base.state.start && match(_types.TokenType.template)) {
                if (ch === _charcodes.charCodes.dollarSign) {
                    _base.state.pos += 2;
                    finishToken(_types.TokenType.dollarBraceL);
                    return;
                } else {
                    ++_base.state.pos;
                    finishToken(_types.TokenType.backQuote);
                    return;
                }
            }
            finishToken(_types.TokenType.template);
            return;
        }
        if (ch === _charcodes.charCodes.backslash) _base.state.pos++;
        _base.state.pos++;
    }
}
function skipWord() {
    while(_base.state.pos < _base.input.length){
        const ch = _base.input.charCodeAt(_base.state.pos);
        if (_identifier.IS_IDENTIFIER_CHAR[ch]) _base.state.pos++;
        else if (ch === _charcodes.charCodes.backslash) {
            // \u
            _base.state.pos += 2;
            if (_base.input.charCodeAt(_base.state.pos) === _charcodes.charCodes.leftCurlyBrace) {
                while(_base.state.pos < _base.input.length && _base.input.charCodeAt(_base.state.pos) !== _charcodes.charCodes.rightCurlyBrace)_base.state.pos++;
                _base.state.pos++;
            }
        } else break;
    }
}

},
"node_modules/sucrase/dist/esm/parser/tokenizer/keywords.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "ContextualKeyword", {
    enumerable: true,
    get: function() {
        return ContextualKeyword;
    }
});
var ContextualKeyword;
(function(ContextualKeyword) {
    const NONE = 0;
    ContextualKeyword[ContextualKeyword["NONE"] = NONE] = "NONE";
    const _abstract = NONE + 1;
    ContextualKeyword[ContextualKeyword["_abstract"] = _abstract] = "_abstract";
    const _accessor = _abstract + 1;
    ContextualKeyword[ContextualKeyword["_accessor"] = _accessor] = "_accessor";
    const _as = _accessor + 1;
    ContextualKeyword[ContextualKeyword["_as"] = _as] = "_as";
    const _assert = _as + 1;
    ContextualKeyword[ContextualKeyword["_assert"] = _assert] = "_assert";
    const _asserts = _assert + 1;
    ContextualKeyword[ContextualKeyword["_asserts"] = _asserts] = "_asserts";
    const _async = _asserts + 1;
    ContextualKeyword[ContextualKeyword["_async"] = _async] = "_async";
    const _await = _async + 1;
    ContextualKeyword[ContextualKeyword["_await"] = _await] = "_await";
    const _checks = _await + 1;
    ContextualKeyword[ContextualKeyword["_checks"] = _checks] = "_checks";
    const _constructor = _checks + 1;
    ContextualKeyword[ContextualKeyword["_constructor"] = _constructor] = "_constructor";
    const _declare = _constructor + 1;
    ContextualKeyword[ContextualKeyword["_declare"] = _declare] = "_declare";
    const _enum = _declare + 1;
    ContextualKeyword[ContextualKeyword["_enum"] = _enum] = "_enum";
    const _exports = _enum + 1;
    ContextualKeyword[ContextualKeyword["_exports"] = _exports] = "_exports";
    const _from = _exports + 1;
    ContextualKeyword[ContextualKeyword["_from"] = _from] = "_from";
    const _get = _from + 1;
    ContextualKeyword[ContextualKeyword["_get"] = _get] = "_get";
    const _global = _get + 1;
    ContextualKeyword[ContextualKeyword["_global"] = _global] = "_global";
    const _implements = _global + 1;
    ContextualKeyword[ContextualKeyword["_implements"] = _implements] = "_implements";
    const _infer = _implements + 1;
    ContextualKeyword[ContextualKeyword["_infer"] = _infer] = "_infer";
    const _interface = _infer + 1;
    ContextualKeyword[ContextualKeyword["_interface"] = _interface] = "_interface";
    const _is = _interface + 1;
    ContextualKeyword[ContextualKeyword["_is"] = _is] = "_is";
    const _keyof = _is + 1;
    ContextualKeyword[ContextualKeyword["_keyof"] = _keyof] = "_keyof";
    const _mixins = _keyof + 1;
    ContextualKeyword[ContextualKeyword["_mixins"] = _mixins] = "_mixins";
    const _module = _mixins + 1;
    ContextualKeyword[ContextualKeyword["_module"] = _module] = "_module";
    const _namespace = _module + 1;
    ContextualKeyword[ContextualKeyword["_namespace"] = _namespace] = "_namespace";
    const _of = _namespace + 1;
    ContextualKeyword[ContextualKeyword["_of"] = _of] = "_of";
    const _opaque = _of + 1;
    ContextualKeyword[ContextualKeyword["_opaque"] = _opaque] = "_opaque";
    const _out = _opaque + 1;
    ContextualKeyword[ContextualKeyword["_out"] = _out] = "_out";
    const _override = _out + 1;
    ContextualKeyword[ContextualKeyword["_override"] = _override] = "_override";
    const _private = _override + 1;
    ContextualKeyword[ContextualKeyword["_private"] = _private] = "_private";
    const _protected = _private + 1;
    ContextualKeyword[ContextualKeyword["_protected"] = _protected] = "_protected";
    const _proto = _protected + 1;
    ContextualKeyword[ContextualKeyword["_proto"] = _proto] = "_proto";
    const _public = _proto + 1;
    ContextualKeyword[ContextualKeyword["_public"] = _public] = "_public";
    const _readonly = _public + 1;
    ContextualKeyword[ContextualKeyword["_readonly"] = _readonly] = "_readonly";
    const _require = _readonly + 1;
    ContextualKeyword[ContextualKeyword["_require"] = _require] = "_require";
    const _satisfies = _require + 1;
    ContextualKeyword[ContextualKeyword["_satisfies"] = _satisfies] = "_satisfies";
    const _set = _satisfies + 1;
    ContextualKeyword[ContextualKeyword["_set"] = _set] = "_set";
    const _static = _set + 1;
    ContextualKeyword[ContextualKeyword["_static"] = _static] = "_static";
    const _symbol = _static + 1;
    ContextualKeyword[ContextualKeyword["_symbol"] = _symbol] = "_symbol";
    const _type = _symbol + 1;
    ContextualKeyword[ContextualKeyword["_type"] = _type] = "_type";
    const _unique = _type + 1;
    ContextualKeyword[ContextualKeyword["_unique"] = _unique] = "_unique";
    const _using = _unique + 1;
    ContextualKeyword[ContextualKeyword["_using"] = _using] = "_using";
})(ContextualKeyword || (ContextualKeyword = {}));

},
"node_modules/sucrase/dist/esm/parser/tokenizer/readWord.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, /**
 * Read an identifier, producing either a name token or matching on one of the existing keywords.
 * For performance, we pre-generate big decision tree that we traverse. Each node represents a
 * prefix and has 27 values, where the first value is the token or contextual token, if any (-1 if
 * not), and the other 26 values are the transitions to other nodes, or -1 to stop.
 */ "default", {
    enumerable: true,
    get: function() {
        return readWord;
    }
});
var _base = __mako_require__("node_modules/sucrase/dist/esm/parser/traverser/base.js");
var _charcodes = __mako_require__("node_modules/sucrase/dist/esm/parser/util/charcodes.js");
var _identifier = __mako_require__("node_modules/sucrase/dist/esm/parser/util/identifier.js");
var _index = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/index.js");
var _readWordTree = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/readWordTree.js");
var _types = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/types.js");
function readWord() {
    let treePos = 0;
    let code = 0;
    let pos = _base.state.pos;
    while(pos < _base.input.length){
        code = _base.input.charCodeAt(pos);
        if (code < _charcodes.charCodes.lowercaseA || code > _charcodes.charCodes.lowercaseZ) break;
        const next = _readWordTree.READ_WORD_TREE[treePos + (code - _charcodes.charCodes.lowercaseA) + 1];
        if (next === -1) break;
        else {
            treePos = next;
            pos++;
        }
    }
    const keywordValue = _readWordTree.READ_WORD_TREE[treePos];
    if (keywordValue > -1 && !_identifier.IS_IDENTIFIER_CHAR[code]) {
        _base.state.pos = pos;
        if (keywordValue & 1) (0, _index.finishToken)(keywordValue >>> 1);
        else (0, _index.finishToken)(_types.TokenType.name, keywordValue >>> 1);
        return;
    }
    while(pos < _base.input.length){
        const ch = _base.input.charCodeAt(pos);
        if (_identifier.IS_IDENTIFIER_CHAR[ch]) pos++;
        else if (ch === _charcodes.charCodes.backslash) {
            // \u
            pos += 2;
            if (_base.input.charCodeAt(pos) === _charcodes.charCodes.leftCurlyBrace) {
                while(pos < _base.input.length && _base.input.charCodeAt(pos) !== _charcodes.charCodes.rightCurlyBrace)pos++;
                pos++;
            }
        } else if (ch === _charcodes.charCodes.atSign && _base.input.charCodeAt(pos + 1) === _charcodes.charCodes.atSign) pos += 2;
        else break;
    }
    _base.state.pos = pos;
    (0, _index.finishToken)(_types.TokenType.name);
}

},
"node_modules/sucrase/dist/esm/parser/tokenizer/readWordTree.js": function (module, exports, __mako_require__){
// Generated file, do not edit! Run "yarn generate" to re-generate this file.
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "READ_WORD_TREE", {
    enumerable: true,
    get: function() {
        return READ_WORD_TREE;
    }
});
var _keywords = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/keywords.js");
var _types = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/types.js");
const READ_WORD_TREE = new Int32Array([
    // ""
    -1,
    27,
    783,
    918,
    1755,
    2376,
    2862,
    3483,
    -1,
    3699,
    -1,
    4617,
    4752,
    4833,
    5130,
    5508,
    5940,
    -1,
    6480,
    6939,
    7749,
    8181,
    8451,
    8613,
    -1,
    8829,
    -1,
    // "a"
    -1,
    -1,
    54,
    243,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    432,
    -1,
    -1,
    -1,
    675,
    -1,
    -1,
    -1,
    // "ab"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    81,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "abs"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    108,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "abst"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    135,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "abstr"
    -1,
    162,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "abstra"
    -1,
    -1,
    -1,
    189,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "abstrac"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    216,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "abstract"
    _keywords.ContextualKeyword._abstract << 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "ac"
    -1,
    -1,
    -1,
    270,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "acc"
    -1,
    -1,
    -1,
    -1,
    -1,
    297,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "acce"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    324,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "acces"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    351,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "access"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    378,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "accesso"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    405,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "accessor"
    _keywords.ContextualKeyword._accessor << 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "as"
    _keywords.ContextualKeyword._as << 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    459,
    -1,
    -1,
    -1,
    -1,
    -1,
    594,
    -1,
    // "ass"
    -1,
    -1,
    -1,
    -1,
    -1,
    486,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "asse"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    513,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "asser"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    540,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "assert"
    _keywords.ContextualKeyword._assert << 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    567,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "asserts"
    _keywords.ContextualKeyword._asserts << 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "asy"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    621,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "asyn"
    -1,
    -1,
    -1,
    648,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "async"
    _keywords.ContextualKeyword._async << 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "aw"
    -1,
    702,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "awa"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    729,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "awai"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    756,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "await"
    _keywords.ContextualKeyword._await << 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "b"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    810,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "br"
    -1,
    -1,
    -1,
    -1,
    -1,
    837,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "bre"
    -1,
    864,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "brea"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    891,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "break"
    (_types.TokenType._break << 1) + 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "c"
    -1,
    945,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1107,
    -1,
    -1,
    -1,
    1242,
    -1,
    -1,
    1350,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "ca"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    972,
    1026,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "cas"
    -1,
    -1,
    -1,
    -1,
    -1,
    999,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "case"
    (_types.TokenType._case << 1) + 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "cat"
    -1,
    -1,
    -1,
    1053,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "catc"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1080,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "catch"
    (_types.TokenType._catch << 1) + 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "ch"
    -1,
    -1,
    -1,
    -1,
    -1,
    1134,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "che"
    -1,
    -1,
    -1,
    1161,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "chec"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1188,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "check"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1215,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "checks"
    _keywords.ContextualKeyword._checks << 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "cl"
    -1,
    1269,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "cla"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1296,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "clas"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1323,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "class"
    (_types.TokenType._class << 1) + 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "co"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1377,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "con"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1404,
    1620,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "cons"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1431,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "const"
    (_types.TokenType._const << 1) + 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1458,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "constr"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1485,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "constru"
    -1,
    -1,
    -1,
    1512,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "construc"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1539,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "construct"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1566,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "constructo"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1593,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "constructor"
    _keywords.ContextualKeyword._constructor << 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "cont"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1647,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "conti"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1674,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "contin"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1701,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "continu"
    -1,
    -1,
    -1,
    -1,
    -1,
    1728,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "continue"
    (_types.TokenType._continue << 1) + 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "d"
    -1,
    -1,
    -1,
    -1,
    -1,
    1782,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2349,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "de"
    -1,
    -1,
    1809,
    1971,
    -1,
    -1,
    2106,
    -1,
    -1,
    -1,
    -1,
    -1,
    2241,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "deb"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1836,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "debu"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1863,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "debug"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1890,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "debugg"
    -1,
    -1,
    -1,
    -1,
    -1,
    1917,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "debugge"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1944,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "debugger"
    (_types.TokenType._debugger << 1) + 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "dec"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1998,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "decl"
    -1,
    2025,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "decla"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2052,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "declar"
    -1,
    -1,
    -1,
    -1,
    -1,
    2079,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "declare"
    _keywords.ContextualKeyword._declare << 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "def"
    -1,
    2133,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "defa"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2160,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "defau"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2187,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "defaul"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2214,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "default"
    (_types.TokenType._default << 1) + 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "del"
    -1,
    -1,
    -1,
    -1,
    -1,
    2268,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "dele"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2295,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "delet"
    -1,
    -1,
    -1,
    -1,
    -1,
    2322,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "delete"
    (_types.TokenType._delete << 1) + 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "do"
    (_types.TokenType._do << 1) + 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "e"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2403,
    -1,
    2484,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2565,
    -1,
    -1,
    // "el"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2430,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "els"
    -1,
    -1,
    -1,
    -1,
    -1,
    2457,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "else"
    (_types.TokenType._else << 1) + 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "en"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2511,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "enu"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2538,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "enum"
    _keywords.ContextualKeyword._enum << 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "ex"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2592,
    -1,
    -1,
    -1,
    2727,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "exp"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2619,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "expo"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2646,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "expor"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2673,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "export"
    (_types.TokenType._export << 1) + 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2700,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "exports"
    _keywords.ContextualKeyword._exports << 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "ext"
    -1,
    -1,
    -1,
    -1,
    -1,
    2754,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "exte"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2781,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "exten"
    -1,
    -1,
    -1,
    -1,
    2808,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "extend"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2835,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "extends"
    (_types.TokenType._extends << 1) + 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "f"
    -1,
    2889,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2997,
    -1,
    -1,
    -1,
    -1,
    -1,
    3159,
    -1,
    -1,
    3213,
    -1,
    -1,
    3294,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "fa"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2916,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "fal"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    2943,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "fals"
    -1,
    -1,
    -1,
    -1,
    -1,
    2970,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "false"
    (_types.TokenType._false << 1) + 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "fi"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3024,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "fin"
    -1,
    3051,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "fina"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3078,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "final"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3105,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "finall"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3132,
    -1,
    // "finally"
    (_types.TokenType._finally << 1) + 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "fo"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3186,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "for"
    (_types.TokenType._for << 1) + 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "fr"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3240,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "fro"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3267,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "from"
    _keywords.ContextualKeyword._from << 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "fu"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3321,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "fun"
    -1,
    -1,
    -1,
    3348,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "func"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3375,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "funct"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3402,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "functi"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3429,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "functio"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3456,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "function"
    (_types.TokenType._function << 1) + 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "g"
    -1,
    -1,
    -1,
    -1,
    -1,
    3510,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3564,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "ge"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3537,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "get"
    _keywords.ContextualKeyword._get << 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "gl"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3591,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "glo"
    -1,
    -1,
    3618,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "glob"
    -1,
    3645,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "globa"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3672,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "global"
    _keywords.ContextualKeyword._global << 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "i"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3726,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3753,
    4077,
    -1,
    -1,
    -1,
    -1,
    4590,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "if"
    (_types.TokenType._if << 1) + 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "im"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3780,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "imp"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3807,
    -1,
    -1,
    3996,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "impl"
    -1,
    -1,
    -1,
    -1,
    -1,
    3834,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "imple"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3861,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "implem"
    -1,
    -1,
    -1,
    -1,
    -1,
    3888,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "impleme"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3915,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "implemen"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3942,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "implement"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    3969,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "implements"
    _keywords.ContextualKeyword._implements << 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "impo"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4023,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "impor"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4050,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "import"
    (_types.TokenType._import << 1) + 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "in"
    (_types.TokenType._in << 1) + 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4104,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4185,
    4401,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "inf"
    -1,
    -1,
    -1,
    -1,
    -1,
    4131,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "infe"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4158,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "infer"
    _keywords.ContextualKeyword._infer << 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "ins"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4212,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "inst"
    -1,
    4239,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "insta"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4266,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "instan"
    -1,
    -1,
    -1,
    4293,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "instanc"
    -1,
    -1,
    -1,
    -1,
    -1,
    4320,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "instance"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4347,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "instanceo"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4374,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "instanceof"
    (_types.TokenType._instanceof << 1) + 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "int"
    -1,
    -1,
    -1,
    -1,
    -1,
    4428,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "inte"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4455,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "inter"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4482,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "interf"
    -1,
    4509,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "interfa"
    -1,
    -1,
    -1,
    4536,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "interfac"
    -1,
    -1,
    -1,
    -1,
    -1,
    4563,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "interface"
    _keywords.ContextualKeyword._interface << 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "is"
    _keywords.ContextualKeyword._is << 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "k"
    -1,
    -1,
    -1,
    -1,
    -1,
    4644,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "ke"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4671,
    -1,
    // "key"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4698,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "keyo"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4725,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "keyof"
    _keywords.ContextualKeyword._keyof << 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "l"
    -1,
    -1,
    -1,
    -1,
    -1,
    4779,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "le"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4806,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "let"
    (_types.TokenType._let << 1) + 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "m"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4860,
    -1,
    -1,
    -1,
    -1,
    -1,
    4995,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "mi"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4887,
    -1,
    -1,
    // "mix"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4914,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "mixi"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4941,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "mixin"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    4968,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "mixins"
    _keywords.ContextualKeyword._mixins << 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "mo"
    -1,
    -1,
    -1,
    -1,
    5022,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "mod"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    5049,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "modu"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    5076,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "modul"
    -1,
    -1,
    -1,
    -1,
    -1,
    5103,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "module"
    _keywords.ContextualKeyword._module << 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "n"
    -1,
    5157,
    -1,
    -1,
    -1,
    5373,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    5427,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "na"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    5184,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "nam"
    -1,
    -1,
    -1,
    -1,
    -1,
    5211,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "name"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    5238,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "names"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    5265,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "namesp"
    -1,
    5292,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "namespa"
    -1,
    -1,
    -1,
    5319,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "namespac"
    -1,
    -1,
    -1,
    -1,
    -1,
    5346,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "namespace"
    _keywords.ContextualKeyword._namespace << 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "ne"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    5400,
    -1,
    -1,
    -1,
    // "new"
    (_types.TokenType._new << 1) + 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "nu"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    5454,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "nul"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    5481,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "null"
    (_types.TokenType._null << 1) + 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "o"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    5535,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    5562,
    -1,
    -1,
    -1,
    -1,
    5697,
    5751,
    -1,
    -1,
    -1,
    -1,
    // "of"
    _keywords.ContextualKeyword._of << 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "op"
    -1,
    5589,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "opa"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    5616,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "opaq"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    5643,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "opaqu"
    -1,
    -1,
    -1,
    -1,
    -1,
    5670,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "opaque"
    _keywords.ContextualKeyword._opaque << 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "ou"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    5724,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "out"
    _keywords.ContextualKeyword._out << 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "ov"
    -1,
    -1,
    -1,
    -1,
    -1,
    5778,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "ove"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    5805,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "over"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    5832,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "overr"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    5859,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "overri"
    -1,
    -1,
    -1,
    -1,
    5886,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "overrid"
    -1,
    -1,
    -1,
    -1,
    -1,
    5913,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "override"
    _keywords.ContextualKeyword._override << 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "p"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    5967,
    -1,
    -1,
    6345,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "pr"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    5994,
    -1,
    -1,
    -1,
    -1,
    -1,
    6129,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "pri"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    6021,
    -1,
    -1,
    -1,
    -1,
    // "priv"
    -1,
    6048,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "priva"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    6075,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "privat"
    -1,
    -1,
    -1,
    -1,
    -1,
    6102,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "private"
    _keywords.ContextualKeyword._private << 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "pro"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    6156,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "prot"
    -1,
    -1,
    -1,
    -1,
    -1,
    6183,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    6318,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "prote"
    -1,
    -1,
    -1,
    6210,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "protec"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    6237,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "protect"
    -1,
    -1,
    -1,
    -1,
    -1,
    6264,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "protecte"
    -1,
    -1,
    -1,
    -1,
    6291,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "protected"
    _keywords.ContextualKeyword._protected << 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "proto"
    _keywords.ContextualKeyword._proto << 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "pu"
    -1,
    -1,
    6372,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "pub"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    6399,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "publ"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    6426,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "publi"
    -1,
    -1,
    -1,
    6453,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "public"
    _keywords.ContextualKeyword._public << 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "r"
    -1,
    -1,
    -1,
    -1,
    -1,
    6507,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "re"
    -1,
    6534,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    6696,
    -1,
    -1,
    6831,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "rea"
    -1,
    -1,
    -1,
    -1,
    6561,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "read"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    6588,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "reado"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    6615,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "readon"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    6642,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "readonl"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    6669,
    -1,
    // "readonly"
    _keywords.ContextualKeyword._readonly << 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "req"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    6723,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "requ"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    6750,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "requi"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    6777,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "requir"
    -1,
    -1,
    -1,
    -1,
    -1,
    6804,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "require"
    _keywords.ContextualKeyword._require << 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "ret"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    6858,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "retu"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    6885,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "retur"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    6912,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "return"
    (_types.TokenType._return << 1) + 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "s"
    -1,
    6966,
    -1,
    -1,
    -1,
    7182,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    7236,
    7371,
    -1,
    7479,
    -1,
    7614,
    -1,
    // "sa"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    6993,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "sat"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    7020,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "sati"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    7047,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "satis"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    7074,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "satisf"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    7101,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "satisfi"
    -1,
    -1,
    -1,
    -1,
    -1,
    7128,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "satisfie"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    7155,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "satisfies"
    _keywords.ContextualKeyword._satisfies << 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "se"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    7209,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "set"
    _keywords.ContextualKeyword._set << 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "st"
    -1,
    7263,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "sta"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    7290,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "stat"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    7317,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "stati"
    -1,
    -1,
    -1,
    7344,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "static"
    _keywords.ContextualKeyword._static << 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "su"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    7398,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "sup"
    -1,
    -1,
    -1,
    -1,
    -1,
    7425,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "supe"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    7452,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "super"
    (_types.TokenType._super << 1) + 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "sw"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    7506,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "swi"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    7533,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "swit"
    -1,
    -1,
    -1,
    7560,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "switc"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    7587,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "switch"
    (_types.TokenType._switch << 1) + 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "sy"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    7641,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "sym"
    -1,
    -1,
    7668,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "symb"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    7695,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "symbo"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    7722,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "symbol"
    _keywords.ContextualKeyword._symbol << 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "t"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    7776,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    7938,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    8046,
    -1,
    // "th"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    7803,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    7857,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "thi"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    7830,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "this"
    (_types.TokenType._this << 1) + 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "thr"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    7884,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "thro"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    7911,
    -1,
    -1,
    -1,
    // "throw"
    (_types.TokenType._throw << 1) + 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "tr"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    7965,
    -1,
    -1,
    -1,
    8019,
    -1,
    // "tru"
    -1,
    -1,
    -1,
    -1,
    -1,
    7992,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "true"
    (_types.TokenType._true << 1) + 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "try"
    (_types.TokenType._try << 1) + 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "ty"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    8073,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "typ"
    -1,
    -1,
    -1,
    -1,
    -1,
    8100,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "type"
    _keywords.ContextualKeyword._type << 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    8127,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "typeo"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    8154,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "typeof"
    (_types.TokenType._typeof << 1) + 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "u"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    8208,
    -1,
    -1,
    -1,
    -1,
    8343,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "un"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    8235,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "uni"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    8262,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "uniq"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    8289,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "uniqu"
    -1,
    -1,
    -1,
    -1,
    -1,
    8316,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "unique"
    _keywords.ContextualKeyword._unique << 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "us"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    8370,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "usi"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    8397,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "usin"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    8424,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "using"
    _keywords.ContextualKeyword._using << 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "v"
    -1,
    8478,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    8532,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "va"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    8505,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "var"
    (_types.TokenType._var << 1) + 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "vo"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    8559,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "voi"
    -1,
    -1,
    -1,
    -1,
    8586,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "void"
    (_types.TokenType._void << 1) + 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "w"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    8640,
    8748,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "wh"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    8667,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "whi"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    8694,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "whil"
    -1,
    -1,
    -1,
    -1,
    -1,
    8721,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "while"
    (_types.TokenType._while << 1) + 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "wi"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    8775,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "wit"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    8802,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "with"
    (_types.TokenType._with << 1) + 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "y"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    8856,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "yi"
    -1,
    -1,
    -1,
    -1,
    -1,
    8883,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "yie"
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    8910,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "yiel"
    -1,
    -1,
    -1,
    -1,
    8937,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    // "yield"
    (_types.TokenType._yield << 1) + 1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1
]);

},
"node_modules/sucrase/dist/esm/parser/tokenizer/state.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    Scope: function() {
        return Scope;
    },
    StateSnapshot: function() {
        return StateSnapshot;
    },
    default: function() {
        return State;
    }
});
var _keywords = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/keywords.js");
var _types = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/types.js");
class Scope {
    constructor(startTokenIndex, endTokenIndex, isFunctionScope){
        this.startTokenIndex = startTokenIndex;
        this.endTokenIndex = endTokenIndex;
        this.isFunctionScope = isFunctionScope;
    }
}
class StateSnapshot {
    constructor(potentialArrowAt, noAnonFunctionType, inDisallowConditionalTypesContext, tokensLength, scopesLength, pos, type, contextualKeyword, start, end, isType, scopeDepth, error){
        this.potentialArrowAt = potentialArrowAt;
        this.noAnonFunctionType = noAnonFunctionType;
        this.inDisallowConditionalTypesContext = inDisallowConditionalTypesContext;
        this.tokensLength = tokensLength;
        this.scopesLength = scopesLength;
        this.pos = pos;
        this.type = type;
        this.contextualKeyword = contextualKeyword;
        this.start = start;
        this.end = end;
        this.isType = isType;
        this.scopeDepth = scopeDepth;
        this.error = error;
    }
}
class State {
    constructor(){
        State.prototype.__init.call(this);
        State.prototype.__init2.call(this);
        State.prototype.__init3.call(this);
        State.prototype.__init4.call(this);
        State.prototype.__init5.call(this);
        State.prototype.__init6.call(this);
        State.prototype.__init7.call(this);
        State.prototype.__init8.call(this);
        State.prototype.__init9.call(this);
        State.prototype.__init10.call(this);
        State.prototype.__init11.call(this);
        State.prototype.__init12.call(this);
        State.prototype.__init13.call(this);
    }
    // Used to signify the start of a potential arrow function
    __init() {
        this.potentialArrowAt = -1;
    }
    // Used by Flow to handle an edge case involving function type parsing.
    __init2() {
        this.noAnonFunctionType = false;
    }
    // Used by TypeScript to handle ambiguities when parsing conditional types.
    __init3() {
        this.inDisallowConditionalTypesContext = false;
    }
    // Token store.
    __init4() {
        this.tokens = [];
    }
    // Array of all observed scopes, ordered by their ending position.
    __init5() {
        this.scopes = [];
    }
    // The current position of the tokenizer in the input.
    __init6() {
        this.pos = 0;
    }
    // Information about the current token.
    __init7() {
        this.type = _types.TokenType.eof;
    }
    __init8() {
        this.contextualKeyword = _keywords.ContextualKeyword.NONE;
    }
    __init9() {
        this.start = 0;
    }
    __init10() {
        this.end = 0;
    }
    __init11() {
        this.isType = false;
    }
    __init12() {
        this.scopeDepth = 0;
    }
    /**
   * If the parser is in an error state, then the token is always tt.eof and all functions can
   * keep executing but should be written so they don't get into an infinite loop in this situation.
   *
   * This approach, combined with the ability to snapshot and restore state, allows us to implement
   * backtracking without exceptions and without needing to explicitly propagate error states
   * everywhere.
   */ __init13() {
        this.error = null;
    }
    snapshot() {
        return new StateSnapshot(this.potentialArrowAt, this.noAnonFunctionType, this.inDisallowConditionalTypesContext, this.tokens.length, this.scopes.length, this.pos, this.type, this.contextualKeyword, this.start, this.end, this.isType, this.scopeDepth, this.error);
    }
    restoreFromSnapshot(snapshot) {
        this.potentialArrowAt = snapshot.potentialArrowAt;
        this.noAnonFunctionType = snapshot.noAnonFunctionType;
        this.inDisallowConditionalTypesContext = snapshot.inDisallowConditionalTypesContext;
        this.tokens.length = snapshot.tokensLength;
        this.scopes.length = snapshot.scopesLength;
        this.pos = snapshot.pos;
        this.type = snapshot.type;
        this.contextualKeyword = snapshot.contextualKeyword;
        this.start = snapshot.start;
        this.end = snapshot.end;
        this.isType = snapshot.isType;
        this.scopeDepth = snapshot.scopeDepth;
        this.error = snapshot.error;
    }
}

},
"node_modules/sucrase/dist/esm/parser/tokenizer/types.js": function (module, exports, __mako_require__){
// Generated file, do not edit! Run "yarn generate" to re-generate this file.
/* istanbul ignore file */ /**
 * Enum of all token types, with bit fields to signify meaningful properties.
 */ "use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    TokenType: function() {
        return TokenType;
    },
    formatTokenType: function() {
        return formatTokenType;
    }
});
var TokenType;
(function(TokenType) {
    // Precedence 0 means not an operator; otherwise it is a positive number up to 12.
    const PRECEDENCE_MASK = 0xf;
    TokenType[TokenType["PRECEDENCE_MASK"] = PRECEDENCE_MASK] = "PRECEDENCE_MASK";
    const IS_KEYWORD = 16;
    TokenType[TokenType["IS_KEYWORD"] = IS_KEYWORD] = "IS_KEYWORD";
    const IS_ASSIGN = 32;
    TokenType[TokenType["IS_ASSIGN"] = IS_ASSIGN] = "IS_ASSIGN";
    const IS_RIGHT_ASSOCIATIVE = 64;
    TokenType[TokenType["IS_RIGHT_ASSOCIATIVE"] = IS_RIGHT_ASSOCIATIVE] = "IS_RIGHT_ASSOCIATIVE";
    const IS_PREFIX = 128;
    TokenType[TokenType["IS_PREFIX"] = IS_PREFIX] = "IS_PREFIX";
    const IS_POSTFIX = 256;
    TokenType[TokenType["IS_POSTFIX"] = IS_POSTFIX] = "IS_POSTFIX";
    const IS_EXPRESSION_START = 512;
    TokenType[TokenType["IS_EXPRESSION_START"] = IS_EXPRESSION_START] = "IS_EXPRESSION_START";
    const num = 512;
    TokenType[TokenType["num"] = num] = "num"; // num startsExpr
    const bigint = 1536;
    TokenType[TokenType["bigint"] = bigint] = "bigint"; // bigint startsExpr
    const decimal = 2560;
    TokenType[TokenType["decimal"] = decimal] = "decimal"; // decimal startsExpr
    const regexp = 3584;
    TokenType[TokenType["regexp"] = regexp] = "regexp"; // regexp startsExpr
    const string = 4608;
    TokenType[TokenType["string"] = string] = "string"; // string startsExpr
    const name = 5632;
    TokenType[TokenType["name"] = name] = "name"; // name startsExpr
    const eof = 6144;
    TokenType[TokenType["eof"] = eof] = "eof"; // eof
    const bracketL = 7680;
    TokenType[TokenType["bracketL"] = bracketL] = "bracketL"; // [ startsExpr
    const bracketR = 8192;
    TokenType[TokenType["bracketR"] = bracketR] = "bracketR"; // ]
    const braceL = 9728;
    TokenType[TokenType["braceL"] = braceL] = "braceL"; // { startsExpr
    const braceBarL = 10752;
    TokenType[TokenType["braceBarL"] = braceBarL] = "braceBarL"; // {| startsExpr
    const braceR = 11264;
    TokenType[TokenType["braceR"] = braceR] = "braceR"; // }
    const braceBarR = 12288;
    TokenType[TokenType["braceBarR"] = braceBarR] = "braceBarR"; // |}
    const parenL = 13824;
    TokenType[TokenType["parenL"] = parenL] = "parenL"; // ( startsExpr
    const parenR = 14336;
    TokenType[TokenType["parenR"] = parenR] = "parenR"; // )
    const comma = 15360;
    TokenType[TokenType["comma"] = comma] = "comma"; // ,
    const semi = 16384;
    TokenType[TokenType["semi"] = semi] = "semi"; // ;
    const colon = 17408;
    TokenType[TokenType["colon"] = colon] = "colon"; // :
    const doubleColon = 18432;
    TokenType[TokenType["doubleColon"] = doubleColon] = "doubleColon"; // ::
    const dot = 19456;
    TokenType[TokenType["dot"] = dot] = "dot"; // .
    const question = 20480;
    TokenType[TokenType["question"] = question] = "question"; // ?
    const questionDot = 21504;
    TokenType[TokenType["questionDot"] = questionDot] = "questionDot"; // ?.
    const arrow = 22528;
    TokenType[TokenType["arrow"] = arrow] = "arrow"; // =>
    const template = 23552;
    TokenType[TokenType["template"] = template] = "template"; // template
    const ellipsis = 24576;
    TokenType[TokenType["ellipsis"] = ellipsis] = "ellipsis"; // ...
    const backQuote = 25600;
    TokenType[TokenType["backQuote"] = backQuote] = "backQuote"; // `
    const dollarBraceL = 27136;
    TokenType[TokenType["dollarBraceL"] = dollarBraceL] = "dollarBraceL"; // ${ startsExpr
    const at = 27648;
    TokenType[TokenType["at"] = at] = "at"; // @
    const hash = 29184;
    TokenType[TokenType["hash"] = hash] = "hash"; // # startsExpr
    const eq = 29728;
    TokenType[TokenType["eq"] = eq] = "eq"; // = isAssign
    const assign = 30752;
    TokenType[TokenType["assign"] = assign] = "assign"; // _= isAssign
    const preIncDec = 32640;
    TokenType[TokenType["preIncDec"] = preIncDec] = "preIncDec"; // ++/-- prefix postfix startsExpr
    const postIncDec = 33664;
    TokenType[TokenType["postIncDec"] = postIncDec] = "postIncDec"; // ++/-- prefix postfix startsExpr
    const bang = 34432;
    TokenType[TokenType["bang"] = bang] = "bang"; // ! prefix startsExpr
    const tilde = 35456;
    TokenType[TokenType["tilde"] = tilde] = "tilde"; // ~ prefix startsExpr
    const pipeline = 35841;
    TokenType[TokenType["pipeline"] = pipeline] = "pipeline"; // |> prec:1
    const nullishCoalescing = 36866;
    TokenType[TokenType["nullishCoalescing"] = nullishCoalescing] = "nullishCoalescing"; // ?? prec:2
    const logicalOR = 37890;
    TokenType[TokenType["logicalOR"] = logicalOR] = "logicalOR"; // || prec:2
    const logicalAND = 38915;
    TokenType[TokenType["logicalAND"] = logicalAND] = "logicalAND"; // && prec:3
    const bitwiseOR = 39940;
    TokenType[TokenType["bitwiseOR"] = bitwiseOR] = "bitwiseOR"; // | prec:4
    const bitwiseXOR = 40965;
    TokenType[TokenType["bitwiseXOR"] = bitwiseXOR] = "bitwiseXOR"; // ^ prec:5
    const bitwiseAND = 41990;
    TokenType[TokenType["bitwiseAND"] = bitwiseAND] = "bitwiseAND"; // & prec:6
    const equality = 43015;
    TokenType[TokenType["equality"] = equality] = "equality"; // ==/!= prec:7
    const lessThan = 44040;
    TokenType[TokenType["lessThan"] = lessThan] = "lessThan"; // < prec:8
    const greaterThan = 45064;
    TokenType[TokenType["greaterThan"] = greaterThan] = "greaterThan"; // > prec:8
    const relationalOrEqual = 46088;
    TokenType[TokenType["relationalOrEqual"] = relationalOrEqual] = "relationalOrEqual"; // <=/>= prec:8
    const bitShiftL = 47113;
    TokenType[TokenType["bitShiftL"] = bitShiftL] = "bitShiftL"; // << prec:9
    const bitShiftR = 48137;
    TokenType[TokenType["bitShiftR"] = bitShiftR] = "bitShiftR"; // >>/>>> prec:9
    const plus = 49802;
    TokenType[TokenType["plus"] = plus] = "plus"; // + prec:10 prefix startsExpr
    const minus = 50826;
    TokenType[TokenType["minus"] = minus] = "minus"; // - prec:10 prefix startsExpr
    const modulo = 51723;
    TokenType[TokenType["modulo"] = modulo] = "modulo"; // % prec:11 startsExpr
    const star = 52235;
    TokenType[TokenType["star"] = star] = "star"; // * prec:11
    const slash = 53259;
    TokenType[TokenType["slash"] = slash] = "slash"; // / prec:11
    const exponent = 54348;
    TokenType[TokenType["exponent"] = exponent] = "exponent"; // ** prec:12 rightAssociative
    const jsxName = 55296;
    TokenType[TokenType["jsxName"] = jsxName] = "jsxName"; // jsxName
    const jsxText = 56320;
    TokenType[TokenType["jsxText"] = jsxText] = "jsxText"; // jsxText
    const jsxEmptyText = 57344;
    TokenType[TokenType["jsxEmptyText"] = jsxEmptyText] = "jsxEmptyText"; // jsxEmptyText
    const jsxTagStart = 58880;
    TokenType[TokenType["jsxTagStart"] = jsxTagStart] = "jsxTagStart"; // jsxTagStart startsExpr
    const jsxTagEnd = 59392;
    TokenType[TokenType["jsxTagEnd"] = jsxTagEnd] = "jsxTagEnd"; // jsxTagEnd
    const typeParameterStart = 60928;
    TokenType[TokenType["typeParameterStart"] = typeParameterStart] = "typeParameterStart"; // typeParameterStart startsExpr
    const nonNullAssertion = 61440;
    TokenType[TokenType["nonNullAssertion"] = nonNullAssertion] = "nonNullAssertion"; // nonNullAssertion
    const _break = 62480;
    TokenType[TokenType["_break"] = _break] = "_break"; // break keyword
    const _case = 63504;
    TokenType[TokenType["_case"] = _case] = "_case"; // case keyword
    const _catch = 64528;
    TokenType[TokenType["_catch"] = _catch] = "_catch"; // catch keyword
    const _continue = 65552;
    TokenType[TokenType["_continue"] = _continue] = "_continue"; // continue keyword
    const _debugger = 66576;
    TokenType[TokenType["_debugger"] = _debugger] = "_debugger"; // debugger keyword
    const _default = 67600;
    TokenType[TokenType["_default"] = _default] = "_default"; // default keyword
    const _do = 68624;
    TokenType[TokenType["_do"] = _do] = "_do"; // do keyword
    const _else = 69648;
    TokenType[TokenType["_else"] = _else] = "_else"; // else keyword
    const _finally = 70672;
    TokenType[TokenType["_finally"] = _finally] = "_finally"; // finally keyword
    const _for = 71696;
    TokenType[TokenType["_for"] = _for] = "_for"; // for keyword
    const _function = 73232;
    TokenType[TokenType["_function"] = _function] = "_function"; // function keyword startsExpr
    const _if = 73744;
    TokenType[TokenType["_if"] = _if] = "_if"; // if keyword
    const _return = 74768;
    TokenType[TokenType["_return"] = _return] = "_return"; // return keyword
    const _switch = 75792;
    TokenType[TokenType["_switch"] = _switch] = "_switch"; // switch keyword
    const _throw = 77456;
    TokenType[TokenType["_throw"] = _throw] = "_throw"; // throw keyword prefix startsExpr
    const _try = 77840;
    TokenType[TokenType["_try"] = _try] = "_try"; // try keyword
    const _var = 78864;
    TokenType[TokenType["_var"] = _var] = "_var"; // var keyword
    const _let = 79888;
    TokenType[TokenType["_let"] = _let] = "_let"; // let keyword
    const _const = 80912;
    TokenType[TokenType["_const"] = _const] = "_const"; // const keyword
    const _while = 81936;
    TokenType[TokenType["_while"] = _while] = "_while"; // while keyword
    const _with = 82960;
    TokenType[TokenType["_with"] = _with] = "_with"; // with keyword
    const _new = 84496;
    TokenType[TokenType["_new"] = _new] = "_new"; // new keyword startsExpr
    const _this = 85520;
    TokenType[TokenType["_this"] = _this] = "_this"; // this keyword startsExpr
    const _super = 86544;
    TokenType[TokenType["_super"] = _super] = "_super"; // super keyword startsExpr
    const _class = 87568;
    TokenType[TokenType["_class"] = _class] = "_class"; // class keyword startsExpr
    const _extends = 88080;
    TokenType[TokenType["_extends"] = _extends] = "_extends"; // extends keyword
    const _export = 89104;
    TokenType[TokenType["_export"] = _export] = "_export"; // export keyword
    const _import = 90640;
    TokenType[TokenType["_import"] = _import] = "_import"; // import keyword startsExpr
    const _yield = 91664;
    TokenType[TokenType["_yield"] = _yield] = "_yield"; // yield keyword startsExpr
    const _null = 92688;
    TokenType[TokenType["_null"] = _null] = "_null"; // null keyword startsExpr
    const _true = 93712;
    TokenType[TokenType["_true"] = _true] = "_true"; // true keyword startsExpr
    const _false = 94736;
    TokenType[TokenType["_false"] = _false] = "_false"; // false keyword startsExpr
    const _in = 95256;
    TokenType[TokenType["_in"] = _in] = "_in"; // in prec:8 keyword
    const _instanceof = 96280;
    TokenType[TokenType["_instanceof"] = _instanceof] = "_instanceof"; // instanceof prec:8 keyword
    const _typeof = 97936;
    TokenType[TokenType["_typeof"] = _typeof] = "_typeof"; // typeof keyword prefix startsExpr
    const _void = 98960;
    TokenType[TokenType["_void"] = _void] = "_void"; // void keyword prefix startsExpr
    const _delete = 99984;
    TokenType[TokenType["_delete"] = _delete] = "_delete"; // delete keyword prefix startsExpr
    const _async = 100880;
    TokenType[TokenType["_async"] = _async] = "_async"; // async keyword startsExpr
    const _get = 101904;
    TokenType[TokenType["_get"] = _get] = "_get"; // get keyword startsExpr
    const _set = 102928;
    TokenType[TokenType["_set"] = _set] = "_set"; // set keyword startsExpr
    const _declare = 103952;
    TokenType[TokenType["_declare"] = _declare] = "_declare"; // declare keyword startsExpr
    const _readonly = 104976;
    TokenType[TokenType["_readonly"] = _readonly] = "_readonly"; // readonly keyword startsExpr
    const _abstract = 106000;
    TokenType[TokenType["_abstract"] = _abstract] = "_abstract"; // abstract keyword startsExpr
    const _static = 107024;
    TokenType[TokenType["_static"] = _static] = "_static"; // static keyword startsExpr
    const _public = 107536;
    TokenType[TokenType["_public"] = _public] = "_public"; // public keyword
    const _private = 108560;
    TokenType[TokenType["_private"] = _private] = "_private"; // private keyword
    const _protected = 109584;
    TokenType[TokenType["_protected"] = _protected] = "_protected"; // protected keyword
    const _override = 110608;
    TokenType[TokenType["_override"] = _override] = "_override"; // override keyword
    const _as = 112144;
    TokenType[TokenType["_as"] = _as] = "_as"; // as keyword startsExpr
    const _enum = 113168;
    TokenType[TokenType["_enum"] = _enum] = "_enum"; // enum keyword startsExpr
    const _type = 114192;
    TokenType[TokenType["_type"] = _type] = "_type"; // type keyword startsExpr
    const _implements = 115216;
    TokenType[TokenType["_implements"] = _implements] = "_implements"; // implements keyword startsExpr
})(TokenType || (TokenType = {}));
function formatTokenType(tokenType) {
    switch(tokenType){
        case TokenType.num:
            return "num";
        case TokenType.bigint:
            return "bigint";
        case TokenType.decimal:
            return "decimal";
        case TokenType.regexp:
            return "regexp";
        case TokenType.string:
            return "string";
        case TokenType.name:
            return "name";
        case TokenType.eof:
            return "eof";
        case TokenType.bracketL:
            return "[";
        case TokenType.bracketR:
            return "]";
        case TokenType.braceL:
            return "{";
        case TokenType.braceBarL:
            return "{|";
        case TokenType.braceR:
            return "}";
        case TokenType.braceBarR:
            return "|}";
        case TokenType.parenL:
            return "(";
        case TokenType.parenR:
            return ")";
        case TokenType.comma:
            return ",";
        case TokenType.semi:
            return ";";
        case TokenType.colon:
            return ":";
        case TokenType.doubleColon:
            return "::";
        case TokenType.dot:
            return ".";
        case TokenType.question:
            return "?";
        case TokenType.questionDot:
            return "?.";
        case TokenType.arrow:
            return "=>";
        case TokenType.template:
            return "template";
        case TokenType.ellipsis:
            return "...";
        case TokenType.backQuote:
            return "`";
        case TokenType.dollarBraceL:
            return "${";
        case TokenType.at:
            return "@";
        case TokenType.hash:
            return "#";
        case TokenType.eq:
            return "=";
        case TokenType.assign:
            return "_=";
        case TokenType.preIncDec:
            return "++/--";
        case TokenType.postIncDec:
            return "++/--";
        case TokenType.bang:
            return "!";
        case TokenType.tilde:
            return "~";
        case TokenType.pipeline:
            return "|>";
        case TokenType.nullishCoalescing:
            return "??";
        case TokenType.logicalOR:
            return "||";
        case TokenType.logicalAND:
            return "&&";
        case TokenType.bitwiseOR:
            return "|";
        case TokenType.bitwiseXOR:
            return "^";
        case TokenType.bitwiseAND:
            return "&";
        case TokenType.equality:
            return "==/!=";
        case TokenType.lessThan:
            return "<";
        case TokenType.greaterThan:
            return ">";
        case TokenType.relationalOrEqual:
            return "<=/>=";
        case TokenType.bitShiftL:
            return "<<";
        case TokenType.bitShiftR:
            return ">>/>>>";
        case TokenType.plus:
            return "+";
        case TokenType.minus:
            return "-";
        case TokenType.modulo:
            return "%";
        case TokenType.star:
            return "*";
        case TokenType.slash:
            return "/";
        case TokenType.exponent:
            return "**";
        case TokenType.jsxName:
            return "jsxName";
        case TokenType.jsxText:
            return "jsxText";
        case TokenType.jsxEmptyText:
            return "jsxEmptyText";
        case TokenType.jsxTagStart:
            return "jsxTagStart";
        case TokenType.jsxTagEnd:
            return "jsxTagEnd";
        case TokenType.typeParameterStart:
            return "typeParameterStart";
        case TokenType.nonNullAssertion:
            return "nonNullAssertion";
        case TokenType._break:
            return "break";
        case TokenType._case:
            return "case";
        case TokenType._catch:
            return "catch";
        case TokenType._continue:
            return "continue";
        case TokenType._debugger:
            return "debugger";
        case TokenType._default:
            return "default";
        case TokenType._do:
            return "do";
        case TokenType._else:
            return "else";
        case TokenType._finally:
            return "finally";
        case TokenType._for:
            return "for";
        case TokenType._function:
            return "function";
        case TokenType._if:
            return "if";
        case TokenType._return:
            return "return";
        case TokenType._switch:
            return "switch";
        case TokenType._throw:
            return "throw";
        case TokenType._try:
            return "try";
        case TokenType._var:
            return "var";
        case TokenType._let:
            return "let";
        case TokenType._const:
            return "const";
        case TokenType._while:
            return "while";
        case TokenType._with:
            return "with";
        case TokenType._new:
            return "new";
        case TokenType._this:
            return "this";
        case TokenType._super:
            return "super";
        case TokenType._class:
            return "class";
        case TokenType._extends:
            return "extends";
        case TokenType._export:
            return "export";
        case TokenType._import:
            return "import";
        case TokenType._yield:
            return "yield";
        case TokenType._null:
            return "null";
        case TokenType._true:
            return "true";
        case TokenType._false:
            return "false";
        case TokenType._in:
            return "in";
        case TokenType._instanceof:
            return "instanceof";
        case TokenType._typeof:
            return "typeof";
        case TokenType._void:
            return "void";
        case TokenType._delete:
            return "delete";
        case TokenType._async:
            return "async";
        case TokenType._get:
            return "get";
        case TokenType._set:
            return "set";
        case TokenType._declare:
            return "declare";
        case TokenType._readonly:
            return "readonly";
        case TokenType._abstract:
            return "abstract";
        case TokenType._static:
            return "static";
        case TokenType._public:
            return "public";
        case TokenType._private:
            return "private";
        case TokenType._protected:
            return "protected";
        case TokenType._override:
            return "override";
        case TokenType._as:
            return "as";
        case TokenType._enum:
            return "enum";
        case TokenType._type:
            return "type";
        case TokenType._implements:
            return "implements";
        default:
            return "";
    }
}

},
"node_modules/sucrase/dist/esm/parser/traverser/base.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    Loc: function() {
        return Loc;
    },
    augmentError: function() {
        return augmentError;
    },
    getNextContextId: function() {
        return getNextContextId;
    },
    initParser: function() {
        return initParser;
    },
    input: function() {
        return input;
    },
    isFlowEnabled: function() {
        return isFlowEnabled;
    },
    isJSXEnabled: function() {
        return isJSXEnabled;
    },
    isTypeScriptEnabled: function() {
        return isTypeScriptEnabled;
    },
    locationForIndex: function() {
        return locationForIndex;
    },
    nextContextId: function() {
        return nextContextId;
    },
    state: function() {
        return state;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _state = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/state.js"));
var _charcodes = __mako_require__("node_modules/sucrase/dist/esm/parser/util/charcodes.js");
let isJSXEnabled;
let isTypeScriptEnabled;
let isFlowEnabled;
let state;
let input;
let nextContextId;
function getNextContextId() {
    return nextContextId++;
}
function augmentError(error) {
    if ("pos" in error) {
        const loc = locationForIndex(error.pos);
        error.message += ` (${loc.line}:${loc.column})`;
        error.loc = loc;
    }
    return error;
}
class Loc {
    constructor(line, column){
        this.line = line;
        this.column = column;
    }
}
function locationForIndex(pos) {
    let line = 1;
    let column = 1;
    for(let i = 0; i < pos; i++)if (input.charCodeAt(i) === _charcodes.charCodes.lineFeed) {
        line++;
        column = 1;
    } else column++;
    return new Loc(line, column);
}
function initParser(inputCode, isJSXEnabledArg, isTypeScriptEnabledArg, isFlowEnabledArg) {
    input = inputCode;
    state = new _state.default();
    nextContextId = 1;
    isJSXEnabled = isJSXEnabledArg;
    isTypeScriptEnabled = isTypeScriptEnabledArg;
    isFlowEnabled = isFlowEnabledArg;
}

},
"node_modules/sucrase/dist/esm/parser/traverser/expression.js": function (module, exports, __mako_require__){
/* eslint max-len: 0 */ // A recursive descent parser operates by defining functions for all
// syntactic elements, and recursively calling those, each function
// advancing the input stream and returning an AST node. Precedence
// of constructs (for example, the fact that `!x[1]` means `!(x[1])`
// instead of `(!x)[1]` is handled by the fact that the parser
// function that parses unary prefix operators is called first, and
// in turn calls the function that parses `[]` subscripts  that
// way, it'll receive the node for `x[1]` already parsed, and wraps
// *that* in the unary operator node.
//
// Acorn uses an [operator precedence parser][opp] to handle binary
// operator precedence, because it is much more compact than using
// the technique outlined above, which uses different, nesting
// functions to specify precedence, for all of the ten binary
// precedence levels that JavaScript defines.
//
// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    StopState: function() {
        return StopState;
    },
    atPossibleAsync: function() {
        return atPossibleAsync;
    },
    baseParseConditional: function() {
        return baseParseConditional;
    },
    baseParseMaybeAssign: function() {
        return baseParseMaybeAssign;
    },
    baseParseSubscript: function() {
        return baseParseSubscript;
    },
    baseParseSubscripts: function() {
        return baseParseSubscripts;
    },
    parseArrow: function() {
        return parseArrow;
    },
    parseArrowExpression: function() {
        return parseArrowExpression;
    },
    parseCallExpressionArguments: function() {
        return parseCallExpressionArguments;
    },
    parseExprAtom: function() {
        return parseExprAtom;
    },
    parseExprSubscripts: function() {
        return parseExprSubscripts;
    },
    parseExpression: function() {
        return parseExpression;
    },
    parseFunctionBody: function() {
        return parseFunctionBody;
    },
    parseFunctionBodyAndFinish: function() {
        return parseFunctionBodyAndFinish;
    },
    parseIdentifier: function() {
        return parseIdentifier;
    },
    parseLiteral: function() {
        return parseLiteral;
    },
    parseMaybeAssign: function() {
        return parseMaybeAssign;
    },
    parseMaybeUnary: function() {
        return parseMaybeUnary;
    },
    parseMethod: function() {
        return parseMethod;
    },
    parseObj: function() {
        return parseObj;
    },
    parseParenExpression: function() {
        return parseParenExpression;
    },
    parsePropertyName: function() {
        return parsePropertyName;
    },
    parseTemplate: function() {
        return parseTemplate;
    }
});
var _flow = __mako_require__("node_modules/sucrase/dist/esm/parser/plugins/flow.js");
var _index = __mako_require__("node_modules/sucrase/dist/esm/parser/plugins/jsx/index.js");
var _types = __mako_require__("node_modules/sucrase/dist/esm/parser/plugins/types.js");
var _typescript = __mako_require__("node_modules/sucrase/dist/esm/parser/plugins/typescript.js");
var _index1 = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/index.js");
var _keywords = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/keywords.js");
var _state = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/state.js");
var _types1 = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/types.js");
var _charcodes = __mako_require__("node_modules/sucrase/dist/esm/parser/util/charcodes.js");
var _identifier = __mako_require__("node_modules/sucrase/dist/esm/parser/util/identifier.js");
var _base = __mako_require__("node_modules/sucrase/dist/esm/parser/traverser/base.js");
var _lval = __mako_require__("node_modules/sucrase/dist/esm/parser/traverser/lval.js");
var _statement = __mako_require__("node_modules/sucrase/dist/esm/parser/traverser/statement.js");
var _util = __mako_require__("node_modules/sucrase/dist/esm/parser/traverser/util.js");
class StopState {
    constructor(stop){
        this.stop = stop;
    }
}
function parseExpression(noIn = false) {
    parseMaybeAssign(noIn);
    if ((0, _index1.match)(_types1.TokenType.comma)) while((0, _index1.eat)(_types1.TokenType.comma))parseMaybeAssign(noIn);
}
function parseMaybeAssign(noIn = false, isWithinParens = false) {
    if (_base.isTypeScriptEnabled) return (0, _typescript.tsParseMaybeAssign)(noIn, isWithinParens);
    else if (_base.isFlowEnabled) return (0, _flow.flowParseMaybeAssign)(noIn, isWithinParens);
    else return baseParseMaybeAssign(noIn, isWithinParens);
}
function baseParseMaybeAssign(noIn, isWithinParens) {
    if ((0, _index1.match)(_types1.TokenType._yield)) {
        parseYield();
        return false;
    }
    if ((0, _index1.match)(_types1.TokenType.parenL) || (0, _index1.match)(_types1.TokenType.name) || (0, _index1.match)(_types1.TokenType._yield)) _base.state.potentialArrowAt = _base.state.start;
    const wasArrow = parseMaybeConditional(noIn);
    if (isWithinParens) parseParenItem();
    if (_base.state.type & _types1.TokenType.IS_ASSIGN) {
        (0, _index1.next)();
        parseMaybeAssign(noIn);
        return false;
    }
    return wasArrow;
}
// Parse a ternary conditional (`?:`) operator.
// Returns true if the expression was an arrow function.
function parseMaybeConditional(noIn) {
    const wasArrow = parseExprOps(noIn);
    if (wasArrow) return true;
    parseConditional(noIn);
    return false;
}
function parseConditional(noIn) {
    if (_base.isTypeScriptEnabled || _base.isFlowEnabled) (0, _types.typedParseConditional)(noIn);
    else baseParseConditional(noIn);
}
function baseParseConditional(noIn) {
    if ((0, _index1.eat)(_types1.TokenType.question)) {
        parseMaybeAssign();
        (0, _util.expect)(_types1.TokenType.colon);
        parseMaybeAssign(noIn);
    }
}
// Start the precedence parser.
// Returns true if this was an arrow function
function parseExprOps(noIn) {
    const startTokenIndex = _base.state.tokens.length;
    const wasArrow = parseMaybeUnary();
    if (wasArrow) return true;
    parseExprOp(startTokenIndex, -1, noIn);
    return false;
}
// Parse binary operators with the operator precedence parsing
// algorithm. `left` is the left-hand side of the operator.
// `minPrec` provides context that allows the function to stop and
// defer further parser to one of its callers when it encounters an
// operator that has a lower precedence than the set it is parsing.
function parseExprOp(startTokenIndex, minPrec, noIn) {
    if (_base.isTypeScriptEnabled && (_types1.TokenType._in & _types1.TokenType.PRECEDENCE_MASK) > minPrec && !(0, _util.hasPrecedingLineBreak)() && ((0, _util.eatContextual)(_keywords.ContextualKeyword._as) || (0, _util.eatContextual)(_keywords.ContextualKeyword._satisfies))) {
        const oldIsType = (0, _index1.pushTypeContext)(1);
        (0, _typescript.tsParseType)();
        (0, _index1.popTypeContext)(oldIsType);
        (0, _index1.rescan_gt)();
        parseExprOp(startTokenIndex, minPrec, noIn);
        return;
    }
    const prec = _base.state.type & _types1.TokenType.PRECEDENCE_MASK;
    if (prec > 0 && (!noIn || !(0, _index1.match)(_types1.TokenType._in))) {
        if (prec > minPrec) {
            const op = _base.state.type;
            (0, _index1.next)();
            if (op === _types1.TokenType.nullishCoalescing) _base.state.tokens[_base.state.tokens.length - 1].nullishStartIndex = startTokenIndex;
            const rhsStartTokenIndex = _base.state.tokens.length;
            parseMaybeUnary();
            // Extend the right operand of this operator if possible.
            parseExprOp(rhsStartTokenIndex, op & _types1.TokenType.IS_RIGHT_ASSOCIATIVE ? prec - 1 : prec, noIn);
            if (op === _types1.TokenType.nullishCoalescing) {
                _base.state.tokens[startTokenIndex].numNullishCoalesceStarts++;
                _base.state.tokens[_base.state.tokens.length - 1].numNullishCoalesceEnds++;
            }
            // Continue with any future operator holding this expression as the left operand.
            parseExprOp(startTokenIndex, minPrec, noIn);
        }
    }
}
function parseMaybeUnary() {
    if (_base.isTypeScriptEnabled && !_base.isJSXEnabled && (0, _index1.eat)(_types1.TokenType.lessThan)) {
        (0, _typescript.tsParseTypeAssertion)();
        return false;
    }
    if ((0, _util.isContextual)(_keywords.ContextualKeyword._module) && (0, _index1.lookaheadCharCode)() === _charcodes.charCodes.leftCurlyBrace && !(0, _util.hasFollowingLineBreak)()) {
        parseModuleExpression();
        return false;
    }
    if (_base.state.type & _types1.TokenType.IS_PREFIX) {
        (0, _index1.next)();
        parseMaybeUnary();
        return false;
    }
    const wasArrow = parseExprSubscripts();
    if (wasArrow) return true;
    while(_base.state.type & _types1.TokenType.IS_POSTFIX && !(0, _util.canInsertSemicolon)()){
        // The tokenizer calls everything a preincrement, so make it a postincrement when
        // we see it in that context.
        if (_base.state.type === _types1.TokenType.preIncDec) _base.state.type = _types1.TokenType.postIncDec;
        (0, _index1.next)();
    }
    return false;
}
function parseExprSubscripts() {
    const startTokenIndex = _base.state.tokens.length;
    const wasArrow = parseExprAtom();
    if (wasArrow) return true;
    parseSubscripts(startTokenIndex);
    // If there was any optional chain operation, the start token would be marked
    // as such, so also mark the end now.
    if (_base.state.tokens.length > startTokenIndex && _base.state.tokens[startTokenIndex].isOptionalChainStart) _base.state.tokens[_base.state.tokens.length - 1].isOptionalChainEnd = true;
    return false;
}
function parseSubscripts(startTokenIndex, noCalls = false) {
    if (_base.isFlowEnabled) (0, _flow.flowParseSubscripts)(startTokenIndex, noCalls);
    else baseParseSubscripts(startTokenIndex, noCalls);
}
function baseParseSubscripts(startTokenIndex, noCalls = false) {
    const stopState = new StopState(false);
    do parseSubscript(startTokenIndex, noCalls, stopState);
    while (!stopState.stop && !_base.state.error)
}
function parseSubscript(startTokenIndex, noCalls, stopState) {
    if (_base.isTypeScriptEnabled) (0, _typescript.tsParseSubscript)(startTokenIndex, noCalls, stopState);
    else if (_base.isFlowEnabled) (0, _flow.flowParseSubscript)(startTokenIndex, noCalls, stopState);
    else baseParseSubscript(startTokenIndex, noCalls, stopState);
}
function baseParseSubscript(startTokenIndex, noCalls, stopState) {
    if (!noCalls && (0, _index1.eat)(_types1.TokenType.doubleColon)) {
        parseNoCallExpr();
        stopState.stop = true;
        // Propagate startTokenIndex so that `a::b?.()` will keep `a` as the first token. We may want
        // to revisit this in the future when fully supporting bind syntax.
        parseSubscripts(startTokenIndex, noCalls);
    } else if ((0, _index1.match)(_types1.TokenType.questionDot)) {
        _base.state.tokens[startTokenIndex].isOptionalChainStart = true;
        if (noCalls && (0, _index1.lookaheadType)() === _types1.TokenType.parenL) {
            stopState.stop = true;
            return;
        }
        (0, _index1.next)();
        _base.state.tokens[_base.state.tokens.length - 1].subscriptStartIndex = startTokenIndex;
        if ((0, _index1.eat)(_types1.TokenType.bracketL)) {
            parseExpression();
            (0, _util.expect)(_types1.TokenType.bracketR);
        } else if ((0, _index1.eat)(_types1.TokenType.parenL)) parseCallExpressionArguments();
        else parseMaybePrivateName();
    } else if ((0, _index1.eat)(_types1.TokenType.dot)) {
        _base.state.tokens[_base.state.tokens.length - 1].subscriptStartIndex = startTokenIndex;
        parseMaybePrivateName();
    } else if ((0, _index1.eat)(_types1.TokenType.bracketL)) {
        _base.state.tokens[_base.state.tokens.length - 1].subscriptStartIndex = startTokenIndex;
        parseExpression();
        (0, _util.expect)(_types1.TokenType.bracketR);
    } else if (!noCalls && (0, _index1.match)(_types1.TokenType.parenL)) {
        if (atPossibleAsync()) {
            // We see "async", but it's possible it's a usage of the name "async". Parse as if it's a
            // function call, and if we see an arrow later, backtrack and re-parse as a parameter list.
            const snapshot = _base.state.snapshot();
            const asyncStartTokenIndex = _base.state.tokens.length;
            (0, _index1.next)();
            _base.state.tokens[_base.state.tokens.length - 1].subscriptStartIndex = startTokenIndex;
            const callContextId = (0, _base.getNextContextId)();
            _base.state.tokens[_base.state.tokens.length - 1].contextId = callContextId;
            parseCallExpressionArguments();
            _base.state.tokens[_base.state.tokens.length - 1].contextId = callContextId;
            if (shouldParseAsyncArrow()) {
                // We hit an arrow, so backtrack and start again parsing function parameters.
                _base.state.restoreFromSnapshot(snapshot);
                stopState.stop = true;
                _base.state.scopeDepth++;
                (0, _statement.parseFunctionParams)();
                parseAsyncArrowFromCallExpression(asyncStartTokenIndex);
            }
        } else {
            (0, _index1.next)();
            _base.state.tokens[_base.state.tokens.length - 1].subscriptStartIndex = startTokenIndex;
            const callContextId = (0, _base.getNextContextId)();
            _base.state.tokens[_base.state.tokens.length - 1].contextId = callContextId;
            parseCallExpressionArguments();
            _base.state.tokens[_base.state.tokens.length - 1].contextId = callContextId;
        }
    } else if ((0, _index1.match)(_types1.TokenType.backQuote)) // Tagged template expression.
    parseTemplate();
    else stopState.stop = true;
}
function atPossibleAsync() {
    // This was made less strict than the original version to avoid passing around nodes, but it
    // should be safe to have rare false positives here.
    return _base.state.tokens[_base.state.tokens.length - 1].contextualKeyword === _keywords.ContextualKeyword._async && !(0, _util.canInsertSemicolon)();
}
function parseCallExpressionArguments() {
    let first = true;
    while(!(0, _index1.eat)(_types1.TokenType.parenR) && !_base.state.error){
        if (first) first = false;
        else {
            (0, _util.expect)(_types1.TokenType.comma);
            if ((0, _index1.eat)(_types1.TokenType.parenR)) break;
        }
        parseExprListItem(false);
    }
}
function shouldParseAsyncArrow() {
    return (0, _index1.match)(_types1.TokenType.colon) || (0, _index1.match)(_types1.TokenType.arrow);
}
function parseAsyncArrowFromCallExpression(startTokenIndex) {
    if (_base.isTypeScriptEnabled) (0, _typescript.tsStartParseAsyncArrowFromCallExpression)();
    else if (_base.isFlowEnabled) (0, _flow.flowStartParseAsyncArrowFromCallExpression)();
    (0, _util.expect)(_types1.TokenType.arrow);
    parseArrowExpression(startTokenIndex);
}
// Parse a no-call expression (like argument of `new` or `::` operators).
function parseNoCallExpr() {
    const startTokenIndex = _base.state.tokens.length;
    parseExprAtom();
    parseSubscripts(startTokenIndex, true);
}
function parseExprAtom() {
    if ((0, _index1.eat)(_types1.TokenType.modulo)) {
        // V8 intrinsic expression. Just parse the identifier, and the function invocation is parsed
        // naturally.
        parseIdentifier();
        return false;
    }
    if ((0, _index1.match)(_types1.TokenType.jsxText) || (0, _index1.match)(_types1.TokenType.jsxEmptyText)) {
        parseLiteral();
        return false;
    } else if ((0, _index1.match)(_types1.TokenType.lessThan) && _base.isJSXEnabled) {
        _base.state.type = _types1.TokenType.jsxTagStart;
        (0, _index.jsxParseElement)();
        (0, _index1.next)();
        return false;
    }
    const canBeArrow = _base.state.potentialArrowAt === _base.state.start;
    switch(_base.state.type){
        case _types1.TokenType.slash:
        case _types1.TokenType.assign:
            (0, _index1.retokenizeSlashAsRegex)();
        // Fall through.
        case _types1.TokenType._super:
        case _types1.TokenType._this:
        case _types1.TokenType.regexp:
        case _types1.TokenType.num:
        case _types1.TokenType.bigint:
        case _types1.TokenType.decimal:
        case _types1.TokenType.string:
        case _types1.TokenType._null:
        case _types1.TokenType._true:
        case _types1.TokenType._false:
            (0, _index1.next)();
            return false;
        case _types1.TokenType._import:
            (0, _index1.next)();
            if ((0, _index1.match)(_types1.TokenType.dot)) {
                // import.meta
                _base.state.tokens[_base.state.tokens.length - 1].type = _types1.TokenType.name;
                (0, _index1.next)();
                parseIdentifier();
            }
            return false;
        case _types1.TokenType.name:
            {
                const startTokenIndex = _base.state.tokens.length;
                const functionStart = _base.state.start;
                const contextualKeyword = _base.state.contextualKeyword;
                parseIdentifier();
                if (contextualKeyword === _keywords.ContextualKeyword._await) {
                    parseAwait();
                    return false;
                } else if (contextualKeyword === _keywords.ContextualKeyword._async && (0, _index1.match)(_types1.TokenType._function) && !(0, _util.canInsertSemicolon)()) {
                    (0, _index1.next)();
                    (0, _statement.parseFunction)(functionStart, false);
                    return false;
                } else if (canBeArrow && contextualKeyword === _keywords.ContextualKeyword._async && !(0, _util.canInsertSemicolon)() && (0, _index1.match)(_types1.TokenType.name)) {
                    _base.state.scopeDepth++;
                    (0, _lval.parseBindingIdentifier)(false);
                    (0, _util.expect)(_types1.TokenType.arrow);
                    // let foo = async bar => {};
                    parseArrowExpression(startTokenIndex);
                    return true;
                } else if ((0, _index1.match)(_types1.TokenType._do) && !(0, _util.canInsertSemicolon)()) {
                    (0, _index1.next)();
                    (0, _statement.parseBlock)();
                    return false;
                }
                if (canBeArrow && !(0, _util.canInsertSemicolon)() && (0, _index1.match)(_types1.TokenType.arrow)) {
                    _base.state.scopeDepth++;
                    (0, _lval.markPriorBindingIdentifier)(false);
                    (0, _util.expect)(_types1.TokenType.arrow);
                    parseArrowExpression(startTokenIndex);
                    return true;
                }
                _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _index1.IdentifierRole.Access;
                return false;
            }
        case _types1.TokenType._do:
            (0, _index1.next)();
            (0, _statement.parseBlock)();
            return false;
        case _types1.TokenType.parenL:
            {
                const wasArrow = parseParenAndDistinguishExpression(canBeArrow);
                return wasArrow;
            }
        case _types1.TokenType.bracketL:
            (0, _index1.next)();
            parseExprList(_types1.TokenType.bracketR, true);
            return false;
        case _types1.TokenType.braceL:
            parseObj(false, false);
            return false;
        case _types1.TokenType._function:
            parseFunctionExpression();
            return false;
        case _types1.TokenType.at:
            (0, _statement.parseDecorators)();
        // Fall through.
        case _types1.TokenType._class:
            (0, _statement.parseClass)(false);
            return false;
        case _types1.TokenType._new:
            parseNew();
            return false;
        case _types1.TokenType.backQuote:
            parseTemplate();
            return false;
        case _types1.TokenType.doubleColon:
            (0, _index1.next)();
            parseNoCallExpr();
            return false;
        case _types1.TokenType.hash:
            {
                const code = (0, _index1.lookaheadCharCode)();
                if (_identifier.IS_IDENTIFIER_START[code] || code === _charcodes.charCodes.backslash) parseMaybePrivateName();
                else (0, _index1.next)();
                // Smart pipeline topic reference.
                return false;
            }
        default:
            (0, _util.unexpected)();
            return false;
    }
}
function parseMaybePrivateName() {
    (0, _index1.eat)(_types1.TokenType.hash);
    parseIdentifier();
}
function parseFunctionExpression() {
    const functionStart = _base.state.start;
    parseIdentifier();
    if ((0, _index1.eat)(_types1.TokenType.dot)) // function.sent
    parseIdentifier();
    (0, _statement.parseFunction)(functionStart, false);
}
function parseLiteral() {
    (0, _index1.next)();
}
function parseParenExpression() {
    (0, _util.expect)(_types1.TokenType.parenL);
    parseExpression();
    (0, _util.expect)(_types1.TokenType.parenR);
}
// Returns true if this was an arrow expression.
function parseParenAndDistinguishExpression(canBeArrow) {
    // Assume this is a normal parenthesized expression, but if we see an arrow, we'll bail and
    // start over as a parameter list.
    const snapshot = _base.state.snapshot();
    const startTokenIndex = _base.state.tokens.length;
    (0, _util.expect)(_types1.TokenType.parenL);
    let first = true;
    while(!(0, _index1.match)(_types1.TokenType.parenR) && !_base.state.error){
        if (first) first = false;
        else {
            (0, _util.expect)(_types1.TokenType.comma);
            if ((0, _index1.match)(_types1.TokenType.parenR)) break;
        }
        if ((0, _index1.match)(_types1.TokenType.ellipsis)) {
            (0, _lval.parseRest)(false);
            parseParenItem();
            break;
        } else parseMaybeAssign(false, true);
    }
    (0, _util.expect)(_types1.TokenType.parenR);
    if (canBeArrow && shouldParseArrow()) {
        const wasArrow = parseArrow();
        if (wasArrow) {
            // It was an arrow function this whole time, so start over and parse it as params so that we
            // get proper token annotations.
            _base.state.restoreFromSnapshot(snapshot);
            _base.state.scopeDepth++;
            // Don't specify a context ID because arrow functions don't need a context ID.
            (0, _statement.parseFunctionParams)();
            parseArrow();
            parseArrowExpression(startTokenIndex);
            if (_base.state.error) {
                // Nevermind! This must have been something that looks very much like an
                // arrow function but where its "parameter list" isn't actually a valid
                // parameter list. Force non-arrow parsing.
                // See https://github.com/alangpierce/sucrase/issues/666 for an example.
                _base.state.restoreFromSnapshot(snapshot);
                parseParenAndDistinguishExpression(false);
                return false;
            }
            return true;
        }
    }
    return false;
}
function shouldParseArrow() {
    return (0, _index1.match)(_types1.TokenType.colon) || !(0, _util.canInsertSemicolon)();
}
function parseArrow() {
    if (_base.isTypeScriptEnabled) return (0, _typescript.tsParseArrow)();
    else if (_base.isFlowEnabled) return (0, _flow.flowParseArrow)();
    else return (0, _index1.eat)(_types1.TokenType.arrow);
}
function parseParenItem() {
    if (_base.isTypeScriptEnabled || _base.isFlowEnabled) (0, _types.typedParseParenItem)();
}
// New's precedence is slightly tricky. It must allow its argument to
// be a `[]` or dot subscript expression, but not a call  at least,
// not without wrapping it in parentheses. Thus, it uses the noCalls
// argument to parseSubscripts to prevent it from consuming the
// argument list.
function parseNew() {
    (0, _util.expect)(_types1.TokenType._new);
    if ((0, _index1.eat)(_types1.TokenType.dot)) {
        // new.target
        parseIdentifier();
        return;
    }
    parseNewCallee();
    if (_base.isFlowEnabled) (0, _flow.flowStartParseNewArguments)();
    if ((0, _index1.eat)(_types1.TokenType.parenL)) parseExprList(_types1.TokenType.parenR);
}
function parseNewCallee() {
    parseNoCallExpr();
    (0, _index1.eat)(_types1.TokenType.questionDot);
}
function parseTemplate() {
    // Finish `, read quasi
    (0, _index1.nextTemplateToken)();
    // Finish quasi, read ${
    (0, _index1.nextTemplateToken)();
    while(!(0, _index1.match)(_types1.TokenType.backQuote) && !_base.state.error){
        (0, _util.expect)(_types1.TokenType.dollarBraceL);
        parseExpression();
        // Finish }, read quasi
        (0, _index1.nextTemplateToken)();
        // Finish quasi, read either ${ or `
        (0, _index1.nextTemplateToken)();
    }
    (0, _index1.next)();
}
function parseObj(isPattern, isBlockScope) {
    // Attach a context ID to the object open and close brace and each object key.
    const contextId = (0, _base.getNextContextId)();
    let first = true;
    (0, _index1.next)();
    _base.state.tokens[_base.state.tokens.length - 1].contextId = contextId;
    while(!(0, _index1.eat)(_types1.TokenType.braceR) && !_base.state.error){
        if (first) first = false;
        else {
            (0, _util.expect)(_types1.TokenType.comma);
            if ((0, _index1.eat)(_types1.TokenType.braceR)) break;
        }
        let isGenerator = false;
        if ((0, _index1.match)(_types1.TokenType.ellipsis)) {
            const previousIndex = _base.state.tokens.length;
            (0, _lval.parseSpread)();
            if (isPattern) {
                // Mark role when the only thing being spread over is an identifier.
                if (_base.state.tokens.length === previousIndex + 2) (0, _lval.markPriorBindingIdentifier)(isBlockScope);
                if ((0, _index1.eat)(_types1.TokenType.braceR)) break;
            }
            continue;
        }
        if (!isPattern) isGenerator = (0, _index1.eat)(_types1.TokenType.star);
        if (!isPattern && (0, _util.isContextual)(_keywords.ContextualKeyword._async)) {
            if (isGenerator) (0, _util.unexpected)();
            parseIdentifier();
            if ((0, _index1.match)(_types1.TokenType.colon) || (0, _index1.match)(_types1.TokenType.parenL) || (0, _index1.match)(_types1.TokenType.braceR) || (0, _index1.match)(_types1.TokenType.eq) || (0, _index1.match)(_types1.TokenType.comma)) ;
            else {
                if ((0, _index1.match)(_types1.TokenType.star)) {
                    (0, _index1.next)();
                    isGenerator = true;
                }
                parsePropertyName(contextId);
            }
        } else parsePropertyName(contextId);
        parseObjPropValue(isPattern, isBlockScope, contextId);
    }
    _base.state.tokens[_base.state.tokens.length - 1].contextId = contextId;
}
function isGetterOrSetterMethod(isPattern) {
    // We go off of the next and don't bother checking if the node key is actually "get" or "set".
    // This lets us avoid generating a node, and should only make the validation worse.
    return !isPattern && ((0, _index1.match)(_types1.TokenType.string) || // get "string"() {}
    (0, _index1.match)(_types1.TokenType.num) || // get 1() {}
    (0, _index1.match)(_types1.TokenType.bracketL) || // get ["string"]() {}
    (0, _index1.match)(_types1.TokenType.name) || // get foo() {}
    !!(_base.state.type & _types1.TokenType.IS_KEYWORD)) // get debugger() {}
    ;
}
// Returns true if this was a method.
function parseObjectMethod(isPattern, objectContextId) {
    // We don't need to worry about modifiers because object methods can't have optional bodies, so
    // the start will never be used.
    const functionStart = _base.state.start;
    if ((0, _index1.match)(_types1.TokenType.parenL)) {
        if (isPattern) (0, _util.unexpected)();
        parseMethod(functionStart, /* isConstructor */ false);
        return true;
    }
    if (isGetterOrSetterMethod(isPattern)) {
        parsePropertyName(objectContextId);
        parseMethod(functionStart, /* isConstructor */ false);
        return true;
    }
    return false;
}
function parseObjectProperty(isPattern, isBlockScope) {
    if ((0, _index1.eat)(_types1.TokenType.colon)) {
        if (isPattern) (0, _lval.parseMaybeDefault)(isBlockScope);
        else parseMaybeAssign(false);
        return;
    }
    // Since there's no colon, we assume this is an object shorthand.
    // If we're in a destructuring, we've now discovered that the key was actually an assignee, so
    // we need to tag it as a declaration with the appropriate scope. Otherwise, we might need to
    // transform it on access, so mark it as a normal object shorthand.
    let identifierRole;
    if (isPattern) {
        if (_base.state.scopeDepth === 0) identifierRole = _index1.IdentifierRole.ObjectShorthandTopLevelDeclaration;
        else if (isBlockScope) identifierRole = _index1.IdentifierRole.ObjectShorthandBlockScopedDeclaration;
        else identifierRole = _index1.IdentifierRole.ObjectShorthandFunctionScopedDeclaration;
    } else identifierRole = _index1.IdentifierRole.ObjectShorthand;
    _base.state.tokens[_base.state.tokens.length - 1].identifierRole = identifierRole;
    // Regardless of whether we know this to be a pattern or if we're in an ambiguous context, allow
    // parsing as if there's a default value.
    (0, _lval.parseMaybeDefault)(isBlockScope, true);
}
function parseObjPropValue(isPattern, isBlockScope, objectContextId) {
    if (_base.isTypeScriptEnabled) (0, _typescript.tsStartParseObjPropValue)();
    else if (_base.isFlowEnabled) (0, _flow.flowStartParseObjPropValue)();
    const wasMethod = parseObjectMethod(isPattern, objectContextId);
    if (!wasMethod) parseObjectProperty(isPattern, isBlockScope);
}
function parsePropertyName(objectContextId) {
    if (_base.isFlowEnabled) (0, _flow.flowParseVariance)();
    if ((0, _index1.eat)(_types1.TokenType.bracketL)) {
        _base.state.tokens[_base.state.tokens.length - 1].contextId = objectContextId;
        parseMaybeAssign();
        (0, _util.expect)(_types1.TokenType.bracketR);
        _base.state.tokens[_base.state.tokens.length - 1].contextId = objectContextId;
    } else {
        if ((0, _index1.match)(_types1.TokenType.num) || (0, _index1.match)(_types1.TokenType.string) || (0, _index1.match)(_types1.TokenType.bigint) || (0, _index1.match)(_types1.TokenType.decimal)) parseExprAtom();
        else parseMaybePrivateName();
        _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _index1.IdentifierRole.ObjectKey;
        _base.state.tokens[_base.state.tokens.length - 1].contextId = objectContextId;
    }
}
function parseMethod(functionStart, isConstructor) {
    const funcContextId = (0, _base.getNextContextId)();
    _base.state.scopeDepth++;
    const startTokenIndex = _base.state.tokens.length;
    const allowModifiers = isConstructor; // For TypeScript parameter properties
    (0, _statement.parseFunctionParams)(allowModifiers, funcContextId);
    parseFunctionBodyAndFinish(functionStart, funcContextId);
    const endTokenIndex = _base.state.tokens.length;
    _base.state.scopes.push(new _state.Scope(startTokenIndex, endTokenIndex, true));
    _base.state.scopeDepth--;
}
function parseArrowExpression(startTokenIndex) {
    parseFunctionBody(true);
    const endTokenIndex = _base.state.tokens.length;
    _base.state.scopes.push(new _state.Scope(startTokenIndex, endTokenIndex, true));
    _base.state.scopeDepth--;
}
function parseFunctionBodyAndFinish(functionStart, funcContextId = 0) {
    if (_base.isTypeScriptEnabled) (0, _typescript.tsParseFunctionBodyAndFinish)(functionStart, funcContextId);
    else if (_base.isFlowEnabled) (0, _flow.flowParseFunctionBodyAndFinish)(funcContextId);
    else parseFunctionBody(false, funcContextId);
}
function parseFunctionBody(allowExpression, funcContextId = 0) {
    const isExpression = allowExpression && !(0, _index1.match)(_types1.TokenType.braceL);
    if (isExpression) parseMaybeAssign();
    else (0, _statement.parseBlock)(true, funcContextId);
}
// Parses a comma-separated list of expressions, and returns them as
// an array. `close` is the token type that ends the list, and
// `allowEmpty` can be turned on to allow subsequent commas with
// nothing in between them to be parsed as `null` (which is needed
// for array literals).
function parseExprList(close, allowEmpty = false) {
    let first = true;
    while(!(0, _index1.eat)(close) && !_base.state.error){
        if (first) first = false;
        else {
            (0, _util.expect)(_types1.TokenType.comma);
            if ((0, _index1.eat)(close)) break;
        }
        parseExprListItem(allowEmpty);
    }
}
function parseExprListItem(allowEmpty) {
    if (allowEmpty && (0, _index1.match)(_types1.TokenType.comma)) ;
    else if ((0, _index1.match)(_types1.TokenType.ellipsis)) {
        (0, _lval.parseSpread)();
        parseParenItem();
    } else if ((0, _index1.match)(_types1.TokenType.question)) // Partial function application proposal.
    (0, _index1.next)();
    else parseMaybeAssign(false, true);
}
function parseIdentifier() {
    (0, _index1.next)();
    _base.state.tokens[_base.state.tokens.length - 1].type = _types1.TokenType.name;
}
// Parses await expression inside async function.
function parseAwait() {
    parseMaybeUnary();
}
// Parses yield expression inside generator.
function parseYield() {
    (0, _index1.next)();
    if (!(0, _index1.match)(_types1.TokenType.semi) && !(0, _util.canInsertSemicolon)()) {
        (0, _index1.eat)(_types1.TokenType.star);
        parseMaybeAssign();
    }
}
// https://github.com/tc39/proposal-js-module-blocks
function parseModuleExpression() {
    (0, _util.expectContextual)(_keywords.ContextualKeyword._module);
    (0, _util.expect)(_types1.TokenType.braceL);
    // For now, just call parseBlockBody to parse the block. In the future when we
    // implement full support, we'll want to emit scopes and possibly other
    // information.
    (0, _statement.parseBlockBody)(_types1.TokenType.braceR);
}

},
"node_modules/sucrase/dist/esm/parser/traverser/index.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "parseFile", {
    enumerable: true,
    get: function() {
        return parseFile;
    }
});
var _index = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/index.js");
var _charcodes = __mako_require__("node_modules/sucrase/dist/esm/parser/util/charcodes.js");
var _base = __mako_require__("node_modules/sucrase/dist/esm/parser/traverser/base.js");
var _statement = __mako_require__("node_modules/sucrase/dist/esm/parser/traverser/statement.js");
function parseFile() {
    // If enabled, skip leading hashbang line.
    if (_base.state.pos === 0 && _base.input.charCodeAt(0) === _charcodes.charCodes.numberSign && _base.input.charCodeAt(1) === _charcodes.charCodes.exclamationMark) (0, _index.skipLineComment)(2);
    (0, _index.nextToken)();
    return (0, _statement.parseTopLevel)();
}

},
"node_modules/sucrase/dist/esm/parser/traverser/lval.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    markPriorBindingIdentifier: function() {
        return markPriorBindingIdentifier;
    },
    parseBindingAtom: function() {
        return parseBindingAtom;
    },
    parseBindingIdentifier: function() {
        return parseBindingIdentifier;
    },
    parseBindingList: function() {
        return parseBindingList;
    },
    parseImportedIdentifier: function() {
        return parseImportedIdentifier;
    },
    parseMaybeDefault: function() {
        return parseMaybeDefault;
    },
    parseRest: function() {
        return parseRest;
    },
    parseSpread: function() {
        return parseSpread;
    }
});
var _flow = __mako_require__("node_modules/sucrase/dist/esm/parser/plugins/flow.js");
var _typescript = __mako_require__("node_modules/sucrase/dist/esm/parser/plugins/typescript.js");
var _index = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/index.js");
var _keywords = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/keywords.js");
var _types = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/types.js");
var _base = __mako_require__("node_modules/sucrase/dist/esm/parser/traverser/base.js");
var _expression = __mako_require__("node_modules/sucrase/dist/esm/parser/traverser/expression.js");
var _util = __mako_require__("node_modules/sucrase/dist/esm/parser/traverser/util.js");
function parseSpread() {
    (0, _index.next)();
    (0, _expression.parseMaybeAssign)(false);
}
function parseRest(isBlockScope) {
    (0, _index.next)();
    parseBindingAtom(isBlockScope);
}
function parseBindingIdentifier(isBlockScope) {
    (0, _expression.parseIdentifier)();
    markPriorBindingIdentifier(isBlockScope);
}
function parseImportedIdentifier() {
    (0, _expression.parseIdentifier)();
    _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _index.IdentifierRole.ImportDeclaration;
}
function markPriorBindingIdentifier(isBlockScope) {
    let identifierRole;
    if (_base.state.scopeDepth === 0) identifierRole = _index.IdentifierRole.TopLevelDeclaration;
    else if (isBlockScope) identifierRole = _index.IdentifierRole.BlockScopedDeclaration;
    else identifierRole = _index.IdentifierRole.FunctionScopedDeclaration;
    _base.state.tokens[_base.state.tokens.length - 1].identifierRole = identifierRole;
}
function parseBindingAtom(isBlockScope) {
    switch(_base.state.type){
        case _types.TokenType._this:
            {
                // In TypeScript, "this" may be the name of a parameter, so allow it.
                const oldIsType = (0, _index.pushTypeContext)(0);
                (0, _index.next)();
                (0, _index.popTypeContext)(oldIsType);
                return;
            }
        case _types.TokenType._yield:
        case _types.TokenType.name:
            _base.state.type = _types.TokenType.name;
            parseBindingIdentifier(isBlockScope);
            return;
        case _types.TokenType.bracketL:
            (0, _index.next)();
            parseBindingList(_types.TokenType.bracketR, isBlockScope, true);
            return;
        case _types.TokenType.braceL:
            (0, _expression.parseObj)(true, isBlockScope);
            return;
        default:
            (0, _util.unexpected)();
    }
}
function parseBindingList(close, isBlockScope, allowEmpty = false, allowModifiers = false, contextId = 0) {
    let first = true;
    let hasRemovedComma = false;
    const firstItemTokenIndex = _base.state.tokens.length;
    while(!(0, _index.eat)(close) && !_base.state.error){
        if (first) first = false;
        else {
            (0, _util.expect)(_types.TokenType.comma);
            _base.state.tokens[_base.state.tokens.length - 1].contextId = contextId;
            // After a "this" type in TypeScript, we need to set the following comma (if any) to also be
            // a type token so that it will be removed.
            if (!hasRemovedComma && _base.state.tokens[firstItemTokenIndex].isType) {
                _base.state.tokens[_base.state.tokens.length - 1].isType = true;
                hasRemovedComma = true;
            }
        }
        if (allowEmpty && (0, _index.match)(_types.TokenType.comma)) ;
        else if ((0, _index.eat)(close)) break;
        else if ((0, _index.match)(_types.TokenType.ellipsis)) {
            parseRest(isBlockScope);
            parseAssignableListItemTypes();
            // Support rest element trailing commas allowed by TypeScript <2.9.
            (0, _index.eat)(_types.TokenType.comma);
            (0, _util.expect)(close);
            break;
        } else parseAssignableListItem(allowModifiers, isBlockScope);
    }
}
function parseAssignableListItem(allowModifiers, isBlockScope) {
    if (allowModifiers) (0, _typescript.tsParseModifiers)([
        _keywords.ContextualKeyword._public,
        _keywords.ContextualKeyword._protected,
        _keywords.ContextualKeyword._private,
        _keywords.ContextualKeyword._readonly,
        _keywords.ContextualKeyword._override
    ]);
    parseMaybeDefault(isBlockScope);
    parseAssignableListItemTypes();
    parseMaybeDefault(isBlockScope, true);
}
function parseAssignableListItemTypes() {
    if (_base.isFlowEnabled) (0, _flow.flowParseAssignableListItemTypes)();
    else if (_base.isTypeScriptEnabled) (0, _typescript.tsParseAssignableListItemTypes)();
}
function parseMaybeDefault(isBlockScope, leftAlreadyParsed = false) {
    if (!leftAlreadyParsed) parseBindingAtom(isBlockScope);
    if (!(0, _index.eat)(_types.TokenType.eq)) return;
    const eqIndex = _base.state.tokens.length - 1;
    (0, _expression.parseMaybeAssign)();
    _base.state.tokens[eqIndex].rhsEndIndex = _base.state.tokens.length;
}

},
"node_modules/sucrase/dist/esm/parser/traverser/statement.js": function (module, exports, __mako_require__){
/* eslint max-len: 0 */ "use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    baseParseExportStar: function() {
        return baseParseExportStar;
    },
    baseParseMaybeDecoratorArguments: function() {
        return baseParseMaybeDecoratorArguments;
    },
    parseBlock: function() {
        return parseBlock;
    },
    parseBlockBody: function() {
        return parseBlockBody;
    },
    parseClass: function() {
        return parseClass;
    },
    parseClassProperty: function() {
        return parseClassProperty;
    },
    parseClassPropertyName: function() {
        return parseClassPropertyName;
    },
    parseDecorators: function() {
        return parseDecorators;
    },
    parseExport: function() {
        return parseExport;
    },
    parseExportFrom: function() {
        return parseExportFrom;
    },
    parseExportSpecifiers: function() {
        return parseExportSpecifiers;
    },
    parseFunction: function() {
        return parseFunction;
    },
    parseFunctionParams: function() {
        return parseFunctionParams;
    },
    parseImport: function() {
        return parseImport;
    },
    parsePostMemberNameModifiers: function() {
        return parsePostMemberNameModifiers;
    },
    parseStatement: function() {
        return parseStatement;
    },
    parseTopLevel: function() {
        return parseTopLevel;
    },
    parseVarStatement: function() {
        return parseVarStatement;
    }
});
var _index = __mako_require__("node_modules/sucrase/dist/esm/parser/index.js");
var _flow = __mako_require__("node_modules/sucrase/dist/esm/parser/plugins/flow.js");
var _typescript = __mako_require__("node_modules/sucrase/dist/esm/parser/plugins/typescript.js");
var _tokenizer = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/index.js");
var _keywords = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/keywords.js");
var _state = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/state.js");
var _types = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/types.js");
var _charcodes = __mako_require__("node_modules/sucrase/dist/esm/parser/util/charcodes.js");
var _base = __mako_require__("node_modules/sucrase/dist/esm/parser/traverser/base.js");
var _expression = __mako_require__("node_modules/sucrase/dist/esm/parser/traverser/expression.js");
var _lval = __mako_require__("node_modules/sucrase/dist/esm/parser/traverser/lval.js");
var _util = __mako_require__("node_modules/sucrase/dist/esm/parser/traverser/util.js");
function parseTopLevel() {
    parseBlockBody(_types.TokenType.eof);
    _base.state.scopes.push(new _state.Scope(0, _base.state.tokens.length, true));
    if (_base.state.scopeDepth !== 0) throw new Error(`Invalid scope depth at end of file: ${_base.state.scopeDepth}`);
    return new _index.File(_base.state.tokens, _base.state.scopes);
}
function parseStatement(declaration) {
    if (_base.isFlowEnabled) {
        if ((0, _flow.flowTryParseStatement)()) return;
    }
    if ((0, _tokenizer.match)(_types.TokenType.at)) parseDecorators();
    parseStatementContent(declaration);
}
function parseStatementContent(declaration) {
    if (_base.isTypeScriptEnabled) {
        if ((0, _typescript.tsTryParseStatementContent)()) return;
    }
    const starttype = _base.state.type;
    // Most types of statements are recognized by the keyword they
    // start with. Many are trivial to parse, some require a bit of
    // complexity.
    switch(starttype){
        case _types.TokenType._break:
        case _types.TokenType._continue:
            parseBreakContinueStatement();
            return;
        case _types.TokenType._debugger:
            parseDebuggerStatement();
            return;
        case _types.TokenType._do:
            parseDoStatement();
            return;
        case _types.TokenType._for:
            parseForStatement();
            return;
        case _types.TokenType._function:
            if ((0, _tokenizer.lookaheadType)() === _types.TokenType.dot) break;
            if (!declaration) (0, _util.unexpected)();
            parseFunctionStatement();
            return;
        case _types.TokenType._class:
            if (!declaration) (0, _util.unexpected)();
            parseClass(true);
            return;
        case _types.TokenType._if:
            parseIfStatement();
            return;
        case _types.TokenType._return:
            parseReturnStatement();
            return;
        case _types.TokenType._switch:
            parseSwitchStatement();
            return;
        case _types.TokenType._throw:
            parseThrowStatement();
            return;
        case _types.TokenType._try:
            parseTryStatement();
            return;
        case _types.TokenType._let:
        case _types.TokenType._const:
            if (!declaration) (0, _util.unexpected)(); // NOTE: falls through to _var
        case _types.TokenType._var:
            parseVarStatement(starttype !== _types.TokenType._var);
            return;
        case _types.TokenType._while:
            parseWhileStatement();
            return;
        case _types.TokenType.braceL:
            parseBlock();
            return;
        case _types.TokenType.semi:
            parseEmptyStatement();
            return;
        case _types.TokenType._export:
        case _types.TokenType._import:
            {
                const nextType = (0, _tokenizer.lookaheadType)();
                if (nextType === _types.TokenType.parenL || nextType === _types.TokenType.dot) break;
                (0, _tokenizer.next)();
                if (starttype === _types.TokenType._import) parseImport();
                else parseExport();
                return;
            }
        case _types.TokenType.name:
            if (_base.state.contextualKeyword === _keywords.ContextualKeyword._async) {
                const functionStart = _base.state.start;
                // peek ahead and see if next token is a function
                const snapshot = _base.state.snapshot();
                (0, _tokenizer.next)();
                if ((0, _tokenizer.match)(_types.TokenType._function) && !(0, _util.canInsertSemicolon)()) {
                    (0, _util.expect)(_types.TokenType._function);
                    parseFunction(functionStart, true);
                    return;
                } else _base.state.restoreFromSnapshot(snapshot);
            } else if (_base.state.contextualKeyword === _keywords.ContextualKeyword._using && !(0, _util.hasFollowingLineBreak)() && // Statements like `using[0]` and `using in foo` aren't actual using
            // declarations.
            (0, _tokenizer.lookaheadType)() === _types.TokenType.name) {
                parseVarStatement(true);
                return;
            } else if (startsAwaitUsing()) {
                (0, _util.expectContextual)(_keywords.ContextualKeyword._await);
                parseVarStatement(true);
                return;
            }
        default:
            break;
    }
    // If the statement does not start with a statement keyword or a
    // brace, it's an ExpressionStatement or LabeledStatement. We
    // simply start parsing an expression, and afterwards, if the
    // next token is a colon and the expression was a simple
    // Identifier node, we switch to interpreting it as a label.
    const initialTokensLength = _base.state.tokens.length;
    (0, _expression.parseExpression)();
    let simpleName = null;
    if (_base.state.tokens.length === initialTokensLength + 1) {
        const token = _base.state.tokens[_base.state.tokens.length - 1];
        if (token.type === _types.TokenType.name) simpleName = token.contextualKeyword;
    }
    if (simpleName == null) {
        (0, _util.semicolon)();
        return;
    }
    if ((0, _tokenizer.eat)(_types.TokenType.colon)) parseLabeledStatement();
    else // This was an identifier, so we might want to handle flow/typescript-specific cases.
    parseIdentifierStatement(simpleName);
}
/**
 * Determine if we're positioned at an `await using` declaration.
 *
 * Note that this can happen either in place of a regular variable declaration
 * or in a loop body, and in both places, there are similar-looking cases where
 * we need to return false.
 *
 * Examples returning true:
 * await using foo = bar();
 * for (await using a of b) {}
 *
 * Examples returning false:
 * await using
 * await using + 1
 * await using instanceof T
 * for (await using;;) {}
 *
 * For now, we early return if we don't see `await`, then do a simple
 * backtracking-based lookahead for the `using` and identifier tokens. In the
 * future, this could be optimized with a character-based approach.
 */ function startsAwaitUsing() {
    if (!(0, _util.isContextual)(_keywords.ContextualKeyword._await)) return false;
    const snapshot = _base.state.snapshot();
    // await
    (0, _tokenizer.next)();
    if (!(0, _util.isContextual)(_keywords.ContextualKeyword._using) || (0, _util.hasPrecedingLineBreak)()) {
        _base.state.restoreFromSnapshot(snapshot);
        return false;
    }
    // using
    (0, _tokenizer.next)();
    if (!(0, _tokenizer.match)(_types.TokenType.name) || (0, _util.hasPrecedingLineBreak)()) {
        _base.state.restoreFromSnapshot(snapshot);
        return false;
    }
    _base.state.restoreFromSnapshot(snapshot);
    return true;
}
function parseDecorators() {
    while((0, _tokenizer.match)(_types.TokenType.at))parseDecorator();
}
function parseDecorator() {
    (0, _tokenizer.next)();
    if ((0, _tokenizer.eat)(_types.TokenType.parenL)) {
        (0, _expression.parseExpression)();
        (0, _util.expect)(_types.TokenType.parenR);
    } else {
        (0, _expression.parseIdentifier)();
        while((0, _tokenizer.eat)(_types.TokenType.dot))(0, _expression.parseIdentifier)();
        parseMaybeDecoratorArguments();
    }
}
function parseMaybeDecoratorArguments() {
    if (_base.isTypeScriptEnabled) (0, _typescript.tsParseMaybeDecoratorArguments)();
    else baseParseMaybeDecoratorArguments();
}
function baseParseMaybeDecoratorArguments() {
    if ((0, _tokenizer.eat)(_types.TokenType.parenL)) (0, _expression.parseCallExpressionArguments)();
}
function parseBreakContinueStatement() {
    (0, _tokenizer.next)();
    if (!(0, _util.isLineTerminator)()) {
        (0, _expression.parseIdentifier)();
        (0, _util.semicolon)();
    }
}
function parseDebuggerStatement() {
    (0, _tokenizer.next)();
    (0, _util.semicolon)();
}
function parseDoStatement() {
    (0, _tokenizer.next)();
    parseStatement(false);
    (0, _util.expect)(_types.TokenType._while);
    (0, _expression.parseParenExpression)();
    (0, _tokenizer.eat)(_types.TokenType.semi);
}
function parseForStatement() {
    _base.state.scopeDepth++;
    const startTokenIndex = _base.state.tokens.length;
    parseAmbiguousForStatement();
    const endTokenIndex = _base.state.tokens.length;
    _base.state.scopes.push(new _state.Scope(startTokenIndex, endTokenIndex, false));
    _base.state.scopeDepth--;
}
/**
 * Determine if this token is a `using` declaration (explicit resource
 * management) as part of a loop.
 * https://github.com/tc39/proposal-explicit-resource-management
 */ function isUsingInLoop() {
    if (!(0, _util.isContextual)(_keywords.ContextualKeyword._using)) return false;
    // This must be `for (using of`, where `using` is the name of the loop
    // variable.
    if ((0, _util.isLookaheadContextual)(_keywords.ContextualKeyword._of)) return false;
    return true;
}
// Disambiguating between a `for` and a `for`/`in` or `for`/`of`
// loop is non-trivial. Basically, we have to parse the init `var`
// statement or expression, disallowing the `in` operator (see
// the second parameter to `parseExpression`), and then check
// whether the next token is `in` or `of`. When there is no init
// part (semicolon immediately after the opening parenthesis), it
// is a regular `for` loop.
function parseAmbiguousForStatement() {
    (0, _tokenizer.next)();
    let forAwait = false;
    if ((0, _util.isContextual)(_keywords.ContextualKeyword._await)) {
        forAwait = true;
        (0, _tokenizer.next)();
    }
    (0, _util.expect)(_types.TokenType.parenL);
    if ((0, _tokenizer.match)(_types.TokenType.semi)) {
        if (forAwait) (0, _util.unexpected)();
        parseFor();
        return;
    }
    const isAwaitUsing = startsAwaitUsing();
    if (isAwaitUsing || (0, _tokenizer.match)(_types.TokenType._var) || (0, _tokenizer.match)(_types.TokenType._let) || (0, _tokenizer.match)(_types.TokenType._const) || isUsingInLoop()) {
        if (isAwaitUsing) (0, _util.expectContextual)(_keywords.ContextualKeyword._await);
        (0, _tokenizer.next)();
        parseVar(true, _base.state.type !== _types.TokenType._var);
        if ((0, _tokenizer.match)(_types.TokenType._in) || (0, _util.isContextual)(_keywords.ContextualKeyword._of)) {
            parseForIn(forAwait);
            return;
        }
        parseFor();
        return;
    }
    (0, _expression.parseExpression)(true);
    if ((0, _tokenizer.match)(_types.TokenType._in) || (0, _util.isContextual)(_keywords.ContextualKeyword._of)) {
        parseForIn(forAwait);
        return;
    }
    if (forAwait) (0, _util.unexpected)();
    parseFor();
}
function parseFunctionStatement() {
    const functionStart = _base.state.start;
    (0, _tokenizer.next)();
    parseFunction(functionStart, true);
}
function parseIfStatement() {
    (0, _tokenizer.next)();
    (0, _expression.parseParenExpression)();
    parseStatement(false);
    if ((0, _tokenizer.eat)(_types.TokenType._else)) parseStatement(false);
}
function parseReturnStatement() {
    (0, _tokenizer.next)();
    // In `return` (and `break`/`continue`), the keywords with
    // optional arguments, we eagerly look for a semicolon or the
    // possibility to insert one.
    if (!(0, _util.isLineTerminator)()) {
        (0, _expression.parseExpression)();
        (0, _util.semicolon)();
    }
}
function parseSwitchStatement() {
    (0, _tokenizer.next)();
    (0, _expression.parseParenExpression)();
    _base.state.scopeDepth++;
    const startTokenIndex = _base.state.tokens.length;
    (0, _util.expect)(_types.TokenType.braceL);
    // Don't bother validation; just go through any sequence of cases, defaults, and statements.
    while(!(0, _tokenizer.match)(_types.TokenType.braceR) && !_base.state.error)if ((0, _tokenizer.match)(_types.TokenType._case) || (0, _tokenizer.match)(_types.TokenType._default)) {
        const isCase = (0, _tokenizer.match)(_types.TokenType._case);
        (0, _tokenizer.next)();
        if (isCase) (0, _expression.parseExpression)();
        (0, _util.expect)(_types.TokenType.colon);
    } else parseStatement(true);
    (0, _tokenizer.next)(); // Closing brace
    const endTokenIndex = _base.state.tokens.length;
    _base.state.scopes.push(new _state.Scope(startTokenIndex, endTokenIndex, false));
    _base.state.scopeDepth--;
}
function parseThrowStatement() {
    (0, _tokenizer.next)();
    (0, _expression.parseExpression)();
    (0, _util.semicolon)();
}
function parseCatchClauseParam() {
    (0, _lval.parseBindingAtom)(true);
    if (_base.isTypeScriptEnabled) (0, _typescript.tsTryParseTypeAnnotation)();
}
function parseTryStatement() {
    (0, _tokenizer.next)();
    parseBlock();
    if ((0, _tokenizer.match)(_types.TokenType._catch)) {
        (0, _tokenizer.next)();
        let catchBindingStartTokenIndex = null;
        if ((0, _tokenizer.match)(_types.TokenType.parenL)) {
            _base.state.scopeDepth++;
            catchBindingStartTokenIndex = _base.state.tokens.length;
            (0, _util.expect)(_types.TokenType.parenL);
            parseCatchClauseParam();
            (0, _util.expect)(_types.TokenType.parenR);
        }
        parseBlock();
        if (catchBindingStartTokenIndex != null) {
            // We need a special scope for the catch binding which includes the binding itself and the
            // catch block.
            const endTokenIndex = _base.state.tokens.length;
            _base.state.scopes.push(new _state.Scope(catchBindingStartTokenIndex, endTokenIndex, false));
            _base.state.scopeDepth--;
        }
    }
    if ((0, _tokenizer.eat)(_types.TokenType._finally)) parseBlock();
}
function parseVarStatement(isBlockScope) {
    (0, _tokenizer.next)();
    parseVar(false, isBlockScope);
    (0, _util.semicolon)();
}
function parseWhileStatement() {
    (0, _tokenizer.next)();
    (0, _expression.parseParenExpression)();
    parseStatement(false);
}
function parseEmptyStatement() {
    (0, _tokenizer.next)();
}
function parseLabeledStatement() {
    parseStatement(true);
}
/**
 * Parse a statement starting with an identifier of the given name. Subclasses match on the name
 * to handle statements like "declare".
 */ function parseIdentifierStatement(contextualKeyword) {
    if (_base.isTypeScriptEnabled) (0, _typescript.tsParseIdentifierStatement)(contextualKeyword);
    else if (_base.isFlowEnabled) (0, _flow.flowParseIdentifierStatement)(contextualKeyword);
    else (0, _util.semicolon)();
}
function parseBlock(isFunctionScope = false, contextId = 0) {
    const startTokenIndex = _base.state.tokens.length;
    _base.state.scopeDepth++;
    (0, _util.expect)(_types.TokenType.braceL);
    if (contextId) _base.state.tokens[_base.state.tokens.length - 1].contextId = contextId;
    parseBlockBody(_types.TokenType.braceR);
    if (contextId) _base.state.tokens[_base.state.tokens.length - 1].contextId = contextId;
    const endTokenIndex = _base.state.tokens.length;
    _base.state.scopes.push(new _state.Scope(startTokenIndex, endTokenIndex, isFunctionScope));
    _base.state.scopeDepth--;
}
function parseBlockBody(end) {
    while(!(0, _tokenizer.eat)(end) && !_base.state.error)parseStatement(true);
}
// Parse a regular `for` loop. The disambiguation code in
// `parseStatement` will already have parsed the init statement or
// expression.
function parseFor() {
    (0, _util.expect)(_types.TokenType.semi);
    if (!(0, _tokenizer.match)(_types.TokenType.semi)) (0, _expression.parseExpression)();
    (0, _util.expect)(_types.TokenType.semi);
    if (!(0, _tokenizer.match)(_types.TokenType.parenR)) (0, _expression.parseExpression)();
    (0, _util.expect)(_types.TokenType.parenR);
    parseStatement(false);
}
// Parse a `for`/`in` and `for`/`of` loop, which are almost
// same from parser's perspective.
function parseForIn(forAwait) {
    if (forAwait) (0, _util.eatContextual)(_keywords.ContextualKeyword._of);
    else (0, _tokenizer.next)();
    (0, _expression.parseExpression)();
    (0, _util.expect)(_types.TokenType.parenR);
    parseStatement(false);
}
// Parse a list of variable declarations.
function parseVar(isFor, isBlockScope) {
    while(true){
        parseVarHead(isBlockScope);
        if ((0, _tokenizer.eat)(_types.TokenType.eq)) {
            const eqIndex = _base.state.tokens.length - 1;
            (0, _expression.parseMaybeAssign)(isFor);
            _base.state.tokens[eqIndex].rhsEndIndex = _base.state.tokens.length;
        }
        if (!(0, _tokenizer.eat)(_types.TokenType.comma)) break;
    }
}
function parseVarHead(isBlockScope) {
    (0, _lval.parseBindingAtom)(isBlockScope);
    if (_base.isTypeScriptEnabled) (0, _typescript.tsAfterParseVarHead)();
    else if (_base.isFlowEnabled) (0, _flow.flowAfterParseVarHead)();
}
function parseFunction(functionStart, isStatement, optionalId = false) {
    if ((0, _tokenizer.match)(_types.TokenType.star)) (0, _tokenizer.next)();
    if (isStatement && !optionalId && !(0, _tokenizer.match)(_types.TokenType.name) && !(0, _tokenizer.match)(_types.TokenType._yield)) (0, _util.unexpected)();
    let nameScopeStartTokenIndex = null;
    if ((0, _tokenizer.match)(_types.TokenType.name)) {
        // Expression-style functions should limit their name's scope to the function body, so we make
        // a new function scope to enforce that.
        if (!isStatement) {
            nameScopeStartTokenIndex = _base.state.tokens.length;
            _base.state.scopeDepth++;
        }
        (0, _lval.parseBindingIdentifier)(false);
    }
    const startTokenIndex = _base.state.tokens.length;
    _base.state.scopeDepth++;
    parseFunctionParams();
    (0, _expression.parseFunctionBodyAndFinish)(functionStart);
    const endTokenIndex = _base.state.tokens.length;
    // In addition to the block scope of the function body, we need a separate function-style scope
    // that includes the params.
    _base.state.scopes.push(new _state.Scope(startTokenIndex, endTokenIndex, true));
    _base.state.scopeDepth--;
    if (nameScopeStartTokenIndex !== null) {
        _base.state.scopes.push(new _state.Scope(nameScopeStartTokenIndex, endTokenIndex, true));
        _base.state.scopeDepth--;
    }
}
function parseFunctionParams(allowModifiers = false, funcContextId = 0) {
    if (_base.isTypeScriptEnabled) (0, _typescript.tsStartParseFunctionParams)();
    else if (_base.isFlowEnabled) (0, _flow.flowStartParseFunctionParams)();
    (0, _util.expect)(_types.TokenType.parenL);
    if (funcContextId) _base.state.tokens[_base.state.tokens.length - 1].contextId = funcContextId;
    (0, _lval.parseBindingList)(_types.TokenType.parenR, false, false, allowModifiers, funcContextId);
    if (funcContextId) _base.state.tokens[_base.state.tokens.length - 1].contextId = funcContextId;
}
function parseClass(isStatement, optionalId = false) {
    // Put a context ID on the class keyword, the open-brace, and the close-brace, so that later
    // code can easily navigate to meaningful points on the class.
    const contextId = (0, _base.getNextContextId)();
    (0, _tokenizer.next)();
    _base.state.tokens[_base.state.tokens.length - 1].contextId = contextId;
    _base.state.tokens[_base.state.tokens.length - 1].isExpression = !isStatement;
    // Like with functions, we declare a special "name scope" from the start of the name to the end
    // of the class, but only with expression-style classes, to represent the fact that the name is
    // available to the body of the class but not an outer declaration.
    let nameScopeStartTokenIndex = null;
    if (!isStatement) {
        nameScopeStartTokenIndex = _base.state.tokens.length;
        _base.state.scopeDepth++;
    }
    parseClassId(isStatement, optionalId);
    parseClassSuper();
    const openBraceIndex = _base.state.tokens.length;
    parseClassBody(contextId);
    if (_base.state.error) return;
    _base.state.tokens[openBraceIndex].contextId = contextId;
    _base.state.tokens[_base.state.tokens.length - 1].contextId = contextId;
    if (nameScopeStartTokenIndex !== null) {
        const endTokenIndex = _base.state.tokens.length;
        _base.state.scopes.push(new _state.Scope(nameScopeStartTokenIndex, endTokenIndex, false));
        _base.state.scopeDepth--;
    }
}
function isClassProperty() {
    return (0, _tokenizer.match)(_types.TokenType.eq) || (0, _tokenizer.match)(_types.TokenType.semi) || (0, _tokenizer.match)(_types.TokenType.braceR) || (0, _tokenizer.match)(_types.TokenType.bang) || (0, _tokenizer.match)(_types.TokenType.colon);
}
function isClassMethod() {
    return (0, _tokenizer.match)(_types.TokenType.parenL) || (0, _tokenizer.match)(_types.TokenType.lessThan);
}
function parseClassBody(classContextId) {
    (0, _util.expect)(_types.TokenType.braceL);
    while(!(0, _tokenizer.eat)(_types.TokenType.braceR) && !_base.state.error){
        if ((0, _tokenizer.eat)(_types.TokenType.semi)) continue;
        if ((0, _tokenizer.match)(_types.TokenType.at)) {
            parseDecorator();
            continue;
        }
        const memberStart = _base.state.start;
        parseClassMember(memberStart, classContextId);
    }
}
function parseClassMember(memberStart, classContextId) {
    if (_base.isTypeScriptEnabled) (0, _typescript.tsParseModifiers)([
        _keywords.ContextualKeyword._declare,
        _keywords.ContextualKeyword._public,
        _keywords.ContextualKeyword._protected,
        _keywords.ContextualKeyword._private,
        _keywords.ContextualKeyword._override
    ]);
    let isStatic = false;
    if ((0, _tokenizer.match)(_types.TokenType.name) && _base.state.contextualKeyword === _keywords.ContextualKeyword._static) {
        (0, _expression.parseIdentifier)(); // eats 'static'
        if (isClassMethod()) {
            parseClassMethod(memberStart, /* isConstructor */ false);
            return;
        } else if (isClassProperty()) {
            parseClassProperty();
            return;
        }
        // otherwise something static
        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._static;
        isStatic = true;
        if ((0, _tokenizer.match)(_types.TokenType.braceL)) {
            // This is a static block. Mark the word "static" with the class context ID for class element
            // detection and parse as a regular block.
            _base.state.tokens[_base.state.tokens.length - 1].contextId = classContextId;
            parseBlock();
            return;
        }
    }
    parseClassMemberWithIsStatic(memberStart, isStatic, classContextId);
}
function parseClassMemberWithIsStatic(memberStart, isStatic, classContextId) {
    if (_base.isTypeScriptEnabled) {
        if ((0, _typescript.tsTryParseClassMemberWithIsStatic)(isStatic)) return;
    }
    if ((0, _tokenizer.eat)(_types.TokenType.star)) {
        // a generator
        parseClassPropertyName(classContextId);
        parseClassMethod(memberStart, /* isConstructor */ false);
        return;
    }
    // Get the identifier name so we can tell if it's actually a keyword like "async", "get", or
    // "set".
    parseClassPropertyName(classContextId);
    let isConstructor = false;
    const token = _base.state.tokens[_base.state.tokens.length - 1];
    // We allow "constructor" as either an identifier or a string.
    if (token.contextualKeyword === _keywords.ContextualKeyword._constructor) isConstructor = true;
    parsePostMemberNameModifiers();
    if (isClassMethod()) parseClassMethod(memberStart, isConstructor);
    else if (isClassProperty()) parseClassProperty();
    else if (token.contextualKeyword === _keywords.ContextualKeyword._async && !(0, _util.isLineTerminator)()) {
        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._async;
        // an async method
        const isGenerator = (0, _tokenizer.match)(_types.TokenType.star);
        if (isGenerator) (0, _tokenizer.next)();
        // The so-called parsed name would have been "async": get the real name.
        parseClassPropertyName(classContextId);
        parsePostMemberNameModifiers();
        parseClassMethod(memberStart, false);
    } else if ((token.contextualKeyword === _keywords.ContextualKeyword._get || token.contextualKeyword === _keywords.ContextualKeyword._set) && !((0, _util.isLineTerminator)() && (0, _tokenizer.match)(_types.TokenType.star))) {
        if (token.contextualKeyword === _keywords.ContextualKeyword._get) _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._get;
        else _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._set;
        // `get\n*` is an uninitialized property named 'get' followed by a generator.
        // a getter or setter
        // The so-called parsed name would have been "get/set": get the real name.
        parseClassPropertyName(classContextId);
        parseClassMethod(memberStart, /* isConstructor */ false);
    } else if (token.contextualKeyword === _keywords.ContextualKeyword._accessor && !(0, _util.isLineTerminator)()) {
        parseClassPropertyName(classContextId);
        parseClassProperty();
    } else if ((0, _util.isLineTerminator)()) // an uninitialized class property (due to ASI, since we don't otherwise recognize the next token)
    parseClassProperty();
    else (0, _util.unexpected)();
}
function parseClassMethod(functionStart, isConstructor) {
    if (_base.isTypeScriptEnabled) (0, _typescript.tsTryParseTypeParameters)();
    else if (_base.isFlowEnabled) {
        if ((0, _tokenizer.match)(_types.TokenType.lessThan)) (0, _flow.flowParseTypeParameterDeclaration)();
    }
    (0, _expression.parseMethod)(functionStart, isConstructor);
}
function parseClassPropertyName(classContextId) {
    (0, _expression.parsePropertyName)(classContextId);
}
function parsePostMemberNameModifiers() {
    if (_base.isTypeScriptEnabled) {
        const oldIsType = (0, _tokenizer.pushTypeContext)(0);
        (0, _tokenizer.eat)(_types.TokenType.question);
        (0, _tokenizer.popTypeContext)(oldIsType);
    }
}
function parseClassProperty() {
    if (_base.isTypeScriptEnabled) {
        (0, _tokenizer.eatTypeToken)(_types.TokenType.bang);
        (0, _typescript.tsTryParseTypeAnnotation)();
    } else if (_base.isFlowEnabled) {
        if ((0, _tokenizer.match)(_types.TokenType.colon)) (0, _flow.flowParseTypeAnnotation)();
    }
    if ((0, _tokenizer.match)(_types.TokenType.eq)) {
        const equalsTokenIndex = _base.state.tokens.length;
        (0, _tokenizer.next)();
        (0, _expression.parseMaybeAssign)();
        _base.state.tokens[equalsTokenIndex].rhsEndIndex = _base.state.tokens.length;
    }
    (0, _util.semicolon)();
}
function parseClassId(isStatement, optionalId = false) {
    if (_base.isTypeScriptEnabled && (!isStatement || optionalId) && (0, _util.isContextual)(_keywords.ContextualKeyword._implements)) return;
    if ((0, _tokenizer.match)(_types.TokenType.name)) (0, _lval.parseBindingIdentifier)(true);
    if (_base.isTypeScriptEnabled) (0, _typescript.tsTryParseTypeParameters)();
    else if (_base.isFlowEnabled) {
        if ((0, _tokenizer.match)(_types.TokenType.lessThan)) (0, _flow.flowParseTypeParameterDeclaration)();
    }
}
// Returns true if there was a superclass.
function parseClassSuper() {
    let hasSuper = false;
    if ((0, _tokenizer.eat)(_types.TokenType._extends)) {
        (0, _expression.parseExprSubscripts)();
        hasSuper = true;
    } else hasSuper = false;
    if (_base.isTypeScriptEnabled) (0, _typescript.tsAfterParseClassSuper)(hasSuper);
    else if (_base.isFlowEnabled) (0, _flow.flowAfterParseClassSuper)(hasSuper);
}
function parseExport() {
    const exportIndex = _base.state.tokens.length - 1;
    if (_base.isTypeScriptEnabled) {
        if ((0, _typescript.tsTryParseExport)()) return;
    }
    // export * from '...'
    if (shouldParseExportStar()) parseExportStar();
    else if (isExportDefaultSpecifier()) {
        // export default from
        (0, _expression.parseIdentifier)();
        if ((0, _tokenizer.match)(_types.TokenType.comma) && (0, _tokenizer.lookaheadType)() === _types.TokenType.star) {
            (0, _util.expect)(_types.TokenType.comma);
            (0, _util.expect)(_types.TokenType.star);
            (0, _util.expectContextual)(_keywords.ContextualKeyword._as);
            (0, _expression.parseIdentifier)();
        } else parseExportSpecifiersMaybe();
        parseExportFrom();
    } else if ((0, _tokenizer.eat)(_types.TokenType._default)) // export default ...
    parseExportDefaultExpression();
    else if (shouldParseExportDeclaration()) parseExportDeclaration();
    else {
        // export { x, y as z } [from '...']
        parseExportSpecifiers();
        parseExportFrom();
    }
    _base.state.tokens[exportIndex].rhsEndIndex = _base.state.tokens.length;
}
function parseExportDefaultExpression() {
    if (_base.isTypeScriptEnabled) {
        if ((0, _typescript.tsTryParseExportDefaultExpression)()) return;
    }
    if (_base.isFlowEnabled) {
        if ((0, _flow.flowTryParseExportDefaultExpression)()) return;
    }
    const functionStart = _base.state.start;
    if ((0, _tokenizer.eat)(_types.TokenType._function)) parseFunction(functionStart, true, true);
    else if ((0, _util.isContextual)(_keywords.ContextualKeyword._async) && (0, _tokenizer.lookaheadType)() === _types.TokenType._function) {
        // async function declaration
        (0, _util.eatContextual)(_keywords.ContextualKeyword._async);
        (0, _tokenizer.eat)(_types.TokenType._function);
        parseFunction(functionStart, true, true);
    } else if ((0, _tokenizer.match)(_types.TokenType._class)) parseClass(true, true);
    else if ((0, _tokenizer.match)(_types.TokenType.at)) {
        parseDecorators();
        parseClass(true, true);
    } else {
        (0, _expression.parseMaybeAssign)();
        (0, _util.semicolon)();
    }
}
function parseExportDeclaration() {
    if (_base.isTypeScriptEnabled) (0, _typescript.tsParseExportDeclaration)();
    else if (_base.isFlowEnabled) (0, _flow.flowParseExportDeclaration)();
    else parseStatement(true);
}
function isExportDefaultSpecifier() {
    if (_base.isTypeScriptEnabled && (0, _typescript.tsIsDeclarationStart)()) return false;
    else if (_base.isFlowEnabled && (0, _flow.flowShouldDisallowExportDefaultSpecifier)()) return false;
    if ((0, _tokenizer.match)(_types.TokenType.name)) return _base.state.contextualKeyword !== _keywords.ContextualKeyword._async;
    if (!(0, _tokenizer.match)(_types.TokenType._default)) return false;
    const _next = (0, _tokenizer.nextTokenStart)();
    const lookahead = (0, _tokenizer.lookaheadTypeAndKeyword)();
    const hasFrom = lookahead.type === _types.TokenType.name && lookahead.contextualKeyword === _keywords.ContextualKeyword._from;
    if (lookahead.type === _types.TokenType.comma) return true;
    // lookahead again when `export default from` is seen
    if (hasFrom) {
        const nextAfterFrom = _base.input.charCodeAt((0, _tokenizer.nextTokenStartSince)(_next + 4));
        return nextAfterFrom === _charcodes.charCodes.quotationMark || nextAfterFrom === _charcodes.charCodes.apostrophe;
    }
    return false;
}
function parseExportSpecifiersMaybe() {
    if ((0, _tokenizer.eat)(_types.TokenType.comma)) parseExportSpecifiers();
}
function parseExportFrom() {
    if ((0, _util.eatContextual)(_keywords.ContextualKeyword._from)) {
        (0, _expression.parseExprAtom)();
        maybeParseImportAttributes();
    }
    (0, _util.semicolon)();
}
function shouldParseExportStar() {
    if (_base.isFlowEnabled) return (0, _flow.flowShouldParseExportStar)();
    else return (0, _tokenizer.match)(_types.TokenType.star);
}
function parseExportStar() {
    if (_base.isFlowEnabled) (0, _flow.flowParseExportStar)();
    else baseParseExportStar();
}
function baseParseExportStar() {
    (0, _util.expect)(_types.TokenType.star);
    if ((0, _util.isContextual)(_keywords.ContextualKeyword._as)) parseExportNamespace();
    else parseExportFrom();
}
function parseExportNamespace() {
    (0, _tokenizer.next)();
    _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._as;
    (0, _expression.parseIdentifier)();
    parseExportSpecifiersMaybe();
    parseExportFrom();
}
function shouldParseExportDeclaration() {
    return _base.isTypeScriptEnabled && (0, _typescript.tsIsDeclarationStart)() || _base.isFlowEnabled && (0, _flow.flowShouldParseExportDeclaration)() || _base.state.type === _types.TokenType._var || _base.state.type === _types.TokenType._const || _base.state.type === _types.TokenType._let || _base.state.type === _types.TokenType._function || _base.state.type === _types.TokenType._class || (0, _util.isContextual)(_keywords.ContextualKeyword._async) || (0, _tokenizer.match)(_types.TokenType.at);
}
function parseExportSpecifiers() {
    let first = true;
    // export { x, y as z } [from '...']
    (0, _util.expect)(_types.TokenType.braceL);
    while(!(0, _tokenizer.eat)(_types.TokenType.braceR) && !_base.state.error){
        if (first) first = false;
        else {
            (0, _util.expect)(_types.TokenType.comma);
            if ((0, _tokenizer.eat)(_types.TokenType.braceR)) break;
        }
        parseExportSpecifier();
    }
}
function parseExportSpecifier() {
    if (_base.isTypeScriptEnabled) {
        (0, _typescript.tsParseExportSpecifier)();
        return;
    }
    (0, _expression.parseIdentifier)();
    _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _tokenizer.IdentifierRole.ExportAccess;
    if ((0, _util.eatContextual)(_keywords.ContextualKeyword._as)) (0, _expression.parseIdentifier)();
}
/**
 * Starting at the `module` token in an import, determine if it was truly an
 * import reflection token or just looks like one.
 *
 * Returns true for:
 * import module foo from "foo";
 * import module from from "foo";
 *
 * Returns false for:
 * import module from "foo";
 * import module, {bar} from "foo";
 */ function isImportReflection() {
    const snapshot = _base.state.snapshot();
    (0, _util.expectContextual)(_keywords.ContextualKeyword._module);
    if ((0, _util.eatContextual)(_keywords.ContextualKeyword._from)) {
        if ((0, _util.isContextual)(_keywords.ContextualKeyword._from)) {
            _base.state.restoreFromSnapshot(snapshot);
            return true;
        } else {
            _base.state.restoreFromSnapshot(snapshot);
            return false;
        }
    } else if ((0, _tokenizer.match)(_types.TokenType.comma)) {
        _base.state.restoreFromSnapshot(snapshot);
        return false;
    } else {
        _base.state.restoreFromSnapshot(snapshot);
        return true;
    }
}
/**
 * Eat the "module" token from the import reflection proposal.
 * https://github.com/tc39/proposal-import-reflection
 */ function parseMaybeImportReflection() {
    // isImportReflection does snapshot/restore, so only run it if we see the word
    // "module".
    if ((0, _util.isContextual)(_keywords.ContextualKeyword._module) && isImportReflection()) (0, _tokenizer.next)();
}
function parseImport() {
    if (_base.isTypeScriptEnabled && (0, _tokenizer.match)(_types.TokenType.name) && (0, _tokenizer.lookaheadType)() === _types.TokenType.eq) {
        (0, _typescript.tsParseImportEqualsDeclaration)();
        return;
    }
    if (_base.isTypeScriptEnabled && (0, _util.isContextual)(_keywords.ContextualKeyword._type)) {
        const lookahead = (0, _tokenizer.lookaheadTypeAndKeyword)();
        if (lookahead.type === _types.TokenType.name && lookahead.contextualKeyword !== _keywords.ContextualKeyword._from) {
            // One of these `import type` cases:
            // import type T = require('T');
            // import type A from 'A';
            (0, _util.expectContextual)(_keywords.ContextualKeyword._type);
            if ((0, _tokenizer.lookaheadType)() === _types.TokenType.eq) {
                (0, _typescript.tsParseImportEqualsDeclaration)();
                return;
            }
        // If this is an `import type...from` statement, then we already ate the
        // type token, so proceed to the regular import parser.
        } else if (lookahead.type === _types.TokenType.star || lookahead.type === _types.TokenType.braceL) // One of these `import type` cases, in which case we can eat the type token
        // and proceed as normal:
        // import type * as A from 'A';
        // import type {a} from 'A';
        (0, _util.expectContextual)(_keywords.ContextualKeyword._type);
    // Otherwise, we are importing the name "type".
    }
    // import '...'
    if ((0, _tokenizer.match)(_types.TokenType.string)) (0, _expression.parseExprAtom)();
    else {
        parseMaybeImportReflection();
        parseImportSpecifiers();
        (0, _util.expectContextual)(_keywords.ContextualKeyword._from);
        (0, _expression.parseExprAtom)();
    }
    maybeParseImportAttributes();
    (0, _util.semicolon)();
}
// eslint-disable-next-line no-unused-vars
function shouldParseDefaultImport() {
    return (0, _tokenizer.match)(_types.TokenType.name);
}
function parseImportSpecifierLocal() {
    (0, _lval.parseImportedIdentifier)();
}
// Parses a comma-separated list of module imports.
function parseImportSpecifiers() {
    if (_base.isFlowEnabled) (0, _flow.flowStartParseImportSpecifiers)();
    let first = true;
    if (shouldParseDefaultImport()) {
        // import defaultObj, { x, y as z } from '...'
        parseImportSpecifierLocal();
        if (!(0, _tokenizer.eat)(_types.TokenType.comma)) return;
    }
    if ((0, _tokenizer.match)(_types.TokenType.star)) {
        (0, _tokenizer.next)();
        (0, _util.expectContextual)(_keywords.ContextualKeyword._as);
        parseImportSpecifierLocal();
        return;
    }
    (0, _util.expect)(_types.TokenType.braceL);
    while(!(0, _tokenizer.eat)(_types.TokenType.braceR) && !_base.state.error){
        if (first) first = false;
        else {
            // Detect an attempt to deep destructure
            if ((0, _tokenizer.eat)(_types.TokenType.colon)) (0, _util.unexpected)("ES2015 named imports do not destructure. Use another statement for destructuring after the import.");
            (0, _util.expect)(_types.TokenType.comma);
            if ((0, _tokenizer.eat)(_types.TokenType.braceR)) break;
        }
        parseImportSpecifier();
    }
}
function parseImportSpecifier() {
    if (_base.isTypeScriptEnabled) {
        (0, _typescript.tsParseImportSpecifier)();
        return;
    }
    if (_base.isFlowEnabled) {
        (0, _flow.flowParseImportSpecifier)();
        return;
    }
    (0, _lval.parseImportedIdentifier)();
    if ((0, _util.isContextual)(_keywords.ContextualKeyword._as)) {
        _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _tokenizer.IdentifierRole.ImportAccess;
        (0, _tokenizer.next)();
        (0, _lval.parseImportedIdentifier)();
    }
}
/**
 * Parse import attributes like `with {type: "json"}`, or the legacy form
 * `assert {type: "json"}`.
 *
 * Import attributes technically have their own syntax, but are always parseable
 * as a plain JS object, so just do that for simplicity.
 */ function maybeParseImportAttributes() {
    if ((0, _tokenizer.match)(_types.TokenType._with) || (0, _util.isContextual)(_keywords.ContextualKeyword._assert) && !(0, _util.hasPrecedingLineBreak)()) {
        (0, _tokenizer.next)();
        (0, _expression.parseObj)(false, false);
    }
}

},
"node_modules/sucrase/dist/esm/parser/traverser/util.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    canInsertSemicolon: function() {
        return canInsertSemicolon;
    },
    eatContextual: function() {
        return eatContextual;
    },
    expect: function() {
        return expect;
    },
    expectContextual: function() {
        return expectContextual;
    },
    hasFollowingLineBreak: function() {
        return hasFollowingLineBreak;
    },
    hasPrecedingLineBreak: function() {
        return hasPrecedingLineBreak;
    },
    isContextual: function() {
        return isContextual;
    },
    isLineTerminator: function() {
        return isLineTerminator;
    },
    isLookaheadContextual: function() {
        return isLookaheadContextual;
    },
    semicolon: function() {
        return semicolon;
    },
    unexpected: function() {
        return unexpected;
    }
});
var _index = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/index.js");
var _types = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/types.js");
var _charcodes = __mako_require__("node_modules/sucrase/dist/esm/parser/util/charcodes.js");
var _base = __mako_require__("node_modules/sucrase/dist/esm/parser/traverser/base.js");
function isContextual(contextualKeyword) {
    return _base.state.contextualKeyword === contextualKeyword;
}
function isLookaheadContextual(contextualKeyword) {
    const l = (0, _index.lookaheadTypeAndKeyword)();
    return l.type === _types.TokenType.name && l.contextualKeyword === contextualKeyword;
}
function eatContextual(contextualKeyword) {
    return _base.state.contextualKeyword === contextualKeyword && (0, _index.eat)(_types.TokenType.name);
}
function expectContextual(contextualKeyword) {
    if (!eatContextual(contextualKeyword)) unexpected();
}
function canInsertSemicolon() {
    return (0, _index.match)(_types.TokenType.eof) || (0, _index.match)(_types.TokenType.braceR) || hasPrecedingLineBreak();
}
function hasPrecedingLineBreak() {
    const prevToken = _base.state.tokens[_base.state.tokens.length - 1];
    const lastTokEnd = prevToken ? prevToken.end : 0;
    for(let i = lastTokEnd; i < _base.state.start; i++){
        const code = _base.input.charCodeAt(i);
        if (code === _charcodes.charCodes.lineFeed || code === _charcodes.charCodes.carriageReturn || code === 0x2028 || code === 0x2029) return true;
    }
    return false;
}
function hasFollowingLineBreak() {
    const nextStart = (0, _index.nextTokenStart)();
    for(let i = _base.state.end; i < nextStart; i++){
        const code = _base.input.charCodeAt(i);
        if (code === _charcodes.charCodes.lineFeed || code === _charcodes.charCodes.carriageReturn || code === 0x2028 || code === 0x2029) return true;
    }
    return false;
}
function isLineTerminator() {
    return (0, _index.eat)(_types.TokenType.semi) || canInsertSemicolon();
}
function semicolon() {
    if (!isLineTerminator()) unexpected('Unexpected token, expected ";"');
}
function expect(type) {
    const matched = (0, _index.eat)(type);
    if (!matched) unexpected(`Unexpected token, expected "${(0, _types.formatTokenType)(type)}"`);
}
function unexpected(message = "Unexpected token", pos = _base.state.start) {
    if (_base.state.error) return;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const err = new SyntaxError(message);
    err.pos = pos;
    _base.state.error = err;
    _base.state.pos = _base.input.length;
    (0, _index.finishToken)(_types.TokenType.eof);
}

},
"node_modules/sucrase/dist/esm/parser/util/charcodes.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    charCodes: function() {
        return charCodes;
    },
    isDigit: function() {
        return isDigit;
    }
});
var charCodes;
(function(charCodes) {
    const backSpace = 8;
    charCodes[charCodes["backSpace"] = backSpace] = "backSpace";
    const lineFeed = 10;
    charCodes[charCodes["lineFeed"] = lineFeed] = "lineFeed"; //  '\n'
    const tab = 9;
    charCodes[charCodes["tab"] = tab] = "tab"; //  '\t'
    const carriageReturn = 13;
    charCodes[charCodes["carriageReturn"] = carriageReturn] = "carriageReturn"; //  '\r'
    const shiftOut = 14;
    charCodes[charCodes["shiftOut"] = shiftOut] = "shiftOut";
    const space = 32;
    charCodes[charCodes["space"] = space] = "space";
    const exclamationMark = 33;
    charCodes[charCodes["exclamationMark"] = exclamationMark] = "exclamationMark"; //  '!'
    const quotationMark = 34;
    charCodes[charCodes["quotationMark"] = quotationMark] = "quotationMark"; //  '"'
    const numberSign = 35;
    charCodes[charCodes["numberSign"] = numberSign] = "numberSign"; //  '#'
    const dollarSign = 36;
    charCodes[charCodes["dollarSign"] = dollarSign] = "dollarSign"; //  '$'
    const percentSign = 37;
    charCodes[charCodes["percentSign"] = percentSign] = "percentSign"; //  '%'
    const ampersand = 38;
    charCodes[charCodes["ampersand"] = ampersand] = "ampersand"; //  '&'
    const apostrophe = 39;
    charCodes[charCodes["apostrophe"] = apostrophe] = "apostrophe"; //  '''
    const leftParenthesis = 40;
    charCodes[charCodes["leftParenthesis"] = leftParenthesis] = "leftParenthesis"; //  '('
    const rightParenthesis = 41;
    charCodes[charCodes["rightParenthesis"] = rightParenthesis] = "rightParenthesis"; //  ')'
    const asterisk = 42;
    charCodes[charCodes["asterisk"] = asterisk] = "asterisk"; //  '*'
    const plusSign = 43;
    charCodes[charCodes["plusSign"] = plusSign] = "plusSign"; //  '+'
    const comma = 44;
    charCodes[charCodes["comma"] = comma] = "comma"; //  ','
    const dash = 45;
    charCodes[charCodes["dash"] = dash] = "dash"; //  '-'
    const dot = 46;
    charCodes[charCodes["dot"] = dot] = "dot"; //  '.'
    const slash = 47;
    charCodes[charCodes["slash"] = slash] = "slash"; //  '/'
    const digit0 = 48;
    charCodes[charCodes["digit0"] = digit0] = "digit0"; //  '0'
    const digit1 = 49;
    charCodes[charCodes["digit1"] = digit1] = "digit1"; //  '1'
    const digit2 = 50;
    charCodes[charCodes["digit2"] = digit2] = "digit2"; //  '2'
    const digit3 = 51;
    charCodes[charCodes["digit3"] = digit3] = "digit3"; //  '3'
    const digit4 = 52;
    charCodes[charCodes["digit4"] = digit4] = "digit4"; //  '4'
    const digit5 = 53;
    charCodes[charCodes["digit5"] = digit5] = "digit5"; //  '5'
    const digit6 = 54;
    charCodes[charCodes["digit6"] = digit6] = "digit6"; //  '6'
    const digit7 = 55;
    charCodes[charCodes["digit7"] = digit7] = "digit7"; //  '7'
    const digit8 = 56;
    charCodes[charCodes["digit8"] = digit8] = "digit8"; //  '8'
    const digit9 = 57;
    charCodes[charCodes["digit9"] = digit9] = "digit9"; //  '9'
    const colon = 58;
    charCodes[charCodes["colon"] = colon] = "colon"; //  ':'
    const semicolon = 59;
    charCodes[charCodes["semicolon"] = semicolon] = "semicolon"; //  ';'
    const lessThan = 60;
    charCodes[charCodes["lessThan"] = lessThan] = "lessThan"; //  '<'
    const equalsTo = 61;
    charCodes[charCodes["equalsTo"] = equalsTo] = "equalsTo"; //  '='
    const greaterThan = 62;
    charCodes[charCodes["greaterThan"] = greaterThan] = "greaterThan"; //  '>'
    const questionMark = 63;
    charCodes[charCodes["questionMark"] = questionMark] = "questionMark"; //  '?'
    const atSign = 64;
    charCodes[charCodes["atSign"] = atSign] = "atSign"; //  '@'
    const uppercaseA = 65;
    charCodes[charCodes["uppercaseA"] = uppercaseA] = "uppercaseA"; //  'A'
    const uppercaseB = 66;
    charCodes[charCodes["uppercaseB"] = uppercaseB] = "uppercaseB"; //  'B'
    const uppercaseC = 67;
    charCodes[charCodes["uppercaseC"] = uppercaseC] = "uppercaseC"; //  'C'
    const uppercaseD = 68;
    charCodes[charCodes["uppercaseD"] = uppercaseD] = "uppercaseD"; //  'D'
    const uppercaseE = 69;
    charCodes[charCodes["uppercaseE"] = uppercaseE] = "uppercaseE"; //  'E'
    const uppercaseF = 70;
    charCodes[charCodes["uppercaseF"] = uppercaseF] = "uppercaseF"; //  'F'
    const uppercaseG = 71;
    charCodes[charCodes["uppercaseG"] = uppercaseG] = "uppercaseG"; //  'G'
    const uppercaseH = 72;
    charCodes[charCodes["uppercaseH"] = uppercaseH] = "uppercaseH"; //  'H'
    const uppercaseI = 73;
    charCodes[charCodes["uppercaseI"] = uppercaseI] = "uppercaseI"; //  'I'
    const uppercaseJ = 74;
    charCodes[charCodes["uppercaseJ"] = uppercaseJ] = "uppercaseJ"; //  'J'
    const uppercaseK = 75;
    charCodes[charCodes["uppercaseK"] = uppercaseK] = "uppercaseK"; //  'K'
    const uppercaseL = 76;
    charCodes[charCodes["uppercaseL"] = uppercaseL] = "uppercaseL"; //  'L'
    const uppercaseM = 77;
    charCodes[charCodes["uppercaseM"] = uppercaseM] = "uppercaseM"; //  'M'
    const uppercaseN = 78;
    charCodes[charCodes["uppercaseN"] = uppercaseN] = "uppercaseN"; //  'N'
    const uppercaseO = 79;
    charCodes[charCodes["uppercaseO"] = uppercaseO] = "uppercaseO"; //  'O'
    const uppercaseP = 80;
    charCodes[charCodes["uppercaseP"] = uppercaseP] = "uppercaseP"; //  'P'
    const uppercaseQ = 81;
    charCodes[charCodes["uppercaseQ"] = uppercaseQ] = "uppercaseQ"; //  'Q'
    const uppercaseR = 82;
    charCodes[charCodes["uppercaseR"] = uppercaseR] = "uppercaseR"; //  'R'
    const uppercaseS = 83;
    charCodes[charCodes["uppercaseS"] = uppercaseS] = "uppercaseS"; //  'S'
    const uppercaseT = 84;
    charCodes[charCodes["uppercaseT"] = uppercaseT] = "uppercaseT"; //  'T'
    const uppercaseU = 85;
    charCodes[charCodes["uppercaseU"] = uppercaseU] = "uppercaseU"; //  'U'
    const uppercaseV = 86;
    charCodes[charCodes["uppercaseV"] = uppercaseV] = "uppercaseV"; //  'V'
    const uppercaseW = 87;
    charCodes[charCodes["uppercaseW"] = uppercaseW] = "uppercaseW"; //  'W'
    const uppercaseX = 88;
    charCodes[charCodes["uppercaseX"] = uppercaseX] = "uppercaseX"; //  'X'
    const uppercaseY = 89;
    charCodes[charCodes["uppercaseY"] = uppercaseY] = "uppercaseY"; //  'Y'
    const uppercaseZ = 90;
    charCodes[charCodes["uppercaseZ"] = uppercaseZ] = "uppercaseZ"; //  'Z'
    const leftSquareBracket = 91;
    charCodes[charCodes["leftSquareBracket"] = leftSquareBracket] = "leftSquareBracket"; //  '['
    const backslash = 92;
    charCodes[charCodes["backslash"] = backslash] = "backslash"; //  '\    '
    const rightSquareBracket = 93;
    charCodes[charCodes["rightSquareBracket"] = rightSquareBracket] = "rightSquareBracket"; //  ']'
    const caret = 94;
    charCodes[charCodes["caret"] = caret] = "caret"; //  '^'
    const underscore = 95;
    charCodes[charCodes["underscore"] = underscore] = "underscore"; //  '_'
    const graveAccent = 96;
    charCodes[charCodes["graveAccent"] = graveAccent] = "graveAccent"; //  '`'
    const lowercaseA = 97;
    charCodes[charCodes["lowercaseA"] = lowercaseA] = "lowercaseA"; //  'a'
    const lowercaseB = 98;
    charCodes[charCodes["lowercaseB"] = lowercaseB] = "lowercaseB"; //  'b'
    const lowercaseC = 99;
    charCodes[charCodes["lowercaseC"] = lowercaseC] = "lowercaseC"; //  'c'
    const lowercaseD = 100;
    charCodes[charCodes["lowercaseD"] = lowercaseD] = "lowercaseD"; //  'd'
    const lowercaseE = 101;
    charCodes[charCodes["lowercaseE"] = lowercaseE] = "lowercaseE"; //  'e'
    const lowercaseF = 102;
    charCodes[charCodes["lowercaseF"] = lowercaseF] = "lowercaseF"; //  'f'
    const lowercaseG = 103;
    charCodes[charCodes["lowercaseG"] = lowercaseG] = "lowercaseG"; //  'g'
    const lowercaseH = 104;
    charCodes[charCodes["lowercaseH"] = lowercaseH] = "lowercaseH"; //  'h'
    const lowercaseI = 105;
    charCodes[charCodes["lowercaseI"] = lowercaseI] = "lowercaseI"; //  'i'
    const lowercaseJ = 106;
    charCodes[charCodes["lowercaseJ"] = lowercaseJ] = "lowercaseJ"; //  'j'
    const lowercaseK = 107;
    charCodes[charCodes["lowercaseK"] = lowercaseK] = "lowercaseK"; //  'k'
    const lowercaseL = 108;
    charCodes[charCodes["lowercaseL"] = lowercaseL] = "lowercaseL"; //  'l'
    const lowercaseM = 109;
    charCodes[charCodes["lowercaseM"] = lowercaseM] = "lowercaseM"; //  'm'
    const lowercaseN = 110;
    charCodes[charCodes["lowercaseN"] = lowercaseN] = "lowercaseN"; //  'n'
    const lowercaseO = 111;
    charCodes[charCodes["lowercaseO"] = lowercaseO] = "lowercaseO"; //  'o'
    const lowercaseP = 112;
    charCodes[charCodes["lowercaseP"] = lowercaseP] = "lowercaseP"; //  'p'
    const lowercaseQ = 113;
    charCodes[charCodes["lowercaseQ"] = lowercaseQ] = "lowercaseQ"; //  'q'
    const lowercaseR = 114;
    charCodes[charCodes["lowercaseR"] = lowercaseR] = "lowercaseR"; //  'r'
    const lowercaseS = 115;
    charCodes[charCodes["lowercaseS"] = lowercaseS] = "lowercaseS"; //  's'
    const lowercaseT = 116;
    charCodes[charCodes["lowercaseT"] = lowercaseT] = "lowercaseT"; //  't'
    const lowercaseU = 117;
    charCodes[charCodes["lowercaseU"] = lowercaseU] = "lowercaseU"; //  'u'
    const lowercaseV = 118;
    charCodes[charCodes["lowercaseV"] = lowercaseV] = "lowercaseV"; //  'v'
    const lowercaseW = 119;
    charCodes[charCodes["lowercaseW"] = lowercaseW] = "lowercaseW"; //  'w'
    const lowercaseX = 120;
    charCodes[charCodes["lowercaseX"] = lowercaseX] = "lowercaseX"; //  'x'
    const lowercaseY = 121;
    charCodes[charCodes["lowercaseY"] = lowercaseY] = "lowercaseY"; //  'y'
    const lowercaseZ = 122;
    charCodes[charCodes["lowercaseZ"] = lowercaseZ] = "lowercaseZ"; //  'z'
    const leftCurlyBrace = 123;
    charCodes[charCodes["leftCurlyBrace"] = leftCurlyBrace] = "leftCurlyBrace"; //  '{'
    const verticalBar = 124;
    charCodes[charCodes["verticalBar"] = verticalBar] = "verticalBar"; //  '|'
    const rightCurlyBrace = 125;
    charCodes[charCodes["rightCurlyBrace"] = rightCurlyBrace] = "rightCurlyBrace"; //  '}'
    const tilde = 126;
    charCodes[charCodes["tilde"] = tilde] = "tilde"; //  '~'
    const nonBreakingSpace = 160;
    charCodes[charCodes["nonBreakingSpace"] = nonBreakingSpace] = "nonBreakingSpace";
    // eslint-disable-next-line no-irregular-whitespace
    const oghamSpaceMark = 5760;
    charCodes[charCodes["oghamSpaceMark"] = oghamSpaceMark] = "oghamSpaceMark"; // ''
    const lineSeparator = 8232;
    charCodes[charCodes["lineSeparator"] = lineSeparator] = "lineSeparator";
    const paragraphSeparator = 8233;
    charCodes[charCodes["paragraphSeparator"] = paragraphSeparator] = "paragraphSeparator";
})(charCodes || (charCodes = {}));
function isDigit(code) {
    return code >= charCodes.digit0 && code <= charCodes.digit9 || code >= charCodes.lowercaseA && code <= charCodes.lowercaseF || code >= charCodes.uppercaseA && code <= charCodes.uppercaseF;
}

},
"node_modules/sucrase/dist/esm/parser/util/identifier.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    IS_IDENTIFIER_CHAR: function() {
        return IS_IDENTIFIER_CHAR;
    },
    IS_IDENTIFIER_START: function() {
        return IS_IDENTIFIER_START;
    }
});
var _charcodes = __mako_require__("node_modules/sucrase/dist/esm/parser/util/charcodes.js");
var _whitespace = __mako_require__("node_modules/sucrase/dist/esm/parser/util/whitespace.js");
function computeIsIdentifierChar(code) {
    if (code < 48) return code === 36;
    if (code < 58) return true;
    if (code < 65) return false;
    if (code < 91) return true;
    if (code < 97) return code === 95;
    if (code < 123) return true;
    if (code < 128) return false;
    throw new Error("Should not be called with non-ASCII char code.");
}
const IS_IDENTIFIER_CHAR = new Uint8Array(65536);
for(let i = 0; i < 128; i++)IS_IDENTIFIER_CHAR[i] = computeIsIdentifierChar(i) ? 1 : 0;
for(let i = 128; i < 65536; i++)IS_IDENTIFIER_CHAR[i] = 1;
// Aside from whitespace and newlines, all characters outside the ASCII space are either
// identifier characters or invalid. Since we're not performing code validation, we can just
// treat all invalid characters as identifier characters.
for (const whitespaceChar of _whitespace.WHITESPACE_CHARS)IS_IDENTIFIER_CHAR[whitespaceChar] = 0;
IS_IDENTIFIER_CHAR[0x2028] = 0;
IS_IDENTIFIER_CHAR[0x2029] = 0;
const IS_IDENTIFIER_START = IS_IDENTIFIER_CHAR.slice();
for(let numChar = _charcodes.charCodes.digit0; numChar <= _charcodes.charCodes.digit9; numChar++)IS_IDENTIFIER_START[numChar] = 0;

},
"node_modules/sucrase/dist/esm/parser/util/whitespace.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    IS_WHITESPACE: function() {
        return IS_WHITESPACE;
    },
    WHITESPACE_CHARS: function() {
        return WHITESPACE_CHARS;
    },
    skipWhiteSpace: function() {
        return skipWhiteSpace;
    }
});
var _charcodes = __mako_require__("node_modules/sucrase/dist/esm/parser/util/charcodes.js");
const WHITESPACE_CHARS = [
    0x0009,
    0x000b,
    0x000c,
    _charcodes.charCodes.space,
    _charcodes.charCodes.nonBreakingSpace,
    _charcodes.charCodes.oghamSpaceMark,
    0x2000,
    0x2001,
    0x2002,
    0x2003,
    0x2004,
    0x2005,
    0x2006,
    0x2007,
    0x2008,
    0x2009,
    0x200a,
    0x202f,
    0x205f,
    0x3000,
    0xfeff
];
const skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
const IS_WHITESPACE = new Uint8Array(65536);
for (const char of WHITESPACE_CHARS)IS_WHITESPACE[char] = 1;

},
"node_modules/sucrase/dist/esm/transformers/CJSImportTransformer.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, /**
 * Class for editing import statements when we are transforming to commonjs.
 */ "default", {
    enumerable: true,
    get: function() {
        return CJSImportTransformer;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _tokenizer = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/index.js");
var _keywords = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/keywords.js");
var _types = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/types.js");
var _elideImportEquals = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/sucrase/dist/esm/util/elideImportEquals.js"));
var _getDeclarationInfo = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/sucrase/dist/esm/util/getDeclarationInfo.js"));
var _getImportExportSpecifierInfo = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/sucrase/dist/esm/util/getImportExportSpecifierInfo.js"));
var _isExportFrom = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/sucrase/dist/esm/util/isExportFrom.js"));
var _removeMaybeImportAttributes = __mako_require__("node_modules/sucrase/dist/esm/util/removeMaybeImportAttributes.js");
var _shouldElideDefaultExport = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/sucrase/dist/esm/util/shouldElideDefaultExport.js"));
var _Transformer = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/sucrase/dist/esm/transformers/Transformer.js"));
class CJSImportTransformer extends _Transformer.default {
    __init() {
        this.hadExport = false;
    }
    __init2() {
        this.hadNamedExport = false;
    }
    __init3() {
        this.hadDefaultExport = false;
    }
    constructor(rootTransformer, tokens, importProcessor, nameManager, helperManager, reactHotLoaderTransformer, enableLegacyBabel5ModuleInterop, enableLegacyTypeScriptModuleInterop, isTypeScriptTransformEnabled, isFlowTransformEnabled, preserveDynamicImport, keepUnusedImports){
        super();
        this.rootTransformer = rootTransformer;
        this.tokens = tokens;
        this.importProcessor = importProcessor;
        this.nameManager = nameManager;
        this.helperManager = helperManager;
        this.reactHotLoaderTransformer = reactHotLoaderTransformer;
        this.enableLegacyBabel5ModuleInterop = enableLegacyBabel5ModuleInterop;
        this.enableLegacyTypeScriptModuleInterop = enableLegacyTypeScriptModuleInterop;
        this.isTypeScriptTransformEnabled = isTypeScriptTransformEnabled;
        this.isFlowTransformEnabled = isFlowTransformEnabled;
        this.preserveDynamicImport = preserveDynamicImport;
        this.keepUnusedImports = keepUnusedImports;
        CJSImportTransformer.prototype.__init.call(this);
        CJSImportTransformer.prototype.__init2.call(this);
        CJSImportTransformer.prototype.__init3.call(this);
        this.declarationInfo = isTypeScriptTransformEnabled ? (0, _getDeclarationInfo.default)(tokens) : _getDeclarationInfo.EMPTY_DECLARATION_INFO;
    }
    getPrefixCode() {
        let prefix = "";
        if (this.hadExport) prefix += 'Object.defineProperty(exports, "__esModule", {value: true});';
        return prefix;
    }
    getSuffixCode() {
        if (this.enableLegacyBabel5ModuleInterop && this.hadDefaultExport && !this.hadNamedExport) return "\nmodule.exports = exports.default;\n";
        return "";
    }
    process() {
        // TypeScript `import foo = require('foo');` should always just be translated to plain require.
        if (this.tokens.matches3(_types.TokenType._import, _types.TokenType.name, _types.TokenType.eq)) return this.processImportEquals();
        if (this.tokens.matches1(_types.TokenType._import)) {
            this.processImport();
            return true;
        }
        if (this.tokens.matches2(_types.TokenType._export, _types.TokenType.eq)) {
            this.tokens.replaceToken("module.exports");
            return true;
        }
        if (this.tokens.matches1(_types.TokenType._export) && !this.tokens.currentToken().isType) {
            this.hadExport = true;
            return this.processExport();
        }
        if (this.tokens.matches2(_types.TokenType.name, _types.TokenType.postIncDec)) {
            // Fall through to normal identifier matching if this doesn't apply.
            if (this.processPostIncDec()) return true;
        }
        if (this.tokens.matches1(_types.TokenType.name) || this.tokens.matches1(_types.TokenType.jsxName)) return this.processIdentifier();
        if (this.tokens.matches1(_types.TokenType.eq)) return this.processAssignment();
        if (this.tokens.matches1(_types.TokenType.assign)) return this.processComplexAssignment();
        if (this.tokens.matches1(_types.TokenType.preIncDec)) return this.processPreIncDec();
        return false;
    }
    processImportEquals() {
        const importName = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);
        if (this.importProcessor.shouldAutomaticallyElideImportedName(importName)) // If this name is only used as a type, elide the whole import.
        (0, _elideImportEquals.default)(this.tokens);
        else // Otherwise, switch `import` to `const`.
        this.tokens.replaceToken("const");
        return true;
    }
    /**
   * Transform this:
   * import foo, {bar} from 'baz';
   * into
   * var _baz = require('baz'); var _baz2 = _interopRequireDefault(_baz);
   *
   * The import code was already generated in the import preprocessing step, so
   * we just need to look it up.
   */ processImport() {
        if (this.tokens.matches2(_types.TokenType._import, _types.TokenType.parenL)) {
            if (this.preserveDynamicImport) {
                // Bail out, only making progress for this one token.
                this.tokens.copyToken();
                return;
            }
            const requireWrapper = this.enableLegacyTypeScriptModuleInterop ? "" : `${this.helperManager.getHelperName("interopRequireWildcard")}(`;
            this.tokens.replaceToken(`Promise.resolve().then(() => ${requireWrapper}require`);
            const contextId = this.tokens.currentToken().contextId;
            if (contextId == null) throw new Error("Expected context ID on dynamic import invocation.");
            this.tokens.copyToken();
            while(!this.tokens.matchesContextIdAndLabel(_types.TokenType.parenR, contextId))this.rootTransformer.processToken();
            this.tokens.replaceToken(requireWrapper ? ")))" : "))");
            return;
        }
        const shouldElideImport = this.removeImportAndDetectIfShouldElide();
        if (shouldElideImport) this.tokens.removeToken();
        else {
            const path = this.tokens.stringValue();
            this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(path));
            this.tokens.appendCode(this.importProcessor.claimImportCode(path));
        }
        (0, _removeMaybeImportAttributes.removeMaybeImportAttributes)(this.tokens);
        if (this.tokens.matches1(_types.TokenType.semi)) this.tokens.removeToken();
    }
    /**
   * Erase this import (since any CJS output would be completely different), and
   * return true if this import is should be elided due to being a type-only
   * import. Such imports will not be emitted at all to avoid side effects.
   *
   * Import elision only happens with the TypeScript or Flow transforms enabled.
   *
   * TODO: This function has some awkward overlap with
   *  CJSImportProcessor.pruneTypeOnlyImports , and the two should be unified.
   *  That function handles TypeScript implicit import name elision, and removes
   *  an import if all typical imported names (without `type`) are removed due
   *  to being type-only imports. This function handles Flow import removal and
   *  properly distinguishes `import 'foo'` from `import {} from 'foo'` for TS
   *  purposes.
   *
   * The position should end at the import string.
   */ removeImportAndDetectIfShouldElide() {
        this.tokens.removeInitialToken();
        if (this.tokens.matchesContextual(_keywords.ContextualKeyword._type) && !this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, _types.TokenType.comma) && !this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, _keywords.ContextualKeyword._from)) {
            // This is an "import type" statement, so exit early.
            this.removeRemainingImport();
            return true;
        }
        if (this.tokens.matches1(_types.TokenType.name) || this.tokens.matches1(_types.TokenType.star)) {
            // We have a default import or namespace import, so there must be some
            // non-type import.
            this.removeRemainingImport();
            return false;
        }
        if (this.tokens.matches1(_types.TokenType.string)) // This is a bare import, so we should proceed with the import.
        return false;
        let foundNonTypeImport = false;
        let foundAnyNamedImport = false;
        while(!this.tokens.matches1(_types.TokenType.string)){
            // Check if any named imports are of the form "foo" or "foo as bar", with
            // no leading "type".
            if (!foundNonTypeImport && this.tokens.matches1(_types.TokenType.braceL) || this.tokens.matches1(_types.TokenType.comma)) {
                this.tokens.removeToken();
                if (!this.tokens.matches1(_types.TokenType.braceR)) foundAnyNamedImport = true;
                if (this.tokens.matches2(_types.TokenType.name, _types.TokenType.comma) || this.tokens.matches2(_types.TokenType.name, _types.TokenType.braceR) || this.tokens.matches4(_types.TokenType.name, _types.TokenType.name, _types.TokenType.name, _types.TokenType.comma) || this.tokens.matches4(_types.TokenType.name, _types.TokenType.name, _types.TokenType.name, _types.TokenType.braceR)) foundNonTypeImport = true;
            }
            this.tokens.removeToken();
        }
        if (this.keepUnusedImports) return false;
        if (this.isTypeScriptTransformEnabled) return !foundNonTypeImport;
        else if (this.isFlowTransformEnabled) // In Flow, unlike TS, `import {} from 'foo';` preserves the import.
        return foundAnyNamedImport && !foundNonTypeImport;
        else return false;
    }
    removeRemainingImport() {
        while(!this.tokens.matches1(_types.TokenType.string))this.tokens.removeToken();
    }
    processIdentifier() {
        const token = this.tokens.currentToken();
        if (token.shadowsGlobal) return false;
        if (token.identifierRole === _tokenizer.IdentifierRole.ObjectShorthand) return this.processObjectShorthand();
        if (token.identifierRole !== _tokenizer.IdentifierRole.Access) return false;
        const replacement = this.importProcessor.getIdentifierReplacement(this.tokens.identifierNameForToken(token));
        if (!replacement) return false;
        // Tolerate any number of closing parens while looking for an opening paren
        // that indicates a function call.
        let possibleOpenParenIndex = this.tokens.currentIndex() + 1;
        while(possibleOpenParenIndex < this.tokens.tokens.length && this.tokens.tokens[possibleOpenParenIndex].type === _types.TokenType.parenR)possibleOpenParenIndex++;
        // Avoid treating imported functions as methods of their `exports` object
        // by using `(0, f)` when the identifier is in a paren expression. Else
        // use `Function.prototype.call` when the identifier is a guaranteed
        // function call. When using `call`, pass undefined as the context.
        if (this.tokens.tokens[possibleOpenParenIndex].type === _types.TokenType.parenL) {
            if (this.tokens.tokenAtRelativeIndex(1).type === _types.TokenType.parenL && this.tokens.tokenAtRelativeIndex(-1).type !== _types.TokenType._new) {
                this.tokens.replaceToken(`${replacement}.call(void 0, `);
                // Remove the old paren.
                this.tokens.removeToken();
                // Balance out the new paren.
                this.rootTransformer.processBalancedCode();
                this.tokens.copyExpectedToken(_types.TokenType.parenR);
            } else // See here: http://2ality.com/2015/12/references.html
            this.tokens.replaceToken(`(0, ${replacement})`);
        } else this.tokens.replaceToken(replacement);
        return true;
    }
    processObjectShorthand() {
        const identifier = this.tokens.identifierName();
        const replacement = this.importProcessor.getIdentifierReplacement(identifier);
        if (!replacement) return false;
        this.tokens.replaceToken(`${identifier}: ${replacement}`);
        return true;
    }
    processExport() {
        if (this.tokens.matches2(_types.TokenType._export, _types.TokenType._enum) || this.tokens.matches3(_types.TokenType._export, _types.TokenType._const, _types.TokenType._enum)) {
            this.hadNamedExport = true;
            // Let the TypeScript transform handle it.
            return false;
        }
        if (this.tokens.matches2(_types.TokenType._export, _types.TokenType._default)) {
            if (this.tokens.matches3(_types.TokenType._export, _types.TokenType._default, _types.TokenType._enum)) {
                this.hadDefaultExport = true;
                // Flow export default enums need some special handling, so handle them
                // in that tranform rather than this one.
                return false;
            }
            this.processExportDefault();
            return true;
        } else if (this.tokens.matches2(_types.TokenType._export, _types.TokenType.braceL)) {
            this.processExportBindings();
            return true;
        } else if (this.tokens.matches2(_types.TokenType._export, _types.TokenType.name) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, _keywords.ContextualKeyword._type)) {
            // export type {a};
            // export type {a as b};
            // export type {a} from './b';
            // export type * from './b';
            // export type * as ns from './b';
            this.tokens.removeInitialToken();
            this.tokens.removeToken();
            if (this.tokens.matches1(_types.TokenType.braceL)) {
                while(!this.tokens.matches1(_types.TokenType.braceR))this.tokens.removeToken();
                this.tokens.removeToken();
            } else {
                // *
                this.tokens.removeToken();
                if (this.tokens.matches1(_types.TokenType._as)) {
                    // as
                    this.tokens.removeToken();
                    // ns
                    this.tokens.removeToken();
                }
            }
            // Remove type re-export `... } from './T'`
            if (this.tokens.matchesContextual(_keywords.ContextualKeyword._from) && this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, _types.TokenType.string)) {
                this.tokens.removeToken();
                this.tokens.removeToken();
                (0, _removeMaybeImportAttributes.removeMaybeImportAttributes)(this.tokens);
            }
            return true;
        }
        this.hadNamedExport = true;
        if (this.tokens.matches2(_types.TokenType._export, _types.TokenType._var) || this.tokens.matches2(_types.TokenType._export, _types.TokenType._let) || this.tokens.matches2(_types.TokenType._export, _types.TokenType._const)) {
            this.processExportVar();
            return true;
        } else if (this.tokens.matches2(_types.TokenType._export, _types.TokenType._function) || // export async function
        this.tokens.matches3(_types.TokenType._export, _types.TokenType.name, _types.TokenType._function)) {
            this.processExportFunction();
            return true;
        } else if (this.tokens.matches2(_types.TokenType._export, _types.TokenType._class) || this.tokens.matches3(_types.TokenType._export, _types.TokenType._abstract, _types.TokenType._class) || this.tokens.matches2(_types.TokenType._export, _types.TokenType.at)) {
            this.processExportClass();
            return true;
        } else if (this.tokens.matches2(_types.TokenType._export, _types.TokenType.star)) {
            this.processExportStar();
            return true;
        } else throw new Error("Unrecognized export syntax.");
    }
    processAssignment() {
        const index = this.tokens.currentIndex();
        const identifierToken = this.tokens.tokens[index - 1];
        // If the LHS is a type identifier, this must be a declaration like `let a: b = c;`,
        // with `b` as the identifier, so nothing needs to be done in that case.
        if (identifierToken.isType || identifierToken.type !== _types.TokenType.name) return false;
        if (identifierToken.shadowsGlobal) return false;
        if (index >= 2 && this.tokens.matches1AtIndex(index - 2, _types.TokenType.dot)) return false;
        if (index >= 2 && [
            _types.TokenType._var,
            _types.TokenType._let,
            _types.TokenType._const
        ].includes(this.tokens.tokens[index - 2].type)) // Declarations don't need an extra assignment. This doesn't avoid the
        // assignment for comma-separated declarations, but it's still correct
        // since the assignment is just redundant.
        return false;
        const assignmentSnippet = this.importProcessor.resolveExportBinding(this.tokens.identifierNameForToken(identifierToken));
        if (!assignmentSnippet) return false;
        this.tokens.copyToken();
        this.tokens.appendCode(` ${assignmentSnippet} =`);
        return true;
    }
    /**
   * Process something like `a += 3`, where `a` might be an exported value.
   */ processComplexAssignment() {
        const index = this.tokens.currentIndex();
        const identifierToken = this.tokens.tokens[index - 1];
        if (identifierToken.type !== _types.TokenType.name) return false;
        if (identifierToken.shadowsGlobal) return false;
        if (index >= 2 && this.tokens.matches1AtIndex(index - 2, _types.TokenType.dot)) return false;
        const assignmentSnippet = this.importProcessor.resolveExportBinding(this.tokens.identifierNameForToken(identifierToken));
        if (!assignmentSnippet) return false;
        this.tokens.appendCode(` = ${assignmentSnippet}`);
        this.tokens.copyToken();
        return true;
    }
    /**
   * Process something like `++a`, where `a` might be an exported value.
   */ processPreIncDec() {
        const index = this.tokens.currentIndex();
        const identifierToken = this.tokens.tokens[index + 1];
        if (identifierToken.type !== _types.TokenType.name) return false;
        if (identifierToken.shadowsGlobal) return false;
        // Ignore things like ++a.b and ++a[b] and ++a().b.
        if (index + 2 < this.tokens.tokens.length && (this.tokens.matches1AtIndex(index + 2, _types.TokenType.dot) || this.tokens.matches1AtIndex(index + 2, _types.TokenType.bracketL) || this.tokens.matches1AtIndex(index + 2, _types.TokenType.parenL))) return false;
        const identifierName = this.tokens.identifierNameForToken(identifierToken);
        const assignmentSnippet = this.importProcessor.resolveExportBinding(identifierName);
        if (!assignmentSnippet) return false;
        this.tokens.appendCode(`${assignmentSnippet} = `);
        this.tokens.copyToken();
        return true;
    }
    /**
   * Process something like `a++`, where `a` might be an exported value.
   * This starts at the `a`, not at the `++`.
   */ processPostIncDec() {
        const index = this.tokens.currentIndex();
        const identifierToken = this.tokens.tokens[index];
        const operatorToken = this.tokens.tokens[index + 1];
        if (identifierToken.type !== _types.TokenType.name) return false;
        if (identifierToken.shadowsGlobal) return false;
        if (index >= 1 && this.tokens.matches1AtIndex(index - 1, _types.TokenType.dot)) return false;
        const identifierName = this.tokens.identifierNameForToken(identifierToken);
        const assignmentSnippet = this.importProcessor.resolveExportBinding(identifierName);
        if (!assignmentSnippet) return false;
        const operatorCode = this.tokens.rawCodeForToken(operatorToken);
        // We might also replace the identifier with something like exports.x, so
        // do that replacement here as well.
        const base = this.importProcessor.getIdentifierReplacement(identifierName) || identifierName;
        if (operatorCode === "++") this.tokens.replaceToken(`(${base} = ${assignmentSnippet} = ${base} + 1, ${base} - 1)`);
        else if (operatorCode === "--") this.tokens.replaceToken(`(${base} = ${assignmentSnippet} = ${base} - 1, ${base} + 1)`);
        else throw new Error(`Unexpected operator: ${operatorCode}`);
        this.tokens.removeToken();
        return true;
    }
    processExportDefault() {
        let exportedRuntimeValue = true;
        if (this.tokens.matches4(_types.TokenType._export, _types.TokenType._default, _types.TokenType._function, _types.TokenType.name) || this.tokens.matches5(_types.TokenType._export, _types.TokenType._default, _types.TokenType.name, _types.TokenType._function, _types.TokenType.name) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 2, _keywords.ContextualKeyword._async)) {
            this.tokens.removeInitialToken();
            this.tokens.removeToken();
            // Named function export case: change it to a top-level function
            // declaration followed by exports statement.
            const name = this.processNamedFunction();
            this.tokens.appendCode(` exports.default = ${name};`);
        } else if (this.tokens.matches4(_types.TokenType._export, _types.TokenType._default, _types.TokenType._class, _types.TokenType.name) || this.tokens.matches5(_types.TokenType._export, _types.TokenType._default, _types.TokenType._abstract, _types.TokenType._class, _types.TokenType.name) || this.tokens.matches3(_types.TokenType._export, _types.TokenType._default, _types.TokenType.at)) {
            this.tokens.removeInitialToken();
            this.tokens.removeToken();
            this.copyDecorators();
            if (this.tokens.matches1(_types.TokenType._abstract)) this.tokens.removeToken();
            const name = this.rootTransformer.processNamedClass();
            this.tokens.appendCode(` exports.default = ${name};`);
        // After this point, this is a plain "export default E" statement.
        } else if ((0, _shouldElideDefaultExport.default)(this.isTypeScriptTransformEnabled, this.keepUnusedImports, this.tokens, this.declarationInfo)) {
            // If the exported value is just an identifier and should be elided by TypeScript
            // rules, then remove it entirely. It will always have the form `export default e`,
            // where `e` is an identifier.
            exportedRuntimeValue = false;
            this.tokens.removeInitialToken();
            this.tokens.removeToken();
            this.tokens.removeToken();
        } else if (this.reactHotLoaderTransformer) {
            // We need to assign E to a variable. Change "export default E" to
            // "let _default; exports.default = _default = E"
            const defaultVarName = this.nameManager.claimFreeName("_default");
            this.tokens.replaceToken(`let ${defaultVarName}; exports.`);
            this.tokens.copyToken();
            this.tokens.appendCode(` = ${defaultVarName} =`);
            this.reactHotLoaderTransformer.setExtractedDefaultExportName(defaultVarName);
        } else {
            // Change "export default E" to "exports.default = E"
            this.tokens.replaceToken("exports.");
            this.tokens.copyToken();
            this.tokens.appendCode(" =");
        }
        if (exportedRuntimeValue) this.hadDefaultExport = true;
    }
    copyDecorators() {
        while(this.tokens.matches1(_types.TokenType.at)){
            this.tokens.copyToken();
            if (this.tokens.matches1(_types.TokenType.parenL)) {
                this.tokens.copyExpectedToken(_types.TokenType.parenL);
                this.rootTransformer.processBalancedCode();
                this.tokens.copyExpectedToken(_types.TokenType.parenR);
            } else {
                this.tokens.copyExpectedToken(_types.TokenType.name);
                while(this.tokens.matches1(_types.TokenType.dot)){
                    this.tokens.copyExpectedToken(_types.TokenType.dot);
                    this.tokens.copyExpectedToken(_types.TokenType.name);
                }
                if (this.tokens.matches1(_types.TokenType.parenL)) {
                    this.tokens.copyExpectedToken(_types.TokenType.parenL);
                    this.rootTransformer.processBalancedCode();
                    this.tokens.copyExpectedToken(_types.TokenType.parenR);
                }
            }
        }
    }
    /**
   * Transform a declaration like `export var`, `export let`, or `export const`.
   */ processExportVar() {
        if (this.isSimpleExportVar()) this.processSimpleExportVar();
        else this.processComplexExportVar();
    }
    /**
   * Determine if the export is of the form:
   * export var/let/const [varName] = [expr];
   * In other words, determine if function name inference might apply.
   */ isSimpleExportVar() {
        let tokenIndex = this.tokens.currentIndex();
        // export
        tokenIndex++;
        // var/let/const
        tokenIndex++;
        if (!this.tokens.matches1AtIndex(tokenIndex, _types.TokenType.name)) return false;
        tokenIndex++;
        while(tokenIndex < this.tokens.tokens.length && this.tokens.tokens[tokenIndex].isType)tokenIndex++;
        if (!this.tokens.matches1AtIndex(tokenIndex, _types.TokenType.eq)) return false;
        return true;
    }
    /**
   * Transform an `export var` declaration initializing a single variable.
   *
   * For example, this:
   * export const f = () => {};
   * becomes this:
   * const f = () => {}; exports.f = f;
   *
   * The variable is unused (e.g. exports.f has the true value of the export).
   * We need to produce an assignment of this form so that the function will
   * have an inferred name of "f", which wouldn't happen in the more general
   * case below.
   */ processSimpleExportVar() {
        // export
        this.tokens.removeInitialToken();
        // var/let/const
        this.tokens.copyToken();
        const varName = this.tokens.identifierName();
        // x: number  ->  x
        while(!this.tokens.matches1(_types.TokenType.eq))this.rootTransformer.processToken();
        const endIndex = this.tokens.currentToken().rhsEndIndex;
        if (endIndex == null) throw new Error("Expected = token with an end index.");
        while(this.tokens.currentIndex() < endIndex)this.rootTransformer.processToken();
        this.tokens.appendCode(`; exports.${varName} = ${varName}`);
    }
    /**
   * Transform normal declaration exports, including handling destructuring.
   * For example, this:
   * export const {x: [a = 2, b], c} = d;
   * becomes this:
   * ({x: [exports.a = 2, exports.b], c: exports.c} = d;)
   */ processComplexExportVar() {
        this.tokens.removeInitialToken();
        this.tokens.removeToken();
        const needsParens = this.tokens.matches1(_types.TokenType.braceL);
        if (needsParens) this.tokens.appendCode("(");
        let depth = 0;
        while(true){
            if (this.tokens.matches1(_types.TokenType.braceL) || this.tokens.matches1(_types.TokenType.dollarBraceL) || this.tokens.matches1(_types.TokenType.bracketL)) {
                depth++;
                this.tokens.copyToken();
            } else if (this.tokens.matches1(_types.TokenType.braceR) || this.tokens.matches1(_types.TokenType.bracketR)) {
                depth--;
                this.tokens.copyToken();
            } else if (depth === 0 && !this.tokens.matches1(_types.TokenType.name) && !this.tokens.currentToken().isType) break;
            else if (this.tokens.matches1(_types.TokenType.eq)) {
                // Default values might have assignments in the RHS that we want to ignore, so skip past
                // them.
                const endIndex = this.tokens.currentToken().rhsEndIndex;
                if (endIndex == null) throw new Error("Expected = token with an end index.");
                while(this.tokens.currentIndex() < endIndex)this.rootTransformer.processToken();
            } else {
                const token = this.tokens.currentToken();
                if ((0, _tokenizer.isDeclaration)(token)) {
                    const name = this.tokens.identifierName();
                    let replacement = this.importProcessor.getIdentifierReplacement(name);
                    if (replacement === null) throw new Error(`Expected a replacement for ${name} in \`export var\` syntax.`);
                    if ((0, _tokenizer.isObjectShorthandDeclaration)(token)) replacement = `${name}: ${replacement}`;
                    this.tokens.replaceToken(replacement);
                } else this.rootTransformer.processToken();
            }
        }
        if (needsParens) {
            // Seek to the end of the RHS.
            const endIndex = this.tokens.currentToken().rhsEndIndex;
            if (endIndex == null) throw new Error("Expected = token with an end index.");
            while(this.tokens.currentIndex() < endIndex)this.rootTransformer.processToken();
            this.tokens.appendCode(")");
        }
    }
    /**
   * Transform this:
   * export function foo() {}
   * into this:
   * function foo() {} exports.foo = foo;
   */ processExportFunction() {
        this.tokens.replaceToken("");
        const name = this.processNamedFunction();
        this.tokens.appendCode(` exports.${name} = ${name};`);
    }
    /**
   * Skip past a function with a name and return that name.
   */ processNamedFunction() {
        if (this.tokens.matches1(_types.TokenType._function)) this.tokens.copyToken();
        else if (this.tokens.matches2(_types.TokenType.name, _types.TokenType._function)) {
            if (!this.tokens.matchesContextual(_keywords.ContextualKeyword._async)) throw new Error("Expected async keyword in function export.");
            this.tokens.copyToken();
            this.tokens.copyToken();
        }
        if (this.tokens.matches1(_types.TokenType.star)) this.tokens.copyToken();
        if (!this.tokens.matches1(_types.TokenType.name)) throw new Error("Expected identifier for exported function name.");
        const name = this.tokens.identifierName();
        this.tokens.copyToken();
        if (this.tokens.currentToken().isType) {
            this.tokens.removeInitialToken();
            while(this.tokens.currentToken().isType)this.tokens.removeToken();
        }
        this.tokens.copyExpectedToken(_types.TokenType.parenL);
        this.rootTransformer.processBalancedCode();
        this.tokens.copyExpectedToken(_types.TokenType.parenR);
        this.rootTransformer.processPossibleTypeRange();
        this.tokens.copyExpectedToken(_types.TokenType.braceL);
        this.rootTransformer.processBalancedCode();
        this.tokens.copyExpectedToken(_types.TokenType.braceR);
        return name;
    }
    /**
   * Transform this:
   * export class A {}
   * into this:
   * class A {} exports.A = A;
   */ processExportClass() {
        this.tokens.removeInitialToken();
        this.copyDecorators();
        if (this.tokens.matches1(_types.TokenType._abstract)) this.tokens.removeToken();
        const name = this.rootTransformer.processNamedClass();
        this.tokens.appendCode(` exports.${name} = ${name};`);
    }
    /**
   * Transform this:
   * export {a, b as c};
   * into this:
   * exports.a = a; exports.c = b;
   *
   * OR
   *
   * Transform this:
   * export {a, b as c} from './foo';
   * into the pre-generated Object.defineProperty code from the ImportProcessor.
   *
   * For the first case, if the TypeScript transform is enabled, we need to skip
   * exports that are only defined as types.
   */ processExportBindings() {
        this.tokens.removeInitialToken();
        this.tokens.removeToken();
        const isReExport = (0, _isExportFrom.default)(this.tokens);
        const exportStatements = [];
        while(true){
            if (this.tokens.matches1(_types.TokenType.braceR)) {
                this.tokens.removeToken();
                break;
            }
            const specifierInfo = (0, _getImportExportSpecifierInfo.default)(this.tokens);
            while(this.tokens.currentIndex() < specifierInfo.endIndex)this.tokens.removeToken();
            const shouldRemoveExport = specifierInfo.isType || !isReExport && this.shouldElideExportedIdentifier(specifierInfo.leftName);
            if (!shouldRemoveExport) {
                const exportedName = specifierInfo.rightName;
                if (exportedName === "default") this.hadDefaultExport = true;
                else this.hadNamedExport = true;
                const localName = specifierInfo.leftName;
                const newLocalName = this.importProcessor.getIdentifierReplacement(localName);
                exportStatements.push(`exports.${exportedName} = ${newLocalName || localName};`);
            }
            if (this.tokens.matches1(_types.TokenType.braceR)) {
                this.tokens.removeToken();
                break;
            }
            if (this.tokens.matches2(_types.TokenType.comma, _types.TokenType.braceR)) {
                this.tokens.removeToken();
                this.tokens.removeToken();
                break;
            } else if (this.tokens.matches1(_types.TokenType.comma)) this.tokens.removeToken();
            else throw new Error(`Unexpected token: ${JSON.stringify(this.tokens.currentToken())}`);
        }
        if (this.tokens.matchesContextual(_keywords.ContextualKeyword._from)) {
            // This is an export...from, so throw away the normal named export code
            // and use the Object.defineProperty code from ImportProcessor.
            this.tokens.removeToken();
            const path = this.tokens.stringValue();
            this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(path));
            (0, _removeMaybeImportAttributes.removeMaybeImportAttributes)(this.tokens);
        } else // This is a normal named export, so use that.
        this.tokens.appendCode(exportStatements.join(" "));
        if (this.tokens.matches1(_types.TokenType.semi)) this.tokens.removeToken();
    }
    processExportStar() {
        this.tokens.removeInitialToken();
        while(!this.tokens.matches1(_types.TokenType.string))this.tokens.removeToken();
        const path = this.tokens.stringValue();
        this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(path));
        (0, _removeMaybeImportAttributes.removeMaybeImportAttributes)(this.tokens);
        if (this.tokens.matches1(_types.TokenType.semi)) this.tokens.removeToken();
    }
    shouldElideExportedIdentifier(name) {
        return this.isTypeScriptTransformEnabled && !this.keepUnusedImports && !this.declarationInfo.valueDeclarations.has(name);
    }
}

},
"node_modules/sucrase/dist/esm/transformers/ESMImportTransformer.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, /**
 * Class for editing import statements when we are keeping the code as ESM. We still need to remove
 * type-only imports in TypeScript and Flow.
 */ "default", {
    enumerable: true,
    get: function() {
        return ESMImportTransformer;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _interop_require_wildcard = __mako_require__("@swc/helpers/_/_interop_require_wildcard");
var _keywords = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/keywords.js");
var _types = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/types.js");
var _elideImportEquals = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/sucrase/dist/esm/util/elideImportEquals.js"));
var _getDeclarationInfo = /*#__PURE__*/ _interop_require_wildcard._(__mako_require__("node_modules/sucrase/dist/esm/util/getDeclarationInfo.js"));
var _getImportExportSpecifierInfo = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/sucrase/dist/esm/util/getImportExportSpecifierInfo.js"));
var _getNonTypeIdentifiers = __mako_require__("node_modules/sucrase/dist/esm/util/getNonTypeIdentifiers.js");
var _isExportFrom = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/sucrase/dist/esm/util/isExportFrom.js"));
var _removeMaybeImportAttributes = __mako_require__("node_modules/sucrase/dist/esm/util/removeMaybeImportAttributes.js");
var _shouldElideDefaultExport = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/sucrase/dist/esm/util/shouldElideDefaultExport.js"));
var _Transformer = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/sucrase/dist/esm/transformers/Transformer.js"));
class ESMImportTransformer extends _Transformer.default {
    constructor(tokens, nameManager, helperManager, reactHotLoaderTransformer, isTypeScriptTransformEnabled, isFlowTransformEnabled, keepUnusedImports, options){
        super();
        this.tokens = tokens;
        this.nameManager = nameManager;
        this.helperManager = helperManager;
        this.reactHotLoaderTransformer = reactHotLoaderTransformer;
        this.isTypeScriptTransformEnabled = isTypeScriptTransformEnabled;
        this.isFlowTransformEnabled = isFlowTransformEnabled;
        this.keepUnusedImports = keepUnusedImports;
        this.nonTypeIdentifiers = isTypeScriptTransformEnabled && !keepUnusedImports ? (0, _getNonTypeIdentifiers.getNonTypeIdentifiers)(tokens, options) : new Set();
        this.declarationInfo = isTypeScriptTransformEnabled && !keepUnusedImports ? (0, _getDeclarationInfo.default)(tokens) : _getDeclarationInfo.EMPTY_DECLARATION_INFO;
        this.injectCreateRequireForImportRequire = Boolean(options.injectCreateRequireForImportRequire);
    }
    process() {
        // TypeScript `import foo = require('foo');` should always just be translated to plain require.
        if (this.tokens.matches3(_types.TokenType._import, _types.TokenType.name, _types.TokenType.eq)) return this.processImportEquals();
        if (this.tokens.matches4(_types.TokenType._import, _types.TokenType.name, _types.TokenType.name, _types.TokenType.eq) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, _keywords.ContextualKeyword._type)) {
            // import type T = require('T')
            this.tokens.removeInitialToken();
            // This construct is always exactly 8 tokens long, so remove the 7 remaining tokens.
            for(let i = 0; i < 7; i++)this.tokens.removeToken();
            return true;
        }
        if (this.tokens.matches2(_types.TokenType._export, _types.TokenType.eq)) {
            this.tokens.replaceToken("module.exports");
            return true;
        }
        if (this.tokens.matches5(_types.TokenType._export, _types.TokenType._import, _types.TokenType.name, _types.TokenType.name, _types.TokenType.eq) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 2, _keywords.ContextualKeyword._type)) {
            // export import type T = require('T')
            this.tokens.removeInitialToken();
            // This construct is always exactly 9 tokens long, so remove the 8 remaining tokens.
            for(let i = 0; i < 8; i++)this.tokens.removeToken();
            return true;
        }
        if (this.tokens.matches1(_types.TokenType._import)) return this.processImport();
        if (this.tokens.matches2(_types.TokenType._export, _types.TokenType._default)) return this.processExportDefault();
        if (this.tokens.matches2(_types.TokenType._export, _types.TokenType.braceL)) return this.processNamedExports();
        if (this.tokens.matches2(_types.TokenType._export, _types.TokenType.name) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, _keywords.ContextualKeyword._type)) {
            // export type {a};
            // export type {a as b};
            // export type {a} from './b';
            // export type * from './b';
            // export type * as ns from './b';
            this.tokens.removeInitialToken();
            this.tokens.removeToken();
            if (this.tokens.matches1(_types.TokenType.braceL)) {
                while(!this.tokens.matches1(_types.TokenType.braceR))this.tokens.removeToken();
                this.tokens.removeToken();
            } else {
                // *
                this.tokens.removeToken();
                if (this.tokens.matches1(_types.TokenType._as)) {
                    // as
                    this.tokens.removeToken();
                    // ns
                    this.tokens.removeToken();
                }
            }
            // Remove type re-export `... } from './T'`
            if (this.tokens.matchesContextual(_keywords.ContextualKeyword._from) && this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, _types.TokenType.string)) {
                this.tokens.removeToken();
                this.tokens.removeToken();
                (0, _removeMaybeImportAttributes.removeMaybeImportAttributes)(this.tokens);
            }
            return true;
        }
        return false;
    }
    processImportEquals() {
        const importName = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);
        if (this.shouldAutomaticallyElideImportedName(importName)) // If this name is only used as a type, elide the whole import.
        (0, _elideImportEquals.default)(this.tokens);
        else if (this.injectCreateRequireForImportRequire) {
            // We're using require in an environment (Node ESM) that doesn't provide
            // it as a global, so generate a helper to import it.
            // import -> const
            this.tokens.replaceToken("const");
            // Foo
            this.tokens.copyToken();
            // =
            this.tokens.copyToken();
            // require
            this.tokens.replaceToken(this.helperManager.getHelperName("require"));
        } else // Otherwise, just switch `import` to `const`.
        this.tokens.replaceToken("const");
        return true;
    }
    processImport() {
        if (this.tokens.matches2(_types.TokenType._import, _types.TokenType.parenL)) // Dynamic imports don't need to be transformed.
        return false;
        const snapshot = this.tokens.snapshot();
        const allImportsRemoved = this.removeImportTypeBindings();
        if (allImportsRemoved) {
            this.tokens.restoreToSnapshot(snapshot);
            while(!this.tokens.matches1(_types.TokenType.string))this.tokens.removeToken();
            this.tokens.removeToken();
            (0, _removeMaybeImportAttributes.removeMaybeImportAttributes)(this.tokens);
            if (this.tokens.matches1(_types.TokenType.semi)) this.tokens.removeToken();
        }
        return true;
    }
    /**
   * Remove type bindings from this import, leaving the rest of the import intact.
   *
   * Return true if this import was ONLY types, and thus is eligible for removal. This will bail out
   * of the replacement operation, so we can return early here.
   */ removeImportTypeBindings() {
        this.tokens.copyExpectedToken(_types.TokenType._import);
        if (this.tokens.matchesContextual(_keywords.ContextualKeyword._type) && !this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, _types.TokenType.comma) && !this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, _keywords.ContextualKeyword._from)) // This is an "import type" statement, so exit early.
        return true;
        if (this.tokens.matches1(_types.TokenType.string)) {
            // This is a bare import, so we should proceed with the import.
            this.tokens.copyToken();
            return false;
        }
        // Skip the "module" token in import reflection.
        if (this.tokens.matchesContextual(_keywords.ContextualKeyword._module) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 2, _keywords.ContextualKeyword._from)) this.tokens.copyToken();
        let foundNonTypeImport = false;
        let foundAnyNamedImport = false;
        let needsComma = false;
        // Handle default import.
        if (this.tokens.matches1(_types.TokenType.name)) {
            if (this.shouldAutomaticallyElideImportedName(this.tokens.identifierName())) {
                this.tokens.removeToken();
                if (this.tokens.matches1(_types.TokenType.comma)) this.tokens.removeToken();
            } else {
                foundNonTypeImport = true;
                this.tokens.copyToken();
                if (this.tokens.matches1(_types.TokenType.comma)) {
                    // We're in a statement like:
                    // import A, * as B from './A';
                    // or
                    // import A, {foo} from './A';
                    // where the `A` is being kept. The comma should be removed if an only
                    // if the next part of the import statement is elided, but that's hard
                    // to determine at this point in the code. Instead, always remove it
                    // and set a flag to add it back if necessary.
                    needsComma = true;
                    this.tokens.removeToken();
                }
            }
        }
        if (this.tokens.matches1(_types.TokenType.star)) {
            if (this.shouldAutomaticallyElideImportedName(this.tokens.identifierNameAtRelativeIndex(2))) {
                this.tokens.removeToken();
                this.tokens.removeToken();
                this.tokens.removeToken();
            } else {
                if (needsComma) this.tokens.appendCode(",");
                foundNonTypeImport = true;
                this.tokens.copyExpectedToken(_types.TokenType.star);
                this.tokens.copyExpectedToken(_types.TokenType.name);
                this.tokens.copyExpectedToken(_types.TokenType.name);
            }
        } else if (this.tokens.matches1(_types.TokenType.braceL)) {
            if (needsComma) this.tokens.appendCode(",");
            this.tokens.copyToken();
            while(!this.tokens.matches1(_types.TokenType.braceR)){
                foundAnyNamedImport = true;
                const specifierInfo = (0, _getImportExportSpecifierInfo.default)(this.tokens);
                if (specifierInfo.isType || this.shouldAutomaticallyElideImportedName(specifierInfo.rightName)) {
                    while(this.tokens.currentIndex() < specifierInfo.endIndex)this.tokens.removeToken();
                    if (this.tokens.matches1(_types.TokenType.comma)) this.tokens.removeToken();
                } else {
                    foundNonTypeImport = true;
                    while(this.tokens.currentIndex() < specifierInfo.endIndex)this.tokens.copyToken();
                    if (this.tokens.matches1(_types.TokenType.comma)) this.tokens.copyToken();
                }
            }
            this.tokens.copyExpectedToken(_types.TokenType.braceR);
        }
        if (this.keepUnusedImports) return false;
        if (this.isTypeScriptTransformEnabled) return !foundNonTypeImport;
        else if (this.isFlowTransformEnabled) // In Flow, unlike TS, `import {} from 'foo';` preserves the import.
        return foundAnyNamedImport && !foundNonTypeImport;
        else return false;
    }
    shouldAutomaticallyElideImportedName(name) {
        return this.isTypeScriptTransformEnabled && !this.keepUnusedImports && !this.nonTypeIdentifiers.has(name);
    }
    processExportDefault() {
        if ((0, _shouldElideDefaultExport.default)(this.isTypeScriptTransformEnabled, this.keepUnusedImports, this.tokens, this.declarationInfo)) {
            // If the exported value is just an identifier and should be elided by TypeScript
            // rules, then remove it entirely. It will always have the form `export default e`,
            // where `e` is an identifier.
            this.tokens.removeInitialToken();
            this.tokens.removeToken();
            this.tokens.removeToken();
            return true;
        }
        const alreadyHasName = this.tokens.matches4(_types.TokenType._export, _types.TokenType._default, _types.TokenType._function, _types.TokenType.name) || this.tokens.matches5(_types.TokenType._export, _types.TokenType._default, _types.TokenType.name, _types.TokenType._function, _types.TokenType.name) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 2, _keywords.ContextualKeyword._async) || this.tokens.matches4(_types.TokenType._export, _types.TokenType._default, _types.TokenType._class, _types.TokenType.name) || this.tokens.matches5(_types.TokenType._export, _types.TokenType._default, _types.TokenType._abstract, _types.TokenType._class, _types.TokenType.name);
        if (!alreadyHasName && this.reactHotLoaderTransformer) {
            // This is a plain "export default E" statement and we need to assign E to a variable.
            // Change "export default E" to "let _default; export default _default = E"
            const defaultVarName = this.nameManager.claimFreeName("_default");
            this.tokens.replaceToken(`let ${defaultVarName}; export`);
            this.tokens.copyToken();
            this.tokens.appendCode(` ${defaultVarName} =`);
            this.reactHotLoaderTransformer.setExtractedDefaultExportName(defaultVarName);
            return true;
        }
        return false;
    }
    /**
   * Handle a statement with one of these forms:
   * export {a, type b};
   * export {c, type d} from 'foo';
   *
   * In both cases, any explicit type exports should be removed. In the first
   * case, we also need to handle implicit export elision for names declared as
   * types. In the second case, we must NOT do implicit named export elision,
   * but we must remove the runtime import if all exports are type exports.
   */ processNamedExports() {
        if (!this.isTypeScriptTransformEnabled) return false;
        this.tokens.copyExpectedToken(_types.TokenType._export);
        this.tokens.copyExpectedToken(_types.TokenType.braceL);
        const isReExport = (0, _isExportFrom.default)(this.tokens);
        let foundNonTypeExport = false;
        while(!this.tokens.matches1(_types.TokenType.braceR)){
            const specifierInfo = (0, _getImportExportSpecifierInfo.default)(this.tokens);
            if (specifierInfo.isType || !isReExport && this.shouldElideExportedName(specifierInfo.leftName)) {
                // Type export, so remove all tokens, including any comma.
                while(this.tokens.currentIndex() < specifierInfo.endIndex)this.tokens.removeToken();
                if (this.tokens.matches1(_types.TokenType.comma)) this.tokens.removeToken();
            } else {
                // Non-type export, so copy all tokens, including any comma.
                foundNonTypeExport = true;
                while(this.tokens.currentIndex() < specifierInfo.endIndex)this.tokens.copyToken();
                if (this.tokens.matches1(_types.TokenType.comma)) this.tokens.copyToken();
            }
        }
        this.tokens.copyExpectedToken(_types.TokenType.braceR);
        if (!this.keepUnusedImports && isReExport && !foundNonTypeExport) {
            // This is a type-only re-export, so skip evaluating the other module. Technically this
            // leaves the statement as `export {}`, but that's ok since that's a no-op.
            this.tokens.removeToken();
            this.tokens.removeToken();
            (0, _removeMaybeImportAttributes.removeMaybeImportAttributes)(this.tokens);
        }
        return true;
    }
    /**
   * ESM elides all imports with the rule that we only elide if we see that it's
   * a type and never see it as a value. This is in contrast to CJS, which
   * elides imports that are completely unknown.
   */ shouldElideExportedName(name) {
        return this.isTypeScriptTransformEnabled && !this.keepUnusedImports && this.declarationInfo.typeDeclarations.has(name) && !this.declarationInfo.valueDeclarations.has(name);
    }
}

},
"node_modules/sucrase/dist/esm/transformers/FlowTransformer.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return FlowTransformer;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _keywords = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/keywords.js");
var _types = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/types.js");
var _Transformer = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/sucrase/dist/esm/transformers/Transformer.js"));
class FlowTransformer extends _Transformer.default {
    constructor(rootTransformer, tokens, isImportsTransformEnabled){
        super();
        this.rootTransformer = rootTransformer;
        this.tokens = tokens;
        this.isImportsTransformEnabled = isImportsTransformEnabled;
    }
    process() {
        if (this.rootTransformer.processPossibleArrowParamEnd() || this.rootTransformer.processPossibleAsyncArrowWithTypeParams() || this.rootTransformer.processPossibleTypeRange()) return true;
        if (this.tokens.matches1(_types.TokenType._enum)) {
            this.processEnum();
            return true;
        }
        if (this.tokens.matches2(_types.TokenType._export, _types.TokenType._enum)) {
            this.processNamedExportEnum();
            return true;
        }
        if (this.tokens.matches3(_types.TokenType._export, _types.TokenType._default, _types.TokenType._enum)) {
            this.processDefaultExportEnum();
            return true;
        }
        return false;
    }
    /**
   * Handle a declaration like:
   * export enum E ...
   *
   * With this imports transform, this becomes:
   * const E = [[enum]]; exports.E = E;
   *
   * otherwise, it becomes:
   * export const E = [[enum]];
   */ processNamedExportEnum() {
        if (this.isImportsTransformEnabled) {
            // export
            this.tokens.removeInitialToken();
            const enumName = this.tokens.identifierNameAtRelativeIndex(1);
            this.processEnum();
            this.tokens.appendCode(` exports.${enumName} = ${enumName};`);
        } else {
            this.tokens.copyToken();
            this.processEnum();
        }
    }
    /**
   * Handle a declaration like:
   * export default enum E
   *
   * With the imports transform, this becomes:
   * const E = [[enum]]; exports.default = E;
   *
   * otherwise, it becomes:
   * const E = [[enum]]; export default E;
   */ processDefaultExportEnum() {
        // export
        this.tokens.removeInitialToken();
        // default
        this.tokens.removeToken();
        const enumName = this.tokens.identifierNameAtRelativeIndex(1);
        this.processEnum();
        if (this.isImportsTransformEnabled) this.tokens.appendCode(` exports.default = ${enumName};`);
        else this.tokens.appendCode(` export default ${enumName};`);
    }
    /**
   * Transpile flow enums to invoke the "flow-enums-runtime" library.
   *
   * Currently, the transpiled code always uses `require("flow-enums-runtime")`,
   * but if future flexibility is needed, we could expose a config option for
   * this string (similar to configurable JSX). Even when targeting ESM, the
   * default behavior of babel-plugin-transform-flow-enums is to use require
   * rather than injecting an import.
   *
   * Flow enums are quite a bit simpler than TS enums and have some convenient
   * constraints:
   * - Element initializers must be either always present or always absent. That
   *   means that we can use fixed lookahead on the first element (if any) and
   *   assume that all elements are like that.
   * - The right-hand side of an element initializer must be a literal value,
   *   not a complex expression and not referencing other elements. That means
   *   we can simply copy a single token.
   *
   * Enums can be broken up into three basic cases:
   *
   * Mirrored enums:
   * enum E {A, B}
   *   ->
   * const E = require("flow-enums-runtime").Mirrored(["A", "B"]);
   *
   * Initializer enums:
   * enum E {A = 1, B = 2}
   *   ->
   * const E = require("flow-enums-runtime")({A: 1, B: 2});
   *
   * Symbol enums:
   * enum E of symbol {A, B}
   *   ->
   * const E = require("flow-enums-runtime")({A: Symbol("A"), B: Symbol("B")});
   *
   * We can statically detect which of the three cases this is by looking at the
   * "of" declaration (if any) and seeing if the first element has an initializer.
   * Since the other transform details are so similar between the three cases, we
   * use a single implementation and vary the transform within processEnumElement
   * based on case.
   */ processEnum() {
        // enum E -> const E
        this.tokens.replaceToken("const");
        this.tokens.copyExpectedToken(_types.TokenType.name);
        let isSymbolEnum = false;
        if (this.tokens.matchesContextual(_keywords.ContextualKeyword._of)) {
            this.tokens.removeToken();
            isSymbolEnum = this.tokens.matchesContextual(_keywords.ContextualKeyword._symbol);
            this.tokens.removeToken();
        }
        const hasInitializers = this.tokens.matches3(_types.TokenType.braceL, _types.TokenType.name, _types.TokenType.eq);
        this.tokens.appendCode(' = require("flow-enums-runtime")');
        const isMirrored = !isSymbolEnum && !hasInitializers;
        this.tokens.replaceTokenTrimmingLeftWhitespace(isMirrored ? ".Mirrored([" : "({");
        while(!this.tokens.matches1(_types.TokenType.braceR)){
            // ... is allowed at the end and has no runtime behavior.
            if (this.tokens.matches1(_types.TokenType.ellipsis)) {
                this.tokens.removeToken();
                break;
            }
            this.processEnumElement(isSymbolEnum, hasInitializers);
            if (this.tokens.matches1(_types.TokenType.comma)) this.tokens.copyToken();
        }
        this.tokens.replaceToken(isMirrored ? "]);" : "});");
    }
    /**
   * Process an individual enum element, producing either an array element or an
   * object element based on what type of enum this is.
   */ processEnumElement(isSymbolEnum, hasInitializers) {
        if (isSymbolEnum) {
            // Symbol enums never have initializers and are expanded to object elements.
            // A, -> A: Symbol("A"),
            const elementName = this.tokens.identifierName();
            this.tokens.copyToken();
            this.tokens.appendCode(`: Symbol("${elementName}")`);
        } else if (hasInitializers) {
            // Initializers are expanded to object elements.
            // A = 1, -> A: 1,
            this.tokens.copyToken();
            this.tokens.replaceTokenTrimmingLeftWhitespace(":");
            this.tokens.copyToken();
        } else // Enum elements without initializers become string literal array elements.
        // A, -> "A",
        this.tokens.replaceToken(`"${this.tokens.identifierName()}"`);
    }
}

},
"node_modules/sucrase/dist/esm/transformers/JSXTransformer.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    default: function() {
        return JSXTransformer;
    },
    startsWithLowerCase: function() {
        return startsWithLowerCase;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _xhtml = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/sucrase/dist/esm/parser/plugins/jsx/xhtml.js"));
var _tokenizer = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/index.js");
var _types = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/types.js");
var _charcodes = __mako_require__("node_modules/sucrase/dist/esm/parser/util/charcodes.js");
var _getJSXPragmaInfo = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/sucrase/dist/esm/util/getJSXPragmaInfo.js"));
var _Transformer = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/sucrase/dist/esm/transformers/Transformer.js"));
class JSXTransformer extends _Transformer.default {
    // State for calculating the line number of each JSX tag in development.
    __init() {
        this.lastLineNumber = 1;
    }
    __init2() {
        this.lastIndex = 0;
    }
    // In development, variable name holding the name of the current file.
    __init3() {
        this.filenameVarName = null;
    }
    // Mapping of claimed names for imports in the automatic transform, e,g.
    // {jsx: "_jsx"}. This determines which imports to generate in the prefix.
    __init4() {
        this.esmAutomaticImportNameResolutions = {};
    }
    // When automatically adding imports in CJS mode, we store the variable name
    // holding the imported CJS module so we can require it in the prefix.
    __init5() {
        this.cjsAutomaticModuleNameResolutions = {};
    }
    constructor(rootTransformer, tokens, importProcessor, nameManager, options){
        super();
        this.rootTransformer = rootTransformer;
        this.tokens = tokens;
        this.importProcessor = importProcessor;
        this.nameManager = nameManager;
        this.options = options;
        JSXTransformer.prototype.__init.call(this);
        JSXTransformer.prototype.__init2.call(this);
        JSXTransformer.prototype.__init3.call(this);
        JSXTransformer.prototype.__init4.call(this);
        JSXTransformer.prototype.__init5.call(this);
        this.jsxPragmaInfo = (0, _getJSXPragmaInfo.default)(options);
        this.isAutomaticRuntime = options.jsxRuntime === "automatic";
        this.jsxImportSource = options.jsxImportSource || "react";
    }
    process() {
        if (this.tokens.matches1(_types.TokenType.jsxTagStart)) {
            this.processJSXTag();
            return true;
        }
        return false;
    }
    getPrefixCode() {
        let prefix = "";
        if (this.filenameVarName) prefix += `const ${this.filenameVarName} = ${JSON.stringify(this.options.filePath || "")};`;
        if (this.isAutomaticRuntime) {
            if (this.importProcessor) // CJS mode: emit require statements for all modules that were referenced.
            for (const [path, resolvedName] of Object.entries(this.cjsAutomaticModuleNameResolutions))prefix += `var ${resolvedName} = require("${path}");`;
            else {
                // ESM mode: consolidate and emit import statements for referenced names.
                const { createElement: createElementResolution, ...otherResolutions } = this.esmAutomaticImportNameResolutions;
                if (createElementResolution) prefix += `import {createElement as ${createElementResolution}} from "${this.jsxImportSource}";`;
                const importSpecifiers = Object.entries(otherResolutions).map(([name, resolvedName])=>`${name} as ${resolvedName}`).join(", ");
                if (importSpecifiers) {
                    const importPath = this.jsxImportSource + (this.options.production ? "/jsx-runtime" : "/jsx-dev-runtime");
                    prefix += `import {${importSpecifiers}} from "${importPath}";`;
                }
            }
        }
        return prefix;
    }
    processJSXTag() {
        const { jsxRole, start } = this.tokens.currentToken();
        // Calculate line number information at the very start (if in development
        // mode) so that the information is guaranteed to be queried in token order.
        const elementLocationCode = this.options.production ? null : this.getElementLocationCode(start);
        if (this.isAutomaticRuntime && jsxRole !== _tokenizer.JSXRole.KeyAfterPropSpread) this.transformTagToJSXFunc(elementLocationCode, jsxRole);
        else this.transformTagToCreateElement(elementLocationCode);
    }
    getElementLocationCode(firstTokenStart) {
        const lineNumber = this.getLineNumberForIndex(firstTokenStart);
        return `lineNumber: ${lineNumber}`;
    }
    /**
   * Get the line number for this source position. This is calculated lazily and
   * must be called in increasing order by index.
   */ getLineNumberForIndex(index) {
        const code = this.tokens.code;
        while(this.lastIndex < index && this.lastIndex < code.length){
            if (code[this.lastIndex] === "\n") this.lastLineNumber++;
            this.lastIndex++;
        }
        return this.lastLineNumber;
    }
    /**
   * Convert the current JSX element to a call to jsx, jsxs, or jsxDEV. This is
   * the primary transformation for the automatic transform.
   *
   * Example:
   * <div a={1} key={2}>Hello{x}</div>
   * becomes
   * jsxs('div', {a: 1, children: ["Hello", x]}, 2)
   */ transformTagToJSXFunc(elementLocationCode, jsxRole) {
        const isStatic = jsxRole === _tokenizer.JSXRole.StaticChildren;
        // First tag is always jsxTagStart.
        this.tokens.replaceToken(this.getJSXFuncInvocationCode(isStatic));
        let keyCode = null;
        if (this.tokens.matches1(_types.TokenType.jsxTagEnd)) {
            // Fragment syntax.
            this.tokens.replaceToken(`${this.getFragmentCode()}, {`);
            this.processAutomaticChildrenAndEndProps(jsxRole);
        } else {
            // Normal open tag or self-closing tag.
            this.processTagIntro();
            this.tokens.appendCode(", {");
            keyCode = this.processProps(true);
            if (this.tokens.matches2(_types.TokenType.slash, _types.TokenType.jsxTagEnd)) // Self-closing tag, no children to add, so close the props.
            this.tokens.appendCode("}");
            else if (this.tokens.matches1(_types.TokenType.jsxTagEnd)) {
                // Tag with children.
                this.tokens.removeToken();
                this.processAutomaticChildrenAndEndProps(jsxRole);
            } else throw new Error("Expected either /> or > at the end of the tag.");
            // If a key was present, move it to its own arg. Note that moving code
            // like this will cause line numbers to get out of sync within the JSX
            // element if the key expression has a newline in it. This is unfortunate,
            // but hopefully should be rare.
            if (keyCode) this.tokens.appendCode(`, ${keyCode}`);
        }
        if (!this.options.production) {
            // If the key wasn't already added, add it now so we can correctly set
            // positional args for jsxDEV.
            if (keyCode === null) this.tokens.appendCode(", void 0");
            this.tokens.appendCode(`, ${isStatic}, ${this.getDevSource(elementLocationCode)}, this`);
        }
        // We're at the close-tag or the end of a self-closing tag, so remove
        // everything else and close the function call.
        this.tokens.removeInitialToken();
        while(!this.tokens.matches1(_types.TokenType.jsxTagEnd))this.tokens.removeToken();
        this.tokens.replaceToken(")");
    }
    /**
   * Convert the current JSX element to a createElement call. In the classic
   * runtime, this is the only case. In the automatic runtime, this is called
   * as a fallback in some situations.
   *
   * Example:
   * <div a={1} key={2}>Hello{x}</div>
   * becomes
   * React.createElement('div', {a: 1, key: 2}, "Hello", x)
   */ transformTagToCreateElement(elementLocationCode) {
        // First tag is always jsxTagStart.
        this.tokens.replaceToken(this.getCreateElementInvocationCode());
        if (this.tokens.matches1(_types.TokenType.jsxTagEnd)) {
            // Fragment syntax.
            this.tokens.replaceToken(`${this.getFragmentCode()}, null`);
            this.processChildren(true);
        } else {
            // Normal open tag or self-closing tag.
            this.processTagIntro();
            this.processPropsObjectWithDevInfo(elementLocationCode);
            if (this.tokens.matches2(_types.TokenType.slash, _types.TokenType.jsxTagEnd)) ;
            else if (this.tokens.matches1(_types.TokenType.jsxTagEnd)) {
                // Tag with children and a close-tag; process the children as args.
                this.tokens.removeToken();
                this.processChildren(true);
            } else throw new Error("Expected either /> or > at the end of the tag.");
        }
        // We're at the close-tag or the end of a self-closing tag, so remove
        // everything else and close the function call.
        this.tokens.removeInitialToken();
        while(!this.tokens.matches1(_types.TokenType.jsxTagEnd))this.tokens.removeToken();
        this.tokens.replaceToken(")");
    }
    /**
   * Get the code for the relevant function for this context: jsx, jsxs,
   * or jsxDEV. The following open-paren is included as well.
   *
   * These functions are only used for the automatic runtime, so they are always
   * auto-imported, but the auto-import will be either CJS or ESM based on the
   * target module format.
   */ getJSXFuncInvocationCode(isStatic) {
        if (this.options.production) {
            if (isStatic) return this.claimAutoImportedFuncInvocation("jsxs", "/jsx-runtime");
            else return this.claimAutoImportedFuncInvocation("jsx", "/jsx-runtime");
        } else return this.claimAutoImportedFuncInvocation("jsxDEV", "/jsx-dev-runtime");
    }
    /**
   * Return the code to use for the createElement function, e.g.
   * `React.createElement`, including the following open-paren.
   *
   * This is the main function to use for the classic runtime. For the
   * automatic runtime, this function is used as a fallback function to
   * preserve behavior when there is a prop spread followed by an explicit
   * key. In that automatic runtime case, the function should be automatically
   * imported.
   */ getCreateElementInvocationCode() {
        if (this.isAutomaticRuntime) return this.claimAutoImportedFuncInvocation("createElement", "");
        else {
            const { jsxPragmaInfo } = this;
            const resolvedPragmaBaseName = this.importProcessor ? this.importProcessor.getIdentifierReplacement(jsxPragmaInfo.base) || jsxPragmaInfo.base : jsxPragmaInfo.base;
            return `${resolvedPragmaBaseName}${jsxPragmaInfo.suffix}(`;
        }
    }
    /**
   * Return the code to use as the component when compiling a shorthand
   * fragment, e.g. `React.Fragment`.
   *
   * This may be called from either the classic or automatic runtime, and
   * the value should be auto-imported for the automatic runtime.
   */ getFragmentCode() {
        if (this.isAutomaticRuntime) return this.claimAutoImportedName("Fragment", this.options.production ? "/jsx-runtime" : "/jsx-dev-runtime");
        else {
            const { jsxPragmaInfo } = this;
            const resolvedFragmentPragmaBaseName = this.importProcessor ? this.importProcessor.getIdentifierReplacement(jsxPragmaInfo.fragmentBase) || jsxPragmaInfo.fragmentBase : jsxPragmaInfo.fragmentBase;
            return resolvedFragmentPragmaBaseName + jsxPragmaInfo.fragmentSuffix;
        }
    }
    /**
   * Return code that invokes the given function.
   *
   * When the imports transform is enabled, use the CJSImportTransformer
   * strategy of using `.call(void 0, ...` to avoid passing a `this` value in a
   * situation that would otherwise look like a method call.
   */ claimAutoImportedFuncInvocation(funcName, importPathSuffix) {
        const funcCode = this.claimAutoImportedName(funcName, importPathSuffix);
        if (this.importProcessor) return `${funcCode}.call(void 0, `;
        else return `${funcCode}(`;
    }
    claimAutoImportedName(funcName, importPathSuffix) {
        if (this.importProcessor) {
            // CJS mode: claim a name for the module and mark it for import.
            const path = this.jsxImportSource + importPathSuffix;
            if (!this.cjsAutomaticModuleNameResolutions[path]) this.cjsAutomaticModuleNameResolutions[path] = this.importProcessor.getFreeIdentifierForPath(path);
            return `${this.cjsAutomaticModuleNameResolutions[path]}.${funcName}`;
        } else {
            // ESM mode: claim a name for this function and add it to the names that
            // should be auto-imported when the prefix is generated.
            if (!this.esmAutomaticImportNameResolutions[funcName]) this.esmAutomaticImportNameResolutions[funcName] = this.nameManager.claimFreeName(`_${funcName}`);
            return this.esmAutomaticImportNameResolutions[funcName];
        }
    }
    /**
   * Process the first part of a tag, before any props.
   */ processTagIntro() {
        // Walk forward until we see one of these patterns:
        // jsxName to start the first prop, preceded by another jsxName to end the tag name.
        // jsxName to start the first prop, preceded by greaterThan to end the type argument.
        // [open brace] to start the first prop.
        // [jsxTagEnd] to end the open-tag.
        // [slash, jsxTagEnd] to end the self-closing tag.
        let introEnd = this.tokens.currentIndex() + 1;
        while(this.tokens.tokens[introEnd].isType || !this.tokens.matches2AtIndex(introEnd - 1, _types.TokenType.jsxName, _types.TokenType.jsxName) && !this.tokens.matches2AtIndex(introEnd - 1, _types.TokenType.greaterThan, _types.TokenType.jsxName) && !this.tokens.matches1AtIndex(introEnd, _types.TokenType.braceL) && !this.tokens.matches1AtIndex(introEnd, _types.TokenType.jsxTagEnd) && !this.tokens.matches2AtIndex(introEnd, _types.TokenType.slash, _types.TokenType.jsxTagEnd))introEnd++;
        if (introEnd === this.tokens.currentIndex() + 1) {
            const tagName = this.tokens.identifierName();
            if (startsWithLowerCase(tagName)) this.tokens.replaceToken(`'${tagName}'`);
        }
        while(this.tokens.currentIndex() < introEnd)this.rootTransformer.processToken();
    }
    /**
   * Starting at the beginning of the props, add the props argument to
   * React.createElement, including the comma before it.
   */ processPropsObjectWithDevInfo(elementLocationCode) {
        const devProps = this.options.production ? "" : `__self: this, __source: ${this.getDevSource(elementLocationCode)}`;
        if (!this.tokens.matches1(_types.TokenType.jsxName) && !this.tokens.matches1(_types.TokenType.braceL)) {
            if (devProps) this.tokens.appendCode(`, {${devProps}}`);
            else this.tokens.appendCode(`, null`);
            return;
        }
        this.tokens.appendCode(`, {`);
        this.processProps(false);
        if (devProps) this.tokens.appendCode(` ${devProps}}`);
        else this.tokens.appendCode("}");
    }
    /**
   * Transform the core part of the props, assuming that a { has already been
   * inserted before us and that a } will be inserted after us.
   *
   * If extractKeyCode is true (i.e. when using any jsx... function), any prop
   * named "key" has its code captured and returned rather than being emitted to
   * the output code. This shifts line numbers, and emitting the code later will
   * correct line numbers again. If no key is found or if extractKeyCode is
   * false, this function returns null.
   */ processProps(extractKeyCode) {
        let keyCode = null;
        while(true){
            if (this.tokens.matches2(_types.TokenType.jsxName, _types.TokenType.eq)) {
                // This is a regular key={value} or key="value" prop.
                const propName = this.tokens.identifierName();
                if (extractKeyCode && propName === "key") {
                    if (keyCode !== null) // The props list has multiple keys. Different implementations are
                    // inconsistent about what to do here: as of this writing, Babel and
                    // swc keep the *last* key and completely remove the rest, while
                    // TypeScript uses the *first* key and leaves the others as regular
                    // props. The React team collaborated with Babel on the
                    // implementation of this behavior, so presumably the Babel behavior
                    // is the one to use.
                    // Since we won't ever be emitting the previous key code, we need to
                    // at least emit its newlines here so that the line numbers match up
                    // in the long run.
                    this.tokens.appendCode(keyCode.replace(/[^\n]/g, ""));
                    // key
                    this.tokens.removeToken();
                    // =
                    this.tokens.removeToken();
                    const snapshot = this.tokens.snapshot();
                    this.processPropValue();
                    keyCode = this.tokens.dangerouslyGetAndRemoveCodeSinceSnapshot(snapshot);
                    continue;
                } else {
                    this.processPropName(propName);
                    this.tokens.replaceToken(": ");
                    this.processPropValue();
                }
            } else if (this.tokens.matches1(_types.TokenType.jsxName)) {
                // This is a shorthand prop like <input disabled />.
                const propName = this.tokens.identifierName();
                this.processPropName(propName);
                this.tokens.appendCode(": true");
            } else if (this.tokens.matches1(_types.TokenType.braceL)) {
                // This is prop spread, like <div {...getProps()}>, which we can pass
                // through fairly directly as an object spread.
                this.tokens.replaceToken("");
                this.rootTransformer.processBalancedCode();
                this.tokens.replaceToken("");
            } else break;
            this.tokens.appendCode(",");
        }
        return keyCode;
    }
    processPropName(propName) {
        if (propName.includes("-")) this.tokens.replaceToken(`'${propName}'`);
        else this.tokens.copyToken();
    }
    processPropValue() {
        if (this.tokens.matches1(_types.TokenType.braceL)) {
            this.tokens.replaceToken("");
            this.rootTransformer.processBalancedCode();
            this.tokens.replaceToken("");
        } else if (this.tokens.matches1(_types.TokenType.jsxTagStart)) this.processJSXTag();
        else this.processStringPropValue();
    }
    processStringPropValue() {
        const token = this.tokens.currentToken();
        const valueCode = this.tokens.code.slice(token.start + 1, token.end - 1);
        const replacementCode = formatJSXTextReplacement(valueCode);
        const literalCode = formatJSXStringValueLiteral(valueCode);
        this.tokens.replaceToken(literalCode + replacementCode);
    }
    /**
   * Starting in the middle of the props object literal, produce an additional
   * prop for the children and close the object literal.
   */ processAutomaticChildrenAndEndProps(jsxRole) {
        if (jsxRole === _tokenizer.JSXRole.StaticChildren) {
            this.tokens.appendCode(" children: [");
            this.processChildren(false);
            this.tokens.appendCode("]}");
        } else {
            // The parser information tells us whether we will see a real child or if
            // all remaining children (if any) will resolve to empty. If there are no
            // non-empty children, don't emit a children prop at all, but still
            // process children so that we properly transform the code into nothing.
            if (jsxRole === _tokenizer.JSXRole.OneChild) this.tokens.appendCode(" children: ");
            this.processChildren(false);
            this.tokens.appendCode("}");
        }
    }
    /**
   * Transform children into a comma-separated list, which will be either
   * arguments to createElement or array elements of a children prop.
   */ processChildren(needsInitialComma) {
        let needsComma = needsInitialComma;
        while(true){
            if (this.tokens.matches2(_types.TokenType.jsxTagStart, _types.TokenType.slash)) // Closing tag, so no more children.
            return;
            let didEmitElement = false;
            if (this.tokens.matches1(_types.TokenType.braceL)) {
                if (this.tokens.matches2(_types.TokenType.braceL, _types.TokenType.braceR)) {
                    // Empty interpolations and comment-only interpolations are allowed
                    // and don't create an extra child arg.
                    this.tokens.replaceToken("");
                    this.tokens.replaceToken("");
                } else {
                    // Interpolated expression.
                    this.tokens.replaceToken(needsComma ? ", " : "");
                    this.rootTransformer.processBalancedCode();
                    this.tokens.replaceToken("");
                    didEmitElement = true;
                }
            } else if (this.tokens.matches1(_types.TokenType.jsxTagStart)) {
                // Child JSX element
                this.tokens.appendCode(needsComma ? ", " : "");
                this.processJSXTag();
                didEmitElement = true;
            } else if (this.tokens.matches1(_types.TokenType.jsxText) || this.tokens.matches1(_types.TokenType.jsxEmptyText)) didEmitElement = this.processChildTextElement(needsComma);
            else throw new Error("Unexpected token when processing JSX children.");
            if (didEmitElement) needsComma = true;
        }
    }
    /**
   * Turn a JSX text element into a string literal, or nothing at all if the JSX
   * text resolves to the empty string.
   *
   * Returns true if a string literal is emitted, false otherwise.
   */ processChildTextElement(needsComma) {
        const token = this.tokens.currentToken();
        const valueCode = this.tokens.code.slice(token.start, token.end);
        const replacementCode = formatJSXTextReplacement(valueCode);
        const literalCode = formatJSXTextLiteral(valueCode);
        if (literalCode === '""') {
            this.tokens.replaceToken(replacementCode);
            return false;
        } else {
            this.tokens.replaceToken(`${needsComma ? ", " : ""}${literalCode}${replacementCode}`);
            return true;
        }
    }
    getDevSource(elementLocationCode) {
        return `{fileName: ${this.getFilenameVarName()}, ${elementLocationCode}}`;
    }
    getFilenameVarName() {
        if (!this.filenameVarName) this.filenameVarName = this.nameManager.claimFreeName("_jsxFileName");
        return this.filenameVarName;
    }
}
function startsWithLowerCase(s) {
    const firstChar = s.charCodeAt(0);
    return firstChar >= _charcodes.charCodes.lowercaseA && firstChar <= _charcodes.charCodes.lowercaseZ;
}
/**
 * Turn the given jsxText string into a JS string literal. Leading and trailing
 * whitespace on lines is removed, except immediately after the open-tag and
 * before the close-tag. Empty lines are completely removed, and spaces are
 * added between lines after that.
 *
 * We use JSON.stringify to introduce escape characters as necessary, and trim
 * the start and end of each line and remove blank lines.
 */ function formatJSXTextLiteral(text) {
    let result = "";
    let whitespace = "";
    let isInInitialLineWhitespace = false;
    let seenNonWhitespace = false;
    for(let i = 0; i < text.length; i++){
        const c = text[i];
        if (c === " " || c === "\t" || c === "\r") {
            if (!isInInitialLineWhitespace) whitespace += c;
        } else if (c === "\n") {
            whitespace = "";
            isInInitialLineWhitespace = true;
        } else {
            if (seenNonWhitespace && isInInitialLineWhitespace) result += " ";
            result += whitespace;
            whitespace = "";
            if (c === "&") {
                const { entity, newI } = processEntity(text, i + 1);
                i = newI - 1;
                result += entity;
            } else result += c;
            seenNonWhitespace = true;
            isInInitialLineWhitespace = false;
        }
    }
    if (!isInInitialLineWhitespace) result += whitespace;
    return JSON.stringify(result);
}
/**
 * Produce the code that should be printed after the JSX text string literal,
 * with most content removed, but all newlines preserved and all spacing at the
 * end preserved.
 */ function formatJSXTextReplacement(text) {
    let numNewlines = 0;
    let numSpaces = 0;
    for (const c of text){
        if (c === "\n") {
            numNewlines++;
            numSpaces = 0;
        } else if (c === " ") numSpaces++;
    }
    return "\n".repeat(numNewlines) + " ".repeat(numSpaces);
}
/**
 * Format a string in the value position of a JSX prop.
 *
 * Use the same implementation as convertAttribute from
 * babel-helper-builder-react-jsx.
 */ function formatJSXStringValueLiteral(text) {
    let result = "";
    for(let i = 0; i < text.length; i++){
        const c = text[i];
        if (c === "\n") {
            if (/\s/.test(text[i + 1])) {
                result += " ";
                while(i < text.length && /\s/.test(text[i + 1]))i++;
            } else result += "\n";
        } else if (c === "&") {
            const { entity, newI } = processEntity(text, i + 1);
            result += entity;
            i = newI - 1;
        } else result += c;
    }
    return JSON.stringify(result);
}
/**
 * Starting at a &, see if there's an HTML entity (specified by name, decimal
 * char code, or hex char code) and return it if so.
 *
 * Modified from jsxReadString in babel-parser.
 */ function processEntity(text, indexAfterAmpersand) {
    let str = "";
    let count = 0;
    let entity;
    let i = indexAfterAmpersand;
    if (text[i] === "#") {
        let radix = 10;
        i++;
        let numStart;
        if (text[i] === "x") {
            radix = 16;
            i++;
            numStart = i;
            while(i < text.length && isHexDigit(text.charCodeAt(i)))i++;
        } else {
            numStart = i;
            while(i < text.length && isDecimalDigit(text.charCodeAt(i)))i++;
        }
        if (text[i] === ";") {
            const numStr = text.slice(numStart, i);
            if (numStr) {
                i++;
                entity = String.fromCodePoint(parseInt(numStr, radix));
            }
        }
    } else while(i < text.length && count++ < 10){
        const ch = text[i];
        i++;
        if (ch === ";") {
            entity = _xhtml.default.get(str);
            break;
        }
        str += ch;
    }
    if (!entity) return {
        entity: "&",
        newI: indexAfterAmpersand
    };
    return {
        entity,
        newI: i
    };
}
function isDecimalDigit(code) {
    return code >= _charcodes.charCodes.digit0 && code <= _charcodes.charCodes.digit9;
}
function isHexDigit(code) {
    return code >= _charcodes.charCodes.digit0 && code <= _charcodes.charCodes.digit9 || code >= _charcodes.charCodes.lowercaseA && code <= _charcodes.charCodes.lowercaseF || code >= _charcodes.charCodes.uppercaseA && code <= _charcodes.charCodes.uppercaseF;
}

},
"node_modules/sucrase/dist/esm/transformers/JestHoistTransformer.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, /**
 * Implementation of babel-plugin-jest-hoist, which hoists up some jest method
 * calls above the imports to allow them to override other imports.
 *
 * To preserve line numbers, rather than directly moving the jest.mock code, we
 * wrap each invocation in a function statement and then call the function from
 * the top of the file.
 */ "default", {
    enumerable: true,
    get: function() {
        return JestHoistTransformer;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _types = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/types.js");
var _Transformer = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/sucrase/dist/esm/transformers/Transformer.js"));
function _optionalChain(ops) {
    let lastAccessLHS = undefined;
    let value = ops[0];
    let i = 1;
    while(i < ops.length){
        const op = ops[i];
        const fn = ops[i + 1];
        i += 2;
        if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) return undefined;
        if (op === 'access' || op === 'optionalAccess') {
            lastAccessLHS = value;
            value = fn(value);
        } else if (op === 'call' || op === 'optionalCall') {
            value = fn((...args)=>value.call(lastAccessLHS, ...args));
            lastAccessLHS = undefined;
        }
    }
    return value;
}
const JEST_GLOBAL_NAME = "jest";
const HOISTED_METHODS = [
    "mock",
    "unmock",
    "enableAutomock",
    "disableAutomock"
];
class JestHoistTransformer extends _Transformer.default {
    __init() {
        this.hoistedFunctionNames = [];
    }
    constructor(rootTransformer, tokens, nameManager, importProcessor){
        super();
        this.rootTransformer = rootTransformer;
        this.tokens = tokens;
        this.nameManager = nameManager;
        this.importProcessor = importProcessor;
        JestHoistTransformer.prototype.__init.call(this);
    }
    process() {
        if (this.tokens.currentToken().scopeDepth === 0 && this.tokens.matches4(_types.TokenType.name, _types.TokenType.dot, _types.TokenType.name, _types.TokenType.parenL) && this.tokens.identifierName() === JEST_GLOBAL_NAME) {
            // TODO: This only works if imports transform is active, which it will be for jest.
            //       But if jest adds module support and we no longer need the import transform, this needs fixing.
            if (_optionalChain([
                this,
                'access',
                (_)=>_.importProcessor,
                'optionalAccess',
                (_2)=>_2.getGlobalNames,
                'call',
                (_3)=>_3(),
                'optionalAccess',
                (_4)=>_4.has,
                'call',
                (_5)=>_5(JEST_GLOBAL_NAME)
            ])) return false;
            return this.extractHoistedCalls();
        }
        return false;
    }
    getHoistedCode() {
        if (this.hoistedFunctionNames.length > 0) // This will be placed before module interop code, but that's fine since
        // imports aren't allowed in module mock factories.
        return this.hoistedFunctionNames.map((name)=>`${name}();`).join("");
        return "";
    }
    /**
   * Extracts any methods calls on the jest-object that should be hoisted.
   *
   * According to the jest docs, https://jestjs.io/docs/en/jest-object#jestmockmodulename-factory-options,
   * mock, unmock, enableAutomock, disableAutomock, are the methods that should be hoisted.
   *
   * We do not apply the same checks of the arguments as babel-plugin-jest-hoist does.
   */ extractHoistedCalls() {
        // We're handling a chain of calls where `jest` may or may not need to be inserted for each call
        // in the chain, so remove the initial `jest` to make the loop implementation cleaner.
        this.tokens.removeToken();
        // Track some state so that multiple non-hoisted chained calls in a row keep their chaining
        // syntax.
        let followsNonHoistedJestCall = false;
        // Iterate through all chained calls on the jest object.
        while(this.tokens.matches3(_types.TokenType.dot, _types.TokenType.name, _types.TokenType.parenL)){
            const methodName = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);
            const shouldHoist = HOISTED_METHODS.includes(methodName);
            if (shouldHoist) {
                // We've matched e.g. `.mock(...)` or similar call.
                // Replace the initial `.` with `function __jestHoist(){jest.`
                const hoistedFunctionName = this.nameManager.claimFreeName("__jestHoist");
                this.hoistedFunctionNames.push(hoistedFunctionName);
                this.tokens.replaceToken(`function ${hoistedFunctionName}(){${JEST_GLOBAL_NAME}.`);
                this.tokens.copyToken();
                this.tokens.copyToken();
                this.rootTransformer.processBalancedCode();
                this.tokens.copyExpectedToken(_types.TokenType.parenR);
                this.tokens.appendCode(";}");
                followsNonHoistedJestCall = false;
            } else {
                // This is a non-hoisted method, so just transform the code as usual.
                if (followsNonHoistedJestCall) // If we didn't hoist the previous call, we can leave the code as-is to chain off of the
                // previous method call. It's important to preserve the code here because we don't know
                // for sure that the method actually returned the jest object for chaining.
                this.tokens.copyToken();
                else // If we hoisted the previous call, we know it returns the jest object back, so we insert
                // the identifier `jest` to continue the chain.
                this.tokens.replaceToken(`${JEST_GLOBAL_NAME}.`);
                this.tokens.copyToken();
                this.tokens.copyToken();
                this.rootTransformer.processBalancedCode();
                this.tokens.copyExpectedToken(_types.TokenType.parenR);
                followsNonHoistedJestCall = true;
            }
        }
        return true;
    }
}

},
"node_modules/sucrase/dist/esm/transformers/NumericSeparatorTransformer.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return NumericSeparatorTransformer;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _types = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/types.js");
var _Transformer = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/sucrase/dist/esm/transformers/Transformer.js"));
class NumericSeparatorTransformer extends _Transformer.default {
    constructor(tokens){
        super();
        this.tokens = tokens;
    }
    process() {
        if (this.tokens.matches1(_types.TokenType.num)) {
            const code = this.tokens.currentTokenCode();
            if (code.includes("_")) {
                this.tokens.replaceToken(code.replace(/_/g, ""));
                return true;
            }
        }
        return false;
    }
}

},
"node_modules/sucrase/dist/esm/transformers/OptionalCatchBindingTransformer.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return OptionalCatchBindingTransformer;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _types = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/types.js");
var _Transformer = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/sucrase/dist/esm/transformers/Transformer.js"));
class OptionalCatchBindingTransformer extends _Transformer.default {
    constructor(tokens, nameManager){
        super();
        this.tokens = tokens;
        this.nameManager = nameManager;
    }
    process() {
        if (this.tokens.matches2(_types.TokenType._catch, _types.TokenType.braceL)) {
            this.tokens.copyToken();
            this.tokens.appendCode(` (${this.nameManager.claimFreeName("e")})`);
            return true;
        }
        return false;
    }
}

},
"node_modules/sucrase/dist/esm/transformers/OptionalChainingNullishTransformer.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, /**
 * Transformer supporting the optional chaining and nullish coalescing operators.
 *
 * Tech plan here:
 * https://github.com/alangpierce/sucrase/wiki/Sucrase-Optional-Chaining-and-Nullish-Coalescing-Technical-Plan
 *
 * The prefix and suffix code snippets are handled by TokenProcessor, and this transformer handles
 * the operators themselves.
 */ "default", {
    enumerable: true,
    get: function() {
        return OptionalChainingNullishTransformer;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _types = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/types.js");
var _Transformer = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/sucrase/dist/esm/transformers/Transformer.js"));
class OptionalChainingNullishTransformer extends _Transformer.default {
    constructor(tokens, nameManager){
        super();
        this.tokens = tokens;
        this.nameManager = nameManager;
    }
    process() {
        if (this.tokens.matches1(_types.TokenType.nullishCoalescing)) {
            const token = this.tokens.currentToken();
            if (this.tokens.tokens[token.nullishStartIndex].isAsyncOperation) this.tokens.replaceTokenTrimmingLeftWhitespace(", async () => (");
            else this.tokens.replaceTokenTrimmingLeftWhitespace(", () => (");
            return true;
        }
        if (this.tokens.matches1(_types.TokenType._delete)) {
            const nextToken = this.tokens.tokenAtRelativeIndex(1);
            if (nextToken.isOptionalChainStart) {
                this.tokens.removeInitialToken();
                return true;
            }
        }
        const token = this.tokens.currentToken();
        const chainStart = token.subscriptStartIndex;
        if (chainStart != null && this.tokens.tokens[chainStart].isOptionalChainStart && // Super subscripts can't be optional (since super is never null/undefined), and the syntax
        // relies on the subscript being intact, so leave this token alone.
        this.tokens.tokenAtRelativeIndex(-1).type !== _types.TokenType._super) {
            const param = this.nameManager.claimFreeName("_");
            let arrowStartSnippet;
            if (chainStart > 0 && this.tokens.matches1AtIndex(chainStart - 1, _types.TokenType._delete) && this.isLastSubscriptInChain()) // Delete operations are special: we already removed the delete keyword, and to still
            // perform a delete, we need to insert a delete in the very last part of the chain, which
            // in correct code will always be a property access.
            arrowStartSnippet = `${param} => delete ${param}`;
            else arrowStartSnippet = `${param} => ${param}`;
            if (this.tokens.tokens[chainStart].isAsyncOperation) arrowStartSnippet = `async ${arrowStartSnippet}`;
            if (this.tokens.matches2(_types.TokenType.questionDot, _types.TokenType.parenL) || this.tokens.matches2(_types.TokenType.questionDot, _types.TokenType.lessThan)) {
                if (this.justSkippedSuper()) this.tokens.appendCode(".bind(this)");
                this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'optionalCall', ${arrowStartSnippet}`);
            } else if (this.tokens.matches2(_types.TokenType.questionDot, _types.TokenType.bracketL)) this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'optionalAccess', ${arrowStartSnippet}`);
            else if (this.tokens.matches1(_types.TokenType.questionDot)) this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'optionalAccess', ${arrowStartSnippet}.`);
            else if (this.tokens.matches1(_types.TokenType.dot)) this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'access', ${arrowStartSnippet}.`);
            else if (this.tokens.matches1(_types.TokenType.bracketL)) this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'access', ${arrowStartSnippet}[`);
            else if (this.tokens.matches1(_types.TokenType.parenL)) {
                if (this.justSkippedSuper()) this.tokens.appendCode(".bind(this)");
                this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'call', ${arrowStartSnippet}(`);
            } else throw new Error("Unexpected subscript operator in optional chain.");
            return true;
        }
        return false;
    }
    /**
   * Determine if the current token is the last of its chain, so that we know whether it's eligible
   * to have a delete op inserted.
   *
   * We can do this by walking forward until we determine one way or another. Each
   * isOptionalChainStart token must be paired with exactly one isOptionalChainEnd token after it in
   * a nesting way, so we can track depth and walk to the end of the chain (the point where the
   * depth goes negative) and see if any other subscript token is after us in the chain.
   */ isLastSubscriptInChain() {
        let depth = 0;
        for(let i = this.tokens.currentIndex() + 1;; i++){
            if (i >= this.tokens.tokens.length) throw new Error("Reached the end of the code while finding the end of the access chain.");
            if (this.tokens.tokens[i].isOptionalChainStart) depth++;
            else if (this.tokens.tokens[i].isOptionalChainEnd) depth--;
            if (depth < 0) return true;
            // This subscript token is a later one in the same chain.
            if (depth === 0 && this.tokens.tokens[i].subscriptStartIndex != null) return false;
        }
    }
    /**
   * Determine if we are the open-paren in an expression like super.a()?.b.
   *
   * We can do this by walking backward to find the previous subscript. If that subscript was
   * preceded by a super, then we must be the subscript after it, so if this is a call expression,
   * we'll need to attach the right context.
   */ justSkippedSuper() {
        let depth = 0;
        let index = this.tokens.currentIndex() - 1;
        while(true){
            if (index < 0) throw new Error("Reached the start of the code while finding the start of the access chain.");
            if (this.tokens.tokens[index].isOptionalChainStart) depth--;
            else if (this.tokens.tokens[index].isOptionalChainEnd) depth++;
            if (depth < 0) return false;
            // This subscript token is a later one in the same chain.
            if (depth === 0 && this.tokens.tokens[index].subscriptStartIndex != null) return this.tokens.tokens[index - 1].type === _types.TokenType._super;
            index--;
        }
    }
}

},
"node_modules/sucrase/dist/esm/transformers/ReactDisplayNameTransformer.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, /**
 * Implementation of babel-plugin-transform-react-display-name, which adds a
 * display name to usages of React.createClass and createReactClass.
 */ "default", {
    enumerable: true,
    get: function() {
        return ReactDisplayNameTransformer;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _tokenizer = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/index.js");
var _types = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/types.js");
var _Transformer = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/sucrase/dist/esm/transformers/Transformer.js"));
class ReactDisplayNameTransformer extends _Transformer.default {
    constructor(rootTransformer, tokens, importProcessor, options){
        super();
        this.rootTransformer = rootTransformer;
        this.tokens = tokens;
        this.importProcessor = importProcessor;
        this.options = options;
    }
    process() {
        const startIndex = this.tokens.currentIndex();
        if (this.tokens.identifierName() === "createReactClass") {
            const newName = this.importProcessor && this.importProcessor.getIdentifierReplacement("createReactClass");
            if (newName) this.tokens.replaceToken(`(0, ${newName})`);
            else this.tokens.copyToken();
            this.tryProcessCreateClassCall(startIndex);
            return true;
        }
        if (this.tokens.matches3(_types.TokenType.name, _types.TokenType.dot, _types.TokenType.name) && this.tokens.identifierName() === "React" && this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 2) === "createClass") {
            const newName = this.importProcessor ? this.importProcessor.getIdentifierReplacement("React") || "React" : "React";
            if (newName) {
                this.tokens.replaceToken(newName);
                this.tokens.copyToken();
                this.tokens.copyToken();
            } else {
                this.tokens.copyToken();
                this.tokens.copyToken();
                this.tokens.copyToken();
            }
            this.tryProcessCreateClassCall(startIndex);
            return true;
        }
        return false;
    }
    /**
   * This is called with the token position at the open-paren.
   */ tryProcessCreateClassCall(startIndex) {
        const displayName = this.findDisplayName(startIndex);
        if (!displayName) return;
        if (this.classNeedsDisplayName()) {
            this.tokens.copyExpectedToken(_types.TokenType.parenL);
            this.tokens.copyExpectedToken(_types.TokenType.braceL);
            this.tokens.appendCode(`displayName: '${displayName}',`);
            this.rootTransformer.processBalancedCode();
            this.tokens.copyExpectedToken(_types.TokenType.braceR);
            this.tokens.copyExpectedToken(_types.TokenType.parenR);
        }
    }
    findDisplayName(startIndex) {
        if (startIndex < 2) return null;
        if (this.tokens.matches2AtIndex(startIndex - 2, _types.TokenType.name, _types.TokenType.eq)) // This is an assignment (or declaration) and the LHS is either an identifier or a member
        // expression ending in an identifier, so use that identifier name.
        return this.tokens.identifierNameAtIndex(startIndex - 2);
        if (startIndex >= 2 && this.tokens.tokens[startIndex - 2].identifierRole === _tokenizer.IdentifierRole.ObjectKey) // This is an object literal value.
        return this.tokens.identifierNameAtIndex(startIndex - 2);
        if (this.tokens.matches2AtIndex(startIndex - 2, _types.TokenType._export, _types.TokenType._default)) return this.getDisplayNameFromFilename();
        return null;
    }
    getDisplayNameFromFilename() {
        const filePath = this.options.filePath || "unknown";
        const pathSegments = filePath.split("/");
        const filename = pathSegments[pathSegments.length - 1];
        const dotIndex = filename.lastIndexOf(".");
        const baseFilename = dotIndex === -1 ? filename : filename.slice(0, dotIndex);
        if (baseFilename === "index" && pathSegments[pathSegments.length - 2]) return pathSegments[pathSegments.length - 2];
        else return baseFilename;
    }
    /**
   * We only want to add a display name when this is a function call containing
   * one argument, which is an object literal without `displayName` as an
   * existing key.
   */ classNeedsDisplayName() {
        let index = this.tokens.currentIndex();
        if (!this.tokens.matches2(_types.TokenType.parenL, _types.TokenType.braceL)) return false;
        // The block starts on the {, and we expect any displayName key to be in
        // that context. We need to ignore other other contexts to avoid matching
        // nested displayName keys.
        const objectStartIndex = index + 1;
        const objectContextId = this.tokens.tokens[objectStartIndex].contextId;
        if (objectContextId == null) throw new Error("Expected non-null context ID on object open-brace.");
        for(; index < this.tokens.tokens.length; index++){
            const token = this.tokens.tokens[index];
            if (token.type === _types.TokenType.braceR && token.contextId === objectContextId) {
                index++;
                break;
            }
            if (this.tokens.identifierNameAtIndex(index) === "displayName" && this.tokens.tokens[index].identifierRole === _tokenizer.IdentifierRole.ObjectKey && token.contextId === objectContextId) // We found a displayName key, so bail out.
            return false;
        }
        if (index === this.tokens.tokens.length) throw new Error("Unexpected end of input when processing React class.");
        // If we got this far, we know we have createClass with an object with no
        // display name, so we want to proceed as long as that was the only argument.
        return this.tokens.matches1AtIndex(index, _types.TokenType.parenR) || this.tokens.matches2AtIndex(index, _types.TokenType.comma, _types.TokenType.parenR);
    }
}

},
"node_modules/sucrase/dist/esm/transformers/ReactHotLoaderTransformer.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return ReactHotLoaderTransformer;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _tokenizer = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/index.js");
var _Transformer = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/sucrase/dist/esm/transformers/Transformer.js"));
class ReactHotLoaderTransformer extends _Transformer.default {
    __init() {
        this.extractedDefaultExportName = null;
    }
    constructor(tokens, filePath){
        super();
        this.tokens = tokens;
        this.filePath = filePath;
        ReactHotLoaderTransformer.prototype.__init.call(this);
    }
    setExtractedDefaultExportName(extractedDefaultExportName) {
        this.extractedDefaultExportName = extractedDefaultExportName;
    }
    getPrefixCode() {
        return `
      (function () {
        var enterModule = require('react-hot-loader').enterModule;
        enterModule && enterModule(module);
      })();`.replace(/\s+/g, " ").trim();
    }
    getSuffixCode() {
        const topLevelNames = new Set();
        for (const token of this.tokens.tokens)if (!token.isType && (0, _tokenizer.isTopLevelDeclaration)(token) && token.identifierRole !== _tokenizer.IdentifierRole.ImportDeclaration) topLevelNames.add(this.tokens.identifierNameForToken(token));
        const namesToRegister = Array.from(topLevelNames).map((name)=>({
                variableName: name,
                uniqueLocalName: name
            }));
        if (this.extractedDefaultExportName) namesToRegister.push({
            variableName: this.extractedDefaultExportName,
            uniqueLocalName: "default"
        });
        return `
;(function () {
  var reactHotLoader = require('react-hot-loader').default;
  var leaveModule = require('react-hot-loader').leaveModule;
  if (!reactHotLoader) {
    return;
  }
${namesToRegister.map(({ variableName, uniqueLocalName })=>`  reactHotLoader.register(${variableName}, "${uniqueLocalName}", ${JSON.stringify(this.filePath || "")});`).join("\n")}
  leaveModule(module);
})();`;
    }
    process() {
        return false;
    }
}

},
"node_modules/sucrase/dist/esm/transformers/RootTransformer.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return RootTransformer;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _keywords = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/keywords.js");
var _types = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/types.js");
var _getClassInfo = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/sucrase/dist/esm/util/getClassInfo.js"));
var _CJSImportTransformer = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/sucrase/dist/esm/transformers/CJSImportTransformer.js"));
var _ESMImportTransformer = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/sucrase/dist/esm/transformers/ESMImportTransformer.js"));
var _FlowTransformer = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/sucrase/dist/esm/transformers/FlowTransformer.js"));
var _JestHoistTransformer = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/sucrase/dist/esm/transformers/JestHoistTransformer.js"));
var _JSXTransformer = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/sucrase/dist/esm/transformers/JSXTransformer.js"));
var _NumericSeparatorTransformer = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/sucrase/dist/esm/transformers/NumericSeparatorTransformer.js"));
var _OptionalCatchBindingTransformer = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/sucrase/dist/esm/transformers/OptionalCatchBindingTransformer.js"));
var _OptionalChainingNullishTransformer = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/sucrase/dist/esm/transformers/OptionalChainingNullishTransformer.js"));
var _ReactDisplayNameTransformer = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/sucrase/dist/esm/transformers/ReactDisplayNameTransformer.js"));
var _ReactHotLoaderTransformer = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/sucrase/dist/esm/transformers/ReactHotLoaderTransformer.js"));
var _TypeScriptTransformer = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/sucrase/dist/esm/transformers/TypeScriptTransformer.js"));
class RootTransformer {
    __init() {
        this.transformers = [];
    }
    __init2() {
        this.generatedVariables = [];
    }
    constructor(sucraseContext, transforms, enableLegacyBabel5ModuleInterop, options){
        RootTransformer.prototype.__init.call(this);
        RootTransformer.prototype.__init2.call(this);
        this.nameManager = sucraseContext.nameManager;
        this.helperManager = sucraseContext.helperManager;
        const { tokenProcessor, importProcessor } = sucraseContext;
        this.tokens = tokenProcessor;
        this.isImportsTransformEnabled = transforms.includes("imports");
        this.isReactHotLoaderTransformEnabled = transforms.includes("react-hot-loader");
        this.disableESTransforms = Boolean(options.disableESTransforms);
        if (!options.disableESTransforms) {
            this.transformers.push(new _OptionalChainingNullishTransformer.default(tokenProcessor, this.nameManager));
            this.transformers.push(new _NumericSeparatorTransformer.default(tokenProcessor));
            this.transformers.push(new _OptionalCatchBindingTransformer.default(tokenProcessor, this.nameManager));
        }
        if (transforms.includes("jsx")) {
            if (options.jsxRuntime !== "preserve") this.transformers.push(new _JSXTransformer.default(this, tokenProcessor, importProcessor, this.nameManager, options));
            this.transformers.push(new _ReactDisplayNameTransformer.default(this, tokenProcessor, importProcessor, options));
        }
        let reactHotLoaderTransformer = null;
        if (transforms.includes("react-hot-loader")) {
            if (!options.filePath) throw new Error("filePath is required when using the react-hot-loader transform.");
            reactHotLoaderTransformer = new _ReactHotLoaderTransformer.default(tokenProcessor, options.filePath);
            this.transformers.push(reactHotLoaderTransformer);
        }
        // Note that we always want to enable the imports transformer, even when the import transform
        // itself isn't enabled, since we need to do type-only import pruning for both Flow and
        // TypeScript.
        if (transforms.includes("imports")) {
            if (importProcessor === null) throw new Error("Expected non-null importProcessor with imports transform enabled.");
            this.transformers.push(new _CJSImportTransformer.default(this, tokenProcessor, importProcessor, this.nameManager, this.helperManager, reactHotLoaderTransformer, enableLegacyBabel5ModuleInterop, Boolean(options.enableLegacyTypeScriptModuleInterop), transforms.includes("typescript"), transforms.includes("flow"), Boolean(options.preserveDynamicImport), Boolean(options.keepUnusedImports)));
        } else this.transformers.push(new _ESMImportTransformer.default(tokenProcessor, this.nameManager, this.helperManager, reactHotLoaderTransformer, transforms.includes("typescript"), transforms.includes("flow"), Boolean(options.keepUnusedImports), options));
        if (transforms.includes("flow")) this.transformers.push(new _FlowTransformer.default(this, tokenProcessor, transforms.includes("imports")));
        if (transforms.includes("typescript")) this.transformers.push(new _TypeScriptTransformer.default(this, tokenProcessor, transforms.includes("imports")));
        if (transforms.includes("jest")) this.transformers.push(new _JestHoistTransformer.default(this, tokenProcessor, this.nameManager, importProcessor));
    }
    transform() {
        this.tokens.reset();
        this.processBalancedCode();
        const shouldAddUseStrict = this.isImportsTransformEnabled;
        // "use strict" always needs to be first, so override the normal transformer order.
        let prefix = shouldAddUseStrict ? '"use strict";' : "";
        for (const transformer of this.transformers)prefix += transformer.getPrefixCode();
        prefix += this.helperManager.emitHelpers();
        prefix += this.generatedVariables.map((v)=>` var ${v};`).join("");
        for (const transformer of this.transformers)prefix += transformer.getHoistedCode();
        let suffix = "";
        for (const transformer of this.transformers)suffix += transformer.getSuffixCode();
        const result = this.tokens.finish();
        let { code } = result;
        if (code.startsWith("#!")) {
            let newlineIndex = code.indexOf("\n");
            if (newlineIndex === -1) {
                newlineIndex = code.length;
                code += "\n";
            }
            return {
                code: code.slice(0, newlineIndex + 1) + prefix + code.slice(newlineIndex + 1) + suffix,
                // The hashbang line has no tokens, so shifting the tokens to account
                // for prefix can happen normally.
                mappings: this.shiftMappings(result.mappings, prefix.length)
            };
        } else return {
            code: prefix + code + suffix,
            mappings: this.shiftMappings(result.mappings, prefix.length)
        };
    }
    processBalancedCode() {
        let braceDepth = 0;
        let parenDepth = 0;
        while(!this.tokens.isAtEnd()){
            if (this.tokens.matches1(_types.TokenType.braceL) || this.tokens.matches1(_types.TokenType.dollarBraceL)) braceDepth++;
            else if (this.tokens.matches1(_types.TokenType.braceR)) {
                if (braceDepth === 0) return;
                braceDepth--;
            }
            if (this.tokens.matches1(_types.TokenType.parenL)) parenDepth++;
            else if (this.tokens.matches1(_types.TokenType.parenR)) {
                if (parenDepth === 0) return;
                parenDepth--;
            }
            this.processToken();
        }
    }
    processToken() {
        if (this.tokens.matches1(_types.TokenType._class)) {
            this.processClass();
            return;
        }
        for (const transformer of this.transformers){
            const wasProcessed = transformer.process();
            if (wasProcessed) return;
        }
        this.tokens.copyToken();
    }
    /**
   * Skip past a class with a name and return that name.
   */ processNamedClass() {
        if (!this.tokens.matches2(_types.TokenType._class, _types.TokenType.name)) throw new Error("Expected identifier for exported class name.");
        const name = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);
        this.processClass();
        return name;
    }
    processClass() {
        const classInfo = (0, _getClassInfo.default)(this, this.tokens, this.nameManager, this.disableESTransforms);
        // Both static and instance initializers need a class name to use to invoke the initializer, so
        // assign to one if necessary.
        const needsCommaExpression = (classInfo.headerInfo.isExpression || !classInfo.headerInfo.className) && classInfo.staticInitializerNames.length + classInfo.instanceInitializerNames.length > 0;
        let className = classInfo.headerInfo.className;
        if (needsCommaExpression) {
            className = this.nameManager.claimFreeName("_class");
            this.generatedVariables.push(className);
            this.tokens.appendCode(` (${className} =`);
        }
        const classToken = this.tokens.currentToken();
        const contextId = classToken.contextId;
        if (contextId == null) throw new Error("Expected class to have a context ID.");
        this.tokens.copyExpectedToken(_types.TokenType._class);
        while(!this.tokens.matchesContextIdAndLabel(_types.TokenType.braceL, contextId))this.processToken();
        this.processClassBody(classInfo, className);
        const staticInitializerStatements = classInfo.staticInitializerNames.map((name)=>`${className}.${name}()`);
        if (needsCommaExpression) this.tokens.appendCode(`, ${staticInitializerStatements.map((s)=>`${s}, `).join("")}${className})`);
        else if (classInfo.staticInitializerNames.length > 0) this.tokens.appendCode(` ${staticInitializerStatements.map((s)=>`${s};`).join(" ")}`);
    }
    /**
   * We want to just handle class fields in all contexts, since TypeScript supports them. Later,
   * when some JS implementations support class fields, this should be made optional.
   */ processClassBody(classInfo, className) {
        const { headerInfo, constructorInsertPos, constructorInitializerStatements, fields, instanceInitializerNames, rangesToRemove } = classInfo;
        let fieldIndex = 0;
        let rangeToRemoveIndex = 0;
        const classContextId = this.tokens.currentToken().contextId;
        if (classContextId == null) throw new Error("Expected non-null context ID on class.");
        this.tokens.copyExpectedToken(_types.TokenType.braceL);
        if (this.isReactHotLoaderTransformEnabled) this.tokens.appendCode("__reactstandin__regenerateByEval(key, code) {this[key] = eval(code);}");
        const needsConstructorInit = constructorInitializerStatements.length + instanceInitializerNames.length > 0;
        if (constructorInsertPos === null && needsConstructorInit) {
            const constructorInitializersCode = this.makeConstructorInitCode(constructorInitializerStatements, instanceInitializerNames, className);
            if (headerInfo.hasSuperclass) {
                const argsName = this.nameManager.claimFreeName("args");
                this.tokens.appendCode(`constructor(...${argsName}) { super(...${argsName}); ${constructorInitializersCode}; }`);
            } else this.tokens.appendCode(`constructor() { ${constructorInitializersCode}; }`);
        }
        while(!this.tokens.matchesContextIdAndLabel(_types.TokenType.braceR, classContextId)){
            if (fieldIndex < fields.length && this.tokens.currentIndex() === fields[fieldIndex].start) {
                let needsCloseBrace = false;
                if (this.tokens.matches1(_types.TokenType.bracketL)) this.tokens.copyTokenWithPrefix(`${fields[fieldIndex].initializerName}() {this`);
                else if (this.tokens.matches1(_types.TokenType.string) || this.tokens.matches1(_types.TokenType.num)) {
                    this.tokens.copyTokenWithPrefix(`${fields[fieldIndex].initializerName}() {this[`);
                    needsCloseBrace = true;
                } else this.tokens.copyTokenWithPrefix(`${fields[fieldIndex].initializerName}() {this.`);
                while(this.tokens.currentIndex() < fields[fieldIndex].end){
                    if (needsCloseBrace && this.tokens.currentIndex() === fields[fieldIndex].equalsIndex) this.tokens.appendCode("]");
                    this.processToken();
                }
                this.tokens.appendCode("}");
                fieldIndex++;
            } else if (rangeToRemoveIndex < rangesToRemove.length && this.tokens.currentIndex() >= rangesToRemove[rangeToRemoveIndex].start) {
                if (this.tokens.currentIndex() < rangesToRemove[rangeToRemoveIndex].end) this.tokens.removeInitialToken();
                while(this.tokens.currentIndex() < rangesToRemove[rangeToRemoveIndex].end)this.tokens.removeToken();
                rangeToRemoveIndex++;
            } else if (this.tokens.currentIndex() === constructorInsertPos) {
                this.tokens.copyToken();
                if (needsConstructorInit) this.tokens.appendCode(`;${this.makeConstructorInitCode(constructorInitializerStatements, instanceInitializerNames, className)};`);
                this.processToken();
            } else this.processToken();
        }
        this.tokens.copyExpectedToken(_types.TokenType.braceR);
    }
    makeConstructorInitCode(constructorInitializerStatements, instanceInitializerNames, className) {
        return [
            ...constructorInitializerStatements,
            ...instanceInitializerNames.map((name)=>`${className}.prototype.${name}.call(this)`)
        ].join(";");
    }
    /**
   * Normally it's ok to simply remove type tokens, but we need to be more careful when dealing with
   * arrow function return types since they can confuse the parser. In that case, we want to move
   * the close-paren to the same line as the arrow.
   *
   * See https://github.com/alangpierce/sucrase/issues/391 for more details.
   */ processPossibleArrowParamEnd() {
        if (this.tokens.matches2(_types.TokenType.parenR, _types.TokenType.colon) && this.tokens.tokenAtRelativeIndex(1).isType) {
            let nextNonTypeIndex = this.tokens.currentIndex() + 1;
            // Look ahead to see if this is an arrow function or something else.
            while(this.tokens.tokens[nextNonTypeIndex].isType)nextNonTypeIndex++;
            if (this.tokens.matches1AtIndex(nextNonTypeIndex, _types.TokenType.arrow)) {
                this.tokens.removeInitialToken();
                while(this.tokens.currentIndex() < nextNonTypeIndex)this.tokens.removeToken();
                this.tokens.replaceTokenTrimmingLeftWhitespace(") =>");
                return true;
            }
        }
        return false;
    }
    /**
   * An async arrow function might be of the form:
   *
   * async <
   *   T
   * >() => {}
   *
   * in which case, removing the type parameters will cause a syntax error. Detect this case and
   * move the open-paren earlier.
   */ processPossibleAsyncArrowWithTypeParams() {
        if (!this.tokens.matchesContextual(_keywords.ContextualKeyword._async) && !this.tokens.matches1(_types.TokenType._async)) return false;
        const nextToken = this.tokens.tokenAtRelativeIndex(1);
        if (nextToken.type !== _types.TokenType.lessThan || !nextToken.isType) return false;
        let nextNonTypeIndex = this.tokens.currentIndex() + 1;
        // Look ahead to see if this is an arrow function or something else.
        while(this.tokens.tokens[nextNonTypeIndex].isType)nextNonTypeIndex++;
        if (this.tokens.matches1AtIndex(nextNonTypeIndex, _types.TokenType.parenL)) {
            this.tokens.replaceToken("async (");
            this.tokens.removeInitialToken();
            while(this.tokens.currentIndex() < nextNonTypeIndex)this.tokens.removeToken();
            this.tokens.removeToken();
            // We ate a ( token, so we need to process the tokens in between and then the ) token so that
            // we remain balanced.
            this.processBalancedCode();
            this.processToken();
            return true;
        }
        return false;
    }
    processPossibleTypeRange() {
        if (this.tokens.currentToken().isType) {
            this.tokens.removeInitialToken();
            while(this.tokens.currentToken().isType)this.tokens.removeToken();
            return true;
        }
        return false;
    }
    shiftMappings(mappings, prefixLength) {
        for(let i = 0; i < mappings.length; i++){
            const mapping = mappings[i];
            if (mapping !== undefined) mappings[i] = mapping + prefixLength;
        }
        return mappings;
    }
}

},
"node_modules/sucrase/dist/esm/transformers/Transformer.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return Transformer;
    }
});
class Transformer {
    // Return true if anything was processed, false otherwise.
    getPrefixCode() {
        return "";
    }
    getHoistedCode() {
        return "";
    }
    getSuffixCode() {
        return "";
    }
}

},
"node_modules/sucrase/dist/esm/transformers/TypeScriptTransformer.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return TypeScriptTransformer;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _types = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/types.js");
var _isIdentifier = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/sucrase/dist/esm/util/isIdentifier.js"));
var _Transformer = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/sucrase/dist/esm/transformers/Transformer.js"));
class TypeScriptTransformer extends _Transformer.default {
    constructor(rootTransformer, tokens, isImportsTransformEnabled){
        super();
        this.rootTransformer = rootTransformer;
        this.tokens = tokens;
        this.isImportsTransformEnabled = isImportsTransformEnabled;
    }
    process() {
        if (this.rootTransformer.processPossibleArrowParamEnd() || this.rootTransformer.processPossibleAsyncArrowWithTypeParams() || this.rootTransformer.processPossibleTypeRange()) return true;
        if (this.tokens.matches1(_types.TokenType._public) || this.tokens.matches1(_types.TokenType._protected) || this.tokens.matches1(_types.TokenType._private) || this.tokens.matches1(_types.TokenType._abstract) || this.tokens.matches1(_types.TokenType._readonly) || this.tokens.matches1(_types.TokenType._override) || this.tokens.matches1(_types.TokenType.nonNullAssertion)) {
            this.tokens.removeInitialToken();
            return true;
        }
        if (this.tokens.matches1(_types.TokenType._enum) || this.tokens.matches2(_types.TokenType._const, _types.TokenType._enum)) {
            this.processEnum();
            return true;
        }
        if (this.tokens.matches2(_types.TokenType._export, _types.TokenType._enum) || this.tokens.matches3(_types.TokenType._export, _types.TokenType._const, _types.TokenType._enum)) {
            this.processEnum(true);
            return true;
        }
        return false;
    }
    processEnum(isExport = false) {
        // We might have "export const enum", so just remove all relevant tokens.
        this.tokens.removeInitialToken();
        while(this.tokens.matches1(_types.TokenType._const) || this.tokens.matches1(_types.TokenType._enum))this.tokens.removeToken();
        const enumName = this.tokens.identifierName();
        this.tokens.removeToken();
        if (isExport && !this.isImportsTransformEnabled) this.tokens.appendCode("export ");
        this.tokens.appendCode(`var ${enumName}; (function (${enumName})`);
        this.tokens.copyExpectedToken(_types.TokenType.braceL);
        this.processEnumBody(enumName);
        this.tokens.copyExpectedToken(_types.TokenType.braceR);
        if (isExport && this.isImportsTransformEnabled) this.tokens.appendCode(`)(${enumName} || (exports.${enumName} = ${enumName} = {}));`);
        else this.tokens.appendCode(`)(${enumName} || (${enumName} = {}));`);
    }
    /**
   * Transform an enum into equivalent JS. This has complexity in a few places:
   * - TS allows string enums, numeric enums, and a mix of the two styles within an enum.
   * - Enum keys are allowed to be referenced in later enum values.
   * - Enum keys are allowed to be strings.
   * - When enum values are omitted, they should follow an auto-increment behavior.
   */ processEnumBody(enumName) {
        // Code that can be used to reference the previous enum member, or null if this is the first
        // enum member.
        let previousValueCode = null;
        while(true){
            if (this.tokens.matches1(_types.TokenType.braceR)) break;
            const { nameStringCode, variableName } = this.extractEnumKeyInfo(this.tokens.currentToken());
            this.tokens.removeInitialToken();
            if (this.tokens.matches3(_types.TokenType.eq, _types.TokenType.string, _types.TokenType.comma) || this.tokens.matches3(_types.TokenType.eq, _types.TokenType.string, _types.TokenType.braceR)) this.processStringLiteralEnumMember(enumName, nameStringCode, variableName);
            else if (this.tokens.matches1(_types.TokenType.eq)) this.processExplicitValueEnumMember(enumName, nameStringCode, variableName);
            else this.processImplicitValueEnumMember(enumName, nameStringCode, variableName, previousValueCode);
            if (this.tokens.matches1(_types.TokenType.comma)) this.tokens.removeToken();
            if (variableName != null) previousValueCode = variableName;
            else previousValueCode = `${enumName}[${nameStringCode}]`;
        }
    }
    /**
   * Detect name information about this enum key, which will be used to determine which code to emit
   * and whether we should declare a variable as part of this declaration.
   *
   * Some cases to keep in mind:
   * - Enum keys can be implicitly referenced later, e.g. `X = 1, Y = X`. In Sucrase, we implement
   *   this by declaring a variable `X` so that later expressions can use it.
   * - In addition to the usual identifier key syntax, enum keys are allowed to be string literals,
   *   e.g. `"hello world" = 3,`. Template literal syntax is NOT allowed.
   * - Even if the enum key is defined as a string literal, it may still be referenced by identifier
   *   later, e.g. `"X" = 1, Y = X`. That means that we need to detect whether or not a string
   *   literal is identifier-like and emit a variable if so, even if the declaration did not use an
   *   identifier.
   * - Reserved keywords like `break` are valid enum keys, but are not valid to be referenced later
   *   and would be a syntax error if we emitted a variable, so we need to skip the variable
   *   declaration in those cases.
   *
   * The variableName return value captures these nuances: if non-null, we can and must emit a
   * variable declaration, and if null, we can't and shouldn't.
   */ extractEnumKeyInfo(nameToken) {
        if (nameToken.type === _types.TokenType.name) {
            const name = this.tokens.identifierNameForToken(nameToken);
            return {
                nameStringCode: `"${name}"`,
                variableName: (0, _isIdentifier.default)(name) ? name : null
            };
        } else if (nameToken.type === _types.TokenType.string) {
            const name = this.tokens.stringValueForToken(nameToken);
            return {
                nameStringCode: this.tokens.code.slice(nameToken.start, nameToken.end),
                variableName: (0, _isIdentifier.default)(name) ? name : null
            };
        } else throw new Error("Expected name or string at beginning of enum element.");
    }
    /**
   * Handle an enum member where the RHS is just a string literal (not omitted, not a number, and
   * not a complex expression). This is the typical form for TS string enums, and in this case, we
   * do *not* create a reverse mapping.
   *
   * This is called after deleting the key token, when the token processor is at the equals sign.
   *
   * Example 1:
   * someKey = "some value"
   * ->
   * const someKey = "some value"; MyEnum["someKey"] = someKey;
   *
   * Example 2:
   * "some key" = "some value"
   * ->
   * MyEnum["some key"] = "some value";
   */ processStringLiteralEnumMember(enumName, nameStringCode, variableName) {
        if (variableName != null) {
            this.tokens.appendCode(`const ${variableName}`);
            // =
            this.tokens.copyToken();
            // value string
            this.tokens.copyToken();
            this.tokens.appendCode(`; ${enumName}[${nameStringCode}] = ${variableName};`);
        } else {
            this.tokens.appendCode(`${enumName}[${nameStringCode}]`);
            // =
            this.tokens.copyToken();
            // value string
            this.tokens.copyToken();
            this.tokens.appendCode(";");
        }
    }
    /**
   * Handle an enum member initialized with an expression on the right-hand side (other than a
   * string literal). In these cases, we should transform the expression and emit code that sets up
   * a reverse mapping.
   *
   * The TypeScript implementation of this operation distinguishes between expressions that can be
   * "constant folded" at compile time (i.e. consist of number literals and simple math operations
   * on those numbers) and ones that are dynamic. For constant expressions, it emits the resolved
   * numeric value, and auto-incrementing is only allowed in that case. Evaluating expressions at
   * compile time would add significant complexity to Sucrase, so Sucrase instead leaves the
   * expression as-is, and will later emit something like `MyEnum["previousKey"] + 1` to implement
   * auto-incrementing.
   *
   * This is called after deleting the key token, when the token processor is at the equals sign.
   *
   * Example 1:
   * someKey = 1 + 1
   * ->
   * const someKey = 1 + 1; MyEnum[MyEnum["someKey"] = someKey] = "someKey";
   *
   * Example 2:
   * "some key" = 1 + 1
   * ->
   * MyEnum[MyEnum["some key"] = 1 + 1] = "some key";
   */ processExplicitValueEnumMember(enumName, nameStringCode, variableName) {
        const rhsEndIndex = this.tokens.currentToken().rhsEndIndex;
        if (rhsEndIndex == null) throw new Error("Expected rhsEndIndex on enum assign.");
        if (variableName != null) {
            this.tokens.appendCode(`const ${variableName}`);
            this.tokens.copyToken();
            while(this.tokens.currentIndex() < rhsEndIndex)this.rootTransformer.processToken();
            this.tokens.appendCode(`; ${enumName}[${enumName}[${nameStringCode}] = ${variableName}] = ${nameStringCode};`);
        } else {
            this.tokens.appendCode(`${enumName}[${enumName}[${nameStringCode}]`);
            this.tokens.copyToken();
            while(this.tokens.currentIndex() < rhsEndIndex)this.rootTransformer.processToken();
            this.tokens.appendCode(`] = ${nameStringCode};`);
        }
    }
    /**
   * Handle an enum member with no right-hand side expression. In this case, the value is the
   * previous value plus 1, or 0 if there was no previous value. We should also always emit a
   * reverse mapping.
   *
   * Example 1:
   * someKey2
   * ->
   * const someKey2 = someKey1 + 1; MyEnum[MyEnum["someKey2"] = someKey2] = "someKey2";
   *
   * Example 2:
   * "some key 2"
   * ->
   * MyEnum[MyEnum["some key 2"] = someKey1 + 1] = "some key 2";
   */ processImplicitValueEnumMember(enumName, nameStringCode, variableName, previousValueCode) {
        let valueCode = previousValueCode != null ? `${previousValueCode} + 1` : "0";
        if (variableName != null) {
            this.tokens.appendCode(`const ${variableName} = ${valueCode}; `);
            valueCode = variableName;
        }
        this.tokens.appendCode(`${enumName}[${enumName}[${nameStringCode}] = ${valueCode}] = ${nameStringCode};`);
    }
}

},
"node_modules/sucrase/dist/esm/util/elideImportEquals.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return elideImportEquals;
    }
});
var _types = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/types.js");
function elideImportEquals(tokens) {
    // import
    tokens.removeInitialToken();
    // name
    tokens.removeToken();
    // =
    tokens.removeToken();
    // name or require
    tokens.removeToken();
    // Handle either `import A = require('A')` or `import A = B.C.D`.
    if (tokens.matches1(_types.TokenType.parenL)) {
        // (
        tokens.removeToken();
        // path string
        tokens.removeToken();
        // )
        tokens.removeToken();
    } else while(tokens.matches1(_types.TokenType.dot)){
        // .
        tokens.removeToken();
        // name
        tokens.removeToken();
    }
}

},
"node_modules/sucrase/dist/esm/util/formatTokens.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return formatTokens;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _linesandcolumns = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/lines-and-columns/build/index.js"));
var _types = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/types.js");
function formatTokens(code, tokens) {
    if (tokens.length === 0) return "";
    const tokenKeys = Object.keys(tokens[0]).filter((k)=>k !== "type" && k !== "value" && k !== "start" && k !== "end" && k !== "loc");
    const typeKeys = Object.keys(tokens[0].type).filter((k)=>k !== "label" && k !== "keyword");
    const headings = [
        "Location",
        "Label",
        "Raw",
        ...tokenKeys,
        ...typeKeys
    ];
    const lines = new _linesandcolumns.default(code);
    const rows = [
        headings,
        ...tokens.map(getTokenComponents)
    ];
    const padding = headings.map(()=>0);
    for (const components of rows)for(let i = 0; i < components.length; i++)padding[i] = Math.max(padding[i], components[i].length);
    return rows.map((components)=>components.map((component, i)=>component.padEnd(padding[i])).join(" ")).join("\n");
    function getTokenComponents(token) {
        const raw = code.slice(token.start, token.end);
        return [
            formatRange(token.start, token.end),
            (0, _types.formatTokenType)(token.type),
            truncate(String(raw), 14),
            // @ts-ignore: Intentional dynamic access by key.
            ...tokenKeys.map((key)=>formatValue(token[key], key)),
            // @ts-ignore: Intentional dynamic access by key.
            ...typeKeys.map((key)=>formatValue(token.type[key], key))
        ];
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function formatValue(value, key) {
        if (value === true) return key;
        else if (value === false || value === null) return "";
        else return String(value);
    }
    function formatRange(start, end) {
        return `${formatPos(start)}-${formatPos(end)}`;
    }
    function formatPos(pos) {
        const location = lines.locationForIndex(pos);
        if (!location) return "Unknown";
        else return `${location.line + 1}:${location.column + 1}`;
    }
}
function truncate(s, length) {
    if (s.length > length) return `${s.slice(0, length - 3)}...`;
    else return s;
}

},
"node_modules/sucrase/dist/esm/util/getClassInfo.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, /**
 * Get information about the class fields for this class, given a token processor pointing to the
 * open-brace at the start of the class.
 */ "default", {
    enumerable: true,
    get: function() {
        return getClassInfo;
    }
});
var _keywords = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/keywords.js");
var _types = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/types.js");
function getClassInfo(rootTransformer, tokens, nameManager, disableESTransforms) {
    const snapshot = tokens.snapshot();
    const headerInfo = processClassHeader(tokens);
    let constructorInitializerStatements = [];
    const instanceInitializerNames = [];
    const staticInitializerNames = [];
    let constructorInsertPos = null;
    const fields = [];
    const rangesToRemove = [];
    const classContextId = tokens.currentToken().contextId;
    if (classContextId == null) throw new Error("Expected non-null class context ID on class open-brace.");
    tokens.nextToken();
    while(!tokens.matchesContextIdAndLabel(_types.TokenType.braceR, classContextId)){
        if (tokens.matchesContextual(_keywords.ContextualKeyword._constructor) && !tokens.currentToken().isType) ({ constructorInitializerStatements, constructorInsertPos } = processConstructor(tokens));
        else if (tokens.matches1(_types.TokenType.semi)) {
            if (!disableESTransforms) rangesToRemove.push({
                start: tokens.currentIndex(),
                end: tokens.currentIndex() + 1
            });
            tokens.nextToken();
        } else if (tokens.currentToken().isType) tokens.nextToken();
        else {
            // Either a method or a field. Skip to the identifier part.
            const statementStartIndex = tokens.currentIndex();
            let isStatic = false;
            let isESPrivate = false;
            let isDeclareOrAbstract = false;
            while(isAccessModifier(tokens.currentToken())){
                if (tokens.matches1(_types.TokenType._static)) isStatic = true;
                if (tokens.matches1(_types.TokenType.hash)) isESPrivate = true;
                if (tokens.matches1(_types.TokenType._declare) || tokens.matches1(_types.TokenType._abstract)) isDeclareOrAbstract = true;
                tokens.nextToken();
            }
            if (isStatic && tokens.matches1(_types.TokenType.braceL)) {
                // This is a static block, so don't process it in any special way.
                skipToNextClassElement(tokens, classContextId);
                continue;
            }
            if (isESPrivate) {
                // Sucrase doesn't attempt to transpile private fields; just leave them as-is.
                skipToNextClassElement(tokens, classContextId);
                continue;
            }
            if (tokens.matchesContextual(_keywords.ContextualKeyword._constructor) && !tokens.currentToken().isType) {
                ({ constructorInitializerStatements, constructorInsertPos } = processConstructor(tokens));
                continue;
            }
            const nameStartIndex = tokens.currentIndex();
            skipFieldName(tokens);
            if (tokens.matches1(_types.TokenType.lessThan) || tokens.matches1(_types.TokenType.parenL)) {
                // This is a method, so nothing to process.
                skipToNextClassElement(tokens, classContextId);
                continue;
            }
            // There might be a type annotation that we need to skip.
            while(tokens.currentToken().isType)tokens.nextToken();
            if (tokens.matches1(_types.TokenType.eq)) {
                const equalsIndex = tokens.currentIndex();
                // This is an initializer, so we need to wrap in an initializer method.
                const valueEnd = tokens.currentToken().rhsEndIndex;
                if (valueEnd == null) throw new Error("Expected rhsEndIndex on class field assignment.");
                tokens.nextToken();
                while(tokens.currentIndex() < valueEnd)rootTransformer.processToken();
                let initializerName;
                if (isStatic) {
                    initializerName = nameManager.claimFreeName("__initStatic");
                    staticInitializerNames.push(initializerName);
                } else {
                    initializerName = nameManager.claimFreeName("__init");
                    instanceInitializerNames.push(initializerName);
                }
                // Fields start at the name, so `static x = 1;` has a field range of `x = 1;`.
                fields.push({
                    initializerName,
                    equalsIndex,
                    start: nameStartIndex,
                    end: tokens.currentIndex()
                });
            } else if (!disableESTransforms || isDeclareOrAbstract) // This is a regular field declaration, like `x;`. With the class transform enabled, we just
            // remove the line so that no output is produced. With the class transform disabled, we
            // usually want to preserve the declaration (but still strip types), but if the `declare`
            // or `abstract` keyword is specified, we should remove the line to avoid initializing the
            // value to undefined.
            rangesToRemove.push({
                start: statementStartIndex,
                end: tokens.currentIndex()
            });
        }
    }
    tokens.restoreToSnapshot(snapshot);
    if (disableESTransforms) // With ES transforms disabled, we don't want to transform regular class
    // field declarations, and we don't need to do any additional tricks to
    // reference the constructor for static init, but we still need to transform
    // TypeScript field initializers defined as constructor parameters and we
    // still need to remove `declare` fields. For now, we run the same code
    // path but omit any field information, as if the class had no field
    // declarations. In the future, when we fully drop the class fields
    // transform, we can simplify this code significantly.
    return {
        headerInfo,
        constructorInitializerStatements,
        instanceInitializerNames: [],
        staticInitializerNames: [],
        constructorInsertPos,
        fields: [],
        rangesToRemove
    };
    else return {
        headerInfo,
        constructorInitializerStatements,
        instanceInitializerNames,
        staticInitializerNames,
        constructorInsertPos,
        fields,
        rangesToRemove
    };
}
/**
 * Move the token processor to the next method/field in the class.
 *
 * To do that, we seek forward to the next start of a class name (either an open
 * bracket or an identifier, or the closing curly brace), then seek backward to
 * include any access modifiers.
 */ function skipToNextClassElement(tokens, classContextId) {
    tokens.nextToken();
    while(tokens.currentToken().contextId !== classContextId)tokens.nextToken();
    while(isAccessModifier(tokens.tokenAtRelativeIndex(-1)))tokens.previousToken();
}
function processClassHeader(tokens) {
    const classToken = tokens.currentToken();
    const contextId = classToken.contextId;
    if (contextId == null) throw new Error("Expected context ID on class token.");
    const isExpression = classToken.isExpression;
    if (isExpression == null) throw new Error("Expected isExpression on class token.");
    let className = null;
    let hasSuperclass = false;
    tokens.nextToken();
    if (tokens.matches1(_types.TokenType.name)) className = tokens.identifierName();
    while(!tokens.matchesContextIdAndLabel(_types.TokenType.braceL, contextId)){
        // If this has a superclass, there will always be an `extends` token. If it doesn't have a
        // superclass, only type parameters and `implements` clauses can show up here, all of which
        // consist only of type tokens. A declaration like `class A<B extends C> {` should *not* count
        // as having a superclass.
        if (tokens.matches1(_types.TokenType._extends) && !tokens.currentToken().isType) hasSuperclass = true;
        tokens.nextToken();
    }
    return {
        isExpression,
        className,
        hasSuperclass
    };
}
/**
 * Extract useful information out of a constructor, starting at the "constructor" name.
 */ function processConstructor(tokens) {
    const constructorInitializerStatements = [];
    tokens.nextToken();
    const constructorContextId = tokens.currentToken().contextId;
    if (constructorContextId == null) throw new Error("Expected context ID on open-paren starting constructor params.");
    // Advance through parameters looking for access modifiers.
    while(!tokens.matchesContextIdAndLabel(_types.TokenType.parenR, constructorContextId))if (tokens.currentToken().contextId === constructorContextId) {
        // Current token is an open paren or comma just before a param, so check
        // that param for access modifiers.
        tokens.nextToken();
        if (isAccessModifier(tokens.currentToken())) {
            tokens.nextToken();
            while(isAccessModifier(tokens.currentToken()))tokens.nextToken();
            const token = tokens.currentToken();
            if (token.type !== _types.TokenType.name) throw new Error("Expected identifier after access modifiers in constructor arg.");
            const name = tokens.identifierNameForToken(token);
            constructorInitializerStatements.push(`this.${name} = ${name}`);
        }
    } else tokens.nextToken();
    // )
    tokens.nextToken();
    // Constructor type annotations are invalid, but skip them anyway since
    // they're easy to skip.
    while(tokens.currentToken().isType)tokens.nextToken();
    let constructorInsertPos = tokens.currentIndex();
    // Advance through body looking for a super call.
    let foundSuperCall = false;
    while(!tokens.matchesContextIdAndLabel(_types.TokenType.braceR, constructorContextId)){
        if (!foundSuperCall && tokens.matches2(_types.TokenType._super, _types.TokenType.parenL)) {
            tokens.nextToken();
            const superCallContextId = tokens.currentToken().contextId;
            if (superCallContextId == null) throw new Error("Expected a context ID on the super call");
            while(!tokens.matchesContextIdAndLabel(_types.TokenType.parenR, superCallContextId))tokens.nextToken();
            constructorInsertPos = tokens.currentIndex();
            foundSuperCall = true;
        }
        tokens.nextToken();
    }
    // }
    tokens.nextToken();
    return {
        constructorInitializerStatements,
        constructorInsertPos
    };
}
/**
 * Determine if this is any token that can go before the name in a method/field.
 */ function isAccessModifier(token) {
    return [
        _types.TokenType._async,
        _types.TokenType._get,
        _types.TokenType._set,
        _types.TokenType.plus,
        _types.TokenType.minus,
        _types.TokenType._readonly,
        _types.TokenType._static,
        _types.TokenType._public,
        _types.TokenType._private,
        _types.TokenType._protected,
        _types.TokenType._override,
        _types.TokenType._abstract,
        _types.TokenType.star,
        _types.TokenType._declare,
        _types.TokenType.hash
    ].includes(token.type);
}
/**
 * The next token or set of tokens is either an identifier or an expression in square brackets, for
 * a method or field name.
 */ function skipFieldName(tokens) {
    if (tokens.matches1(_types.TokenType.bracketL)) {
        const startToken = tokens.currentToken();
        const classContextId = startToken.contextId;
        if (classContextId == null) throw new Error("Expected class context ID on computed name open bracket.");
        while(!tokens.matchesContextIdAndLabel(_types.TokenType.bracketR, classContextId))tokens.nextToken();
        tokens.nextToken();
    } else tokens.nextToken();
}

},
"node_modules/sucrase/dist/esm/util/getDeclarationInfo.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
__mako_require__.e(exports, {
    EMPTY_DECLARATION_INFO: function() {
        return EMPTY_DECLARATION_INFO;
    },
    /**
 * Get all top-level identifiers that should be preserved when exported in TypeScript.
 *
 * Examples:
 * - If an identifier is declared as `const x`, then `export {x}` should be preserved.
 * - If it's declared as `type x`, then `export {x}` should be removed.
 * - If it's declared as both `const x` and `type x`, then the export should be preserved.
 * - Classes and enums should be preserved (even though they also introduce types).
 * - Imported identifiers should be preserved since we don't have enough information to
 *   rule them out. --isolatedModules disallows re-exports, which catches errors here.
 */ default: function() {
        return getDeclarationInfo;
    }
});
var _tokenizer = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/index.js");
var _types = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/types.js");
const EMPTY_DECLARATION_INFO = {
    typeDeclarations: new Set(),
    valueDeclarations: new Set()
};
function getDeclarationInfo(tokens) {
    const typeDeclarations = new Set();
    const valueDeclarations = new Set();
    for(let i = 0; i < tokens.tokens.length; i++){
        const token = tokens.tokens[i];
        if (token.type === _types.TokenType.name && (0, _tokenizer.isTopLevelDeclaration)(token)) {
            if (token.isType) typeDeclarations.add(tokens.identifierNameForToken(token));
            else valueDeclarations.add(tokens.identifierNameForToken(token));
        }
    }
    return {
        typeDeclarations,
        valueDeclarations
    };
}

},
"node_modules/sucrase/dist/esm/util/getIdentifierNames.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, /**
 * Get all identifier names in the code, in order, including duplicates.
 */ "default", {
    enumerable: true,
    get: function() {
        return getIdentifierNames;
    }
});
var _types = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/types.js");
function getIdentifierNames(code, tokens) {
    const names = [];
    for (const token of tokens)if (token.type === _types.TokenType.name) names.push(code.slice(token.start, token.end));
    return names;
}

},
"node_modules/sucrase/dist/esm/util/getImportExportSpecifierInfo.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, /**
 * Determine information about this named import or named export specifier.
 *
 * This syntax is the `a` from statements like these:
 * import {A} from "./foo";
 * export {A};
 * export {A} from "./foo";
 *
 * As it turns out, we can exactly characterize the syntax meaning by simply
 * counting the number of tokens, which can be from 1 to 4:
 * {A}
 * {type A}
 * {A as B}
 * {type A as B}
 *
 * In the type case, we never actually need the names in practice, so don't get
 * them.
 *
 * TODO: There's some redundancy with the type detection here and the isType
 * flag that's already present on tokens in TS mode. This function could
 * potentially be simplified and/or pushed to the call sites to avoid the object
 * allocation.
 */ "default", {
    enumerable: true,
    get: function() {
        return getImportExportSpecifierInfo;
    }
});
var _types = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/types.js");
function getImportExportSpecifierInfo(tokens, index = tokens.currentIndex()) {
    let endIndex = index + 1;
    if (isSpecifierEnd(tokens, endIndex)) {
        // import {A}
        const name = tokens.identifierNameAtIndex(index);
        return {
            isType: false,
            leftName: name,
            rightName: name,
            endIndex
        };
    }
    endIndex++;
    if (isSpecifierEnd(tokens, endIndex)) // import {type A}
    return {
        isType: true,
        leftName: null,
        rightName: null,
        endIndex
    };
    endIndex++;
    if (isSpecifierEnd(tokens, endIndex)) // import {A as B}
    return {
        isType: false,
        leftName: tokens.identifierNameAtIndex(index),
        rightName: tokens.identifierNameAtIndex(index + 2),
        endIndex
    };
    endIndex++;
    if (isSpecifierEnd(tokens, endIndex)) // import {type A as B}
    return {
        isType: true,
        leftName: null,
        rightName: null,
        endIndex
    };
    throw new Error(`Unexpected import/export specifier at ${index}`);
}
function isSpecifierEnd(tokens, index) {
    const token = tokens.tokens[index];
    return token.type === _types.TokenType.braceR || token.type === _types.TokenType.comma;
}

},
"node_modules/sucrase/dist/esm/util/getJSXPragmaInfo.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "default", {
    enumerable: true,
    get: function() {
        return getJSXPragmaInfo;
    }
});
function getJSXPragmaInfo(options) {
    const [base, suffix] = splitPragma(options.jsxPragma || "React.createElement");
    const [fragmentBase, fragmentSuffix] = splitPragma(options.jsxFragmentPragma || "React.Fragment");
    return {
        base,
        suffix,
        fragmentBase,
        fragmentSuffix
    };
}
function splitPragma(pragma) {
    let dotIndex = pragma.indexOf(".");
    if (dotIndex === -1) dotIndex = pragma.length;
    return [
        pragma.slice(0, dotIndex),
        pragma.slice(dotIndex)
    ];
}

},
"node_modules/sucrase/dist/esm/util/getNonTypeIdentifiers.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "getNonTypeIdentifiers", {
    enumerable: true,
    get: function() {
        return getNonTypeIdentifiers;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _tokenizer = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/index.js");
var _types = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/types.js");
var _JSXTransformer = __mako_require__("node_modules/sucrase/dist/esm/transformers/JSXTransformer.js");
var _getJSXPragmaInfo = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/sucrase/dist/esm/util/getJSXPragmaInfo.js"));
function getNonTypeIdentifiers(tokens, options) {
    const jsxPragmaInfo = (0, _getJSXPragmaInfo.default)(options);
    const nonTypeIdentifiers = new Set();
    for(let i = 0; i < tokens.tokens.length; i++){
        const token = tokens.tokens[i];
        if (token.type === _types.TokenType.name && !token.isType && (token.identifierRole === _tokenizer.IdentifierRole.Access || token.identifierRole === _tokenizer.IdentifierRole.ObjectShorthand || token.identifierRole === _tokenizer.IdentifierRole.ExportAccess) && !token.shadowsGlobal) nonTypeIdentifiers.add(tokens.identifierNameForToken(token));
        if (token.type === _types.TokenType.jsxTagStart) nonTypeIdentifiers.add(jsxPragmaInfo.base);
        if (token.type === _types.TokenType.jsxTagStart && i + 1 < tokens.tokens.length && tokens.tokens[i + 1].type === _types.TokenType.jsxTagEnd) {
            nonTypeIdentifiers.add(jsxPragmaInfo.base);
            nonTypeIdentifiers.add(jsxPragmaInfo.fragmentBase);
        }
        if (token.type === _types.TokenType.jsxName && token.identifierRole === _tokenizer.IdentifierRole.Access) {
            const identifierName = tokens.identifierNameForToken(token);
            // Lower-case single-component tag names like "div" don't count.
            if (!(0, _JSXTransformer.startsWithLowerCase)(identifierName) || tokens.tokens[i + 1].type === _types.TokenType.dot) nonTypeIdentifiers.add(tokens.identifierNameForToken(token));
        }
    }
    return nonTypeIdentifiers;
}

},
"node_modules/sucrase/dist/esm/util/getTSImportedNames.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, /**
 * Special case code to scan for imported names in ESM TypeScript. We need to do this so we can
 * properly get globals so we can compute shadowed globals.
 *
 * This is similar to logic in CJSImportProcessor, but trimmed down to avoid logic with CJS
 * replacement and flow type imports.
 */ "default", {
    enumerable: true,
    get: function() {
        return getTSImportedNames;
    }
});
var _interop_require_default = __mako_require__("@swc/helpers/_/_interop_require_default");
var _types = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/types.js");
var _getImportExportSpecifierInfo = /*#__PURE__*/ _interop_require_default._(__mako_require__("node_modules/sucrase/dist/esm/util/getImportExportSpecifierInfo.js"));
function getTSImportedNames(tokens) {
    const importedNames = new Set();
    for(let i = 0; i < tokens.tokens.length; i++)if (tokens.matches1AtIndex(i, _types.TokenType._import) && !tokens.matches3AtIndex(i, _types.TokenType._import, _types.TokenType.name, _types.TokenType.eq)) collectNamesForImport(tokens, i, importedNames);
    return importedNames;
}
function collectNamesForImport(tokens, index, importedNames) {
    index++;
    if (tokens.matches1AtIndex(index, _types.TokenType.parenL)) // Dynamic import, so nothing to do
    return;
    if (tokens.matches1AtIndex(index, _types.TokenType.name)) {
        importedNames.add(tokens.identifierNameAtIndex(index));
        index++;
        if (tokens.matches1AtIndex(index, _types.TokenType.comma)) index++;
    }
    if (tokens.matches1AtIndex(index, _types.TokenType.star)) {
        // * as
        index += 2;
        importedNames.add(tokens.identifierNameAtIndex(index));
        index++;
    }
    if (tokens.matches1AtIndex(index, _types.TokenType.braceL)) {
        index++;
        collectNamesForNamedImport(tokens, index, importedNames);
    }
}
function collectNamesForNamedImport(tokens, index, importedNames) {
    while(true){
        if (tokens.matches1AtIndex(index, _types.TokenType.braceR)) return;
        const specifierInfo = (0, _getImportExportSpecifierInfo.default)(tokens, index);
        index = specifierInfo.endIndex;
        if (!specifierInfo.isType) importedNames.add(specifierInfo.rightName);
        if (tokens.matches2AtIndex(index, _types.TokenType.comma, _types.TokenType.braceR)) return;
        else if (tokens.matches1AtIndex(index, _types.TokenType.braceR)) return;
        else if (tokens.matches1AtIndex(index, _types.TokenType.comma)) index++;
        else throw new Error(`Unexpected token: ${JSON.stringify(tokens.tokens[index])}`);
    }
}

},
"node_modules/sucrase/dist/esm/util/isAsyncOperation.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, /**
 * Determine whether this optional chain or nullish coalescing operation has any await statements in
 * it. If so, we'll need to transpile to an async operation.
 *
 * We compute this by walking the length of the operation and returning true if we see an await
 * keyword used as a real await (rather than an object key or property access). Nested optional
 * chain/nullish operations need to be tracked but don't silence await, but a nested async function
 * (or any other nested scope) will make the await not count.
 */ "default", {
    enumerable: true,
    get: function() {
        return isAsyncOperation;
    }
});
var _keywords = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/keywords.js");
function isAsyncOperation(tokens) {
    let index = tokens.currentIndex();
    let depth = 0;
    const startToken = tokens.currentToken();
    do {
        const token = tokens.tokens[index];
        if (token.isOptionalChainStart) depth++;
        if (token.isOptionalChainEnd) depth--;
        depth += token.numNullishCoalesceStarts;
        depth -= token.numNullishCoalesceEnds;
        if (token.contextualKeyword === _keywords.ContextualKeyword._await && token.identifierRole == null && token.scopeDepth === startToken.scopeDepth) return true;
        index += 1;
    }while (depth > 0 && index < tokens.tokens.length)
    return false;
}

},
"node_modules/sucrase/dist/esm/util/isExportFrom.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, /**
 * Starting at `export {`, look ahead and return `true` if this is an
 * `export {...} from` statement and `false` if this is a plain multi-export.
 */ "default", {
    enumerable: true,
    get: function() {
        return isExportFrom;
    }
});
var _keywords = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/keywords.js");
var _types = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/types.js");
function isExportFrom(tokens) {
    let closeBraceIndex = tokens.currentIndex();
    while(!tokens.matches1AtIndex(closeBraceIndex, _types.TokenType.braceR))closeBraceIndex++;
    return tokens.matchesContextualAtIndex(closeBraceIndex + 1, _keywords.ContextualKeyword._from) && tokens.matches1AtIndex(closeBraceIndex + 2, _types.TokenType.string);
}

},
"node_modules/sucrase/dist/esm/util/isIdentifier.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, /**
 * Determine if the given name is a legal variable name.
 *
 * This is needed when transforming TypeScript enums; if an enum key is a valid
 * variable name, it might be referenced later in the enum, so we need to
 * declare a variable.
 */ "default", {
    enumerable: true,
    get: function() {
        return isIdentifier;
    }
});
var _identifier = __mako_require__("node_modules/sucrase/dist/esm/parser/util/identifier.js");
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar
// Hard-code a list of reserved words rather than trying to use keywords or contextual keywords
// from the parser, since currently there are various exceptions, like `package` being reserved
// but unused and various contextual keywords being reserved. Note that we assume that all code
// compiled by Sucrase is in a module, so strict mode words and await are all considered reserved
// here.
const RESERVED_WORDS = new Set([
    // Reserved keywords as of ECMAScript 2015
    "break",
    "case",
    "catch",
    "class",
    "const",
    "continue",
    "debugger",
    "default",
    "delete",
    "do",
    "else",
    "export",
    "extends",
    "finally",
    "for",
    "function",
    "if",
    "import",
    "in",
    "instanceof",
    "new",
    "return",
    "super",
    "switch",
    "this",
    "throw",
    "try",
    "typeof",
    "var",
    "void",
    "while",
    "with",
    "yield",
    // Future reserved keywords
    "enum",
    "implements",
    "interface",
    "let",
    "package",
    "private",
    "protected",
    "public",
    "static",
    "await",
    // Literals that cannot be used as identifiers
    "false",
    "null",
    "true"
]);
function isIdentifier(name) {
    if (name.length === 0) return false;
    if (!_identifier.IS_IDENTIFIER_START[name.charCodeAt(0)]) return false;
    for(let i = 1; i < name.length; i++){
        if (!_identifier.IS_IDENTIFIER_CHAR[name.charCodeAt(i)]) return false;
    }
    return !RESERVED_WORDS.has(name);
}

},
"node_modules/sucrase/dist/esm/util/removeMaybeImportAttributes.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, "removeMaybeImportAttributes", {
    enumerable: true,
    get: function() {
        return removeMaybeImportAttributes;
    }
});
var _keywords = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/keywords.js");
var _types = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/types.js");
function removeMaybeImportAttributes(tokens) {
    if (tokens.matches2(_types.TokenType._with, _types.TokenType.braceL) || tokens.matches2(_types.TokenType.name, _types.TokenType.braceL) && tokens.matchesContextual(_keywords.ContextualKeyword._assert)) {
        // assert
        tokens.removeToken();
        // {
        tokens.removeToken();
        tokens.removeBalancedCode();
        // }
        tokens.removeToken();
    }
}

},
"node_modules/sucrase/dist/esm/util/shouldElideDefaultExport.js": function (module, exports, __mako_require__){
"use strict";
__mako_require__.d(exports, "__esModule", {
    value: true
});
__mako_require__.d(exports, /**
 * Common method sharing code between CJS and ESM cases, since they're the same here.
 */ "default", {
    enumerable: true,
    get: function() {
        return shouldElideDefaultExport;
    }
});
var _types = __mako_require__("node_modules/sucrase/dist/esm/parser/tokenizer/types.js");
function shouldElideDefaultExport(isTypeScriptTransformEnabled, keepUnusedImports, tokens, declarationInfo) {
    if (!isTypeScriptTransformEnabled || keepUnusedImports) return false;
    const exportToken = tokens.currentToken();
    if (exportToken.rhsEndIndex == null) throw new Error("Expected non-null rhsEndIndex on export token.");
    // The export must be of the form `export default a` or `export default a;`.
    const numTokens = exportToken.rhsEndIndex - tokens.currentIndex();
    if (numTokens !== 3 && !(numTokens === 4 && tokens.matches1AtIndex(exportToken.rhsEndIndex - 1, _types.TokenType.semi))) return false;
    const identifierToken = tokens.tokenAtRelativeIndex(2);
    if (identifierToken.type !== _types.TokenType.name) return false;
    const exportedName = tokens.identifierNameForToken(identifierToken);
    return declarationInfo.typeDeclarations.has(exportedName) && !declarationInfo.valueDeclarations.has(exportedName);
}

},
"node_modules/ts-interface-checker/dist/index.js": function (module, exports, __mako_require__){
"use strict";
var __spreadArrays = this && this.__spreadArrays || function() {
    for(var s = 0, i = 0, il = arguments.length; i < il; i++)s += arguments[i].length;
    for(var r = Array(s), k = 0, i = 0; i < il; i++)for(var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Checker = exports.createCheckers = void 0;
var types_1 = __mako_require__("node_modules/ts-interface-checker/dist/types.js");
var util_1 = __mako_require__("node_modules/ts-interface-checker/dist/util.js");
/**
 * Export functions used to define interfaces.
 */ var types_2 = __mako_require__("node_modules/ts-interface-checker/dist/types.js");
Object.defineProperty(exports, "TArray", {
    enumerable: true,
    get: function() {
        return types_2.TArray;
    }
});
Object.defineProperty(exports, "TEnumType", {
    enumerable: true,
    get: function() {
        return types_2.TEnumType;
    }
});
Object.defineProperty(exports, "TEnumLiteral", {
    enumerable: true,
    get: function() {
        return types_2.TEnumLiteral;
    }
});
Object.defineProperty(exports, "TFunc", {
    enumerable: true,
    get: function() {
        return types_2.TFunc;
    }
});
Object.defineProperty(exports, "TIface", {
    enumerable: true,
    get: function() {
        return types_2.TIface;
    }
});
Object.defineProperty(exports, "TLiteral", {
    enumerable: true,
    get: function() {
        return types_2.TLiteral;
    }
});
Object.defineProperty(exports, "TName", {
    enumerable: true,
    get: function() {
        return types_2.TName;
    }
});
Object.defineProperty(exports, "TOptional", {
    enumerable: true,
    get: function() {
        return types_2.TOptional;
    }
});
Object.defineProperty(exports, "TParam", {
    enumerable: true,
    get: function() {
        return types_2.TParam;
    }
});
Object.defineProperty(exports, "TParamList", {
    enumerable: true,
    get: function() {
        return types_2.TParamList;
    }
});
Object.defineProperty(exports, "TProp", {
    enumerable: true,
    get: function() {
        return types_2.TProp;
    }
});
Object.defineProperty(exports, "TTuple", {
    enumerable: true,
    get: function() {
        return types_2.TTuple;
    }
});
Object.defineProperty(exports, "TType", {
    enumerable: true,
    get: function() {
        return types_2.TType;
    }
});
Object.defineProperty(exports, "TUnion", {
    enumerable: true,
    get: function() {
        return types_2.TUnion;
    }
});
Object.defineProperty(exports, "TIntersection", {
    enumerable: true,
    get: function() {
        return types_2.TIntersection;
    }
});
Object.defineProperty(exports, "array", {
    enumerable: true,
    get: function() {
        return types_2.array;
    }
});
Object.defineProperty(exports, "enumlit", {
    enumerable: true,
    get: function() {
        return types_2.enumlit;
    }
});
Object.defineProperty(exports, "enumtype", {
    enumerable: true,
    get: function() {
        return types_2.enumtype;
    }
});
Object.defineProperty(exports, "func", {
    enumerable: true,
    get: function() {
        return types_2.func;
    }
});
Object.defineProperty(exports, "iface", {
    enumerable: true,
    get: function() {
        return types_2.iface;
    }
});
Object.defineProperty(exports, "lit", {
    enumerable: true,
    get: function() {
        return types_2.lit;
    }
});
Object.defineProperty(exports, "name", {
    enumerable: true,
    get: function() {
        return types_2.name;
    }
});
Object.defineProperty(exports, "opt", {
    enumerable: true,
    get: function() {
        return types_2.opt;
    }
});
Object.defineProperty(exports, "param", {
    enumerable: true,
    get: function() {
        return types_2.param;
    }
});
Object.defineProperty(exports, "tuple", {
    enumerable: true,
    get: function() {
        return types_2.tuple;
    }
});
Object.defineProperty(exports, "union", {
    enumerable: true,
    get: function() {
        return types_2.union;
    }
});
Object.defineProperty(exports, "intersection", {
    enumerable: true,
    get: function() {
        return types_2.intersection;
    }
});
Object.defineProperty(exports, "BasicType", {
    enumerable: true,
    get: function() {
        return types_2.BasicType;
    }
});
var util_2 = __mako_require__("node_modules/ts-interface-checker/dist/util.js");
Object.defineProperty(exports, "VError", {
    enumerable: true,
    get: function() {
        return util_2.VError;
    }
});
/**
 * Takes one of more type suites (e.g. a module generated by `ts-interface-builder`), and combines
 * them into a suite of interface checkers. If a type is used by name, that name should be present
 * among the passed-in type suites.
 *
 * The returned object maps type names to Checker objects.
 */ function createCheckers() {
    var typeSuite = [];
    for(var _i = 0; _i < arguments.length; _i++)typeSuite[_i] = arguments[_i];
    var fullSuite = Object.assign.apply(Object, __spreadArrays([
        {},
        types_1.basicTypes
    ], typeSuite));
    var checkers = {};
    for(var _a = 0, typeSuite_1 = typeSuite; _a < typeSuite_1.length; _a++){
        var suite_1 = typeSuite_1[_a];
        for(var _b = 0, _c = Object.keys(suite_1); _b < _c.length; _b++){
            var name = _c[_b];
            checkers[name] = new Checker(fullSuite, suite_1[name]);
        }
    }
    return checkers;
}
exports.createCheckers = createCheckers;
/**
 * Checker implements validation of objects, and also includes accessors to validate method calls.
 * Checkers should be created using `createCheckers()`.
 */ var Checker = function() {
    // Create checkers by using `createCheckers()` function.
    function Checker(suite, ttype, _path) {
        if (_path === void 0) _path = 'value';
        this.suite = suite;
        this.ttype = ttype;
        this._path = _path;
        this.props = new Map();
        if (ttype instanceof types_1.TIface) for(var _i = 0, _a = ttype.props; _i < _a.length; _i++){
            var p = _a[_i];
            this.props.set(p.name, p.ttype);
        }
        this.checkerPlain = this.ttype.getChecker(suite, false);
        this.checkerStrict = this.ttype.getChecker(suite, true);
    }
    /**
     * Set the path to report in errors, instead of the default "value". (E.g. if the Checker is for
     * a "person" interface, set path to "person" to report e.g. "person.name is not a string".)
     */ Checker.prototype.setReportedPath = function(path) {
        this._path = path;
    };
    /**
     * Check that the given value satisfies this checker's type, or throw Error.
     */ Checker.prototype.check = function(value) {
        return this._doCheck(this.checkerPlain, value);
    };
    /**
     * A fast check for whether or not the given value satisfies this Checker's type. This returns
     * true or false, does not produce an error message, and is fast both on success and on failure.
     */ Checker.prototype.test = function(value) {
        return this.checkerPlain(value, new util_1.NoopContext());
    };
    /**
     * Returns an error object describing the errors if the given value does not satisfy this
     * Checker's type, or null if it does.
     */ Checker.prototype.validate = function(value) {
        return this._doValidate(this.checkerPlain, value);
    };
    /**
     * Check that the given value satisfies this checker's type strictly. This checks that objects
     * and tuples have no extra members. Note that this prevents backward compatibility, so usually
     * a plain check() is more appropriate.
     */ Checker.prototype.strictCheck = function(value) {
        return this._doCheck(this.checkerStrict, value);
    };
    /**
     * A fast strict check for whether or not the given value satisfies this Checker's type. Returns
     * true or false, does not produce an error message, and is fast both on success and on failure.
     */ Checker.prototype.strictTest = function(value) {
        return this.checkerStrict(value, new util_1.NoopContext());
    };
    /**
     * Returns an error object describing the errors if the given value does not satisfy this
     * Checker's type strictly, or null if it does.
     */ Checker.prototype.strictValidate = function(value) {
        return this._doValidate(this.checkerStrict, value);
    };
    /**
     * If this checker is for an interface, returns a Checker for the type required for the given
     * property of this interface.
     */ Checker.prototype.getProp = function(prop) {
        var ttype = this.props.get(prop);
        if (!ttype) throw new Error("Type has no property " + prop);
        return new Checker(this.suite, ttype, this._path + "." + prop);
    };
    /**
     * If this checker is for an interface, returns a Checker for the argument-list required to call
     * the given method of this interface. E.g. if this Checker is for the interface:
     *    interface Foo {
     *      find(s: string, pos?: number): number;
     *    }
     * Then methodArgs("find").check(...) will succeed for ["foo"] and ["foo", 3], but not for [17].
     */ Checker.prototype.methodArgs = function(methodName) {
        var tfunc = this._getMethod(methodName);
        return new Checker(this.suite, tfunc.paramList);
    };
    /**
     * If this checker is for an interface, returns a Checker for the return value of the given
     * method of this interface.
     */ Checker.prototype.methodResult = function(methodName) {
        var tfunc = this._getMethod(methodName);
        return new Checker(this.suite, tfunc.result);
    };
    /**
     * If this checker is for a function, returns a Checker for its argument-list.
     */ Checker.prototype.getArgs = function() {
        if (!(this.ttype instanceof types_1.TFunc)) throw new Error("getArgs() applied to non-function");
        return new Checker(this.suite, this.ttype.paramList);
    };
    /**
     * If this checker is for a function, returns a Checker for its result.
     */ Checker.prototype.getResult = function() {
        if (!(this.ttype instanceof types_1.TFunc)) throw new Error("getResult() applied to non-function");
        return new Checker(this.suite, this.ttype.result);
    };
    /**
     * Return the type for which this is a checker.
     */ Checker.prototype.getType = function() {
        return this.ttype;
    };
    /**
     * Actual implementation of check() and strictCheck().
     */ Checker.prototype._doCheck = function(checkerFunc, value) {
        var noopCtx = new util_1.NoopContext();
        if (!checkerFunc(value, noopCtx)) {
            var detailCtx = new util_1.DetailContext();
            checkerFunc(value, detailCtx);
            throw detailCtx.getError(this._path);
        }
    };
    Checker.prototype._doValidate = function(checkerFunc, value) {
        var noopCtx = new util_1.NoopContext();
        if (checkerFunc(value, noopCtx)) return null;
        var detailCtx = new util_1.DetailContext();
        checkerFunc(value, detailCtx);
        return detailCtx.getErrorDetail(this._path);
    };
    Checker.prototype._getMethod = function(methodName) {
        var ttype = this.props.get(methodName);
        if (!ttype) throw new Error("Type has no property " + methodName);
        if (!(ttype instanceof types_1.TFunc)) throw new Error("Property " + methodName + " is not a method");
        return ttype;
    };
    return Checker;
}();
exports.Checker = Checker;

},
"node_modules/ts-interface-checker/dist/types.js": function (module, exports, __mako_require__){
const Buffer = __mako_require__("node_modules/node-libs-browser-okam/polyfill/buffer.js").Buffer;
"use strict";
/**
 * This module defines nodes used to define types and validations for objects and interfaces.
 */ // tslint:disable:no-shadowed-variable prefer-for-of
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.basicTypes = exports.BasicType = exports.TParamList = exports.TParam = exports.param = exports.TFunc = exports.func = exports.TProp = exports.TOptional = exports.opt = exports.TIface = exports.iface = exports.TEnumLiteral = exports.enumlit = exports.TEnumType = exports.enumtype = exports.TIntersection = exports.intersection = exports.TUnion = exports.union = exports.TTuple = exports.tuple = exports.TArray = exports.array = exports.TLiteral = exports.lit = exports.TName = exports.name = exports.TType = void 0;
var util_1 = __mako_require__("node_modules/ts-interface-checker/dist/util.js");
/** Node that represents a type. */ var TType = function() {
    function TType() {}
    return TType;
}();
exports.TType = TType;
/** Parses a type spec into a TType node. */ function parseSpec(typeSpec) {
    return typeof typeSpec === "string" ? name(typeSpec) : typeSpec;
}
function getNamedType(suite, name) {
    var ttype = suite[name];
    if (!ttype) throw new Error("Unknown type " + name);
    return ttype;
}
/**
 * Defines a type name, either built-in, or defined in this suite. It can typically be included in
 * the specs as just a plain string.
 */ function name(value) {
    return new TName(value);
}
exports.name = name;
var TName = function(_super) {
    __extends(TName, _super);
    function TName(name) {
        var _this = _super.call(this) || this;
        _this.name = name;
        _this._failMsg = "is not a " + name;
        return _this;
    }
    TName.prototype.getChecker = function(suite, strict, allowedProps) {
        var _this = this;
        var ttype = getNamedType(suite, this.name);
        var checker = ttype.getChecker(suite, strict, allowedProps);
        if (ttype instanceof BasicType || ttype instanceof TName) return checker;
        // For complex types, add an additional "is not a <Type>" message on failure.
        return function(value, ctx) {
            return checker(value, ctx) ? true : ctx.fail(null, _this._failMsg, 0);
        };
    };
    return TName;
}(TType);
exports.TName = TName;
/**
 * Defines a literal value, e.g. lit('hello') or lit(123).
 */ function lit(value) {
    return new TLiteral(value);
}
exports.lit = lit;
var TLiteral = function(_super) {
    __extends(TLiteral, _super);
    function TLiteral(value) {
        var _this = _super.call(this) || this;
        _this.value = value;
        _this.name = JSON.stringify(value);
        _this._failMsg = "is not " + _this.name;
        return _this;
    }
    TLiteral.prototype.getChecker = function(suite, strict) {
        var _this = this;
        return function(value, ctx) {
            return value === _this.value ? true : ctx.fail(null, _this._failMsg, -1);
        };
    };
    return TLiteral;
}(TType);
exports.TLiteral = TLiteral;
/**
 * Defines an array type, e.g. array('number').
 */ function array(typeSpec) {
    return new TArray(parseSpec(typeSpec));
}
exports.array = array;
var TArray = function(_super) {
    __extends(TArray, _super);
    function TArray(ttype) {
        var _this = _super.call(this) || this;
        _this.ttype = ttype;
        return _this;
    }
    TArray.prototype.getChecker = function(suite, strict) {
        var itemChecker = this.ttype.getChecker(suite, strict);
        return function(value, ctx) {
            if (!Array.isArray(value)) return ctx.fail(null, "is not an array", 0);
            for(var i = 0; i < value.length; i++){
                var ok = itemChecker(value[i], ctx);
                if (!ok) return ctx.fail(i, null, 1);
            }
            return true;
        };
    };
    return TArray;
}(TType);
exports.TArray = TArray;
/**
 * Defines a tuple type, e.g. tuple('string', 'number').
 */ function tuple() {
    var typeSpec = [];
    for(var _i = 0; _i < arguments.length; _i++)typeSpec[_i] = arguments[_i];
    return new TTuple(typeSpec.map(function(t) {
        return parseSpec(t);
    }));
}
exports.tuple = tuple;
var TTuple = function(_super) {
    __extends(TTuple, _super);
    function TTuple(ttypes) {
        var _this = _super.call(this) || this;
        _this.ttypes = ttypes;
        return _this;
    }
    TTuple.prototype.getChecker = function(suite, strict) {
        var itemCheckers = this.ttypes.map(function(t) {
            return t.getChecker(suite, strict);
        });
        var checker = function(value, ctx) {
            if (!Array.isArray(value)) return ctx.fail(null, "is not an array", 0);
            for(var i = 0; i < itemCheckers.length; i++){
                var ok = itemCheckers[i](value[i], ctx);
                if (!ok) return ctx.fail(i, null, 1);
            }
            return true;
        };
        if (!strict) return checker;
        return function(value, ctx) {
            if (!checker(value, ctx)) return false;
            return value.length <= itemCheckers.length ? true : ctx.fail(itemCheckers.length, "is extraneous", 2);
        };
    };
    return TTuple;
}(TType);
exports.TTuple = TTuple;
/**
 * Defines a union type, e.g. union('number', 'null').
 */ function union() {
    var typeSpec = [];
    for(var _i = 0; _i < arguments.length; _i++)typeSpec[_i] = arguments[_i];
    return new TUnion(typeSpec.map(function(t) {
        return parseSpec(t);
    }));
}
exports.union = union;
var TUnion = function(_super) {
    __extends(TUnion, _super);
    function TUnion(ttypes) {
        var _this = _super.call(this) || this;
        _this.ttypes = ttypes;
        var names = ttypes.map(function(t) {
            return t instanceof TName || t instanceof TLiteral ? t.name : null;
        }).filter(function(n) {
            return n;
        });
        var otherTypes = ttypes.length - names.length;
        if (names.length) {
            if (otherTypes > 0) names.push(otherTypes + " more");
            _this._failMsg = "is none of " + names.join(", ");
        } else _this._failMsg = "is none of " + otherTypes + " types";
        return _this;
    }
    TUnion.prototype.getChecker = function(suite, strict) {
        var _this = this;
        var itemCheckers = this.ttypes.map(function(t) {
            return t.getChecker(suite, strict);
        });
        return function(value, ctx) {
            var ur = ctx.unionResolver();
            for(var i = 0; i < itemCheckers.length; i++){
                var ok = itemCheckers[i](value, ur.createContext());
                if (ok) return true;
            }
            ctx.resolveUnion(ur);
            return ctx.fail(null, _this._failMsg, 0);
        };
    };
    return TUnion;
}(TType);
exports.TUnion = TUnion;
/**
 * Defines an intersection type, e.g. intersection('number', 'null').
 */ function intersection() {
    var typeSpec = [];
    for(var _i = 0; _i < arguments.length; _i++)typeSpec[_i] = arguments[_i];
    return new TIntersection(typeSpec.map(function(t) {
        return parseSpec(t);
    }));
}
exports.intersection = intersection;
var TIntersection = function(_super) {
    __extends(TIntersection, _super);
    function TIntersection(ttypes) {
        var _this = _super.call(this) || this;
        _this.ttypes = ttypes;
        return _this;
    }
    TIntersection.prototype.getChecker = function(suite, strict) {
        var allowedProps = new Set();
        var itemCheckers = this.ttypes.map(function(t) {
            return t.getChecker(suite, strict, allowedProps);
        });
        return function(value, ctx) {
            var ok = itemCheckers.every(function(checker) {
                return checker(value, ctx);
            });
            if (ok) return true;
            return ctx.fail(null, null, 0);
        };
    };
    return TIntersection;
}(TType);
exports.TIntersection = TIntersection;
/**
 * Defines an enum type, e.g. enum({'A': 1, 'B': 2}).
 */ function enumtype(values) {
    return new TEnumType(values);
}
exports.enumtype = enumtype;
var TEnumType = function(_super) {
    __extends(TEnumType, _super);
    function TEnumType(members) {
        var _this = _super.call(this) || this;
        _this.members = members;
        _this.validValues = new Set();
        _this._failMsg = "is not a valid enum value";
        _this.validValues = new Set(Object.keys(members).map(function(name) {
            return members[name];
        }));
        return _this;
    }
    TEnumType.prototype.getChecker = function(suite, strict) {
        var _this = this;
        return function(value, ctx) {
            return _this.validValues.has(value) ? true : ctx.fail(null, _this._failMsg, 0);
        };
    };
    return TEnumType;
}(TType);
exports.TEnumType = TEnumType;
/**
 * Defines a literal enum value, such as Direction.Up, specified as enumlit("Direction", "Up").
 */ function enumlit(name, prop) {
    return new TEnumLiteral(name, prop);
}
exports.enumlit = enumlit;
var TEnumLiteral = function(_super) {
    __extends(TEnumLiteral, _super);
    function TEnumLiteral(enumName, prop) {
        var _this = _super.call(this) || this;
        _this.enumName = enumName;
        _this.prop = prop;
        _this._failMsg = "is not " + enumName + "." + prop;
        return _this;
    }
    TEnumLiteral.prototype.getChecker = function(suite, strict) {
        var _this = this;
        var ttype = getNamedType(suite, this.enumName);
        if (!(ttype instanceof TEnumType)) throw new Error("Type " + this.enumName + " used in enumlit is not an enum type");
        var val = ttype.members[this.prop];
        if (!ttype.members.hasOwnProperty(this.prop)) throw new Error("Unknown value " + this.enumName + "." + this.prop + " used in enumlit");
        return function(value, ctx) {
            return value === val ? true : ctx.fail(null, _this._failMsg, -1);
        };
    };
    return TEnumLiteral;
}(TType);
exports.TEnumLiteral = TEnumLiteral;
function makeIfaceProps(props) {
    return Object.keys(props).map(function(name) {
        return makeIfaceProp(name, props[name]);
    });
}
function makeIfaceProp(name, prop) {
    return prop instanceof TOptional ? new TProp(name, prop.ttype, true) : new TProp(name, parseSpec(prop), false);
}
/**
 * Defines an interface. The first argument is an array of interfaces that it extends, and the
 * second is an array of properties.
 */ function iface(bases, props) {
    return new TIface(bases, makeIfaceProps(props));
}
exports.iface = iface;
var TIface = function(_super) {
    __extends(TIface, _super);
    function TIface(bases, props) {
        var _this = _super.call(this) || this;
        _this.bases = bases;
        _this.props = props;
        _this.propSet = new Set(props.map(function(p) {
            return p.name;
        }));
        return _this;
    }
    TIface.prototype.getChecker = function(suite, strict, allowedProps) {
        var _this = this;
        var baseCheckers = this.bases.map(function(b) {
            return getNamedType(suite, b).getChecker(suite, strict);
        });
        var propCheckers = this.props.map(function(prop) {
            return prop.ttype.getChecker(suite, strict);
        });
        var testCtx = new util_1.NoopContext();
        // Consider a prop required if it's not optional AND does not allow for undefined as a value.
        var isPropRequired = this.props.map(function(prop, i) {
            return !prop.isOpt && !propCheckers[i](undefined, testCtx);
        });
        var checker = function(value, ctx) {
            if (typeof value !== "object" || value === null) return ctx.fail(null, "is not an object", 0);
            for(var i = 0; i < baseCheckers.length; i++){
                if (!baseCheckers[i](value, ctx)) return false;
            }
            for(var i = 0; i < propCheckers.length; i++){
                var name_1 = _this.props[i].name;
                var v = value[name_1];
                if (v === undefined) {
                    if (isPropRequired[i]) return ctx.fail(name_1, "is missing", 1);
                } else {
                    var ok = propCheckers[i](v, ctx);
                    if (!ok) return ctx.fail(name_1, null, 1);
                }
            }
            return true;
        };
        if (!strict) return checker;
        var propSet = this.propSet;
        if (allowedProps) {
            this.propSet.forEach(function(prop) {
                return allowedProps.add(prop);
            });
            propSet = allowedProps;
        }
        // In strict mode, check also for unknown enumerable properties.
        return function(value, ctx) {
            if (!checker(value, ctx)) return false;
            for(var prop in value){
                if (!propSet.has(prop)) return ctx.fail(prop, "is extraneous", 2);
            }
            return true;
        };
    };
    return TIface;
}(TType);
exports.TIface = TIface;
/**
 * Defines an optional property on an interface.
 */ function opt(typeSpec) {
    return new TOptional(parseSpec(typeSpec));
}
exports.opt = opt;
var TOptional = function(_super) {
    __extends(TOptional, _super);
    function TOptional(ttype) {
        var _this = _super.call(this) || this;
        _this.ttype = ttype;
        return _this;
    }
    TOptional.prototype.getChecker = function(suite, strict) {
        var itemChecker = this.ttype.getChecker(suite, strict);
        return function(value, ctx) {
            return value === undefined || itemChecker(value, ctx);
        };
    };
    return TOptional;
}(TType);
exports.TOptional = TOptional;
/**
 * Defines a property in an interface.
 */ var TProp = function() {
    function TProp(name, ttype, isOpt) {
        this.name = name;
        this.ttype = ttype;
        this.isOpt = isOpt;
    }
    return TProp;
}();
exports.TProp = TProp;
/**
 * Defines a function. The first argument declares the function's return type, the rest declare
 * its parameters.
 */ function func(resultSpec) {
    var params = [];
    for(var _i = 1; _i < arguments.length; _i++)params[_i - 1] = arguments[_i];
    return new TFunc(new TParamList(params), parseSpec(resultSpec));
}
exports.func = func;
var TFunc = function(_super) {
    __extends(TFunc, _super);
    function TFunc(paramList, result) {
        var _this = _super.call(this) || this;
        _this.paramList = paramList;
        _this.result = result;
        return _this;
    }
    TFunc.prototype.getChecker = function(suite, strict) {
        return function(value, ctx) {
            return typeof value === "function" ? true : ctx.fail(null, "is not a function", 0);
        };
    };
    return TFunc;
}(TType);
exports.TFunc = TFunc;
/**
 * Defines a function parameter.
 */ function param(name, typeSpec, isOpt) {
    return new TParam(name, parseSpec(typeSpec), Boolean(isOpt));
}
exports.param = param;
var TParam = function() {
    function TParam(name, ttype, isOpt) {
        this.name = name;
        this.ttype = ttype;
        this.isOpt = isOpt;
    }
    return TParam;
}();
exports.TParam = TParam;
/**
 * Defines a function parameter list.
 */ var TParamList = function(_super) {
    __extends(TParamList, _super);
    function TParamList(params) {
        var _this = _super.call(this) || this;
        _this.params = params;
        return _this;
    }
    TParamList.prototype.getChecker = function(suite, strict) {
        var _this = this;
        var itemCheckers = this.params.map(function(t) {
            return t.ttype.getChecker(suite, strict);
        });
        var testCtx = new util_1.NoopContext();
        var isParamRequired = this.params.map(function(param, i) {
            return !param.isOpt && !itemCheckers[i](undefined, testCtx);
        });
        var checker = function(value, ctx) {
            if (!Array.isArray(value)) return ctx.fail(null, "is not an array", 0);
            for(var i = 0; i < itemCheckers.length; i++){
                var p = _this.params[i];
                if (value[i] === undefined) {
                    if (isParamRequired[i]) return ctx.fail(p.name, "is missing", 1);
                } else {
                    var ok = itemCheckers[i](value[i], ctx);
                    if (!ok) return ctx.fail(p.name, null, 1);
                }
            }
            return true;
        };
        if (!strict) return checker;
        return function(value, ctx) {
            if (!checker(value, ctx)) return false;
            return value.length <= itemCheckers.length ? true : ctx.fail(itemCheckers.length, "is extraneous", 2);
        };
    };
    return TParamList;
}(TType);
exports.TParamList = TParamList;
/**
 * Single TType implementation for all basic built-in types.
 */ var BasicType = function(_super) {
    __extends(BasicType, _super);
    function BasicType(validator, message) {
        var _this = _super.call(this) || this;
        _this.validator = validator;
        _this.message = message;
        return _this;
    }
    BasicType.prototype.getChecker = function(suite, strict) {
        var _this = this;
        return function(value, ctx) {
            return _this.validator(value) ? true : ctx.fail(null, _this.message, 0);
        };
    };
    return BasicType;
}(TType);
exports.BasicType = BasicType;
/**
 * Defines the suite of basic types.
 */ exports.basicTypes = {
    any: new BasicType(function(v) {
        return true;
    }, "is invalid"),
    number: new BasicType(function(v) {
        return typeof v === "number";
    }, "is not a number"),
    object: new BasicType(function(v) {
        return typeof v === "object" && v;
    }, "is not an object"),
    boolean: new BasicType(function(v) {
        return typeof v === "boolean";
    }, "is not a boolean"),
    string: new BasicType(function(v) {
        return typeof v === "string";
    }, "is not a string"),
    symbol: new BasicType(function(v) {
        return typeof v === "symbol";
    }, "is not a symbol"),
    void: new BasicType(function(v) {
        return v == null;
    }, "is not void"),
    undefined: new BasicType(function(v) {
        return v === undefined;
    }, "is not undefined"),
    null: new BasicType(function(v) {
        return v === null;
    }, "is not null"),
    never: new BasicType(function(v) {
        return false;
    }, "is unexpected"),
    Date: new BasicType(getIsNativeChecker("[object Date]"), "is not a Date"),
    RegExp: new BasicType(getIsNativeChecker("[object RegExp]"), "is not a RegExp")
};
// This approach for checking native object types mirrors that of lodash. Its advantage over
// `isinstance` is that it can still return true for native objects created in different JS
// execution environments.
var nativeToString = Object.prototype.toString;
function getIsNativeChecker(tag) {
    return function(v) {
        return typeof v === "object" && v && nativeToString.call(v) === tag;
    };
}
if (typeof Buffer !== "undefined") exports.basicTypes.Buffer = new BasicType(function(v) {
    return Buffer.isBuffer(v);
}, "is not a Buffer");
var _loop_1 = function(array_1) {
    exports.basicTypes[array_1.name] = new BasicType(function(v) {
        return v instanceof array_1;
    }, "is not a " + array_1.name);
};
// Support typed arrays of various flavors
for(var _i = 0, _a = [
    Int8Array,
    Uint8Array,
    Uint8ClampedArray,
    Int16Array,
    Uint16Array,
    Int32Array,
    Uint32Array,
    Float32Array,
    Float64Array,
    ArrayBuffer
]; _i < _a.length; _i++){
    var array_1 = _a[_i];
    _loop_1(array_1);
}

},
"node_modules/ts-interface-checker/dist/util.js": function (module, exports, __mako_require__){
"use strict";
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DetailContext = exports.NoopContext = exports.VError = void 0;
/**
 * Error thrown by validation. Besides an informative message, it includes the path to the
 * property which triggered the failure.
 */ var VError = function(_super) {
    __extends(VError, _super);
    function VError(path, message) {
        var _this = _super.call(this, message) || this;
        _this.path = path;
        // See https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work for info about this workaround.
        Object.setPrototypeOf(_this, VError.prototype);
        return _this;
    }
    return VError;
}(Error);
exports.VError = VError;
/**
 * Fast implementation of IContext used for first-pass validation. If that fails, we can validate
 * using DetailContext to collect error messages. That's faster for the common case when messages
 * normally pass validation.
 */ var NoopContext = function() {
    function NoopContext() {}
    NoopContext.prototype.fail = function(relPath, message, score) {
        return false;
    };
    NoopContext.prototype.unionResolver = function() {
        return this;
    };
    NoopContext.prototype.createContext = function() {
        return this;
    };
    NoopContext.prototype.resolveUnion = function(ur) {};
    return NoopContext;
}();
exports.NoopContext = NoopContext;
/**
 * Complete implementation of IContext that collects meaningfull errors.
 */ var DetailContext = function() {
    function DetailContext() {
        // Stack of property names and associated messages for reporting helpful error messages.
        this._propNames = [
            ""
        ];
        this._messages = [
            null
        ];
        // Score is used to choose the best union member whose DetailContext to use for reporting.
        // Higher score means better match (or rather less severe mismatch).
        this._score = 0;
    }
    DetailContext.prototype.fail = function(relPath, message, score) {
        this._propNames.push(relPath);
        this._messages.push(message);
        this._score += score;
        return false;
    };
    DetailContext.prototype.unionResolver = function() {
        return new DetailUnionResolver();
    };
    DetailContext.prototype.resolveUnion = function(unionResolver) {
        var _a, _b;
        var u = unionResolver;
        var best = null;
        for(var _i = 0, _c = u.contexts; _i < _c.length; _i++){
            var ctx = _c[_i];
            if (!best || ctx._score >= best._score) best = ctx;
        }
        if (best && best._score > 0) {
            (_a = this._propNames).push.apply(_a, best._propNames);
            (_b = this._messages).push.apply(_b, best._messages);
        }
    };
    DetailContext.prototype.getError = function(path) {
        var msgParts = [];
        for(var i = this._propNames.length - 1; i >= 0; i--){
            var p = this._propNames[i];
            path += typeof p === "number" ? "[" + p + "]" : p ? "." + p : "";
            var m = this._messages[i];
            if (m) msgParts.push(path + " " + m);
        }
        return new VError(path, msgParts.join("; "));
    };
    DetailContext.prototype.getErrorDetail = function(path) {
        var details = [];
        for(var i = this._propNames.length - 1; i >= 0; i--){
            var p = this._propNames[i];
            path += typeof p === "number" ? "[" + p + "]" : p ? "." + p : "";
            var message = this._messages[i];
            if (message) details.push({
                path: path,
                message: message
            });
        }
        var detail = null;
        for(var i = details.length - 1; i >= 0; i--){
            if (detail) details[i].nested = [
                detail
            ];
            detail = details[i];
        }
        return detail;
    };
    return DetailContext;
}();
exports.DetailContext = DetailContext;
var DetailUnionResolver = function() {
    function DetailUnionResolver() {
        this.contexts = [];
    }
    DetailUnionResolver.prototype.createContext = function() {
        var ctx = new DetailContext();
        this.contexts.push(ctx);
        return ctx;
    };
    return DetailUnionResolver;
}();

},
 }]);
//# sourceMappingURL=vendors-async.js.map